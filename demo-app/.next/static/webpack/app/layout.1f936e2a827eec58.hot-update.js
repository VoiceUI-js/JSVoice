"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/layout",{

/***/ "(app-pages-browser)/../src/JSVoice.js":
/*!*************************!*\
  !*** ../src/JSVoice.js ***!
  \*************************/
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _utils_helpers_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/helpers.js */ \"(app-pages-browser)/../src/utils/helpers.js\");\n/* harmony import */ var _modules_RecognitionManager_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modules/RecognitionManager.js */ \"(app-pages-browser)/../src/modules/RecognitionManager.js\");\n/* harmony import */ var _modules_CommandManager_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./modules/CommandManager.js */ \"(app-pages-browser)/../src/modules/CommandManager.js\");\n\n\n\n/**\r\n * JSVoice Core\r\n * A modular voice command library. \r\n * NOTE: This class is pure logic. It does NOT bundle engines by default.\r\n */ class JSVoice {\n    static get isApiSupported() {\n        // Only check if window exists (SSR Guard)\n        if (false) {}\n        return !!(window.SpeechRecognition || window.webkitSpeechRecognition);\n    }\n    _initEngine() {\n        let EngineClassToUse = null;\n        let engineInstance = this.options.engine;\n        if (!engineInstance) {\n            const enginesList = Array.isArray(this.options.engines) ? this.options.engines : [];\n            for (const EngineClass of enginesList){\n                if (EngineClass && EngineClass.isSupported) {\n                    EngineClassToUse = EngineClass;\n                    break;\n                }\n            }\n            if (EngineClassToUse) {\n                engineInstance = new EngineClassToUse(this.options);\n            }\n        }\n        if (!engineInstance) {\n            // Only log if we expected engines (i.e. browser environment)\n            if ( true && this.options.engines.length > 0) {\n                console.warn(\"[JSVoice] No supported speech engine found.\");\n            }\n            return;\n        }\n        // Attach State Listener\n        if (engineInstance.setCallbacks) {\n        // We need to wrap existing setCallbacks logic or pass it down. \n        // Currently initRecognition handles setCallbacks. We must make sure it includes state changes.\n        // See RecognitionManager change below or inline logic. \n        // Since initRecognition is external, we'll verify it handles 'onStateChange' or we monkey-patch it here.\n        }\n        // We pass onStateChange directly to the engine instance before initRecognition \n        // if the engine supports direct callback assignment, OR we rely on initRecognition to wire it up.\n        // Let's modify initRecognition to support hooking onStateChange.\n        // For now, let's inject it into the options passed to initRecognition's scope?\n        // Actually, initRecognition accepts the engine instance. We can just attach the listener.\n        engineInstance.onStateChange = (state)=>{\n            this._callCallback(\"onEngineStateChange\", state);\n        };\n        this.recognition = (0,_modules_RecognitionManager_js__WEBPACK_IMPORTED_MODULE_1__.initRecognition)(engineInstance, this._updateStatus.bind(this), this._callCallback.bind(this), this._handleSpeechResult.bind(this), this._startRecognitionInternal.bind(this), this._state);\n        this._initPromise = this.recognition.init().catch((e)=>{\n            console.error(\"[JSVoice] Engine Init Error:\", e);\n            this._callCallback(\"onError\", e);\n        });\n    }\n    _callCallback(callbackName) {\n        for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n            args[_key - 1] = arguments[_key];\n        }\n        (0,_utils_helpers_js__WEBPACK_IMPORTED_MODULE_0__.callCallback)(this.options, callbackName, ...args);\n    }\n    _updateStatus(message) {\n        this._currentVoiceFeedback = message;\n        this._callCallback(\"onStatusChange\", message);\n    }\n    async _checkMicrophonePermission(opts) {\n        return (0,_modules_RecognitionManager_js__WEBPACK_IMPORTED_MODULE_1__.checkMicrophonePermission)(this._updateStatus.bind(this), this._callCallback.bind(this), this._state, opts);\n    }\n    async _handleSpeechResult(rawTranscript) {\n        const cleanedTranscript = (0,_utils_helpers_js__WEBPACK_IMPORTED_MODULE_0__.cleanText)(rawTranscript);\n        // Wake Word Logic\n        if (this._state._wakeWordModeActive) {\n            if (!this._state._awaitingCommand) {\n                if (cleanedTranscript.includes(this.options.wakeWord)) {\n                    this._state._awaitingCommand = true;\n                    this._callCallback(\"onWakeWordDetected\", this.options.wakeWord);\n                    this._updateStatus(\"Wake word detected! Listening...\");\n                    if (this._wakeWordCommandTimer) clearTimeout(this._wakeWordCommandTimer);\n                    this._wakeWordCommandTimer = setTimeout(()=>{\n                        this._resetWakeWordState();\n                    }, this.options.wakeWordTimeout);\n                    return true;\n                } else {\n                    this._updateStatus('Waiting for \"'.concat(this.options.wakeWord, '\"...'));\n                    return false;\n                }\n            } else {\n                // Extend timeout logic\n                if (this._wakeWordCommandTimer) clearTimeout(this._wakeWordCommandTimer);\n                this._wakeWordCommandTimer = setTimeout(()=>{\n                    this._resetWakeWordState();\n                }, this.options.wakeWordTimeout);\n            }\n        }\n        // Delegation to CommandManager\n        const commandHandled = await this._commandManager.process(rawTranscript, this.speak.bind(this));\n        if (commandHandled) {\n        // We can manually trigger onCommandRecognized here if we want core to fire it,\n        // but CommandManager handles execution. \n        // We should likely bind the core callback to the manager output or fire it here using the manager result.\n        // The manager's process returns boolean. To keep legacy callbacks firing (onCommandRecognized),\n        // we might want the manager to return details or fire the callback itself. \n        // Current Manager impl calls callback but doesn't fire core events.\n        // The `onCommandRecognized` global event is skipped in current Manager impl.\n        // We should fix Manager to emit this or return structured result. \n        // For this iteration, we rely on the specific command callback firing.\n        // If we want Global events, we should have passed `this._callCallback` to Manager. Not done yet.\n        }\n        if (!commandHandled && !this._state._wakeWordModeActive && this._state._isListening) {\n            this._updateStatus(\"Listening for commands...\");\n            this._callCallback(\"onCommandNotRecognized\", rawTranscript);\n        }\n        return commandHandled;\n    }\n    _resetWakeWordState() {\n        this._state._awaitingCommand = false;\n        if (this._wakeWordCommandTimer) {\n            clearTimeout(this._wakeWordCommandTimer);\n            this._wakeWordCommandTimer = null;\n        }\n        if (this._state._isListening) {\n            this._updateStatus(\"Reverted to wake word mode.\");\n        }\n    }\n    async _startRecognitionInternal() {\n        if (this.recognition && !this._state._isListening) {\n            try {\n                await this.recognition.start();\n                return true;\n            } catch (e) {\n                this._callCallback(\"onError\", e);\n                this._state._isListening = false;\n                return false;\n            }\n        }\n        return false;\n    }\n    /**\r\n   * Safe Start Method.\r\n   */ async start() {\n        if (this._startLock) {\n            console.warn(\"[JSVoice] start() ignored: operation already in progress.\");\n            return false;\n        }\n        this._startLock = true;\n        const mySession = ++this._sessionToken;\n        try {\n            if (!this.recognition) {\n                this._updateStatus(\"Voice commands not initialized.\");\n                return false;\n            }\n            if (this._initPromise) await this._initPromise.catch(()=>{});\n            // Async Check: Did stop() happen while we waited?\n            if (mySession !== this._sessionToken) return false;\n            await this._checkMicrophonePermission();\n            // Async Check 2\n            if (mySession !== this._sessionToken) return false;\n            if (!this._state._microphoneAllowed) {\n                this._updateStatus(\"Microphone access denied.\");\n                return false;\n            }\n            if (this._state._wakeWordModeActive) {\n                this._state._awaitingCommand = false;\n                this._updateStatus('Waiting for \"'.concat(this.options.wakeWord, '\"...'));\n            } else {\n                this._updateStatus(\"Listening for commands...\");\n            }\n            return await this._startRecognitionInternal();\n        } finally{\n            this._startLock = false;\n        }\n    }\n    stop() {\n        this._sessionToken++; // Invalidate any pending start()\n        if (this.recognition && this._state._isListening) {\n            this._state._isStoppingIntentionally = true;\n            this.recognition.stop();\n            // stop visualizer if plugin attached (via weak ref or simple check)\n            if (this._audioVisualizer) {\n                this.stopAmplitude();\n            }\n        } else {\n            this._updateStatus(\"Voice commands off.\");\n        }\n    }\n    toggle() {\n        if (this._state._isListening) {\n            this.stop();\n        } else {\n            this.start();\n        }\n    }\n    speak(text) {\n        let lang = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.options.lang;\n        if (false) {} // SSR Guard\n        if (!text) return;\n        if (!this.speechSynthesis || !window.SpeechSynthesisUtterance) {\n            console.warn(\"[JSVoice] SpeechSynthesis not supported.\");\n            return;\n        }\n        // Logic to pause recognition...\n        const wasListening = this._state._isListening;\n        let restartRecognition = false;\n        if (wasListening && this._state._microphoneAllowed) {\n            this._state._isStoppingIntentionally = true;\n            this.recognition.stop();\n            restartRecognition = true;\n        }\n        const utterance = new SpeechSynthesisUtterance(text);\n        utterance.lang = lang;\n        const finalizeSpeak = ()=>{\n            if (restartRecognition && this._state._microphoneAllowed) {\n                this._startRecognitionInternal();\n            }\n        };\n        utterance.onend = finalizeSpeak;\n        utterance.onerror = finalizeSpeak;\n        this.speechSynthesis.speak(utterance);\n    }\n    // --- Visualizer Proxy Methods ---\n    // The core doesn't import visualizer, but exposes the API if the module is loaded via plugin\n    // or manually attached.\n    startAmplitude(callback, options) {\n        if (!this._audioVisualizer) {\n            console.error(\"[JSVoice] AudioVisualizer module not loaded. Use createVoice() or voice.use(VisualizerPlugin).\");\n            return;\n        }\n        // Optimization: If we have an active engine with a stream, pass it!\n        // But NativeSpeechEngine (Web Speech API) does NOT expose the stream.\n        // So we usually must create a new one. AudioVisualizer.js handles the sharing logic if passed.\n        this._audioVisualizer.start(callback, options).catch((err)=>{\n            this._callCallback(\"onError\", err);\n        });\n    }\n    stopAmplitude() {\n        if (this._audioVisualizer) {\n            this._audioVisualizer.stop();\n        }\n    }\n    /* --- New Command API (Proxied to Manager) --- */ /**\r\n   * registers a command with optional configuration.\r\n   * @param {string} phrase \r\n   * @param {Function} callback \r\n   * @param {Object} options { priority, scope, cooldown, once }\r\n   */ addCommand(phrase, callback) {\n        let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n        this._commandManager.register(phrase, callback, options);\n    }\n    removeCommand(phrase) {\n        return this._commandManager.unregister(phrase);\n    }\n    addPatternCommand(pattern, callback) {\n        // Backwards compatibility wrapper\n        this._commandManager.register(pattern, callback, {\n            type: \"pattern\",\n            isPattern: true\n        });\n    }\n    removePatternCommand(pattern) {\n        return this._commandManager.unregister(pattern);\n    }\n    setScope(scopeName) {\n        this._commandManager.setScope(scopeName);\n    }\n    resetScope() {\n        this._commandManager.resetScope();\n    }\n    /* --- Options --- */ setOption(key, value) {\n        this.options[key] = value;\n        if (key === \"debug\") {\n            this._commandManager.debugMode = !!value;\n        }\n        if (this.recognition && this.recognition.setOptions) {\n            this.recognition.setOptions({\n                [key]: value\n            });\n        }\n    }\n    // Getters\n    /* -------------------------------------------------------------------------- */ /*                               Internal Helpers                             */ /* -------------------------------------------------------------------------- */ getSnapshot() {\n        return this._snapshot;\n    }\n    subscribe(listener) {\n        if (!this._listeners) this._listeners = new Set();\n        this._listeners.add(listener);\n        // Emit initial\n        listener(this._snapshot, {\n            type: \"init\"\n        });\n        return ()=>this._listeners.delete(listener);\n    }\n    _notifyListeners(event) {\n        if (!this._listeners) return;\n        this._listeners.forEach((l)=>l(this._snapshot, event));\n    }\n    _updateSnapshot(changes) {\n        this._snapshot = {\n            ...this._snapshot,\n            ...changes\n        };\n    }\n    _callCallback(name) {\n        for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n            args[_key - 1] = arguments[_key];\n        }\n        // 1. Update Snapshot based on event\n        if (name === \"onEngineStateChange\") {\n            const state = args[0] || \"unknown\";\n            this._updateSnapshot({\n                status: state\n            });\n        }\n        if (name === \"onResult\") {\n            // args[0] is transcript or event\n            const data = args[0];\n            const now = Date.now();\n            if (typeof data === \"string\") {\n                this._updateSnapshot({\n                    transcript: {\n                        partial: !args[1] ? data : \"\",\n                        final: args[1] ? data : this._snapshot.transcript.final,\n                        updatedAt: now\n                    }\n                });\n            } else if (data && typeof data === \"object\") {\n                // Protocol\n                this._updateSnapshot({\n                    transcript: {\n                        partial: !data.isFinal ? data.text : \"\",\n                        final: data.isFinal ? data.text : this._snapshot.transcript.final,\n                        updatedAt: now\n                    }\n                });\n            }\n        }\n        if (name === \"onEngineSelected\") {\n            const { mode } = args[0] || {};\n            this._updateSnapshot({\n                engine: {\n                    ...this._snapshot.engine,\n                    mode\n                }\n            });\n        }\n        if (this._listeners) {\n            this._notifyListeners({\n                type: name,\n                payload: args\n            });\n        }\n        // 3. Execute legacy callback\n        if (this._callbacks && typeof this._callbacks[name] === \"function\") {\n            try {\n                this._callbacks[name](...args);\n            } catch (err) {\n                console.error(\"[JSVoice] Error in callback '\".concat(name, \"':\"), err);\n            }\n        }\n    }\n    _updateStatus(message) {\n        this._callCallback(\"onStatusChange\", message);\n    }\n    // Getters\n    get isListening() {\n        return this._state._isListening;\n    }\n    get microphoneAllowed() {\n        return this._state._microphoneAllowed;\n    }\n    get voiceFeedback() {\n        return this._currentVoiceFeedback;\n    }\n    constructor(options = {}){\n        this.options = {\n            continuous: true,\n            interimResults: true,\n            lang: \"en-US\",\n            commands: {},\n            patternCommands: [],\n            autoRestart: true,\n            restartDelay: 500,\n            wakeWord: null,\n            wakeWordTimeout: 5000,\n            engines: [],\n            engine: null,\n            plugins: [],\n            debug: false,\n            defaultScope: \"global\",\n            onSpeechStart: ()=>{},\n            onSpeechEnd: ()=>{},\n            onCommandRecognized: ()=>{},\n            onCommandNotRecognized: ()=>{},\n            onActionPerformed: ()=>{},\n            onMicrophonePermissionGranted: ()=>{},\n            onMicrophonePermissionDenied: ()=>{},\n            onWakeWordDetected: ()=>{},\n            onEngineStateChange: ()=>{},\n            onCommandEvaluated: ()=>{},\n            onError: ()=>{},\n            onStatusChange: ()=>{},\n            onEngineSelected: ()=>{},\n            onFallbackActivated: ()=>{},\n            onTelemetry: ()=>{},\n            ...options\n        };\n        // New Callbacks object to manage events\n        this._callbacks = {\n            onSpeechStart: ()=>{},\n            onSpeechEnd: ()=>{},\n            onResult: (transcript, isFinal)=>{},\n            onCommandRecognized: (commandName, commandText)=>{},\n            onCommandNotRecognized: ()=>{},\n            onMicrophonePermissionGranted: ()=>{},\n            onMicrophonePermissionDenied: ()=>{},\n            onEngineStateChange: ()=>{},\n            onEngineSelected: ()=>{},\n            onFallbackActivated: ()=>{},\n            onTelemetry: ()=>{},\n            onCommandEvaluated: ()=>{},\n            onError: ()=>{},\n            onStatusChange: ()=>{},\n            ...options\n        };\n        // State Snapshot (Reactive Source of Truth)\n        this._snapshot = {\n            status: \"idle\",\n            transcript: {\n                partial: \"\",\n                final: \"\",\n                updatedAt: 0\n            },\n            permissions: {\n                microphone: \"unknown\"\n            },\n            engine: {\n                name: \"unknown\",\n                mode: \"unknown\"\n            },\n            metrics: {}\n        };\n        this._listeners = new Set();\n        // Warn if no engines provided\n        if ((!this.options.engines || this.options.engines.length === 0) && !this.options.engine) {\n            console.warn(\"[JSVoice] No engines provided. Use createVoice() for defaults or inject NativeSpeechEngine.\");\n        }\n        // Initialize Command Manager\n        this._commandManager = new _modules_CommandManager_js__WEBPACK_IMPORTED_MODULE_2__.CommandManager();\n        this._commandManager.debugMode = !!this.options.debug;\n        this._commandManager.onCommandEvaluated = (evt)=>this._callCallback(\"onCommandEvaluated\", evt);\n        this._commandManager.onTelemetry = (evt)=>this._callCallback(\"onTelemetry\", evt);\n        // Set initial scope if defined\n        if (this.options.defaultScope !== \"global\") {\n            this._commandManager.setScope(this.options.defaultScope);\n        }\n        /**\r\n     * Registers a plugin function with this JSVoice instance.\r\n     * @param {Function} plugin - Function receiving a restricted API\r\n     */ this.use = (plugin)=>{\n            if (typeof plugin === \"function\") {\n                const pluginApi = {\n                    // Public Methods\n                    start: this.start.bind(this),\n                    stop: this.stop.bind(this),\n                    toggle: this.toggle.bind(this),\n                    speak: this.speak.bind(this),\n                    addCommand: this.addCommand.bind(this),\n                    removeCommand: this.removeCommand.bind(this),\n                    // Pattern cmds are now unified in addCommand, but keeping for back-compat\n                    addPatternCommand: this.addPatternCommand.bind(this),\n                    removePatternCommand: this.removePatternCommand.bind(this),\n                    setOption: this.setOption.bind(this),\n                    startAmplitude: this.startAmplitude.bind(this),\n                    stopAmplitude: this.stopAmplitude.bind(this),\n                    // Scopes\n                    setScope: this.setScope.bind(this),\n                    resetScope: this.resetScope.bind(this),\n                    // Getters (read-only)\n                    get isListening () {\n                        return this.isListening;\n                    },\n                    get microphoneAllowed () {\n                        return this.microphoneAllowed;\n                    },\n                    get voiceFeedback () {\n                        return this.voiceFeedback;\n                    },\n                    get isApiSupported () {\n                        return JSVoice.isApiSupported;\n                    },\n                    get options () {\n                        return {\n                            ..._self.options\n                        };\n                    }\n                };\n                plugin(pluginApi);\n            }\n            return this;\n        };\n        // Load initial plugins\n        if (this.options.plugins && Array.isArray(this.options.plugins)) {\n            this.options.plugins.forEach((p)=>this.use(p));\n        }\n        if (this.options.wakeWord) {\n            this.options.continuous = true;\n            this.options.wakeWord = (0,_utils_helpers_js__WEBPACK_IMPORTED_MODULE_0__.cleanText)(this.options.wakeWord);\n        }\n        this.recognition = null;\n        this.speechSynthesis =  true ? window.speechSynthesis : 0;\n        this._state = {\n            _isListening: false,\n            _microphoneAllowed: false,\n            _awaitingCommand: false,\n            _wakeWordModeActive: !!this.options.wakeWord,\n            _isStoppingIntentionally: false\n        };\n        this._currentVoiceFeedback = \"Initializing...\";\n        // Remove old internal command storage, defer to manager\n        // this._commands = {}; \n        // this._patternCommands = [];\n        this._wakeWordCommandTimer = null;\n        // Concurrency Guards\n        this._startLock = false;\n        this._sessionToken = 0; // Incremented on every start attempt\n        // Process initial Legacy commands (convert to Manager)\n        for(const phrase in this.options.commands){\n            this._commandManager.register(phrase, this.options.commands[phrase], {\n                type: \"exact\"\n            });\n        }\n        for (const patternCmd of this.options.patternCommands){\n            this._commandManager.register(patternCmd.pattern, patternCmd.callback, {\n                type: \"pattern\"\n            });\n        }\n        // Engine initialization logic\n        this._initEngine();\n    }\n}\n/* harmony default export */ __webpack_exports__[\"default\"] = (JSVoice);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = __webpack_module__.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = __webpack_module__.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, __webpack_module__.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                __webpack_module__.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                __webpack_module__.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        __webpack_module__.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    __webpack_module__.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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YSxHQUFHLEdBQUcscUNBQXFDO1FBRTdELHVEQUF1RDtRQUN2RCxJQUFLLE1BQU1xQixVQUFVLElBQUksQ0FBQ3hFLE9BQU8sQ0FBQzBILFFBQVEsQ0FBRTtZQUMxQyxJQUFJLENBQUM5RSxlQUFlLENBQUM2QixRQUFRLENBQUNELFFBQVEsSUFBSSxDQUFDeEUsT0FBTyxDQUFDMEgsUUFBUSxDQUFDbEQsT0FBTyxFQUFFO2dCQUFFTSxNQUFNO1lBQVE7UUFDdkY7UUFDQSxLQUFLLE1BQU04RSxjQUFjLElBQUksQ0FBQzVKLE9BQU8sQ0FBQzJILGVBQWUsQ0FBRTtZQUNyRCxJQUFJLENBQUMvRSxlQUFlLENBQUM2QixRQUFRLENBQUNtRixXQUFXL0UsT0FBTyxFQUFFK0UsV0FBV3ZGLFFBQVEsRUFBRTtnQkFBRVMsTUFBTTtZQUFVO1FBQzNGO1FBRUEsOEJBQThCO1FBQzlCLElBQUksQ0FBQ2pGLFdBQVc7SUFDbEI7QUEyWkY7QUFFQSwrREFBZUwsT0FBT0EsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vc3JjL0pTVm9pY2UuanM/YmM0NCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjYWxsQ2FsbGJhY2ssIGNsZWFuVGV4dCB9IGZyb20gJy4vdXRpbHMvaGVscGVycy5qcyc7XHJcbmltcG9ydCB7IGluaXRSZWNvZ25pdGlvbiwgY2hlY2tNaWNyb3Bob25lUGVybWlzc2lvbiB9IGZyb20gJy4vbW9kdWxlcy9SZWNvZ25pdGlvbk1hbmFnZXIuanMnO1xyXG5pbXBvcnQgeyBDb21tYW5kTWFuYWdlciB9IGZyb20gJy4vbW9kdWxlcy9Db21tYW5kTWFuYWdlci5qcyc7XHJcblxyXG4vKipcclxuICogSlNWb2ljZSBDb3JlXHJcbiAqIEEgbW9kdWxhciB2b2ljZSBjb21tYW5kIGxpYnJhcnkuIFxyXG4gKiBOT1RFOiBUaGlzIGNsYXNzIGlzIHB1cmUgbG9naWMuIEl0IGRvZXMgTk9UIGJ1bmRsZSBlbmdpbmVzIGJ5IGRlZmF1bHQuXHJcbiAqL1xyXG5jbGFzcyBKU1ZvaWNlIHtcclxuICBzdGF0aWMgZ2V0IGlzQXBpU3VwcG9ydGVkKCkge1xyXG4gICAgLy8gT25seSBjaGVjayBpZiB3aW5kb3cgZXhpc3RzIChTU1IgR3VhcmQpXHJcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybiBmYWxzZTtcclxuICAgIHJldHVybiAhISh3aW5kb3cuU3BlZWNoUmVjb2duaXRpb24gfHwgd2luZG93LndlYmtpdFNwZWVjaFJlY29nbml0aW9uKTtcclxuICB9XHJcblxyXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xyXG4gICAgdGhpcy5vcHRpb25zID0ge1xyXG4gICAgICBjb250aW51b3VzOiB0cnVlLFxyXG4gICAgICBpbnRlcmltUmVzdWx0czogdHJ1ZSxcclxuICAgICAgbGFuZzogJ2VuLVVTJyxcclxuICAgICAgY29tbWFuZHM6IHt9LFxyXG4gICAgICBwYXR0ZXJuQ29tbWFuZHM6IFtdLFxyXG4gICAgICBhdXRvUmVzdGFydDogdHJ1ZSxcclxuICAgICAgcmVzdGFydERlbGF5OiA1MDAsXHJcbiAgICAgIHdha2VXb3JkOiBudWxsLFxyXG4gICAgICB3YWtlV29yZFRpbWVvdXQ6IDUwMDAsXHJcbiAgICAgIGVuZ2luZXM6IFtdLCAvLyBNdXN0IGJlIGluamVjdGVkXHJcbiAgICAgIGVuZ2luZTogbnVsbCwgLy8gTWFudWFsIGluc3RhbmNlIG92ZXJyaWRlXHJcbiAgICAgIHBsdWdpbnM6IFtdLCAvLyBQbHVnaW5zIHRvIGxvYWRcclxuICAgICAgZGVidWc6IGZhbHNlLCAvLyBOZXcgZGVidWcgbW9kZVxyXG4gICAgICBkZWZhdWx0U2NvcGU6ICdnbG9iYWwnLFxyXG4gICAgICBvblNwZWVjaFN0YXJ0OiAoKSA9PiB7IH0sXHJcbiAgICAgIG9uU3BlZWNoRW5kOiAoKSA9PiB7IH0sXHJcbiAgICAgIG9uQ29tbWFuZFJlY29nbml6ZWQ6ICgpID0+IHsgfSxcclxuICAgICAgb25Db21tYW5kTm90UmVjb2duaXplZDogKCkgPT4geyB9LFxyXG4gICAgICBvbkFjdGlvblBlcmZvcm1lZDogKCkgPT4geyB9LFxyXG4gICAgICBvbk1pY3JvcGhvbmVQZXJtaXNzaW9uR3JhbnRlZDogKCkgPT4geyB9LFxyXG4gICAgICBvbk1pY3JvcGhvbmVQZXJtaXNzaW9uRGVuaWVkOiAoKSA9PiB7IH0sXHJcbiAgICAgIG9uV2FrZVdvcmREZXRlY3RlZDogKCkgPT4geyB9LFxyXG4gICAgICBvbkVuZ2luZVN0YXRlQ2hhbmdlOiAoKSA9PiB7IH0sIC8vIE5ldyBTdGF0ZSBDYWxsYmFja1xyXG4gICAgICBvbkNvbW1hbmRFdmFsdWF0ZWQ6ICgpID0+IHsgfSwgIC8vIE5ldyBEZWJ1ZyBDYWxsYmFja1xyXG4gICAgICBvbkVycm9yOiAoKSA9PiB7IH0sXHJcbiAgICAgIG9uU3RhdHVzQ2hhbmdlOiAoKSA9PiB7IH0sXHJcbiAgICAgIG9uRW5naW5lU2VsZWN0ZWQ6ICgpID0+IHsgfSxcclxuICAgICAgb25GYWxsYmFja0FjdGl2YXRlZDogKCkgPT4geyB9LFxyXG4gICAgICBvblRlbGVtZXRyeTogKCkgPT4geyB9LCAvLyBHbG9iYWwgVGVsZW1ldHJ5IEhvb2tcclxuICAgICAgLi4ub3B0aW9ucyxcclxuICAgIH07XHJcblxyXG4gICAgLy8gTmV3IENhbGxiYWNrcyBvYmplY3QgdG8gbWFuYWdlIGV2ZW50c1xyXG4gICAgdGhpcy5fY2FsbGJhY2tzID0ge1xyXG4gICAgICBvblNwZWVjaFN0YXJ0OiAoKSA9PiB7IH0sXHJcbiAgICAgIG9uU3BlZWNoRW5kOiAoKSA9PiB7IH0sXHJcbiAgICAgIG9uUmVzdWx0OiAodHJhbnNjcmlwdCwgaXNGaW5hbCkgPT4geyB9LFxyXG4gICAgICBvbkNvbW1hbmRSZWNvZ25pemVkOiAoY29tbWFuZE5hbWUsIGNvbW1hbmRUZXh0KSA9PiB7IH0sXHJcbiAgICAgIG9uQ29tbWFuZE5vdFJlY29nbml6ZWQ6ICgpID0+IHsgfSxcclxuICAgICAgb25NaWNyb3Bob25lUGVybWlzc2lvbkdyYW50ZWQ6ICgpID0+IHsgfSxcclxuICAgICAgb25NaWNyb3Bob25lUGVybWlzc2lvbkRlbmllZDogKCkgPT4geyB9LFxyXG4gICAgICBvbkVuZ2luZVN0YXRlQ2hhbmdlOiAoKSA9PiB7IH0sXHJcbiAgICAgIG9uRW5naW5lU2VsZWN0ZWQ6ICgpID0+IHsgfSxcclxuICAgICAgb25GYWxsYmFja0FjdGl2YXRlZDogKCkgPT4geyB9LFxyXG4gICAgICBvblRlbGVtZXRyeTogKCkgPT4geyB9LFxyXG4gICAgICBvbkNvbW1hbmRFdmFsdWF0ZWQ6ICgpID0+IHsgfSxcclxuICAgICAgb25FcnJvcjogKCkgPT4geyB9LFxyXG4gICAgICBvblN0YXR1c0NoYW5nZTogKCkgPT4geyB9LFxyXG4gICAgICAuLi5vcHRpb25zLCAvLyBNZXJnZSB1c2VyLXByb3ZpZGVkIGNhbGxiYWNrc1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBTdGF0ZSBTbmFwc2hvdCAoUmVhY3RpdmUgU291cmNlIG9mIFRydXRoKVxyXG4gICAgdGhpcy5fc25hcHNob3QgPSB7XHJcbiAgICAgIHN0YXR1czogJ2lkbGUnLFxyXG4gICAgICB0cmFuc2NyaXB0OiB7IHBhcnRpYWw6ICcnLCBmaW5hbDogJycsIHVwZGF0ZWRBdDogMCB9LFxyXG4gICAgICBwZXJtaXNzaW9uczogeyBtaWNyb3Bob25lOiAndW5rbm93bicgfSxcclxuICAgICAgZW5naW5lOiB7IG5hbWU6ICd1bmtub3duJywgbW9kZTogJ3Vua25vd24nIH0sXHJcbiAgICAgIG1ldHJpY3M6IHt9XHJcbiAgICB9O1xyXG4gICAgdGhpcy5fbGlzdGVuZXJzID0gbmV3IFNldCgpO1xyXG5cclxuXHJcbiAgICAvLyBXYXJuIGlmIG5vIGVuZ2luZXMgcHJvdmlkZWRcclxuICAgIGlmICgoIXRoaXMub3B0aW9ucy5lbmdpbmVzIHx8IHRoaXMub3B0aW9ucy5lbmdpbmVzLmxlbmd0aCA9PT0gMCkgJiYgIXRoaXMub3B0aW9ucy5lbmdpbmUpIHtcclxuICAgICAgY29uc29sZS53YXJuKCdbSlNWb2ljZV0gTm8gZW5naW5lcyBwcm92aWRlZC4gVXNlIGNyZWF0ZVZvaWNlKCkgZm9yIGRlZmF1bHRzIG9yIGluamVjdCBOYXRpdmVTcGVlY2hFbmdpbmUuJyk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gSW5pdGlhbGl6ZSBDb21tYW5kIE1hbmFnZXJcclxuICAgIHRoaXMuX2NvbW1hbmRNYW5hZ2VyID0gbmV3IENvbW1hbmRNYW5hZ2VyKCk7XHJcbiAgICB0aGlzLl9jb21tYW5kTWFuYWdlci5kZWJ1Z01vZGUgPSAhIXRoaXMub3B0aW9ucy5kZWJ1ZztcclxuICAgIHRoaXMuX2NvbW1hbmRNYW5hZ2VyLm9uQ29tbWFuZEV2YWx1YXRlZCA9IChldnQpID0+IHRoaXMuX2NhbGxDYWxsYmFjaygnb25Db21tYW5kRXZhbHVhdGVkJywgZXZ0KTtcclxuICAgIHRoaXMuX2NvbW1hbmRNYW5hZ2VyLm9uVGVsZW1ldHJ5ID0gKGV2dCkgPT4gdGhpcy5fY2FsbENhbGxiYWNrKCdvblRlbGVtZXRyeScsIGV2dCk7XHJcblxyXG4gICAgLy8gU2V0IGluaXRpYWwgc2NvcGUgaWYgZGVmaW5lZFxyXG4gICAgaWYgKHRoaXMub3B0aW9ucy5kZWZhdWx0U2NvcGUgIT09ICdnbG9iYWwnKSB7XHJcbiAgICAgIHRoaXMuX2NvbW1hbmRNYW5hZ2VyLnNldFNjb3BlKHRoaXMub3B0aW9ucy5kZWZhdWx0U2NvcGUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVnaXN0ZXJzIGEgcGx1Z2luIGZ1bmN0aW9uIHdpdGggdGhpcyBKU1ZvaWNlIGluc3RhbmNlLlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcGx1Z2luIC0gRnVuY3Rpb24gcmVjZWl2aW5nIGEgcmVzdHJpY3RlZCBBUElcclxuICAgICAqL1xyXG4gICAgdGhpcy51c2UgPSAocGx1Z2luKSA9PiB7XHJcbiAgICAgIGlmICh0eXBlb2YgcGx1Z2luID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgY29uc3QgcGx1Z2luQXBpID0ge1xyXG4gICAgICAgICAgLy8gUHVibGljIE1ldGhvZHNcclxuICAgICAgICAgIHN0YXJ0OiB0aGlzLnN0YXJ0LmJpbmQodGhpcyksXHJcbiAgICAgICAgICBzdG9wOiB0aGlzLnN0b3AuYmluZCh0aGlzKSxcclxuICAgICAgICAgIHRvZ2dsZTogdGhpcy50b2dnbGUuYmluZCh0aGlzKSxcclxuICAgICAgICAgIHNwZWFrOiB0aGlzLnNwZWFrLmJpbmQodGhpcyksXHJcbiAgICAgICAgICBhZGRDb21tYW5kOiB0aGlzLmFkZENvbW1hbmQuYmluZCh0aGlzKSxcclxuICAgICAgICAgIHJlbW92ZUNvbW1hbmQ6IHRoaXMucmVtb3ZlQ29tbWFuZC5iaW5kKHRoaXMpLFxyXG4gICAgICAgICAgLy8gUGF0dGVybiBjbWRzIGFyZSBub3cgdW5pZmllZCBpbiBhZGRDb21tYW5kLCBidXQga2VlcGluZyBmb3IgYmFjay1jb21wYXRcclxuICAgICAgICAgIGFkZFBhdHRlcm5Db21tYW5kOiB0aGlzLmFkZFBhdHRlcm5Db21tYW5kLmJpbmQodGhpcyksXHJcbiAgICAgICAgICByZW1vdmVQYXR0ZXJuQ29tbWFuZDogdGhpcy5yZW1vdmVQYXR0ZXJuQ29tbWFuZC5iaW5kKHRoaXMpLFxyXG4gICAgICAgICAgc2V0T3B0aW9uOiB0aGlzLnNldE9wdGlvbi5iaW5kKHRoaXMpLFxyXG4gICAgICAgICAgc3RhcnRBbXBsaXR1ZGU6IHRoaXMuc3RhcnRBbXBsaXR1ZGUuYmluZCh0aGlzKSxcclxuICAgICAgICAgIHN0b3BBbXBsaXR1ZGU6IHRoaXMuc3RvcEFtcGxpdHVkZS5iaW5kKHRoaXMpLFxyXG5cclxuICAgICAgICAgIC8vIFNjb3Blc1xyXG4gICAgICAgICAgc2V0U2NvcGU6IHRoaXMuc2V0U2NvcGUuYmluZCh0aGlzKSxcclxuICAgICAgICAgIHJlc2V0U2NvcGU6IHRoaXMucmVzZXRTY29wZS5iaW5kKHRoaXMpLFxyXG5cclxuICAgICAgICAgIC8vIEdldHRlcnMgKHJlYWQtb25seSlcclxuICAgICAgICAgIGdldCBpc0xpc3RlbmluZygpIHsgcmV0dXJuIHRoaXMuaXNMaXN0ZW5pbmc7IH0sXHJcbiAgICAgICAgICBnZXQgbWljcm9waG9uZUFsbG93ZWQoKSB7IHJldHVybiB0aGlzLm1pY3JvcGhvbmVBbGxvd2VkOyB9LFxyXG4gICAgICAgICAgZ2V0IHZvaWNlRmVlZGJhY2soKSB7IHJldHVybiB0aGlzLnZvaWNlRmVlZGJhY2s7IH0sXHJcbiAgICAgICAgICBnZXQgaXNBcGlTdXBwb3J0ZWQoKSB7IHJldHVybiBKU1ZvaWNlLmlzQXBpU3VwcG9ydGVkOyB9LFxyXG4gICAgICAgICAgZ2V0IG9wdGlvbnMoKSB7IHJldHVybiB7IC4uLl9zZWxmLm9wdGlvbnMgfTsgfVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHBsdWdpbihwbHVnaW5BcGkpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBMb2FkIGluaXRpYWwgcGx1Z2luc1xyXG4gICAgaWYgKHRoaXMub3B0aW9ucy5wbHVnaW5zICYmIEFycmF5LmlzQXJyYXkodGhpcy5vcHRpb25zLnBsdWdpbnMpKSB7XHJcbiAgICAgIHRoaXMub3B0aW9ucy5wbHVnaW5zLmZvckVhY2gocCA9PiB0aGlzLnVzZShwKSk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMub3B0aW9ucy53YWtlV29yZCkge1xyXG4gICAgICB0aGlzLm9wdGlvbnMuY29udGludW91cyA9IHRydWU7XHJcbiAgICAgIHRoaXMub3B0aW9ucy53YWtlV29yZCA9IGNsZWFuVGV4dCh0aGlzLm9wdGlvbnMud2FrZVdvcmQpO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMucmVjb2duaXRpb24gPSBudWxsO1xyXG4gICAgdGhpcy5zcGVlY2hTeW50aGVzaXMgPSAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpID8gd2luZG93LnNwZWVjaFN5bnRoZXNpcyA6IG51bGw7XHJcblxyXG4gICAgdGhpcy5fc3RhdGUgPSB7XHJcbiAgICAgIF9pc0xpc3RlbmluZzogZmFsc2UsXHJcbiAgICAgIF9taWNyb3Bob25lQWxsb3dlZDogZmFsc2UsXHJcbiAgICAgIF9hd2FpdGluZ0NvbW1hbmQ6IGZhbHNlLFxyXG4gICAgICBfd2FrZVdvcmRNb2RlQWN0aXZlOiAhIXRoaXMub3B0aW9ucy53YWtlV29yZCxcclxuICAgICAgX2lzU3RvcHBpbmdJbnRlbnRpb25hbGx5OiBmYWxzZSxcclxuICAgIH07XHJcblxyXG4gICAgdGhpcy5fY3VycmVudFZvaWNlRmVlZGJhY2sgPSAnSW5pdGlhbGl6aW5nLi4uJztcclxuICAgIC8vIFJlbW92ZSBvbGQgaW50ZXJuYWwgY29tbWFuZCBzdG9yYWdlLCBkZWZlciB0byBtYW5hZ2VyXHJcbiAgICAvLyB0aGlzLl9jb21tYW5kcyA9IHt9OyBcclxuICAgIC8vIHRoaXMuX3BhdHRlcm5Db21tYW5kcyA9IFtdO1xyXG4gICAgdGhpcy5fd2FrZVdvcmRDb21tYW5kVGltZXIgPSBudWxsO1xyXG5cclxuICAgIC8vIENvbmN1cnJlbmN5IEd1YXJkc1xyXG4gICAgdGhpcy5fc3RhcnRMb2NrID0gZmFsc2U7XHJcbiAgICB0aGlzLl9zZXNzaW9uVG9rZW4gPSAwOyAvLyBJbmNyZW1lbnRlZCBvbiBldmVyeSBzdGFydCBhdHRlbXB0XHJcblxyXG4gICAgLy8gUHJvY2VzcyBpbml0aWFsIExlZ2FjeSBjb21tYW5kcyAoY29udmVydCB0byBNYW5hZ2VyKVxyXG4gICAgZm9yIChjb25zdCBwaHJhc2UgaW4gdGhpcy5vcHRpb25zLmNvbW1hbmRzKSB7XHJcbiAgICAgIHRoaXMuX2NvbW1hbmRNYW5hZ2VyLnJlZ2lzdGVyKHBocmFzZSwgdGhpcy5vcHRpb25zLmNvbW1hbmRzW3BocmFzZV0sIHsgdHlwZTogJ2V4YWN0JyB9KTtcclxuICAgIH1cclxuICAgIGZvciAoY29uc3QgcGF0dGVybkNtZCBvZiB0aGlzLm9wdGlvbnMucGF0dGVybkNvbW1hbmRzKSB7XHJcbiAgICAgIHRoaXMuX2NvbW1hbmRNYW5hZ2VyLnJlZ2lzdGVyKHBhdHRlcm5DbWQucGF0dGVybiwgcGF0dGVybkNtZC5jYWxsYmFjaywgeyB0eXBlOiAncGF0dGVybicgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRW5naW5lIGluaXRpYWxpemF0aW9uIGxvZ2ljXHJcbiAgICB0aGlzLl9pbml0RW5naW5lKCk7XHJcbiAgfVxyXG5cclxuICBfaW5pdEVuZ2luZSgpIHtcclxuICAgIGxldCBFbmdpbmVDbGFzc1RvVXNlID0gbnVsbDtcclxuICAgIGxldCBlbmdpbmVJbnN0YW5jZSA9IHRoaXMub3B0aW9ucy5lbmdpbmU7XHJcblxyXG4gICAgaWYgKCFlbmdpbmVJbnN0YW5jZSkge1xyXG4gICAgICBjb25zdCBlbmdpbmVzTGlzdCA9IEFycmF5LmlzQXJyYXkodGhpcy5vcHRpb25zLmVuZ2luZXMpID8gdGhpcy5vcHRpb25zLmVuZ2luZXMgOiBbXTtcclxuXHJcbiAgICAgIGZvciAoY29uc3QgRW5naW5lQ2xhc3Mgb2YgZW5naW5lc0xpc3QpIHtcclxuICAgICAgICBpZiAoRW5naW5lQ2xhc3MgJiYgRW5naW5lQ2xhc3MuaXNTdXBwb3J0ZWQpIHtcclxuICAgICAgICAgIEVuZ2luZUNsYXNzVG9Vc2UgPSBFbmdpbmVDbGFzcztcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKEVuZ2luZUNsYXNzVG9Vc2UpIHtcclxuICAgICAgICBlbmdpbmVJbnN0YW5jZSA9IG5ldyBFbmdpbmVDbGFzc1RvVXNlKHRoaXMub3B0aW9ucyk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAoIWVuZ2luZUluc3RhbmNlKSB7XHJcbiAgICAgIC8vIE9ubHkgbG9nIGlmIHdlIGV4cGVjdGVkIGVuZ2luZXMgKGkuZS4gYnJvd3NlciBlbnZpcm9ubWVudClcclxuICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHRoaXMub3B0aW9ucy5lbmdpbmVzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICBjb25zb2xlLndhcm4oJ1tKU1ZvaWNlXSBObyBzdXBwb3J0ZWQgc3BlZWNoIGVuZ2luZSBmb3VuZC4nKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQXR0YWNoIFN0YXRlIExpc3RlbmVyXHJcbiAgICBpZiAoZW5naW5lSW5zdGFuY2Uuc2V0Q2FsbGJhY2tzKSB7XHJcbiAgICAgIC8vIFdlIG5lZWQgdG8gd3JhcCBleGlzdGluZyBzZXRDYWxsYmFja3MgbG9naWMgb3IgcGFzcyBpdCBkb3duLiBcclxuICAgICAgLy8gQ3VycmVudGx5IGluaXRSZWNvZ25pdGlvbiBoYW5kbGVzIHNldENhbGxiYWNrcy4gV2UgbXVzdCBtYWtlIHN1cmUgaXQgaW5jbHVkZXMgc3RhdGUgY2hhbmdlcy5cclxuICAgICAgLy8gU2VlIFJlY29nbml0aW9uTWFuYWdlciBjaGFuZ2UgYmVsb3cgb3IgaW5saW5lIGxvZ2ljLiBcclxuICAgICAgLy8gU2luY2UgaW5pdFJlY29nbml0aW9uIGlzIGV4dGVybmFsLCB3ZSdsbCB2ZXJpZnkgaXQgaGFuZGxlcyAnb25TdGF0ZUNoYW5nZScgb3Igd2UgbW9ua2V5LXBhdGNoIGl0IGhlcmUuXHJcbiAgICB9XHJcblxyXG4gICAgLy8gV2UgcGFzcyBvblN0YXRlQ2hhbmdlIGRpcmVjdGx5IHRvIHRoZSBlbmdpbmUgaW5zdGFuY2UgYmVmb3JlIGluaXRSZWNvZ25pdGlvbiBcclxuICAgIC8vIGlmIHRoZSBlbmdpbmUgc3VwcG9ydHMgZGlyZWN0IGNhbGxiYWNrIGFzc2lnbm1lbnQsIE9SIHdlIHJlbHkgb24gaW5pdFJlY29nbml0aW9uIHRvIHdpcmUgaXQgdXAuXHJcbiAgICAvLyBMZXQncyBtb2RpZnkgaW5pdFJlY29nbml0aW9uIHRvIHN1cHBvcnQgaG9va2luZyBvblN0YXRlQ2hhbmdlLlxyXG5cclxuICAgIC8vIEZvciBub3csIGxldCdzIGluamVjdCBpdCBpbnRvIHRoZSBvcHRpb25zIHBhc3NlZCB0byBpbml0UmVjb2duaXRpb24ncyBzY29wZT9cclxuICAgIC8vIEFjdHVhbGx5LCBpbml0UmVjb2duaXRpb24gYWNjZXB0cyB0aGUgZW5naW5lIGluc3RhbmNlLiBXZSBjYW4ganVzdCBhdHRhY2ggdGhlIGxpc3RlbmVyLlxyXG4gICAgZW5naW5lSW5zdGFuY2Uub25TdGF0ZUNoYW5nZSA9IChzdGF0ZSkgPT4ge1xyXG4gICAgICB0aGlzLl9jYWxsQ2FsbGJhY2soJ29uRW5naW5lU3RhdGVDaGFuZ2UnLCBzdGF0ZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMucmVjb2duaXRpb24gPSBpbml0UmVjb2duaXRpb24oXHJcbiAgICAgIGVuZ2luZUluc3RhbmNlLFxyXG4gICAgICB0aGlzLl91cGRhdGVTdGF0dXMuYmluZCh0aGlzKSxcclxuICAgICAgdGhpcy5fY2FsbENhbGxiYWNrLmJpbmQodGhpcyksXHJcbiAgICAgIHRoaXMuX2hhbmRsZVNwZWVjaFJlc3VsdC5iaW5kKHRoaXMpLFxyXG4gICAgICB0aGlzLl9zdGFydFJlY29nbml0aW9uSW50ZXJuYWwuYmluZCh0aGlzKSxcclxuICAgICAgdGhpcy5fc3RhdGVcclxuICAgICk7XHJcblxyXG4gICAgdGhpcy5faW5pdFByb21pc2UgPSB0aGlzLnJlY29nbml0aW9uLmluaXQoKS5jYXRjaCgoZSkgPT4ge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdbSlNWb2ljZV0gRW5naW5lIEluaXQgRXJyb3I6JywgZSk7XHJcbiAgICAgIHRoaXMuX2NhbGxDYWxsYmFjaygnb25FcnJvcicsIGUpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICBfY2FsbENhbGxiYWNrKGNhbGxiYWNrTmFtZSwgLi4uYXJncykge1xyXG4gICAgY2FsbENhbGxiYWNrKHRoaXMub3B0aW9ucywgY2FsbGJhY2tOYW1lLCAuLi5hcmdzKTtcclxuICB9XHJcblxyXG4gIF91cGRhdGVTdGF0dXMobWVzc2FnZSkge1xyXG4gICAgdGhpcy5fY3VycmVudFZvaWNlRmVlZGJhY2sgPSBtZXNzYWdlO1xyXG4gICAgdGhpcy5fY2FsbENhbGxiYWNrKCdvblN0YXR1c0NoYW5nZScsIG1lc3NhZ2UpO1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgX2NoZWNrTWljcm9waG9uZVBlcm1pc3Npb24ob3B0cykge1xyXG4gICAgcmV0dXJuIGNoZWNrTWljcm9waG9uZVBlcm1pc3Npb24oXHJcbiAgICAgIHRoaXMuX3VwZGF0ZVN0YXR1cy5iaW5kKHRoaXMpLFxyXG4gICAgICB0aGlzLl9jYWxsQ2FsbGJhY2suYmluZCh0aGlzKSxcclxuICAgICAgdGhpcy5fc3RhdGUsXHJcbiAgICAgIG9wdHNcclxuICAgICk7XHJcbiAgfVxyXG5cclxuICBhc3luYyBfaGFuZGxlU3BlZWNoUmVzdWx0KHJhd1RyYW5zY3JpcHQpIHtcclxuICAgIGNvbnN0IGNsZWFuZWRUcmFuc2NyaXB0ID0gY2xlYW5UZXh0KHJhd1RyYW5zY3JpcHQpO1xyXG5cclxuICAgIC8vIFdha2UgV29yZCBMb2dpY1xyXG4gICAgaWYgKHRoaXMuX3N0YXRlLl93YWtlV29yZE1vZGVBY3RpdmUpIHtcclxuICAgICAgaWYgKCF0aGlzLl9zdGF0ZS5fYXdhaXRpbmdDb21tYW5kKSB7XHJcbiAgICAgICAgaWYgKGNsZWFuZWRUcmFuc2NyaXB0LmluY2x1ZGVzKHRoaXMub3B0aW9ucy53YWtlV29yZCkpIHtcclxuICAgICAgICAgIHRoaXMuX3N0YXRlLl9hd2FpdGluZ0NvbW1hbmQgPSB0cnVlO1xyXG4gICAgICAgICAgdGhpcy5fY2FsbENhbGxiYWNrKCdvbldha2VXb3JkRGV0ZWN0ZWQnLCB0aGlzLm9wdGlvbnMud2FrZVdvcmQpO1xyXG4gICAgICAgICAgdGhpcy5fdXBkYXRlU3RhdHVzKGBXYWtlIHdvcmQgZGV0ZWN0ZWQhIExpc3RlbmluZy4uLmApO1xyXG5cclxuICAgICAgICAgIGlmICh0aGlzLl93YWtlV29yZENvbW1hbmRUaW1lcikgY2xlYXJUaW1lb3V0KHRoaXMuX3dha2VXb3JkQ29tbWFuZFRpbWVyKTtcclxuICAgICAgICAgIHRoaXMuX3dha2VXb3JkQ29tbWFuZFRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuX3Jlc2V0V2FrZVdvcmRTdGF0ZSgpO1xyXG4gICAgICAgICAgfSwgdGhpcy5vcHRpb25zLndha2VXb3JkVGltZW91dCk7XHJcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgdGhpcy5fdXBkYXRlU3RhdHVzKGBXYWl0aW5nIGZvciBcIiR7dGhpcy5vcHRpb25zLndha2VXb3JkfVwiLi4uYCk7XHJcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIEV4dGVuZCB0aW1lb3V0IGxvZ2ljXHJcbiAgICAgICAgaWYgKHRoaXMuX3dha2VXb3JkQ29tbWFuZFRpbWVyKSBjbGVhclRpbWVvdXQodGhpcy5fd2FrZVdvcmRDb21tYW5kVGltZXIpO1xyXG4gICAgICAgIHRoaXMuX3dha2VXb3JkQ29tbWFuZFRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICB0aGlzLl9yZXNldFdha2VXb3JkU3RhdGUoKTtcclxuICAgICAgICB9LCB0aGlzLm9wdGlvbnMud2FrZVdvcmRUaW1lb3V0KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIERlbGVnYXRpb24gdG8gQ29tbWFuZE1hbmFnZXJcclxuICAgIGNvbnN0IGNvbW1hbmRIYW5kbGVkID0gYXdhaXQgdGhpcy5fY29tbWFuZE1hbmFnZXIucHJvY2VzcyhcclxuICAgICAgcmF3VHJhbnNjcmlwdCxcclxuICAgICAgdGhpcy5zcGVhay5iaW5kKHRoaXMpXHJcbiAgICApO1xyXG5cclxuICAgIGlmIChjb21tYW5kSGFuZGxlZCkge1xyXG4gICAgICAvLyBXZSBjYW4gbWFudWFsbHkgdHJpZ2dlciBvbkNvbW1hbmRSZWNvZ25pemVkIGhlcmUgaWYgd2Ugd2FudCBjb3JlIHRvIGZpcmUgaXQsXHJcbiAgICAgIC8vIGJ1dCBDb21tYW5kTWFuYWdlciBoYW5kbGVzIGV4ZWN1dGlvbi4gXHJcbiAgICAgIC8vIFdlIHNob3VsZCBsaWtlbHkgYmluZCB0aGUgY29yZSBjYWxsYmFjayB0byB0aGUgbWFuYWdlciBvdXRwdXQgb3IgZmlyZSBpdCBoZXJlIHVzaW5nIHRoZSBtYW5hZ2VyIHJlc3VsdC5cclxuICAgICAgLy8gVGhlIG1hbmFnZXIncyBwcm9jZXNzIHJldHVybnMgYm9vbGVhbi4gVG8ga2VlcCBsZWdhY3kgY2FsbGJhY2tzIGZpcmluZyAob25Db21tYW5kUmVjb2duaXplZCksXHJcbiAgICAgIC8vIHdlIG1pZ2h0IHdhbnQgdGhlIG1hbmFnZXIgdG8gcmV0dXJuIGRldGFpbHMgb3IgZmlyZSB0aGUgY2FsbGJhY2sgaXRzZWxmLiBcclxuICAgICAgLy8gQ3VycmVudCBNYW5hZ2VyIGltcGwgY2FsbHMgY2FsbGJhY2sgYnV0IGRvZXNuJ3QgZmlyZSBjb3JlIGV2ZW50cy5cclxuICAgICAgLy8gVGhlIGBvbkNvbW1hbmRSZWNvZ25pemVkYCBnbG9iYWwgZXZlbnQgaXMgc2tpcHBlZCBpbiBjdXJyZW50IE1hbmFnZXIgaW1wbC5cclxuICAgICAgLy8gV2Ugc2hvdWxkIGZpeCBNYW5hZ2VyIHRvIGVtaXQgdGhpcyBvciByZXR1cm4gc3RydWN0dXJlZCByZXN1bHQuIFxyXG4gICAgICAvLyBGb3IgdGhpcyBpdGVyYXRpb24sIHdlIHJlbHkgb24gdGhlIHNwZWNpZmljIGNvbW1hbmQgY2FsbGJhY2sgZmlyaW5nLlxyXG4gICAgICAvLyBJZiB3ZSB3YW50IEdsb2JhbCBldmVudHMsIHdlIHNob3VsZCBoYXZlIHBhc3NlZCBgdGhpcy5fY2FsbENhbGxiYWNrYCB0byBNYW5hZ2VyLiBOb3QgZG9uZSB5ZXQuXHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCFjb21tYW5kSGFuZGxlZCAmJiAhdGhpcy5fc3RhdGUuX3dha2VXb3JkTW9kZUFjdGl2ZSAmJiB0aGlzLl9zdGF0ZS5faXNMaXN0ZW5pbmcpIHtcclxuICAgICAgdGhpcy5fdXBkYXRlU3RhdHVzKCdMaXN0ZW5pbmcgZm9yIGNvbW1hbmRzLi4uJyk7XHJcbiAgICAgIHRoaXMuX2NhbGxDYWxsYmFjaygnb25Db21tYW5kTm90UmVjb2duaXplZCcsIHJhd1RyYW5zY3JpcHQpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNvbW1hbmRIYW5kbGVkO1xyXG4gIH1cclxuXHJcbiAgX3Jlc2V0V2FrZVdvcmRTdGF0ZSgpIHtcclxuICAgIHRoaXMuX3N0YXRlLl9hd2FpdGluZ0NvbW1hbmQgPSBmYWxzZTtcclxuICAgIGlmICh0aGlzLl93YWtlV29yZENvbW1hbmRUaW1lcikge1xyXG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5fd2FrZVdvcmRDb21tYW5kVGltZXIpO1xyXG4gICAgICB0aGlzLl93YWtlV29yZENvbW1hbmRUaW1lciA9IG51bGw7XHJcbiAgICB9XHJcbiAgICBpZiAodGhpcy5fc3RhdGUuX2lzTGlzdGVuaW5nKSB7XHJcbiAgICAgIHRoaXMuX3VwZGF0ZVN0YXR1cyhgUmV2ZXJ0ZWQgdG8gd2FrZSB3b3JkIG1vZGUuYCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBhc3luYyBfc3RhcnRSZWNvZ25pdGlvbkludGVybmFsKCkge1xyXG4gICAgaWYgKHRoaXMucmVjb2duaXRpb24gJiYgIXRoaXMuX3N0YXRlLl9pc0xpc3RlbmluZykge1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGF3YWl0IHRoaXMucmVjb2duaXRpb24uc3RhcnQoKTtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgIHRoaXMuX2NhbGxDYWxsYmFjaygnb25FcnJvcicsIGUpO1xyXG4gICAgICAgIHRoaXMuX3N0YXRlLl9pc0xpc3RlbmluZyA9IGZhbHNlO1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2FmZSBTdGFydCBNZXRob2QuXHJcbiAgICovXHJcbiAgYXN5bmMgc3RhcnQoKSB7XHJcbiAgICBpZiAodGhpcy5fc3RhcnRMb2NrKSB7XHJcbiAgICAgIGNvbnNvbGUud2FybignW0pTVm9pY2VdIHN0YXJ0KCkgaWdub3JlZDogb3BlcmF0aW9uIGFscmVhZHkgaW4gcHJvZ3Jlc3MuJyk7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIHRoaXMuX3N0YXJ0TG9jayA9IHRydWU7XHJcbiAgICBjb25zdCBteVNlc3Npb24gPSArK3RoaXMuX3Nlc3Npb25Ub2tlbjtcclxuXHJcbiAgICB0cnkge1xyXG4gICAgICBpZiAoIXRoaXMucmVjb2duaXRpb24pIHtcclxuICAgICAgICB0aGlzLl91cGRhdGVTdGF0dXMoJ1ZvaWNlIGNvbW1hbmRzIG5vdCBpbml0aWFsaXplZC4nKTtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICh0aGlzLl9pbml0UHJvbWlzZSkgYXdhaXQgdGhpcy5faW5pdFByb21pc2UuY2F0Y2goKCkgPT4geyB9KTtcclxuXHJcbiAgICAgIC8vIEFzeW5jIENoZWNrOiBEaWQgc3RvcCgpIGhhcHBlbiB3aGlsZSB3ZSB3YWl0ZWQ/XHJcbiAgICAgIGlmIChteVNlc3Npb24gIT09IHRoaXMuX3Nlc3Npb25Ub2tlbikgcmV0dXJuIGZhbHNlO1xyXG5cclxuICAgICAgYXdhaXQgdGhpcy5fY2hlY2tNaWNyb3Bob25lUGVybWlzc2lvbigpO1xyXG5cclxuICAgICAgLy8gQXN5bmMgQ2hlY2sgMlxyXG4gICAgICBpZiAobXlTZXNzaW9uICE9PSB0aGlzLl9zZXNzaW9uVG9rZW4pIHJldHVybiBmYWxzZTtcclxuXHJcbiAgICAgIGlmICghdGhpcy5fc3RhdGUuX21pY3JvcGhvbmVBbGxvd2VkKSB7XHJcbiAgICAgICAgdGhpcy5fdXBkYXRlU3RhdHVzKCdNaWNyb3Bob25lIGFjY2VzcyBkZW5pZWQuJyk7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAodGhpcy5fc3RhdGUuX3dha2VXb3JkTW9kZUFjdGl2ZSkge1xyXG4gICAgICAgIHRoaXMuX3N0YXRlLl9hd2FpdGluZ0NvbW1hbmQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl91cGRhdGVTdGF0dXMoYFdhaXRpbmcgZm9yIFwiJHt0aGlzLm9wdGlvbnMud2FrZVdvcmR9XCIuLi5gKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLl91cGRhdGVTdGF0dXMoJ0xpc3RlbmluZyBmb3IgY29tbWFuZHMuLi4nKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX3N0YXJ0UmVjb2duaXRpb25JbnRlcm5hbCgpO1xyXG4gICAgfSBmaW5hbGx5IHtcclxuICAgICAgdGhpcy5fc3RhcnRMb2NrID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBzdG9wKCkge1xyXG4gICAgdGhpcy5fc2Vzc2lvblRva2VuKys7IC8vIEludmFsaWRhdGUgYW55IHBlbmRpbmcgc3RhcnQoKVxyXG4gICAgaWYgKHRoaXMucmVjb2duaXRpb24gJiYgdGhpcy5fc3RhdGUuX2lzTGlzdGVuaW5nKSB7XHJcbiAgICAgIHRoaXMuX3N0YXRlLl9pc1N0b3BwaW5nSW50ZW50aW9uYWxseSA9IHRydWU7XHJcbiAgICAgIHRoaXMucmVjb2duaXRpb24uc3RvcCgpO1xyXG4gICAgICAvLyBzdG9wIHZpc3VhbGl6ZXIgaWYgcGx1Z2luIGF0dGFjaGVkICh2aWEgd2VhayByZWYgb3Igc2ltcGxlIGNoZWNrKVxyXG4gICAgICBpZiAodGhpcy5fYXVkaW9WaXN1YWxpemVyKSB7XHJcbiAgICAgICAgdGhpcy5zdG9wQW1wbGl0dWRlKCk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMuX3VwZGF0ZVN0YXR1cygnVm9pY2UgY29tbWFuZHMgb2ZmLicpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgdG9nZ2xlKCkge1xyXG4gICAgaWYgKHRoaXMuX3N0YXRlLl9pc0xpc3RlbmluZykge1xyXG4gICAgICB0aGlzLnN0b3AoKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMuc3RhcnQoKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHNwZWFrKHRleHQsIGxhbmcgPSB0aGlzLm9wdGlvbnMubGFuZykge1xyXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSByZXR1cm47IC8vIFNTUiBHdWFyZFxyXG4gICAgaWYgKCF0ZXh0KSByZXR1cm47XHJcblxyXG4gICAgaWYgKCF0aGlzLnNwZWVjaFN5bnRoZXNpcyB8fCAhd2luZG93LlNwZWVjaFN5bnRoZXNpc1V0dGVyYW5jZSkge1xyXG4gICAgICBjb25zb2xlLndhcm4oJ1tKU1ZvaWNlXSBTcGVlY2hTeW50aGVzaXMgbm90IHN1cHBvcnRlZC4nKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIExvZ2ljIHRvIHBhdXNlIHJlY29nbml0aW9uLi4uXHJcbiAgICBjb25zdCB3YXNMaXN0ZW5pbmcgPSB0aGlzLl9zdGF0ZS5faXNMaXN0ZW5pbmc7XHJcbiAgICBsZXQgcmVzdGFydFJlY29nbml0aW9uID0gZmFsc2U7XHJcblxyXG4gICAgaWYgKHdhc0xpc3RlbmluZyAmJiB0aGlzLl9zdGF0ZS5fbWljcm9waG9uZUFsbG93ZWQpIHtcclxuICAgICAgdGhpcy5fc3RhdGUuX2lzU3RvcHBpbmdJbnRlbnRpb25hbGx5ID0gdHJ1ZTtcclxuICAgICAgdGhpcy5yZWNvZ25pdGlvbi5zdG9wKCk7XHJcbiAgICAgIHJlc3RhcnRSZWNvZ25pdGlvbiA9IHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgdXR0ZXJhbmNlID0gbmV3IFNwZWVjaFN5bnRoZXNpc1V0dGVyYW5jZSh0ZXh0KTtcclxuICAgIHV0dGVyYW5jZS5sYW5nID0gbGFuZztcclxuXHJcbiAgICBjb25zdCBmaW5hbGl6ZVNwZWFrID0gKCkgPT4ge1xyXG4gICAgICBpZiAocmVzdGFydFJlY29nbml0aW9uICYmIHRoaXMuX3N0YXRlLl9taWNyb3Bob25lQWxsb3dlZCkge1xyXG4gICAgICAgIHRoaXMuX3N0YXJ0UmVjb2duaXRpb25JbnRlcm5hbCgpO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHV0dGVyYW5jZS5vbmVuZCA9IGZpbmFsaXplU3BlYWs7XHJcbiAgICB1dHRlcmFuY2Uub25lcnJvciA9IGZpbmFsaXplU3BlYWs7XHJcbiAgICB0aGlzLnNwZWVjaFN5bnRoZXNpcy5zcGVhayh1dHRlcmFuY2UpO1xyXG4gIH1cclxuXHJcbiAgLy8gLS0tIFZpc3VhbGl6ZXIgUHJveHkgTWV0aG9kcyAtLS1cclxuICAvLyBUaGUgY29yZSBkb2Vzbid0IGltcG9ydCB2aXN1YWxpemVyLCBidXQgZXhwb3NlcyB0aGUgQVBJIGlmIHRoZSBtb2R1bGUgaXMgbG9hZGVkIHZpYSBwbHVnaW5cclxuICAvLyBvciBtYW51YWxseSBhdHRhY2hlZC5cclxuICBzdGFydEFtcGxpdHVkZShjYWxsYmFjaywgb3B0aW9ucykge1xyXG4gICAgaWYgKCF0aGlzLl9hdWRpb1Zpc3VhbGl6ZXIpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignW0pTVm9pY2VdIEF1ZGlvVmlzdWFsaXplciBtb2R1bGUgbm90IGxvYWRlZC4gVXNlIGNyZWF0ZVZvaWNlKCkgb3Igdm9pY2UudXNlKFZpc3VhbGl6ZXJQbHVnaW4pLicpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICAvLyBPcHRpbWl6YXRpb246IElmIHdlIGhhdmUgYW4gYWN0aXZlIGVuZ2luZSB3aXRoIGEgc3RyZWFtLCBwYXNzIGl0IVxyXG4gICAgLy8gQnV0IE5hdGl2ZVNwZWVjaEVuZ2luZSAoV2ViIFNwZWVjaCBBUEkpIGRvZXMgTk9UIGV4cG9zZSB0aGUgc3RyZWFtLlxyXG4gICAgLy8gU28gd2UgdXN1YWxseSBtdXN0IGNyZWF0ZSBhIG5ldyBvbmUuIEF1ZGlvVmlzdWFsaXplci5qcyBoYW5kbGVzIHRoZSBzaGFyaW5nIGxvZ2ljIGlmIHBhc3NlZC5cclxuICAgIHRoaXMuX2F1ZGlvVmlzdWFsaXplci5zdGFydChjYWxsYmFjaywgb3B0aW9ucykuY2F0Y2goKGVycikgPT4ge1xyXG4gICAgICB0aGlzLl9jYWxsQ2FsbGJhY2soJ29uRXJyb3InLCBlcnIpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICBzdG9wQW1wbGl0dWRlKCkge1xyXG4gICAgaWYgKHRoaXMuX2F1ZGlvVmlzdWFsaXplcikge1xyXG4gICAgICB0aGlzLl9hdWRpb1Zpc3VhbGl6ZXIuc3RvcCgpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyogLS0tIE5ldyBDb21tYW5kIEFQSSAoUHJveGllZCB0byBNYW5hZ2VyKSAtLS0gKi9cclxuXHJcbiAgLyoqXHJcbiAgICogcmVnaXN0ZXJzIGEgY29tbWFuZCB3aXRoIG9wdGlvbmFsIGNvbmZpZ3VyYXRpb24uXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBocmFzZSBcclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBcclxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyB7IHByaW9yaXR5LCBzY29wZSwgY29vbGRvd24sIG9uY2UgfVxyXG4gICAqL1xyXG4gIGFkZENvbW1hbmQocGhyYXNlLCBjYWxsYmFjaywgb3B0aW9ucyA9IHt9KSB7XHJcbiAgICB0aGlzLl9jb21tYW5kTWFuYWdlci5yZWdpc3RlcihwaHJhc2UsIGNhbGxiYWNrLCBvcHRpb25zKTtcclxuICB9XHJcblxyXG4gIHJlbW92ZUNvbW1hbmQocGhyYXNlKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fY29tbWFuZE1hbmFnZXIudW5yZWdpc3RlcihwaHJhc2UpO1xyXG4gIH1cclxuXHJcbiAgYWRkUGF0dGVybkNvbW1hbmQocGF0dGVybiwgY2FsbGJhY2spIHtcclxuICAgIC8vIEJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHdyYXBwZXJcclxuICAgIHRoaXMuX2NvbW1hbmRNYW5hZ2VyLnJlZ2lzdGVyKHBhdHRlcm4sIGNhbGxiYWNrLCB7IHR5cGU6ICdwYXR0ZXJuJywgaXNQYXR0ZXJuOiB0cnVlIH0pO1xyXG4gIH1cclxuXHJcbiAgcmVtb3ZlUGF0dGVybkNvbW1hbmQocGF0dGVybikge1xyXG4gICAgcmV0dXJuIHRoaXMuX2NvbW1hbmRNYW5hZ2VyLnVucmVnaXN0ZXIocGF0dGVybik7XHJcbiAgfVxyXG5cclxuICBzZXRTY29wZShzY29wZU5hbWUpIHtcclxuICAgIHRoaXMuX2NvbW1hbmRNYW5hZ2VyLnNldFNjb3BlKHNjb3BlTmFtZSk7XHJcbiAgfVxyXG5cclxuICByZXNldFNjb3BlKCkge1xyXG4gICAgdGhpcy5fY29tbWFuZE1hbmFnZXIucmVzZXRTY29wZSgpO1xyXG4gIH1cclxuXHJcbiAgLyogLS0tIE9wdGlvbnMgLS0tICovXHJcblxyXG4gIHNldE9wdGlvbihrZXksIHZhbHVlKSB7XHJcbiAgICB0aGlzLm9wdGlvbnNba2V5XSA9IHZhbHVlO1xyXG4gICAgaWYgKGtleSA9PT0gJ2RlYnVnJykge1xyXG4gICAgICB0aGlzLl9jb21tYW5kTWFuYWdlci5kZWJ1Z01vZGUgPSAhIXZhbHVlO1xyXG4gICAgfVxyXG4gICAgaWYgKHRoaXMucmVjb2duaXRpb24gJiYgdGhpcy5yZWNvZ25pdGlvbi5zZXRPcHRpb25zKSB7XHJcbiAgICAgIHRoaXMucmVjb2duaXRpb24uc2V0T3B0aW9ucyh7IFtrZXldOiB2YWx1ZSB9KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIEdldHRlcnNcclxuICAvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xyXG4gIC8qICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEludGVybmFsIEhlbHBlcnMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcbiAgLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cclxuXHJcbiAgZ2V0U25hcHNob3QoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fc25hcHNob3Q7XHJcbiAgfVxyXG5cclxuICBzdWJzY3JpYmUobGlzdGVuZXIpIHtcclxuICAgIGlmICghdGhpcy5fbGlzdGVuZXJzKSB0aGlzLl9saXN0ZW5lcnMgPSBuZXcgU2V0KCk7XHJcbiAgICB0aGlzLl9saXN0ZW5lcnMuYWRkKGxpc3RlbmVyKTtcclxuICAgIC8vIEVtaXQgaW5pdGlhbFxyXG4gICAgbGlzdGVuZXIodGhpcy5fc25hcHNob3QsIHsgdHlwZTogJ2luaXQnIH0pO1xyXG4gICAgcmV0dXJuICgpID0+IHRoaXMuX2xpc3RlbmVycy5kZWxldGUobGlzdGVuZXIpO1xyXG4gIH1cclxuXHJcbiAgX25vdGlmeUxpc3RlbmVycyhldmVudCkge1xyXG4gICAgaWYgKCF0aGlzLl9saXN0ZW5lcnMpIHJldHVybjtcclxuICAgIHRoaXMuX2xpc3RlbmVycy5mb3JFYWNoKGwgPT4gbCh0aGlzLl9zbmFwc2hvdCwgZXZlbnQpKTtcclxuICB9XHJcblxyXG4gIF91cGRhdGVTbmFwc2hvdChjaGFuZ2VzKSB7XHJcbiAgICB0aGlzLl9zbmFwc2hvdCA9IHsgLi4udGhpcy5fc25hcHNob3QsIC4uLmNoYW5nZXMgfTtcclxuICB9XHJcblxyXG4gIF9jYWxsQ2FsbGJhY2sobmFtZSwgLi4uYXJncykge1xyXG4gICAgLy8gMS4gVXBkYXRlIFNuYXBzaG90IGJhc2VkIG9uIGV2ZW50XHJcbiAgICBpZiAobmFtZSA9PT0gJ29uRW5naW5lU3RhdGVDaGFuZ2UnKSB7XHJcbiAgICAgIGNvbnN0IHN0YXRlID0gYXJnc1swXSB8fCAndW5rbm93bic7XHJcbiAgICAgIHRoaXMuX3VwZGF0ZVNuYXBzaG90KHsgc3RhdHVzOiBzdGF0ZSB9KTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAobmFtZSA9PT0gJ29uUmVzdWx0Jykge1xyXG4gICAgICAvLyBhcmdzWzBdIGlzIHRyYW5zY3JpcHQgb3IgZXZlbnRcclxuICAgICAgY29uc3QgZGF0YSA9IGFyZ3NbMF07XHJcbiAgICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XHJcbiAgICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICB0aGlzLl91cGRhdGVTbmFwc2hvdCh7XHJcbiAgICAgICAgICB0cmFuc2NyaXB0OiB7XHJcbiAgICAgICAgICAgIHBhcnRpYWw6ICghYXJnc1sxXSA/IGRhdGEgOiAnJyksXHJcbiAgICAgICAgICAgIGZpbmFsOiAoYXJnc1sxXSA/IGRhdGEgOiB0aGlzLl9zbmFwc2hvdC50cmFuc2NyaXB0LmZpbmFsKSxcclxuICAgICAgICAgICAgdXBkYXRlZEF0OiBub3dcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgfSBlbHNlIGlmIChkYXRhICYmIHR5cGVvZiBkYXRhID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgIC8vIFByb3RvY29sXHJcbiAgICAgICAgdGhpcy5fdXBkYXRlU25hcHNob3Qoe1xyXG4gICAgICAgICAgdHJhbnNjcmlwdDoge1xyXG4gICAgICAgICAgICBwYXJ0aWFsOiAoIWRhdGEuaXNGaW5hbCA/IGRhdGEudGV4dCA6ICcnKSxcclxuICAgICAgICAgICAgZmluYWw6IChkYXRhLmlzRmluYWwgPyBkYXRhLnRleHQgOiB0aGlzLl9zbmFwc2hvdC50cmFuc2NyaXB0LmZpbmFsKSxcclxuICAgICAgICAgICAgdXBkYXRlZEF0OiBub3dcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmIChuYW1lID09PSAnb25FbmdpbmVTZWxlY3RlZCcpIHtcclxuICAgICAgY29uc3QgeyBtb2RlIH0gPSBhcmdzWzBdIHx8IHt9O1xyXG4gICAgICB0aGlzLl91cGRhdGVTbmFwc2hvdCh7IGVuZ2luZTogeyAuLi50aGlzLl9zbmFwc2hvdC5lbmdpbmUsIG1vZGUgfSB9KTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy5fbGlzdGVuZXJzKSB7XHJcbiAgICAgIHRoaXMuX25vdGlmeUxpc3RlbmVycyh7IHR5cGU6IG5hbWUsIHBheWxvYWQ6IGFyZ3MgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gMy4gRXhlY3V0ZSBsZWdhY3kgY2FsbGJhY2tcclxuICAgIGlmICh0aGlzLl9jYWxsYmFja3MgJiYgdHlwZW9mIHRoaXMuX2NhbGxiYWNrc1tuYW1lXSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIHRoaXMuX2NhbGxiYWNrc1tuYW1lXSguLi5hcmdzKTtcclxuICAgICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcihgW0pTVm9pY2VdIEVycm9yIGluIGNhbGxiYWNrICcke25hbWV9JzpgLCBlcnIpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBfdXBkYXRlU3RhdHVzKG1lc3NhZ2UpIHtcclxuICAgIHRoaXMuX2NhbGxDYWxsYmFjaygnb25TdGF0dXNDaGFuZ2UnLCBtZXNzYWdlKTtcclxuICB9XHJcblxyXG4gIC8vIEdldHRlcnNcclxuICBnZXQgaXNMaXN0ZW5pbmcoKSB7IHJldHVybiB0aGlzLl9zdGF0ZS5faXNMaXN0ZW5pbmc7IH1cclxuICBnZXQgbWljcm9waG9uZUFsbG93ZWQoKSB7IHJldHVybiB0aGlzLl9zdGF0ZS5fbWljcm9waG9uZUFsbG93ZWQ7IH1cclxuICBnZXQgdm9pY2VGZWVkYmFjaygpIHsgcmV0dXJuIHRoaXMuX2N1cnJlbnRWb2ljZUZlZWRiYWNrOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IEpTVm9pY2U7XHJcbiJdLCJuYW1lcyI6WyJjYWxsQ2FsbGJhY2siLCJjbGVhblRleHQiLCJpbml0UmVjb2duaXRpb24iLCJjaGVja01pY3JvcGhvbmVQZXJtaXNzaW9uIiwiQ29tbWFuZE1hbmFnZXIiLCJKU1ZvaWNlIiwiaXNBcGlTdXBwb3J0ZWQiLCJ3aW5kb3ciLCJTcGVlY2hSZWNvZ25pdGlvbiIsIndlYmtpdFNwZWVjaFJlY29nbml0aW9uIiwiX2luaXRFbmdpbmUiLCJFbmdpbmVDbGFzc1RvVXNlIiwiZW5naW5lSW5zdGFuY2UiLCJvcHRpb25zIiwiZW5naW5lIiwiZW5naW5lc0xpc3QiLCJBcnJheSIsImlzQXJyYXkiLCJlbmdpbmVzIiwiRW5naW5lQ2xhc3MiLCJpc1N1cHBvcnRlZCIsImxlbmd0aCIsImNvbnNvbGUiLCJ3YXJuIiwic2V0Q2FsbGJhY2tzIiwib25TdGF0ZUNoYW5nZSIsInN0YXRlIiwiX2NhbGxDYWxsYmFjayIsInJlY29nbml0aW9uIiwiX3VwZGF0ZVN0YXR1cyIsImJpbmQiLCJfaGFuZGxlU3BlZWNoUmVzdWx0IiwiX3N0YXJ0UmVjb2duaXRpb25JbnRlcm5hbCIsIl9zdGF0ZSIsIl9pbml0UHJvbWlzZSIsImluaXQiLCJjYXRjaCIsImUiLCJlcnJvciIsImNhbGxiYWNrTmFtZSIsImFyZ3MiLCJtZXNzYWdlIiwiX2N1cnJlbnRWb2ljZUZlZWRiYWNrIiwiX2NoZWNrTWljcm9waG9uZVBlcm1pc3Npb24iLCJvcHRzIiwicmF3VHJhbnNjcmlwdCIsImNsZWFuZWRUcmFuc2NyaXB0IiwiX3dha2VXb3JkTW9kZUFjdGl2ZSIsIl9hd2FpdGluZ0NvbW1hbmQiLCJpbmNsdWRlcyIsIndha2VXb3JkIiwiX3dha2VXb3JkQ29tbWFuZFRpbWVyIiwiY2xlYXJUaW1lb3V0Iiwic2V0VGltZW91dCIsIl9yZXNldFdha2VXb3JkU3RhdGUiLCJ3YWtlV29yZFRpbWVvdXQiLCJjb21tYW5kSGFuZGxlZCIsIl9jb21tYW5kTWFuYWdlciIsInByb2Nlc3MiLCJzcGVhayIsIl9pc0xpc3RlbmluZyIsInN0YXJ0IiwiX3N0YXJ0TG9jayIsIm15U2Vzc2lvbiIsIl9zZXNzaW9uVG9rZW4iLCJfbWljcm9waG9uZUFsbG93ZWQiLCJzdG9wIiwiX2lzU3RvcHBpbmdJbnRlbnRpb25hbGx5IiwiX2F1ZGlvVmlzdWFsaXplciIsInN0b3BBbXBsaXR1ZGUiLCJ0b2dnbGUiLCJ0ZXh0IiwibGFuZyIsInNwZWVjaFN5bnRoZXNpcyIsIlNwZWVjaFN5bnRoZXNpc1V0dGVyYW5jZSIsIndhc0xpc3RlbmluZyIsInJlc3RhcnRSZWNvZ25pdGlvbiIsInV0dGVyYW5jZSIsImZpbmFsaXplU3BlYWsiLCJvbmVuZCIsIm9uZXJyb3IiLCJzdGFydEFtcGxpdHVkZSIsImNhbGxiYWNrIiwiZXJyIiwiYWRkQ29tbWFuZCIsInBocmFzZSIsInJlZ2lzdGVyIiwicmVtb3ZlQ29tbWFuZCIsInVucmVnaXN0ZXIiLCJhZGRQYXR0ZXJuQ29tbWFuZCIsInBhdHRlcm4iLCJ0eXBlIiwiaXNQYXR0ZXJuIiwicmVtb3ZlUGF0dGVybkNvbW1hbmQiLCJzZXRTY29wZSIsInNjb3BlTmFtZSIsInJlc2V0U2NvcGUiLCJzZXRPcHRpb24iLCJrZXkiLCJ2YWx1ZSIsImRlYnVnTW9kZSIsInNldE9wdGlvbnMiLCJnZXRTbmFwc2hvdCIsIl9zbmFwc2hvdCIsInN1YnNjcmliZSIsImxpc3RlbmVyIiwiX2xpc3RlbmVycyIsIlNldCIsImFkZCIsImRlbGV0ZSIsIl9ub3RpZnlMaXN0ZW5lcnMiLCJldmVudCIsImZvckVhY2giLCJsIiwiX3VwZGF0ZVNuYXBzaG90IiwiY2hhbmdlcyIsIm5hbWUiLCJzdGF0dXMiLCJkYXRhIiwibm93IiwiRGF0ZSIsInRyYW5zY3JpcHQiLCJwYXJ0aWFsIiwiZmluYWwiLCJ1cGRhdGVkQXQiLCJpc0ZpbmFsIiwibW9kZSIsInBheWxvYWQiLCJfY2FsbGJhY2tzIiwiaXNMaXN0ZW5pbmciLCJtaWNyb3Bob25lQWxsb3dlZCIsInZvaWNlRmVlZGJhY2siLCJjb25zdHJ1Y3RvciIsImNvbnRpbnVvdXMiLCJpbnRlcmltUmVzdWx0cyIsImNvbW1hbmRzIiwicGF0dGVybkNvbW1hbmRzIiwiYXV0b1Jlc3RhcnQiLCJyZXN0YXJ0RGVsYXkiLCJwbHVnaW5zIiwiZGVidWciLCJkZWZhdWx0U2NvcGUiLCJvblNwZWVjaFN0YXJ0Iiwib25TcGVlY2hFbmQiLCJvbkNvbW1hbmRSZWNvZ25pemVkIiwib25Db21tYW5kTm90UmVjb2duaXplZCIsIm9uQWN0aW9uUGVyZm9ybWVkIiwib25NaWNyb3Bob25lUGVybWlzc2lvbkdyYW50ZWQiLCJvbk1pY3JvcGhvbmVQZXJtaXNzaW9uRGVuaWVkIiwib25XYWtlV29yZERldGVjdGVkIiwib25FbmdpbmVTdGF0ZUNoYW5nZSIsIm9uQ29tbWFuZEV2YWx1YXRlZCIsIm9uRXJyb3IiLCJvblN0YXR1c0NoYW5nZSIsIm9uRW5naW5lU2VsZWN0ZWQiLCJvbkZhbGxiYWNrQWN0aXZhdGVkIiwib25UZWxlbWV0cnkiLCJvblJlc3VsdCIsImNvbW1hbmROYW1lIiwiY29tbWFuZFRleHQiLCJwZXJtaXNzaW9ucyIsIm1pY3JvcGhvbmUiLCJtZXRyaWNzIiwiZXZ0IiwidXNlIiwicGx1Z2luIiwicGx1Z2luQXBpIiwiX3NlbGYiLCJwIiwicGF0dGVybkNtZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../src/JSVoice.js\n"));

/***/ })

});