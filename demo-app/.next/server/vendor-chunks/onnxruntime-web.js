/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/onnxruntime-web";
exports.ids = ["vendor-chunks/onnxruntime-web"];
exports.modules = {

/***/ "(ssr)/../node_modules/onnxruntime-web/dist/ort-web.node.js":
/*!************************************************************!*\
  !*** ../node_modules/onnxruntime-web/dist/ort-web.node.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/*!\n* ONNX Runtime Web v1.14.0\n* Copyright (c) Microsoft Corporation. All rights reserved.\n* Licensed under the MIT License.\n*/ (()=>{\n    var __webpack_modules__ = {\n        3474: (t, e, n)=>{\n            var _scriptDir, r = (_scriptDir = (_scriptDir = \"undefined\" != typeof document && document.currentScript ? document.currentScript.src : void 0) || __filename, function(t) {\n                function e() {\n                    return $.buffer != C && H($.buffer), F;\n                }\n                function r() {\n                    return $.buffer != C && H($.buffer), N;\n                }\n                function i() {\n                    return $.buffer != C && H($.buffer), R;\n                }\n                function o() {\n                    return $.buffer != C && H($.buffer), L;\n                }\n                function a() {\n                    return $.buffer != C && H($.buffer), M;\n                }\n                var s, u, c;\n                t = t || {}, s || (s = void 0 !== t ? t : {}), s.ready = new Promise(function(t, e) {\n                    u = t, c = e;\n                });\n                var l, p, f, d, h, g, b = Object.assign({}, s), m = \"./this.program\", y = (t, e)=>{\n                    throw e;\n                }, _ = \"object\" == \"undefined\", v = \"function\" == typeof importScripts, w = \"object\" == typeof process && \"object\" == typeof process.versions && \"string\" == typeof process.versions.node, x = s.ENVIRONMENT_IS_PTHREAD || !1, T = \"\";\n                function S(t) {\n                    return s.locateFile ? s.locateFile(t, T) : T + t;\n                }\n                if (w) {\n                    let e;\n                    T = v ? n(1423).dirname(T) + \"/\" : __dirname + \"/\", g = ()=>{\n                        h || (d = n(6231), h = n(1423));\n                    }, l = function(t, e) {\n                        return g(), t = h.normalize(t), d.readFileSync(t, e ? void 0 : \"utf8\");\n                    }, f = (t)=>((t = l(t, !0)).buffer || (t = new Uint8Array(t)), t), p = (t, e, n)=>{\n                        g(), t = h.normalize(t), d.readFile(t, function(t, r) {\n                            t ? n(t) : e(r.buffer);\n                        });\n                    }, 1 < process.argv.length && (m = process.argv[1].replace(/\\\\/g, \"/\")), process.argv.slice(2), process.on(\"uncaughtException\", function(t) {\n                        if (!(t instanceof ut)) throw t;\n                    }), process.on(\"unhandledRejection\", function(t) {\n                        throw t;\n                    }), y = (t, e)=>{\n                        if (J()) throw process.exitCode = t, e;\n                        e instanceof ut || P(\"exiting due to exception: \" + e), process.exit(t);\n                    }, s.inspect = function() {\n                        return \"[Emscripten Module object]\";\n                    };\n                    try {\n                        e = n(4564);\n                    } catch (t) {\n                        throw console.error('The \"worker_threads\" module is not supported in this node.js build - perhaps a newer version is needed?'), t;\n                    }\n                    global.Worker = e.Worker;\n                } else (_ || v) && (v ? T = self.location.href : \"undefined\" != typeof document && document.currentScript && (T = document.currentScript.src), _scriptDir && (T = _scriptDir), T = 0 !== T.indexOf(\"blob:\") ? T.substr(0, T.replace(/[?#].*/, \"\").lastIndexOf(\"/\") + 1) : \"\", w || (l = (t)=>{\n                    var e = new XMLHttpRequest;\n                    return e.open(\"GET\", t, !1), e.send(null), e.responseText;\n                }, v && (f = (t)=>{\n                    var e = new XMLHttpRequest;\n                    return e.open(\"GET\", t, !1), e.responseType = \"arraybuffer\", e.send(null), new Uint8Array(e.response);\n                }), p = (t, e, n)=>{\n                    var r = new XMLHttpRequest;\n                    r.open(\"GET\", t, !0), r.responseType = \"arraybuffer\", r.onload = ()=>{\n                        200 == r.status || 0 == r.status && r.response ? e(r.response) : n();\n                    }, r.onerror = n, r.send(null);\n                }));\n                w && \"undefined\" == typeof performance && (global.performance = n(498).performance);\n                var O = console.log.bind(console), A = console.warn.bind(console);\n                w && (g(), O = (t)=>d.writeSync(1, t + \"\\n\"), A = (t)=>d.writeSync(2, t + \"\\n\"));\n                var E, I = s.print || O, P = s.printErr || A;\n                Object.assign(s, b), b = null, s.thisProgram && (m = s.thisProgram), s.quit && (y = s.quit), s.wasmBinary && (E = s.wasmBinary);\n                var D = s.noExitRuntime || !1;\n                \"object\" != typeof WebAssembly && it(\"no native wasm support detected\");\n                var $, k, C, F, N, R, L, M, j = !1, U = \"undefined\" != typeof TextDecoder ? new TextDecoder(\"utf8\") : void 0;\n                function V(t, e, n) {\n                    var r = (e >>>= 0) + n;\n                    for(n = e; t[n] && !(n >= r);)++n;\n                    if (16 < n - e && t.buffer && U) return U.decode(t.buffer instanceof SharedArrayBuffer ? t.slice(e, n) : t.subarray(e, n));\n                    for(r = \"\"; e < n;){\n                        var i = t[e++];\n                        if (128 & i) {\n                            var o = 63 & t[e++];\n                            if (192 == (224 & i)) r += String.fromCharCode((31 & i) << 6 | o);\n                            else {\n                                var a = 63 & t[e++];\n                                65536 > (i = 224 == (240 & i) ? (15 & i) << 12 | o << 6 | a : (7 & i) << 18 | o << 12 | a << 6 | 63 & t[e++]) ? r += String.fromCharCode(i) : (i -= 65536, r += String.fromCharCode(55296 | i >> 10, 56320 | 1023 & i));\n                            }\n                        } else r += String.fromCharCode(i);\n                    }\n                    return r;\n                }\n                function B(t, e) {\n                    return (t >>>= 0) ? V(r(), t, e) : \"\";\n                }\n                function z(t, e, n, r) {\n                    if (!(0 < r)) return 0;\n                    var i = n >>>= 0;\n                    r = n + r - 1;\n                    for(var o = 0; o < t.length; ++o){\n                        var a = t.charCodeAt(o);\n                        if (55296 <= a && 57343 >= a && (a = 65536 + ((1023 & a) << 10) | 1023 & t.charCodeAt(++o)), 127 >= a) {\n                            if (n >= r) break;\n                            e[n++ >>> 0] = a;\n                        } else {\n                            if (2047 >= a) {\n                                if (n + 1 >= r) break;\n                                e[n++ >>> 0] = 192 | a >> 6;\n                            } else {\n                                if (65535 >= a) {\n                                    if (n + 2 >= r) break;\n                                    e[n++ >>> 0] = 224 | a >> 12;\n                                } else {\n                                    if (n + 3 >= r) break;\n                                    e[n++ >>> 0] = 240 | a >> 18, e[n++ >>> 0] = 128 | a >> 12 & 63;\n                                }\n                                e[n++ >>> 0] = 128 | a >> 6 & 63;\n                            }\n                            e[n++ >>> 0] = 128 | 63 & a;\n                        }\n                    }\n                    return e[n >>> 0] = 0, n - i;\n                }\n                function G(t) {\n                    for(var e = 0, n = 0; n < t.length; ++n){\n                        var r = t.charCodeAt(n);\n                        127 >= r ? e++ : 2047 >= r ? e += 2 : 55296 <= r && 57343 >= r ? (e += 4, ++n) : e += 3;\n                    }\n                    return e;\n                }\n                function H(t) {\n                    C = t, s.HEAP8 = F = new Int8Array(t), s.HEAP16 = new Int16Array(t), s.HEAP32 = R = new Int32Array(t), s.HEAPU8 = N = new Uint8Array(t), s.HEAPU16 = new Uint16Array(t), s.HEAPU32 = L = new Uint32Array(t), s.HEAPF32 = new Float32Array(t), s.HEAPF64 = M = new Float64Array(t);\n                }\n                x && (C = s.buffer);\n                var q = s.INITIAL_MEMORY || 16777216;\n                if (x) $ = s.wasmMemory, C = s.buffer;\n                else if (s.wasmMemory) $ = s.wasmMemory;\n                else if (!(($ = new WebAssembly.Memory({\n                    initial: q / 65536,\n                    maximum: 65536,\n                    shared: !0\n                })).buffer instanceof SharedArrayBuffer)) throw P(\"requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag\"), w && console.log(\"(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and also use a recent version)\"), Error(\"bad memory\");\n                $ && (C = $.buffer), q = C.byteLength, H(C);\n                var W, X = [], Y = [], K = [], Z = [];\n                function J() {\n                    return D || !1;\n                }\n                function Q() {\n                    var t = s.preRun.shift();\n                    X.unshift(t);\n                }\n                var tt, et = 0, nt = null, rt = null;\n                function it(t) {\n                    throw x ? postMessage({\n                        cmd: \"onAbort\",\n                        arg: t\n                    }) : s.onAbort && s.onAbort(t), P(t = \"Aborted(\" + t + \")\"), j = !0, t = new WebAssembly.RuntimeError(t + \". Build with -sASSERTIONS for more info.\"), c(t), t;\n                }\n                function ot() {\n                    return tt.startsWith(\"data:application/octet-stream;base64,\");\n                }\n                function at() {\n                    var t = tt;\n                    try {\n                        if (t == tt && E) return new Uint8Array(E);\n                        if (f) return f(t);\n                        throw \"both async and sync fetching of the wasm failed\";\n                    } catch (t) {\n                        it(t);\n                    }\n                }\n                tt = \"ort-wasm-threaded.wasm\", ot() || (tt = S(tt));\n                var st = {};\n                function ut(t) {\n                    this.name = \"ExitStatus\", this.message = \"Program terminated with exit(\" + t + \")\", this.status = t;\n                }\n                function ct(t) {\n                    (t = dt.Vb[t]) || it(), dt.mc(t);\n                }\n                function lt(t) {\n                    var e = dt.Cc();\n                    if (!e) return 6;\n                    dt.ac.push(e), dt.Vb[t.Ub] = e, e.Ub = t.Ub;\n                    var n = {\n                        cmd: \"run\",\n                        start_routine: t.Ic,\n                        arg: t.zc,\n                        pthread_ptr: t.Ub\n                    };\n                    return e.$b = ()=>{\n                        n.time = performance.now(), e.postMessage(n, t.Nc);\n                    }, e.loaded && (e.$b(), delete e.$b), 0;\n                }\n                function pt(t) {\n                    if (x) return Wt(1, 1, t);\n                    J() || (dt.oc(), s.onExit && s.onExit(t), j = !0), y(t, new ut(t));\n                }\n                function ft(t, e) {\n                    if (!e && x) throw bt(t), \"unwind\";\n                    J() || x || (me(), ht(K), be(0), re[1].length && ie(1, 10), re[2].length && ie(2, 10), dt.oc()), pt(t);\n                }\n                var dt = {\n                    Yb: [],\n                    ac: [],\n                    qc: [],\n                    Vb: {},\n                    fc: function() {\n                        x && dt.Ec();\n                    },\n                    Pc: function() {},\n                    Ec: function() {\n                        dt.receiveObjectTransfer = dt.Gc, dt.threadInitTLS = dt.pc, dt.setExitStatus = dt.nc, D = !1;\n                    },\n                    nc: function() {},\n                    oc: function() {\n                        for (var t of Object.values(dt.Vb))dt.mc(t);\n                        for (t of dt.Yb)t.terminate();\n                        dt.Yb = [];\n                    },\n                    mc: function(t) {\n                        var e = t.Ub;\n                        delete dt.Vb[e], dt.Yb.push(t), dt.ac.splice(dt.ac.indexOf(t), 1), t.Ub = 0, xe(e);\n                    },\n                    Gc: function() {},\n                    pc: function() {\n                        dt.qc.forEach((t)=>t());\n                    },\n                    Fc: function(t, e) {\n                        t.onmessage = (n)=>{\n                            var r = (n = n.data).cmd;\n                            if (t.Ub && (dt.Bc = t.Ub), n.targetThread && n.targetThread != de()) {\n                                var i = dt.Vb[n.Qc];\n                                i ? i.postMessage(n, n.transferList) : P('Internal error! Worker sent a message \"' + r + '\" to target pthread ' + n.targetThread + \", but that thread no longer exists!\");\n                            } else \"processProxyingQueue\" === r ? Vt(n.queue) : \"spawnThread\" === r ? lt(n) : \"cleanupThread\" === r ? ct(n.thread) : \"killThread\" === r ? (n = n.thread, r = dt.Vb[n], delete dt.Vb[n], r.terminate(), xe(n), dt.ac.splice(dt.ac.indexOf(r), 1), r.Ub = 0) : \"cancelThread\" === r ? dt.Vb[n.thread].postMessage({\n                                cmd: \"cancel\"\n                            }) : \"loaded\" === r ? (t.loaded = !0, e && e(t), t.$b && (t.$b(), delete t.$b)) : \"print\" === r ? I(\"Thread \" + n.threadId + \": \" + n.text) : \"printErr\" === r ? P(\"Thread \" + n.threadId + \": \" + n.text) : \"alert\" === r ? alert(\"Thread \" + n.threadId + \": \" + n.text) : \"setimmediate\" === n.target ? t.postMessage(n) : \"onAbort\" === r ? s.onAbort && s.onAbort(n.arg) : r && P(\"worker sent an unknown command \" + r);\n                            dt.Bc = void 0;\n                        }, t.onerror = (t)=>{\n                            throw P(\"worker sent an error! \" + t.filename + \":\" + t.lineno + \": \" + t.message), t;\n                        }, w && (t.on(\"message\", function(e) {\n                            t.onmessage({\n                                data: e\n                            });\n                        }), t.on(\"error\", function(e) {\n                            t.onerror(e);\n                        }), t.on(\"detachedExit\", function() {})), t.postMessage({\n                            cmd: \"load\",\n                            urlOrBlob: s.mainScriptUrlOrBlob || _scriptDir,\n                            wasmMemory: $,\n                            wasmModule: k\n                        });\n                    },\n                    yc: function() {\n                        var t = S(\"ort-wasm-threaded.worker.js\");\n                        dt.Yb.push(new Worker(t));\n                    },\n                    Cc: function() {\n                        return 0 == dt.Yb.length && (dt.yc(), dt.Fc(dt.Yb[0])), dt.Yb.pop();\n                    }\n                };\n                function ht(t) {\n                    for(; 0 < t.length;)t.shift()(s);\n                }\n                function gt(t) {\n                    var e = Ae();\n                    return t = t(), Ee(e), t;\n                }\n                function bt(t) {\n                    if (x) return Wt(2, 0, t);\n                    try {\n                        ft(t);\n                    } catch (t) {\n                        t instanceof ut || \"unwind\" == t || y(1, t);\n                    }\n                }\n                s.PThread = dt, s.establishStackSpace = function() {\n                    var t = de(), e = i()[t + 44 >> 2 >>> 0];\n                    t = i()[t + 48 >> 2 >>> 0], Oe(e, e - t), Ee(e);\n                };\n                var mt = [];\n                function yt(t) {\n                    var e = mt[t];\n                    return e || (t >= mt.length && (mt.length = t + 1), mt[t] = e = W.get(t)), e;\n                }\n                s.invokeEntryPoint = function(t, e) {\n                    t = yt(t)(e), J() ? dt.nc(t) : Te(t);\n                };\n                var _t, vt, wt = [], xt = 0, Tt = 0;\n                function St(t) {\n                    this.Zb = t, this.Sb = t - 24, this.xc = function(t) {\n                        o()[this.Sb + 4 >> 2 >>> 0] = t;\n                    }, this.bc = function() {\n                        return o()[this.Sb + 4 >> 2 >>> 0];\n                    }, this.wc = function(t) {\n                        o()[this.Sb + 8 >> 2 >>> 0] = t;\n                    }, this.Dc = function() {\n                        return o()[this.Sb + 8 >> 2 >>> 0];\n                    }, this.rc = function() {\n                        i()[this.Sb >> 2 >>> 0] = 0;\n                    }, this.hc = function(t) {\n                        t = t ? 1 : 0, e()[this.Sb + 12 >> 0 >>> 0] = t;\n                    }, this.uc = function() {\n                        return 0 != e()[this.Sb + 12 >> 0 >>> 0];\n                    }, this.ic = function(t) {\n                        t = t ? 1 : 0, e()[this.Sb + 13 >> 0 >>> 0] = t;\n                    }, this.kc = function() {\n                        return 0 != e()[this.Sb + 13 >> 0 >>> 0];\n                    }, this.fc = function(t, e) {\n                        this.cc(0), this.xc(t), this.wc(e), this.rc(), this.hc(!1), this.ic(!1);\n                    }, this.sc = function() {\n                        Atomics.add(i(), this.Sb >> 2, 1);\n                    }, this.Hc = function() {\n                        return 1 === Atomics.sub(i(), this.Sb >> 2, 1);\n                    }, this.cc = function(t) {\n                        o()[this.Sb + 16 >> 2 >>> 0] = t;\n                    }, this.tc = function() {\n                        return o()[this.Sb + 16 >> 2 >>> 0];\n                    }, this.vc = function() {\n                        if (De(this.bc())) return o()[this.Zb >> 2 >>> 0];\n                        var t = this.tc();\n                        return 0 !== t ? t : this.Zb;\n                    };\n                }\n                function Ot(t) {\n                    return ge(new St(t).Sb);\n                }\n                function At(t, e, n, r) {\n                    return x ? Wt(3, 1, t, e, n, r) : Et(t, e, n, r);\n                }\n                function Et(t, e, n, r) {\n                    if (\"undefined\" == typeof SharedArrayBuffer) return P(\"Current environment does not support SharedArrayBuffer, pthreads are not available!\"), 6;\n                    var i = [];\n                    return x && 0 === i.length ? At(t, e, n, r) : (t = {\n                        Ic: n,\n                        Ub: t,\n                        zc: r,\n                        Nc: i\n                    }, x ? (t.Oc = \"spawnThread\", postMessage(t, i), 0) : lt(t));\n                }\n                function It(t, e, n) {\n                    return x ? Wt(4, 1, t, e, n) : 0;\n                }\n                function Pt(t, e) {\n                    if (x) return Wt(5, 1, t, e);\n                }\n                function Dt(t, e) {\n                    if (x) return Wt(6, 1, t, e);\n                }\n                function $t(t, e, n) {\n                    if (x) return Wt(7, 1, t, e, n);\n                }\n                function kt(t, e, n) {\n                    return x ? Wt(8, 1, t, e, n) : 0;\n                }\n                function Ct(t, e) {\n                    if (x) return Wt(9, 1, t, e);\n                }\n                function Ft(t, e, n) {\n                    if (x) return Wt(10, 1, t, e, n);\n                }\n                function Nt(t, e, n, r) {\n                    if (x) return Wt(11, 1, t, e, n, r);\n                }\n                function Rt(t, e, n, r) {\n                    if (x) return Wt(12, 1, t, e, n, r);\n                }\n                function Lt(t, e, n, r) {\n                    if (x) return Wt(13, 1, t, e, n, r);\n                }\n                function Mt(t) {\n                    if (x) return Wt(14, 1, t);\n                }\n                function jt(t, e) {\n                    if (x) return Wt(15, 1, t, e);\n                }\n                function Ut(t, e, n) {\n                    if (x) return Wt(16, 1, t, e, n);\n                }\n                function Vt(t) {\n                    Atomics.store(i(), t >> 2, 1), de() && we(t), Atomics.compareExchange(i(), t >> 2, 1, 0);\n                }\n                function Bt(t) {\n                    return o()[t >>> 2] + 4294967296 * i()[t + 4 >>> 2];\n                }\n                function zt(t, e, n, r, i, o) {\n                    return x ? Wt(17, 1, t, e, n, r, i, o) : -52;\n                }\n                function Gt(t, e, n, r, i, o) {\n                    if (x) return Wt(18, 1, t, e, n, r, i, o);\n                }\n                function Ht(t) {\n                    var n = G(t) + 1, r = he(n);\n                    return r && z(t, e(), r, n), r;\n                }\n                function qt(t, e, n) {\n                    function r(t) {\n                        return (t = t.toTimeString().match(/\\(([A-Za-z ]+)\\)$/)) ? t[1] : \"GMT\";\n                    }\n                    if (x) return Wt(19, 1, t, e, n);\n                    var a = (new Date).getFullYear(), s = new Date(a, 0, 1), u = new Date(a, 6, 1);\n                    a = s.getTimezoneOffset();\n                    var c = u.getTimezoneOffset(), l = Math.max(a, c);\n                    i()[t >> 2 >>> 0] = 60 * l, i()[e >> 2 >>> 0] = Number(a != c), t = r(s), e = r(u), t = Ht(t), e = Ht(e), c < a ? (o()[n >> 2 >>> 0] = t, o()[n + 4 >> 2 >>> 0] = e) : (o()[n >> 2 >>> 0] = e, o()[n + 4 >> 2 >>> 0] = t);\n                }\n                function Wt(t, e) {\n                    var n = arguments.length - 2, r = arguments;\n                    return gt(()=>{\n                        for(var i = Ie(8 * n), o = i >> 3, s = 0; s < n; s++){\n                            var u = r[2 + s];\n                            a()[o + s >>> 0] = u;\n                        }\n                        return ve(t, n, i, e);\n                    });\n                }\n                s.executeNotifiedProxyingQueue = Vt, vt = w ? ()=>{\n                    var t = process.hrtime();\n                    return 1e3 * t[0] + t[1] / 1e6;\n                } : x ? ()=>performance.now() - s.__performance_now_clock_drift : ()=>performance.now();\n                var Xt, Yt = [], Kt = {};\n                function Zt() {\n                    if (!Xt) {\n                        var t, e = {\n                            USER: \"web_user\",\n                            LOGNAME: \"web_user\",\n                            PATH: \"/\",\n                            PWD: \"/\",\n                            HOME: \"/home/web_user\",\n                            LANG: (\"object\" == typeof navigator && navigator.languages && navigator.languages[0] || \"C\").replace(\"-\", \"_\") + \".UTF-8\",\n                            _: m || \"./this.program\"\n                        };\n                        for(t in Kt)void 0 === Kt[t] ? delete e[t] : e[t] = Kt[t];\n                        var n = [];\n                        for(t in e)n.push(t + \"=\" + e[t]);\n                        Xt = n;\n                    }\n                    return Xt;\n                }\n                function Jt(t, n) {\n                    if (x) return Wt(20, 1, t, n);\n                    var r = 0;\n                    return Zt().forEach(function(i, a) {\n                        var s = n + r;\n                        for(a = o()[t + 4 * a >> 2 >>> 0] = s, s = 0; s < i.length; ++s)e()[a++ >> 0 >>> 0] = i.charCodeAt(s);\n                        e()[a >> 0 >>> 0] = 0, r += i.length + 1;\n                    }), 0;\n                }\n                function Qt(t, e) {\n                    if (x) return Wt(21, 1, t, e);\n                    var n = Zt();\n                    o()[t >> 2 >>> 0] = n.length;\n                    var r = 0;\n                    return n.forEach(function(t) {\n                        r += t.length + 1;\n                    }), o()[e >> 2 >>> 0] = r, 0;\n                }\n                function te(t) {\n                    return x ? Wt(22, 1, t) : 52;\n                }\n                function ee(t, e, n, r) {\n                    return x ? Wt(23, 1, t, e, n, r) : 52;\n                }\n                function ne(t, e, n, r, i) {\n                    return x ? Wt(24, 1, t, e, n, r, i) : 70;\n                }\n                var re = [\n                    null,\n                    [],\n                    []\n                ];\n                function ie(t, e) {\n                    var n = re[t];\n                    0 === e || 10 === e ? ((1 === t ? I : P)(V(n, 0)), n.length = 0) : n.push(e);\n                }\n                function oe(t, e, n, i) {\n                    if (x) return Wt(25, 1, t, e, n, i);\n                    for(var a = 0, s = 0; s < n; s++){\n                        var u = o()[e >> 2 >>> 0], c = o()[e + 4 >> 2 >>> 0];\n                        e += 8;\n                        for(var l = 0; l < c; l++)ie(t, r()[u + l >>> 0]);\n                        a += c;\n                    }\n                    return o()[i >> 2 >>> 0] = a, 0;\n                }\n                var ae = 0;\n                function se(t) {\n                    return 0 == t % 4 && (0 != t % 100 || 0 == t % 400);\n                }\n                var ue = [\n                    31,\n                    29,\n                    31,\n                    30,\n                    31,\n                    30,\n                    31,\n                    31,\n                    30,\n                    31,\n                    30,\n                    31\n                ], ce = [\n                    31,\n                    28,\n                    31,\n                    30,\n                    31,\n                    30,\n                    31,\n                    31,\n                    30,\n                    31,\n                    30,\n                    31\n                ];\n                function le(t, n, r, o) {\n                    function a(t, e, n) {\n                        for(t = \"number\" == typeof t ? t.toString() : t || \"\"; t.length < e;)t = n[0] + t;\n                        return t;\n                    }\n                    function s(t, e) {\n                        return a(t, e, \"0\");\n                    }\n                    function u(t, e) {\n                        function n(t) {\n                            return 0 > t ? -1 : 0 < t ? 1 : 0;\n                        }\n                        var r;\n                        return 0 === (r = n(t.getFullYear() - e.getFullYear())) && 0 === (r = n(t.getMonth() - e.getMonth())) && (r = n(t.getDate() - e.getDate())), r;\n                    }\n                    function c(t) {\n                        switch(t.getDay()){\n                            case 0:\n                                return new Date(t.getFullYear() - 1, 11, 29);\n                            case 1:\n                                return t;\n                            case 2:\n                                return new Date(t.getFullYear(), 0, 3);\n                            case 3:\n                                return new Date(t.getFullYear(), 0, 2);\n                            case 4:\n                                return new Date(t.getFullYear(), 0, 1);\n                            case 5:\n                                return new Date(t.getFullYear() - 1, 11, 31);\n                            case 6:\n                                return new Date(t.getFullYear() - 1, 11, 30);\n                        }\n                    }\n                    function l(t) {\n                        var e = t.Wb;\n                        for(t = new Date(new Date(t.Xb + 1900, 0, 1).getTime()); 0 < e;){\n                            var n = t.getMonth(), r = (se(t.getFullYear()) ? ue : ce)[n];\n                            if (!(e > r - t.getDate())) {\n                                t.setDate(t.getDate() + e);\n                                break;\n                            }\n                            e -= r - t.getDate() + 1, t.setDate(1), 11 > n ? t.setMonth(n + 1) : (t.setMonth(0), t.setFullYear(t.getFullYear() + 1));\n                        }\n                        return n = new Date(t.getFullYear() + 1, 0, 4), e = c(new Date(t.getFullYear(), 0, 4)), n = c(n), 0 >= u(e, t) ? 0 >= u(n, t) ? t.getFullYear() + 1 : t.getFullYear() : t.getFullYear() - 1;\n                    }\n                    var p = i()[o + 40 >> 2 >>> 0];\n                    for(var f in o = {\n                        Lc: i()[o >> 2 >>> 0],\n                        Kc: i()[o + 4 >> 2 >>> 0],\n                        dc: i()[o + 8 >> 2 >>> 0],\n                        jc: i()[o + 12 >> 2 >>> 0],\n                        ec: i()[o + 16 >> 2 >>> 0],\n                        Xb: i()[o + 20 >> 2 >>> 0],\n                        Tb: i()[o + 24 >> 2 >>> 0],\n                        Wb: i()[o + 28 >> 2 >>> 0],\n                        Rc: i()[o + 32 >> 2 >>> 0],\n                        Jc: i()[o + 36 >> 2 >>> 0],\n                        Mc: p ? B(p) : \"\"\n                    }, r = B(r), p = {\n                        \"%c\": \"%a %b %d %H:%M:%S %Y\",\n                        \"%D\": \"%m/%d/%y\",\n                        \"%F\": \"%Y-%m-%d\",\n                        \"%h\": \"%b\",\n                        \"%r\": \"%I:%M:%S %p\",\n                        \"%R\": \"%H:%M\",\n                        \"%T\": \"%H:%M:%S\",\n                        \"%x\": \"%m/%d/%y\",\n                        \"%X\": \"%H:%M:%S\",\n                        \"%Ec\": \"%c\",\n                        \"%EC\": \"%C\",\n                        \"%Ex\": \"%m/%d/%y\",\n                        \"%EX\": \"%H:%M:%S\",\n                        \"%Ey\": \"%y\",\n                        \"%EY\": \"%Y\",\n                        \"%Od\": \"%d\",\n                        \"%Oe\": \"%e\",\n                        \"%OH\": \"%H\",\n                        \"%OI\": \"%I\",\n                        \"%Om\": \"%m\",\n                        \"%OM\": \"%M\",\n                        \"%OS\": \"%S\",\n                        \"%Ou\": \"%u\",\n                        \"%OU\": \"%U\",\n                        \"%OV\": \"%V\",\n                        \"%Ow\": \"%w\",\n                        \"%OW\": \"%W\",\n                        \"%Oy\": \"%y\"\n                    })r = r.replace(new RegExp(f, \"g\"), p[f]);\n                    var d = \"Sunday Monday Tuesday Wednesday Thursday Friday Saturday\".split(\" \"), h = \"January February March April May June July August September October November December\".split(\" \");\n                    for(f in p = {\n                        \"%a\": function(t) {\n                            return d[t.Tb].substring(0, 3);\n                        },\n                        \"%A\": function(t) {\n                            return d[t.Tb];\n                        },\n                        \"%b\": function(t) {\n                            return h[t.ec].substring(0, 3);\n                        },\n                        \"%B\": function(t) {\n                            return h[t.ec];\n                        },\n                        \"%C\": function(t) {\n                            return s((t.Xb + 1900) / 100 | 0, 2);\n                        },\n                        \"%d\": function(t) {\n                            return s(t.jc, 2);\n                        },\n                        \"%e\": function(t) {\n                            return a(t.jc, 2, \" \");\n                        },\n                        \"%g\": function(t) {\n                            return l(t).toString().substring(2);\n                        },\n                        \"%G\": function(t) {\n                            return l(t);\n                        },\n                        \"%H\": function(t) {\n                            return s(t.dc, 2);\n                        },\n                        \"%I\": function(t) {\n                            return 0 == (t = t.dc) ? t = 12 : 12 < t && (t -= 12), s(t, 2);\n                        },\n                        \"%j\": function(t) {\n                            for(var e = 0, n = 0; n <= t.ec - 1; e += (se(t.Xb + 1900) ? ue : ce)[n++]);\n                            return s(t.jc + e, 3);\n                        },\n                        \"%m\": function(t) {\n                            return s(t.ec + 1, 2);\n                        },\n                        \"%M\": function(t) {\n                            return s(t.Kc, 2);\n                        },\n                        \"%n\": function() {\n                            return \"\\n\";\n                        },\n                        \"%p\": function(t) {\n                            return 0 <= t.dc && 12 > t.dc ? \"AM\" : \"PM\";\n                        },\n                        \"%S\": function(t) {\n                            return s(t.Lc, 2);\n                        },\n                        \"%t\": function() {\n                            return \"\t\";\n                        },\n                        \"%u\": function(t) {\n                            return t.Tb || 7;\n                        },\n                        \"%U\": function(t) {\n                            return s(Math.floor((t.Wb + 7 - t.Tb) / 7), 2);\n                        },\n                        \"%V\": function(t) {\n                            var e = Math.floor((t.Wb + 7 - (t.Tb + 6) % 7) / 7);\n                            if (2 >= (t.Tb + 371 - t.Wb - 2) % 7 && e++, e) 53 == e && (4 == (n = (t.Tb + 371 - t.Wb) % 7) || 3 == n && se(t.Xb) || (e = 1));\n                            else {\n                                e = 52;\n                                var n = (t.Tb + 7 - t.Wb - 1) % 7;\n                                (4 == n || 5 == n && se(t.Xb % 400 - 1)) && e++;\n                            }\n                            return s(e, 2);\n                        },\n                        \"%w\": function(t) {\n                            return t.Tb;\n                        },\n                        \"%W\": function(t) {\n                            return s(Math.floor((t.Wb + 7 - (t.Tb + 6) % 7) / 7), 2);\n                        },\n                        \"%y\": function(t) {\n                            return (t.Xb + 1900).toString().substring(2);\n                        },\n                        \"%Y\": function(t) {\n                            return t.Xb + 1900;\n                        },\n                        \"%z\": function(t) {\n                            var e = 0 <= (t = t.Jc);\n                            return t = Math.abs(t) / 60, (e ? \"+\" : \"-\") + String(\"0000\" + (t / 60 * 100 + t % 60)).slice(-4);\n                        },\n                        \"%Z\": function(t) {\n                            return t.Mc;\n                        },\n                        \"%%\": function() {\n                            return \"%\";\n                        }\n                    }, r = r.replace(/%%/g, \"\\x00\\x00\"), p)r.includes(f) && (r = r.replace(new RegExp(f, \"g\"), p[f](o)));\n                    return f = function(t) {\n                        var e = Array(G(t) + 1);\n                        return z(t, e, 0, e.length), e;\n                    }(r = r.replace(/\\0\\0/g, \"%\")), f.length > n ? 0 : (function(t, n) {\n                        e().set(t, n >>> 0);\n                    }(f, t), f.length - 1);\n                }\n                dt.fc();\n                var pe = [\n                    null,\n                    pt,\n                    bt,\n                    At,\n                    It,\n                    Pt,\n                    Dt,\n                    $t,\n                    kt,\n                    Ct,\n                    Ft,\n                    Nt,\n                    Rt,\n                    Lt,\n                    Mt,\n                    jt,\n                    Ut,\n                    zt,\n                    Gt,\n                    qt,\n                    Jt,\n                    Qt,\n                    te,\n                    ee,\n                    ne,\n                    oe\n                ], fe = {\n                    b: function(t) {\n                        return he(t + 24) + 24;\n                    },\n                    n: function(t) {\n                        return (t = new St(t)).uc() || (t.hc(!0), xt--), t.ic(!1), wt.push(t), t.sc(), t.vc();\n                    },\n                    ma: function(t) {\n                        throw P(\"Unexpected exception thrown, this is not properly supported - aborting\"), j = !0, t;\n                    },\n                    x: function() {\n                        Se(0);\n                        var t = wt.pop();\n                        if (t.Hc() && !t.kc()) {\n                            var e = t.Dc();\n                            e && yt(e)(t.Zb), Ot(t.Zb);\n                        }\n                        Tt = 0;\n                    },\n                    e: function() {\n                        var t = Tt;\n                        if (!t) return ae = 0;\n                        var e = new St(t);\n                        e.cc(t);\n                        var n = e.bc();\n                        if (!n) return ae = 0, t;\n                        for(var r = Array.prototype.slice.call(arguments), i = 0; i < r.length; i++){\n                            var o = r[i];\n                            if (0 === o || o === n) break;\n                            if (Pe(o, n, e.Sb + 16)) return ae = o, t;\n                        }\n                        return ae = n, t;\n                    },\n                    l: function() {\n                        var t = Tt;\n                        if (!t) return ae = 0;\n                        var e = new St(t);\n                        e.cc(t);\n                        var n = e.bc();\n                        if (!n) return ae = 0, t;\n                        for(var r = Array.prototype.slice.call(arguments), i = 0; i < r.length; i++){\n                            var o = r[i];\n                            if (0 === o || o === n) break;\n                            if (Pe(o, n, e.Sb + 16)) return ae = o, t;\n                        }\n                        return ae = n, t;\n                    },\n                    h: function() {\n                        var t = Tt;\n                        if (!t) return ae = 0;\n                        var e = new St(t);\n                        e.cc(t);\n                        var n = e.bc();\n                        if (!n) return ae = 0, t;\n                        for(var r = Array.prototype.slice.call(arguments), i = 0; i < r.length; i++){\n                            var o = r[i];\n                            if (0 === o || o === n) break;\n                            if (Pe(o, n, e.Sb + 16)) return ae = o, t;\n                        }\n                        return ae = n, t;\n                    },\n                    t: Ot,\n                    M: function() {\n                        var t = wt.pop();\n                        t || it(\"no exception to throw\");\n                        var e = t.Zb;\n                        throw t.kc() || (wt.push(t), t.ic(!0), t.hc(!1), xt++), Tt = e, e;\n                    },\n                    c: function(t, e, n) {\n                        throw new St(t).fc(e, n), Tt = t, xt++, t;\n                    },\n                    pa: function() {\n                        return xt;\n                    },\n                    Fa: function(t) {\n                        ye(t, !v, 1, !_), dt.pc();\n                    },\n                    T: function(t) {\n                        x ? postMessage({\n                            cmd: \"cleanupThread\",\n                            thread: t\n                        }) : ct(t);\n                    },\n                    xa: Et,\n                    j: function(t) {\n                        throw Tt || (Tt = t), t;\n                    },\n                    H: It,\n                    Ma: Pt,\n                    ua: Dt,\n                    wa: $t,\n                    oa: kt,\n                    Ka: Ct,\n                    Ca: Ft,\n                    Ja: Nt,\n                    V: Rt,\n                    va: Lt,\n                    sa: Mt,\n                    La: jt,\n                    ta: Ut,\n                    Ta: function() {},\n                    X: function() {\n                        it(\"To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking\");\n                    },\n                    Ua: function() {\n                        it(\"To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking\");\n                    },\n                    W: function() {\n                        return Date.now();\n                    },\n                    ya: function() {\n                        return 2097152;\n                    },\n                    Oa: function() {\n                        return !0;\n                    },\n                    za: function(t, e, n, r) {\n                        if (t == e) setTimeout(()=>Vt(r));\n                        else if (x) postMessage({\n                            targetThread: t,\n                            cmd: \"processProxyingQueue\",\n                            queue: r\n                        });\n                        else {\n                            if (!(t = dt.Vb[t])) return;\n                            t.postMessage({\n                                cmd: \"processProxyingQueue\",\n                                queue: r\n                            });\n                        }\n                        return 1;\n                    },\n                    Ea: function() {\n                        return -1;\n                    },\n                    Pa: function(t, e) {\n                        t = new Date(1e3 * Bt(t)), i()[e >> 2 >>> 0] = t.getUTCSeconds(), i()[e + 4 >> 2 >>> 0] = t.getUTCMinutes(), i()[e + 8 >> 2 >>> 0] = t.getUTCHours(), i()[e + 12 >> 2 >>> 0] = t.getUTCDate(), i()[e + 16 >> 2 >>> 0] = t.getUTCMonth(), i()[e + 20 >> 2 >>> 0] = t.getUTCFullYear() - 1900, i()[e + 24 >> 2 >>> 0] = t.getUTCDay(), t = (t.getTime() - Date.UTC(t.getUTCFullYear(), 0, 1, 0, 0, 0, 0)) / 864e5 | 0, i()[e + 28 >> 2 >>> 0] = t;\n                    },\n                    Qa: function(t, e) {\n                        t = new Date(1e3 * Bt(t)), i()[e >> 2 >>> 0] = t.getSeconds(), i()[e + 4 >> 2 >>> 0] = t.getMinutes(), i()[e + 8 >> 2 >>> 0] = t.getHours(), i()[e + 12 >> 2 >>> 0] = t.getDate(), i()[e + 16 >> 2 >>> 0] = t.getMonth(), i()[e + 20 >> 2 >>> 0] = t.getFullYear() - 1900, i()[e + 24 >> 2 >>> 0] = t.getDay();\n                        var n = new Date(t.getFullYear(), 0, 1), r = (t.getTime() - n.getTime()) / 864e5 | 0;\n                        i()[e + 28 >> 2 >>> 0] = r, i()[e + 36 >> 2 >>> 0] = -60 * t.getTimezoneOffset(), r = new Date(t.getFullYear(), 6, 1).getTimezoneOffset(), t = 0 | (r != (n = n.getTimezoneOffset()) && t.getTimezoneOffset() == Math.min(n, r)), i()[e + 32 >> 2 >>> 0] = t;\n                    },\n                    Ra: function(t) {\n                        var e = new Date(i()[t + 20 >> 2 >>> 0] + 1900, i()[t + 16 >> 2 >>> 0], i()[t + 12 >> 2 >>> 0], i()[t + 8 >> 2 >>> 0], i()[t + 4 >> 2 >>> 0], i()[t >> 2 >>> 0], 0), n = i()[t + 32 >> 2 >>> 0], r = e.getTimezoneOffset(), o = new Date(e.getFullYear(), 0, 1), a = new Date(e.getFullYear(), 6, 1).getTimezoneOffset(), s = o.getTimezoneOffset(), u = Math.min(s, a);\n                        return 0 > n ? i()[t + 32 >> 2 >>> 0] = Number(a != s && u == r) : 0 < n != (u == r) && (a = Math.max(s, a), e.setTime(e.getTime() + 6e4 * ((0 < n ? u : a) - r))), i()[t + 24 >> 2 >>> 0] = e.getDay(), n = (e.getTime() - o.getTime()) / 864e5 | 0, i()[t + 28 >> 2 >>> 0] = n, i()[t >> 2 >>> 0] = e.getSeconds(), i()[t + 4 >> 2 >>> 0] = e.getMinutes(), i()[t + 8 >> 2 >>> 0] = e.getHours(), i()[t + 12 >> 2 >>> 0] = e.getDate(), i()[t + 16 >> 2 >>> 0] = e.getMonth(), e.getTime() / 1e3 | 0;\n                    },\n                    Aa: zt,\n                    Ba: Gt,\n                    Sa: function t(e, n, r) {\n                        t.Ac || (t.Ac = !0, qt(e, n, r));\n                    },\n                    y: function() {\n                        it(\"\");\n                    },\n                    U: function() {\n                        if (!w && !v) {\n                            var t = \"Blocking on the main thread is very dangerous, see https://emscripten.org/docs/porting/pthreads.html#blocking-on-the-main-browser-thread\";\n                            _t || (_t = {}), _t[t] || (_t[t] = 1, w && (t = \"warning: \" + t), P(t));\n                        }\n                    },\n                    ra: function() {\n                        return 4294901760;\n                    },\n                    B: vt,\n                    Ia: function(t, e, n) {\n                        r().copyWithin(t >>> 0, e >>> 0, e + n >>> 0);\n                    },\n                    F: function() {\n                        return w ? n(9719).cpus().length : navigator.hardwareConcurrency;\n                    },\n                    Da: function(t, e, n) {\n                        Yt.length = e, n >>= 3;\n                        for(var r = 0; r < e; r++)Yt[r] = a()[n + r >>> 0];\n                        return (0 > t ? st[-t - 1] : pe[t]).apply(null, Yt);\n                    },\n                    qa: function(t) {\n                        var e = r().length;\n                        if ((t >>>= 0) <= e || 4294901760 < t) return !1;\n                        for(var n = 1; 4 >= n; n *= 2){\n                            var i = e * (1 + .2 / n);\n                            i = Math.min(i, t + 100663296);\n                            var o = Math;\n                            i = Math.max(t, i), o = o.min.call(o, 4294901760, i + (65536 - i % 65536) % 65536);\n                            t: {\n                                try {\n                                    $.grow(o - C.byteLength + 65535 >>> 16), H($.buffer);\n                                    var a = 1;\n                                    break t;\n                                } catch (t) {}\n                                a = void 0;\n                            }\n                            if (a) return !0;\n                        }\n                        return !1;\n                    },\n                    Na: function() {\n                        throw \"unwind\";\n                    },\n                    Ga: Jt,\n                    Ha: Qt,\n                    J: ft,\n                    I: te,\n                    S: ee,\n                    ga: ne,\n                    R: oe,\n                    d: function() {\n                        return ae;\n                    },\n                    na: function t(r, i) {\n                        t.lc || (t.lc = function() {\n                            if (\"object\" == typeof crypto && \"function\" == typeof crypto.getRandomValues) {\n                                var t = new Uint8Array(1);\n                                return ()=>(crypto.getRandomValues(t), t[0]);\n                            }\n                            if (w) try {\n                                var e = n(6113);\n                                return ()=>e.randomBytes(1)[0];\n                            } catch (t) {}\n                            return ()=>it(\"randomDevice\");\n                        }());\n                        for(var o = 0; o < i; o++)e()[r + o >> 0 >>> 0] = t.lc();\n                        return 0;\n                    },\n                    ia: function(t, e, n) {\n                        var r = Ae();\n                        try {\n                            return yt(t)(e, n);\n                        } catch (t) {\n                            if (Ee(r), t !== t + 0) throw t;\n                            Se(1, 0);\n                        }\n                    },\n                    ja: function(t, e, n) {\n                        var r = Ae();\n                        try {\n                            return yt(t)(e, n);\n                        } catch (t) {\n                            if (Ee(r), t !== t + 0) throw t;\n                            Se(1, 0);\n                        }\n                    },\n                    K: function(t) {\n                        var e = Ae();\n                        try {\n                            return yt(t)();\n                        } catch (t) {\n                            if (Ee(e), t !== t + 0) throw t;\n                            Se(1, 0);\n                        }\n                    },\n                    f: function(t, e) {\n                        var n = Ae();\n                        try {\n                            return yt(t)(e);\n                        } catch (t) {\n                            if (Ee(n), t !== t + 0) throw t;\n                            Se(1, 0);\n                        }\n                    },\n                    P: function(t, e, n) {\n                        var r = Ae();\n                        try {\n                            return yt(t)(e, n);\n                        } catch (t) {\n                            if (Ee(r), t !== t + 0) throw t;\n                            Se(1, 0);\n                        }\n                    },\n                    Q: function(t, e, n) {\n                        var r = Ae();\n                        try {\n                            return yt(t)(e, n);\n                        } catch (t) {\n                            if (Ee(r), t !== t + 0) throw t;\n                            Se(1, 0);\n                        }\n                    },\n                    k: function(t, e, n) {\n                        var r = Ae();\n                        try {\n                            return yt(t)(e, n);\n                        } catch (t) {\n                            if (Ee(r), t !== t + 0) throw t;\n                            Se(1, 0);\n                        }\n                    },\n                    p: function(t, e, n, r) {\n                        var i = Ae();\n                        try {\n                            return yt(t)(e, n, r);\n                        } catch (t) {\n                            if (Ee(i), t !== t + 0) throw t;\n                            Se(1, 0);\n                        }\n                    },\n                    q: function(t, e, n, r, i) {\n                        var o = Ae();\n                        try {\n                            return yt(t)(e, n, r, i);\n                        } catch (t) {\n                            if (Ee(o), t !== t + 0) throw t;\n                            Se(1, 0);\n                        }\n                    },\n                    N: function(t, e, n, r, i, o) {\n                        var a = Ae();\n                        try {\n                            return yt(t)(e, n, r, i, o);\n                        } catch (t) {\n                            if (Ee(a), t !== t + 0) throw t;\n                            Se(1, 0);\n                        }\n                    },\n                    s: function(t, e, n, r, i, o) {\n                        var a = Ae();\n                        try {\n                            return yt(t)(e, n, r, i, o);\n                        } catch (t) {\n                            if (Ee(a), t !== t + 0) throw t;\n                            Se(1, 0);\n                        }\n                    },\n                    w: function(t, e, n, r, i, o, a) {\n                        var s = Ae();\n                        try {\n                            return yt(t)(e, n, r, i, o, a);\n                        } catch (t) {\n                            if (Ee(s), t !== t + 0) throw t;\n                            Se(1, 0);\n                        }\n                    },\n                    L: function(t, e, n, r, i, o, a, s) {\n                        var u = Ae();\n                        try {\n                            return yt(t)(e, n, r, i, o, a, s);\n                        } catch (t) {\n                            if (Ee(u), t !== t + 0) throw t;\n                            Se(1, 0);\n                        }\n                    },\n                    E: function(t, e, n, r, i, o, a, s, u, c, l, p) {\n                        var f = Ae();\n                        try {\n                            return yt(t)(e, n, r, i, o, a, s, u, c, l, p);\n                        } catch (t) {\n                            if (Ee(f), t !== t + 0) throw t;\n                            Se(1, 0);\n                        }\n                    },\n                    aa: function(t, e, n, r, i, o, a, s) {\n                        var u = Ae();\n                        try {\n                            return je(t, e, n, r, i, o, a, s);\n                        } catch (t) {\n                            if (Ee(u), t !== t + 0) throw t;\n                            Se(1, 0);\n                        }\n                    },\n                    _: function(t, e, n, r, i, o, a) {\n                        var s = Ae();\n                        try {\n                            return ke(t, e, n, r, i, o, a);\n                        } catch (t) {\n                            if (Ee(s), t !== t + 0) throw t;\n                            Se(1, 0);\n                        }\n                    },\n                    Z: function(t, e, n, r, i) {\n                        var o = Ae();\n                        try {\n                            return Ue(t, e, n, r, i);\n                        } catch (t) {\n                            if (Ee(o), t !== t + 0) throw t;\n                            Se(1, 0);\n                        }\n                    },\n                    ca: function(t, e, n, r) {\n                        var i = Ae();\n                        try {\n                            return Le(t, e, n, r);\n                        } catch (t) {\n                            if (Ee(i), t !== t + 0) throw t;\n                            Se(1, 0);\n                        }\n                    },\n                    $: function(t) {\n                        var e = Ae();\n                        try {\n                            return $e(t);\n                        } catch (t) {\n                            if (Ee(e), t !== t + 0) throw t;\n                            Se(1, 0);\n                        }\n                    },\n                    ba: function(t, e) {\n                        var n = Ae();\n                        try {\n                            return Me(t, e);\n                        } catch (t) {\n                            if (Ee(n), t !== t + 0) throw t;\n                            Se(1, 0);\n                        }\n                    },\n                    Y: function(t, e, n) {\n                        var r = Ae();\n                        try {\n                            return Ce(t, e, n);\n                        } catch (t) {\n                            if (Ee(r), t !== t + 0) throw t;\n                            Se(1, 0);\n                        }\n                    },\n                    g: function(t) {\n                        var e = Ae();\n                        try {\n                            yt(t)();\n                        } catch (t) {\n                            if (Ee(e), t !== t + 0) throw t;\n                            Se(1, 0);\n                        }\n                    },\n                    r: function(t, e) {\n                        var n = Ae();\n                        try {\n                            yt(t)(e);\n                        } catch (t) {\n                            if (Ee(n), t !== t + 0) throw t;\n                            Se(1, 0);\n                        }\n                    },\n                    i: function(t, e, n) {\n                        var r = Ae();\n                        try {\n                            yt(t)(e, n);\n                        } catch (t) {\n                            if (Ee(r), t !== t + 0) throw t;\n                            Se(1, 0);\n                        }\n                    },\n                    ha: function(t, e, n, r) {\n                        var i = Ae();\n                        try {\n                            yt(t)(e, n, r);\n                        } catch (t) {\n                            if (Ee(i), t !== t + 0) throw t;\n                            Se(1, 0);\n                        }\n                    },\n                    m: function(t, e, n, r) {\n                        var i = Ae();\n                        try {\n                            yt(t)(e, n, r);\n                        } catch (t) {\n                            if (Ee(i), t !== t + 0) throw t;\n                            Se(1, 0);\n                        }\n                    },\n                    v: function(t, e, n, r, i) {\n                        var o = Ae();\n                        try {\n                            yt(t)(e, n, r, i);\n                        } catch (t) {\n                            if (Ee(o), t !== t + 0) throw t;\n                            Se(1, 0);\n                        }\n                    },\n                    u: function(t, e, n, r, i, o) {\n                        var a = Ae();\n                        try {\n                            yt(t)(e, n, r, i, o);\n                        } catch (t) {\n                            if (Ee(a), t !== t + 0) throw t;\n                            Se(1, 0);\n                        }\n                    },\n                    O: function(t, e, n, r, i, o, a) {\n                        var s = Ae();\n                        try {\n                            yt(t)(e, n, r, i, o, a);\n                        } catch (t) {\n                            if (Ee(s), t !== t + 0) throw t;\n                            Se(1, 0);\n                        }\n                    },\n                    A: function(t, e, n, r, i, o, a, s) {\n                        var u = Ae();\n                        try {\n                            yt(t)(e, n, r, i, o, a, s);\n                        } catch (t) {\n                            if (Ee(u), t !== t + 0) throw t;\n                            Se(1, 0);\n                        }\n                    },\n                    ka: function(t, e, n, r, i, o, a, s, u) {\n                        var c = Ae();\n                        try {\n                            yt(t)(e, n, r, i, o, a, s, u);\n                        } catch (t) {\n                            if (Ee(c), t !== t + 0) throw t;\n                            Se(1, 0);\n                        }\n                    },\n                    C: function(t, e, n, r, i, o, a, s, u, c, l) {\n                        var p = Ae();\n                        try {\n                            yt(t)(e, n, r, i, o, a, s, u, c, l);\n                        } catch (t) {\n                            if (Ee(p), t !== t + 0) throw t;\n                            Se(1, 0);\n                        }\n                    },\n                    D: function(t, e, n, r, i, o, a, s, u, c, l, p, f, d, h, g) {\n                        var b = Ae();\n                        try {\n                            yt(t)(e, n, r, i, o, a, s, u, c, l, p, f, d, h, g);\n                        } catch (t) {\n                            if (Ee(b), t !== t + 0) throw t;\n                            Se(1, 0);\n                        }\n                    },\n                    fa: function(t, e, n, r, i, o, a, s) {\n                        var u = Ae();\n                        try {\n                            Fe(t, e, n, r, i, o, a, s);\n                        } catch (t) {\n                            if (Ee(u), t !== t + 0) throw t;\n                            Se(1, 0);\n                        }\n                    },\n                    da: function(t, e, n, r, i, o, a, s, u, c, l, p) {\n                        var f = Ae();\n                        try {\n                            Re(t, e, n, r, i, o, a, s, u, c, l, p);\n                        } catch (t) {\n                            if (Ee(f), t !== t + 0) throw t;\n                            Se(1, 0);\n                        }\n                    },\n                    ea: function(t, e, n, r, i, o) {\n                        var a = Ae();\n                        try {\n                            Ne(t, e, n, r, i, o);\n                        } catch (t) {\n                            if (Ee(a), t !== t + 0) throw t;\n                            Se(1, 0);\n                        }\n                    },\n                    o: function(t) {\n                        return t;\n                    },\n                    a: $ || s.wasmMemory,\n                    G: function(t) {\n                        ae = t;\n                    },\n                    la: le,\n                    z: function(t, e, n, r) {\n                        return le(t, e, n, r);\n                    }\n                };\n                !function() {\n                    function t(t, e) {\n                        s.asm = t.exports, dt.qc.push(s.asm.sb), W = s.asm.ub, Y.unshift(s.asm.Va), k = e, x || (et--, s.monitorRunDependencies && s.monitorRunDependencies(et), 0 == et && (null !== nt && (clearInterval(nt), nt = null), rt && (t = rt, rt = null, t())));\n                    }\n                    function e(e) {\n                        t(e.instance, e.module);\n                    }\n                    function n(t) {\n                        return (function() {\n                            if (!E && (_ || v)) {\n                                if (\"function\" == typeof fetch && !tt.startsWith(\"file://\")) return fetch(tt, {\n                                    credentials: \"same-origin\"\n                                }).then(function(t) {\n                                    if (!t.ok) throw \"failed to load wasm binary file at '\" + tt + \"'\";\n                                    return t.arrayBuffer();\n                                }).catch(function() {\n                                    return at();\n                                });\n                                if (p) return new Promise(function(t, e) {\n                                    p(tt, function(e) {\n                                        t(new Uint8Array(e));\n                                    }, e);\n                                });\n                            }\n                            return Promise.resolve().then(function() {\n                                return at();\n                            });\n                        })().then(function(t) {\n                            return WebAssembly.instantiate(t, r);\n                        }).then(function(t) {\n                            return t;\n                        }).then(t, function(t) {\n                            P(\"failed to asynchronously prepare wasm: \" + t), it(t);\n                        });\n                    }\n                    var r = {\n                        a: fe\n                    };\n                    if (x || (et++, s.monitorRunDependencies && s.monitorRunDependencies(et)), s.instantiateWasm) try {\n                        return s.instantiateWasm(r, t);\n                    } catch (t) {\n                        return P(\"Module.instantiateWasm callback failed with error: \" + t), !1;\n                    }\n                    (E || \"function\" != typeof WebAssembly.instantiateStreaming || ot() || tt.startsWith(\"file://\") || w || \"function\" != typeof fetch ? n(e) : fetch(tt, {\n                        credentials: \"same-origin\"\n                    }).then(function(t) {\n                        return WebAssembly.instantiateStreaming(t, r).then(e, function(t) {\n                            return P(\"wasm streaming compile failed: \" + t), P(\"falling back to ArrayBuffer instantiation\"), n(e);\n                        });\n                    })).catch(c);\n                }(), s.___wasm_call_ctors = function() {\n                    return (s.___wasm_call_ctors = s.asm.Va).apply(null, arguments);\n                }, s._OrtInit = function() {\n                    return (s._OrtInit = s.asm.Wa).apply(null, arguments);\n                }, s._OrtCreateSessionOptions = function() {\n                    return (s._OrtCreateSessionOptions = s.asm.Xa).apply(null, arguments);\n                }, s._OrtAppendExecutionProvider = function() {\n                    return (s._OrtAppendExecutionProvider = s.asm.Ya).apply(null, arguments);\n                }, s._OrtAddSessionConfigEntry = function() {\n                    return (s._OrtAddSessionConfigEntry = s.asm.Za).apply(null, arguments);\n                }, s._OrtReleaseSessionOptions = function() {\n                    return (s._OrtReleaseSessionOptions = s.asm._a).apply(null, arguments);\n                }, s._OrtCreateSession = function() {\n                    return (s._OrtCreateSession = s.asm.$a).apply(null, arguments);\n                }, s._OrtReleaseSession = function() {\n                    return (s._OrtReleaseSession = s.asm.ab).apply(null, arguments);\n                }, s._OrtGetInputCount = function() {\n                    return (s._OrtGetInputCount = s.asm.bb).apply(null, arguments);\n                }, s._OrtGetOutputCount = function() {\n                    return (s._OrtGetOutputCount = s.asm.cb).apply(null, arguments);\n                }, s._OrtGetInputName = function() {\n                    return (s._OrtGetInputName = s.asm.db).apply(null, arguments);\n                }, s._OrtGetOutputName = function() {\n                    return (s._OrtGetOutputName = s.asm.eb).apply(null, arguments);\n                }, s._OrtFree = function() {\n                    return (s._OrtFree = s.asm.fb).apply(null, arguments);\n                }, s._OrtCreateTensor = function() {\n                    return (s._OrtCreateTensor = s.asm.gb).apply(null, arguments);\n                }, s._OrtGetTensorData = function() {\n                    return (s._OrtGetTensorData = s.asm.hb).apply(null, arguments);\n                }, s._OrtReleaseTensor = function() {\n                    return (s._OrtReleaseTensor = s.asm.ib).apply(null, arguments);\n                }, s._OrtCreateRunOptions = function() {\n                    return (s._OrtCreateRunOptions = s.asm.jb).apply(null, arguments);\n                }, s._OrtAddRunConfigEntry = function() {\n                    return (s._OrtAddRunConfigEntry = s.asm.kb).apply(null, arguments);\n                }, s._OrtReleaseRunOptions = function() {\n                    return (s._OrtReleaseRunOptions = s.asm.lb).apply(null, arguments);\n                }, s._OrtRun = function() {\n                    return (s._OrtRun = s.asm.mb).apply(null, arguments);\n                }, s._OrtEndProfiling = function() {\n                    return (s._OrtEndProfiling = s.asm.nb).apply(null, arguments);\n                };\n                var de = s._pthread_self = function() {\n                    return (de = s._pthread_self = s.asm.ob).apply(null, arguments);\n                }, he = s._malloc = function() {\n                    return (he = s._malloc = s.asm.pb).apply(null, arguments);\n                }, ge = s._free = function() {\n                    return (ge = s._free = s.asm.qb).apply(null, arguments);\n                }, be = s._fflush = function() {\n                    return (be = s._fflush = s.asm.rb).apply(null, arguments);\n                };\n                s.__emscripten_tls_init = function() {\n                    return (s.__emscripten_tls_init = s.asm.sb).apply(null, arguments);\n                };\n                var me = s.___funcs_on_exit = function() {\n                    return (me = s.___funcs_on_exit = s.asm.tb).apply(null, arguments);\n                }, ye = s.__emscripten_thread_init = function() {\n                    return (ye = s.__emscripten_thread_init = s.asm.vb).apply(null, arguments);\n                };\n                s.__emscripten_thread_crashed = function() {\n                    return (s.__emscripten_thread_crashed = s.asm.wb).apply(null, arguments);\n                };\n                var _e, ve = s._emscripten_run_in_main_runtime_thread_js = function() {\n                    return (ve = s._emscripten_run_in_main_runtime_thread_js = s.asm.xb).apply(null, arguments);\n                }, we = s.__emscripten_proxy_execute_task_queue = function() {\n                    return (we = s.__emscripten_proxy_execute_task_queue = s.asm.yb).apply(null, arguments);\n                }, xe = s.__emscripten_thread_free_data = function() {\n                    return (xe = s.__emscripten_thread_free_data = s.asm.zb).apply(null, arguments);\n                }, Te = s.__emscripten_thread_exit = function() {\n                    return (Te = s.__emscripten_thread_exit = s.asm.Ab).apply(null, arguments);\n                }, Se = s._setThrew = function() {\n                    return (Se = s._setThrew = s.asm.Bb).apply(null, arguments);\n                }, Oe = s._emscripten_stack_set_limits = function() {\n                    return (Oe = s._emscripten_stack_set_limits = s.asm.Cb).apply(null, arguments);\n                }, Ae = s.stackSave = function() {\n                    return (Ae = s.stackSave = s.asm.Db).apply(null, arguments);\n                }, Ee = s.stackRestore = function() {\n                    return (Ee = s.stackRestore = s.asm.Eb).apply(null, arguments);\n                }, Ie = s.stackAlloc = function() {\n                    return (Ie = s.stackAlloc = s.asm.Fb).apply(null, arguments);\n                }, Pe = s.___cxa_can_catch = function() {\n                    return (Pe = s.___cxa_can_catch = s.asm.Gb).apply(null, arguments);\n                }, De = s.___cxa_is_pointer_type = function() {\n                    return (De = s.___cxa_is_pointer_type = s.asm.Hb).apply(null, arguments);\n                }, $e = s.dynCall_j = function() {\n                    return ($e = s.dynCall_j = s.asm.Ib).apply(null, arguments);\n                }, ke = s.dynCall_iiiiij = function() {\n                    return (ke = s.dynCall_iiiiij = s.asm.Jb).apply(null, arguments);\n                }, Ce = s.dynCall_jii = function() {\n                    return (Ce = s.dynCall_jii = s.asm.Kb).apply(null, arguments);\n                }, Fe = s.dynCall_viiiiij = function() {\n                    return (Fe = s.dynCall_viiiiij = s.asm.Lb).apply(null, arguments);\n                }, Ne = s.dynCall_vjji = function() {\n                    return (Ne = s.dynCall_vjji = s.asm.Mb).apply(null, arguments);\n                }, Re = s.dynCall_viiijjjii = function() {\n                    return (Re = s.dynCall_viiijjjii = s.asm.Nb).apply(null, arguments);\n                }, Le = s.dynCall_iij = function() {\n                    return (Le = s.dynCall_iij = s.asm.Ob).apply(null, arguments);\n                }, Me = s.dynCall_ji = function() {\n                    return (Me = s.dynCall_ji = s.asm.Pb).apply(null, arguments);\n                }, je = s.dynCall_iiiiiij = function() {\n                    return (je = s.dynCall_iiiiiij = s.asm.Qb).apply(null, arguments);\n                }, Ue = s.dynCall_iiij = function() {\n                    return (Ue = s.dynCall_iiij = s.asm.Rb).apply(null, arguments);\n                };\n                function Ve() {\n                    function t() {\n                        if (!_e && (_e = !0, s.calledRun = !0, !j) && (x || ht(Y), u(s), s.onRuntimeInitialized && s.onRuntimeInitialized(), !x)) {\n                            if (s.postRun) for(\"function\" == typeof s.postRun && (s.postRun = [\n                                s.postRun\n                            ]); s.postRun.length;){\n                                var t = s.postRun.shift();\n                                Z.unshift(t);\n                            }\n                            ht(Z);\n                        }\n                    }\n                    if (!(0 < et)) if (x) u(s), x || ht(Y), postMessage({\n                        cmd: \"loaded\"\n                    });\n                    else {\n                        if (s.preRun) for(\"function\" == typeof s.preRun && (s.preRun = [\n                            s.preRun\n                        ]); s.preRun.length;)Q();\n                        ht(X), 0 < et || (s.setStatus ? (s.setStatus(\"Running...\"), setTimeout(function() {\n                            setTimeout(function() {\n                                s.setStatus(\"\");\n                            }, 1), t();\n                        }, 1)) : t());\n                    }\n                }\n                if (s.UTF8ToString = B, s.stringToUTF8 = function(t, e, n) {\n                    return z(t, r(), e, n);\n                }, s.lengthBytesUTF8 = G, s.keepRuntimeAlive = J, s.wasmMemory = $, s.stackSave = Ae, s.stackRestore = Ee, s.stackAlloc = Ie, s.ExitStatus = ut, s.PThread = dt, rt = function t() {\n                    _e || Ve(), _e || (rt = t);\n                }, s.preInit) for(\"function\" == typeof s.preInit && (s.preInit = [\n                    s.preInit\n                ]); 0 < s.preInit.length;)s.preInit.pop()();\n                return Ve(), t.ready;\n            });\n            t.exports = r;\n        },\n        932: (t, e, n)=>{\n            var _scriptDir, r = (_scriptDir = (_scriptDir = \"undefined\" != typeof document && document.currentScript ? document.currentScript.src : void 0) || __filename, function(t) {\n                var e, r, i;\n                t = t || {}, e || (e = void 0 !== t ? t : {}), e.ready = new Promise(function(t, e) {\n                    r = t, i = e;\n                });\n                var o, a, s, u, c, l, p = Object.assign({}, e), f = \"./this.program\", d = (t, e)=>{\n                    throw e;\n                }, h = \"object\" == \"undefined\", g = \"function\" == typeof importScripts, b = \"object\" == typeof process && \"object\" == typeof process.versions && \"string\" == typeof process.versions.node, m = \"\";\n                b ? (m = g ? n(1423).dirname(m) + \"/\" : __dirname + \"/\", l = ()=>{\n                    c || (u = n(6231), c = n(1423));\n                }, o = function(t, e) {\n                    return l(), t = c.normalize(t), u.readFileSync(t, e ? void 0 : \"utf8\");\n                }, s = (t)=>((t = o(t, !0)).buffer || (t = new Uint8Array(t)), t), a = (t, e, n)=>{\n                    l(), t = c.normalize(t), u.readFile(t, function(t, r) {\n                        t ? n(t) : e(r.buffer);\n                    });\n                }, 1 < process.argv.length && (f = process.argv[1].replace(/\\\\/g, \"/\")), process.argv.slice(2), process.on(\"uncaughtException\", function(t) {\n                    if (!(t instanceof K)) throw t;\n                }), process.on(\"unhandledRejection\", function(t) {\n                    throw t;\n                }), d = (t, e)=>{\n                    if (w || 0 < U) throw process.exitCode = t, e;\n                    e instanceof K || v(\"exiting due to exception: \" + e), process.exit(t);\n                }, e.inspect = function() {\n                    return \"[Emscripten Module object]\";\n                }) : (h || g) && (g ? m = self.location.href : \"undefined\" != typeof document && document.currentScript && (m = document.currentScript.src), _scriptDir && (m = _scriptDir), m = 0 !== m.indexOf(\"blob:\") ? m.substr(0, m.replace(/[?#].*/, \"\").lastIndexOf(\"/\") + 1) : \"\", o = (t)=>{\n                    var e = new XMLHttpRequest;\n                    return e.open(\"GET\", t, !1), e.send(null), e.responseText;\n                }, g && (s = (t)=>{\n                    var e = new XMLHttpRequest;\n                    return e.open(\"GET\", t, !1), e.responseType = \"arraybuffer\", e.send(null), new Uint8Array(e.response);\n                }), a = (t, e, n)=>{\n                    var r = new XMLHttpRequest;\n                    r.open(\"GET\", t, !0), r.responseType = \"arraybuffer\", r.onload = ()=>{\n                        200 == r.status || 0 == r.status && r.response ? e(r.response) : n();\n                    }, r.onerror = n, r.send(null);\n                });\n                var y, _ = e.print || console.log.bind(console), v = e.printErr || console.warn.bind(console);\n                Object.assign(e, p), p = null, e.thisProgram && (f = e.thisProgram), e.quit && (d = e.quit), e.wasmBinary && (y = e.wasmBinary);\n                var w = e.noExitRuntime || !1;\n                \"object\" != typeof WebAssembly && q(\"no native wasm support detected\");\n                var x, T, S, O, A, E, I = !1, P = \"undefined\" != typeof TextDecoder ? new TextDecoder(\"utf8\") : void 0;\n                function D(t, e, n) {\n                    var r = (e >>>= 0) + n;\n                    for(n = e; t[n] && !(n >= r);)++n;\n                    if (16 < n - e && t.buffer && P) return P.decode(t.subarray(e, n));\n                    for(r = \"\"; e < n;){\n                        var i = t[e++];\n                        if (128 & i) {\n                            var o = 63 & t[e++];\n                            if (192 == (224 & i)) r += String.fromCharCode((31 & i) << 6 | o);\n                            else {\n                                var a = 63 & t[e++];\n                                65536 > (i = 224 == (240 & i) ? (15 & i) << 12 | o << 6 | a : (7 & i) << 18 | o << 12 | a << 6 | 63 & t[e++]) ? r += String.fromCharCode(i) : (i -= 65536, r += String.fromCharCode(55296 | i >> 10, 56320 | 1023 & i));\n                            }\n                        } else r += String.fromCharCode(i);\n                    }\n                    return r;\n                }\n                function $(t, e) {\n                    return (t >>>= 0) ? D(O, t, e) : \"\";\n                }\n                function k(t, e, n, r) {\n                    if (!(0 < r)) return 0;\n                    var i = n >>>= 0;\n                    r = n + r - 1;\n                    for(var o = 0; o < t.length; ++o){\n                        var a = t.charCodeAt(o);\n                        if (55296 <= a && 57343 >= a && (a = 65536 + ((1023 & a) << 10) | 1023 & t.charCodeAt(++o)), 127 >= a) {\n                            if (n >= r) break;\n                            e[n++ >>> 0] = a;\n                        } else {\n                            if (2047 >= a) {\n                                if (n + 1 >= r) break;\n                                e[n++ >>> 0] = 192 | a >> 6;\n                            } else {\n                                if (65535 >= a) {\n                                    if (n + 2 >= r) break;\n                                    e[n++ >>> 0] = 224 | a >> 12;\n                                } else {\n                                    if (n + 3 >= r) break;\n                                    e[n++ >>> 0] = 240 | a >> 18, e[n++ >>> 0] = 128 | a >> 12 & 63;\n                                }\n                                e[n++ >>> 0] = 128 | a >> 6 & 63;\n                            }\n                            e[n++ >>> 0] = 128 | 63 & a;\n                        }\n                    }\n                    return e[n >>> 0] = 0, n - i;\n                }\n                function C(t) {\n                    for(var e = 0, n = 0; n < t.length; ++n){\n                        var r = t.charCodeAt(n);\n                        127 >= r ? e++ : 2047 >= r ? e += 2 : 55296 <= r && 57343 >= r ? (e += 4, ++n) : e += 3;\n                    }\n                    return e;\n                }\n                function F() {\n                    var t = x.buffer;\n                    T = t, e.HEAP8 = S = new Int8Array(t), e.HEAP16 = new Int16Array(t), e.HEAP32 = A = new Int32Array(t), e.HEAPU8 = O = new Uint8Array(t), e.HEAPU16 = new Uint16Array(t), e.HEAPU32 = E = new Uint32Array(t), e.HEAPF32 = new Float32Array(t), e.HEAPF64 = new Float64Array(t);\n                }\n                var N, R = [], L = [], M = [], j = [], U = 0;\n                function V() {\n                    var t = e.preRun.shift();\n                    R.unshift(t);\n                }\n                var B, z = 0, G = null, H = null;\n                function q(t) {\n                    throw e.onAbort && e.onAbort(t), v(t = \"Aborted(\" + t + \")\"), I = !0, t = new WebAssembly.RuntimeError(t + \". Build with -sASSERTIONS for more info.\"), i(t), t;\n                }\n                function W() {\n                    return B.startsWith(\"data:application/octet-stream;base64,\");\n                }\n                if (B = \"ort-wasm.wasm\", !W()) {\n                    var X = B;\n                    B = e.locateFile ? e.locateFile(X, m) : m + X;\n                }\n                function Y() {\n                    var t = B;\n                    try {\n                        if (t == B && y) return new Uint8Array(y);\n                        if (s) return s(t);\n                        throw \"both async and sync fetching of the wasm failed\";\n                    } catch (t) {\n                        q(t);\n                    }\n                }\n                function K(t) {\n                    this.name = \"ExitStatus\", this.message = \"Program terminated with exit(\" + t + \")\", this.status = t;\n                }\n                function Z(t) {\n                    for(; 0 < t.length;)t.shift()(e);\n                }\n                var J = [], Q = 0, tt = 0;\n                function et(t) {\n                    this.Db = t, this.zb = t - 24, this.Ub = function(t) {\n                        E[this.zb + 4 >> 2 >>> 0] = t;\n                    }, this.Eb = function() {\n                        return E[this.zb + 4 >> 2 >>> 0];\n                    }, this.Sb = function(t) {\n                        E[this.zb + 8 >> 2 >>> 0] = t;\n                    }, this.Wb = function() {\n                        return E[this.zb + 8 >> 2 >>> 0];\n                    }, this.Tb = function() {\n                        A[this.zb >> 2 >>> 0] = 0;\n                    }, this.Ib = function(t) {\n                        S[this.zb + 12 >> 0 >>> 0] = t ? 1 : 0;\n                    }, this.Pb = function() {\n                        return 0 != S[this.zb + 12 >> 0 >>> 0];\n                    }, this.Jb = function(t) {\n                        S[this.zb + 13 >> 0 >>> 0] = t ? 1 : 0;\n                    }, this.Lb = function() {\n                        return 0 != S[this.zb + 13 >> 0 >>> 0];\n                    }, this.Rb = function(t, e) {\n                        this.Fb(0), this.Ub(t), this.Sb(e), this.Tb(), this.Ib(!1), this.Jb(!1);\n                    }, this.Nb = function() {\n                        A[this.zb >> 2 >>> 0] += 1;\n                    }, this.Xb = function() {\n                        var t = A[this.zb >> 2 >>> 0];\n                        return A[this.zb >> 2 >>> 0] = t - 1, 1 === t;\n                    }, this.Fb = function(t) {\n                        E[this.zb + 16 >> 2 >>> 0] = t;\n                    }, this.Ob = function() {\n                        return E[this.zb + 16 >> 2 >>> 0];\n                    }, this.Qb = function() {\n                        if (Et(this.Eb())) return E[this.Db >> 2 >>> 0];\n                        var t = this.Ob();\n                        return 0 !== t ? t : this.Db;\n                    };\n                }\n                function nt(t) {\n                    return _t(new et(t).zb);\n                }\n                var rt = [];\n                function it(t) {\n                    var e = rt[t];\n                    return e || (t >= rt.length && (rt.length = t + 1), rt[t] = e = N.get(t)), e;\n                }\n                function ot(t) {\n                    var e = C(t) + 1, n = yt(e);\n                    return n && k(t, S, n, e), n;\n                }\n                var at = {};\n                function st() {\n                    if (!ut) {\n                        var t, e = {\n                            USER: \"web_user\",\n                            LOGNAME: \"web_user\",\n                            PATH: \"/\",\n                            PWD: \"/\",\n                            HOME: \"/home/web_user\",\n                            LANG: (\"object\" == typeof navigator && navigator.languages && navigator.languages[0] || \"C\").replace(\"-\", \"_\") + \".UTF-8\",\n                            _: f || \"./this.program\"\n                        };\n                        for(t in at)void 0 === at[t] ? delete e[t] : e[t] = at[t];\n                        var n = [];\n                        for(t in e)n.push(t + \"=\" + e[t]);\n                        ut = n;\n                    }\n                    return ut;\n                }\n                var ut, ct = [\n                    null,\n                    [],\n                    []\n                ];\n                function lt(t, e) {\n                    var n = ct[t];\n                    0 === e || 10 === e ? ((1 === t ? _ : v)(D(n, 0)), n.length = 0) : n.push(e);\n                }\n                var pt = 0;\n                function ft(t) {\n                    return 0 == t % 4 && (0 != t % 100 || 0 == t % 400);\n                }\n                var dt = [\n                    31,\n                    29,\n                    31,\n                    30,\n                    31,\n                    30,\n                    31,\n                    31,\n                    30,\n                    31,\n                    30,\n                    31\n                ], ht = [\n                    31,\n                    28,\n                    31,\n                    30,\n                    31,\n                    30,\n                    31,\n                    31,\n                    30,\n                    31,\n                    30,\n                    31\n                ];\n                function gt(t, e, n, r) {\n                    function i(t, e, n) {\n                        for(t = \"number\" == typeof t ? t.toString() : t || \"\"; t.length < e;)t = n[0] + t;\n                        return t;\n                    }\n                    function o(t, e) {\n                        return i(t, e, \"0\");\n                    }\n                    function a(t, e) {\n                        function n(t) {\n                            return 0 > t ? -1 : 0 < t ? 1 : 0;\n                        }\n                        var r;\n                        return 0 === (r = n(t.getFullYear() - e.getFullYear())) && 0 === (r = n(t.getMonth() - e.getMonth())) && (r = n(t.getDate() - e.getDate())), r;\n                    }\n                    function s(t) {\n                        switch(t.getDay()){\n                            case 0:\n                                return new Date(t.getFullYear() - 1, 11, 29);\n                            case 1:\n                                return t;\n                            case 2:\n                                return new Date(t.getFullYear(), 0, 3);\n                            case 3:\n                                return new Date(t.getFullYear(), 0, 2);\n                            case 4:\n                                return new Date(t.getFullYear(), 0, 1);\n                            case 5:\n                                return new Date(t.getFullYear() - 1, 11, 31);\n                            case 6:\n                                return new Date(t.getFullYear() - 1, 11, 30);\n                        }\n                    }\n                    function u(t) {\n                        var e = t.Bb;\n                        for(t = new Date(new Date(t.Cb + 1900, 0, 1).getTime()); 0 < e;){\n                            var n = t.getMonth(), r = (ft(t.getFullYear()) ? dt : ht)[n];\n                            if (!(e > r - t.getDate())) {\n                                t.setDate(t.getDate() + e);\n                                break;\n                            }\n                            e -= r - t.getDate() + 1, t.setDate(1), 11 > n ? t.setMonth(n + 1) : (t.setMonth(0), t.setFullYear(t.getFullYear() + 1));\n                        }\n                        return n = new Date(t.getFullYear() + 1, 0, 4), e = s(new Date(t.getFullYear(), 0, 4)), n = s(n), 0 >= a(e, t) ? 0 >= a(n, t) ? t.getFullYear() + 1 : t.getFullYear() : t.getFullYear() - 1;\n                    }\n                    var c = A[r + 40 >> 2 >>> 0];\n                    for(var l in r = {\n                        $b: A[r >> 2 >>> 0],\n                        Zb: A[r + 4 >> 2 >>> 0],\n                        Gb: A[r + 8 >> 2 >>> 0],\n                        Kb: A[r + 12 >> 2 >>> 0],\n                        Hb: A[r + 16 >> 2 >>> 0],\n                        Cb: A[r + 20 >> 2 >>> 0],\n                        Ab: A[r + 24 >> 2 >>> 0],\n                        Bb: A[r + 28 >> 2 >>> 0],\n                        bc: A[r + 32 >> 2 >>> 0],\n                        Yb: A[r + 36 >> 2 >>> 0],\n                        ac: c ? $(c) : \"\"\n                    }, n = $(n), c = {\n                        \"%c\": \"%a %b %d %H:%M:%S %Y\",\n                        \"%D\": \"%m/%d/%y\",\n                        \"%F\": \"%Y-%m-%d\",\n                        \"%h\": \"%b\",\n                        \"%r\": \"%I:%M:%S %p\",\n                        \"%R\": \"%H:%M\",\n                        \"%T\": \"%H:%M:%S\",\n                        \"%x\": \"%m/%d/%y\",\n                        \"%X\": \"%H:%M:%S\",\n                        \"%Ec\": \"%c\",\n                        \"%EC\": \"%C\",\n                        \"%Ex\": \"%m/%d/%y\",\n                        \"%EX\": \"%H:%M:%S\",\n                        \"%Ey\": \"%y\",\n                        \"%EY\": \"%Y\",\n                        \"%Od\": \"%d\",\n                        \"%Oe\": \"%e\",\n                        \"%OH\": \"%H\",\n                        \"%OI\": \"%I\",\n                        \"%Om\": \"%m\",\n                        \"%OM\": \"%M\",\n                        \"%OS\": \"%S\",\n                        \"%Ou\": \"%u\",\n                        \"%OU\": \"%U\",\n                        \"%OV\": \"%V\",\n                        \"%Ow\": \"%w\",\n                        \"%OW\": \"%W\",\n                        \"%Oy\": \"%y\"\n                    })n = n.replace(new RegExp(l, \"g\"), c[l]);\n                    var p = \"Sunday Monday Tuesday Wednesday Thursday Friday Saturday\".split(\" \"), f = \"January February March April May June July August September October November December\".split(\" \");\n                    for(l in c = {\n                        \"%a\": function(t) {\n                            return p[t.Ab].substring(0, 3);\n                        },\n                        \"%A\": function(t) {\n                            return p[t.Ab];\n                        },\n                        \"%b\": function(t) {\n                            return f[t.Hb].substring(0, 3);\n                        },\n                        \"%B\": function(t) {\n                            return f[t.Hb];\n                        },\n                        \"%C\": function(t) {\n                            return o((t.Cb + 1900) / 100 | 0, 2);\n                        },\n                        \"%d\": function(t) {\n                            return o(t.Kb, 2);\n                        },\n                        \"%e\": function(t) {\n                            return i(t.Kb, 2, \" \");\n                        },\n                        \"%g\": function(t) {\n                            return u(t).toString().substring(2);\n                        },\n                        \"%G\": function(t) {\n                            return u(t);\n                        },\n                        \"%H\": function(t) {\n                            return o(t.Gb, 2);\n                        },\n                        \"%I\": function(t) {\n                            return 0 == (t = t.Gb) ? t = 12 : 12 < t && (t -= 12), o(t, 2);\n                        },\n                        \"%j\": function(t) {\n                            for(var e = 0, n = 0; n <= t.Hb - 1; e += (ft(t.Cb + 1900) ? dt : ht)[n++]);\n                            return o(t.Kb + e, 3);\n                        },\n                        \"%m\": function(t) {\n                            return o(t.Hb + 1, 2);\n                        },\n                        \"%M\": function(t) {\n                            return o(t.Zb, 2);\n                        },\n                        \"%n\": function() {\n                            return \"\\n\";\n                        },\n                        \"%p\": function(t) {\n                            return 0 <= t.Gb && 12 > t.Gb ? \"AM\" : \"PM\";\n                        },\n                        \"%S\": function(t) {\n                            return o(t.$b, 2);\n                        },\n                        \"%t\": function() {\n                            return \"\t\";\n                        },\n                        \"%u\": function(t) {\n                            return t.Ab || 7;\n                        },\n                        \"%U\": function(t) {\n                            return o(Math.floor((t.Bb + 7 - t.Ab) / 7), 2);\n                        },\n                        \"%V\": function(t) {\n                            var e = Math.floor((t.Bb + 7 - (t.Ab + 6) % 7) / 7);\n                            if (2 >= (t.Ab + 371 - t.Bb - 2) % 7 && e++, e) 53 == e && (4 == (n = (t.Ab + 371 - t.Bb) % 7) || 3 == n && ft(t.Cb) || (e = 1));\n                            else {\n                                e = 52;\n                                var n = (t.Ab + 7 - t.Bb - 1) % 7;\n                                (4 == n || 5 == n && ft(t.Cb % 400 - 1)) && e++;\n                            }\n                            return o(e, 2);\n                        },\n                        \"%w\": function(t) {\n                            return t.Ab;\n                        },\n                        \"%W\": function(t) {\n                            return o(Math.floor((t.Bb + 7 - (t.Ab + 6) % 7) / 7), 2);\n                        },\n                        \"%y\": function(t) {\n                            return (t.Cb + 1900).toString().substring(2);\n                        },\n                        \"%Y\": function(t) {\n                            return t.Cb + 1900;\n                        },\n                        \"%z\": function(t) {\n                            var e = 0 <= (t = t.Yb);\n                            return t = Math.abs(t) / 60, (e ? \"+\" : \"-\") + String(\"0000\" + (t / 60 * 100 + t % 60)).slice(-4);\n                        },\n                        \"%Z\": function(t) {\n                            return t.ac;\n                        },\n                        \"%%\": function() {\n                            return \"%\";\n                        }\n                    }, n = n.replace(/%%/g, \"\\x00\\x00\"), c)n.includes(l) && (n = n.replace(new RegExp(l, \"g\"), c[l](r)));\n                    return l = function(t) {\n                        var e = Array(C(t) + 1);\n                        return k(t, e, 0, e.length), e;\n                    }(n = n.replace(/\\0\\0/g, \"%\")), l.length > e ? 0 : (S.set(l, t >>> 0), l.length - 1);\n                }\n                var bt = {\n                    a: function(t) {\n                        return yt(t + 24) + 24;\n                    },\n                    m: function(t) {\n                        return (t = new et(t)).Pb() || (t.Ib(!0), Q--), t.Jb(!1), J.push(t), t.Nb(), t.Qb();\n                    },\n                    ia: function(t) {\n                        throw v(\"Unexpected exception thrown, this is not properly supported - aborting\"), I = !0, t;\n                    },\n                    w: function() {\n                        xt(0);\n                        var t = J.pop();\n                        if (t.Xb() && !t.Lb()) {\n                            var e = t.Wb();\n                            e && it(e)(t.Db), nt(t.Db);\n                        }\n                        tt = 0;\n                    },\n                    d: function() {\n                        var t = tt;\n                        if (!t) return pt = 0;\n                        var e = new et(t);\n                        e.Fb(t);\n                        var n = e.Eb();\n                        if (!n) return pt = 0, t;\n                        for(var r = Array.prototype.slice.call(arguments), i = 0; i < r.length; i++){\n                            var o = r[i];\n                            if (0 === o || o === n) break;\n                            if (At(o, n, e.zb + 16)) return pt = o, t;\n                        }\n                        return pt = n, t;\n                    },\n                    k: function() {\n                        var t = tt;\n                        if (!t) return pt = 0;\n                        var e = new et(t);\n                        e.Fb(t);\n                        var n = e.Eb();\n                        if (!n) return pt = 0, t;\n                        for(var r = Array.prototype.slice.call(arguments), i = 0; i < r.length; i++){\n                            var o = r[i];\n                            if (0 === o || o === n) break;\n                            if (At(o, n, e.zb + 16)) return pt = o, t;\n                        }\n                        return pt = n, t;\n                    },\n                    g: function() {\n                        var t = tt;\n                        if (!t) return pt = 0;\n                        var e = new et(t);\n                        e.Fb(t);\n                        var n = e.Eb();\n                        if (!n) return pt = 0, t;\n                        for(var r = Array.prototype.slice.call(arguments), i = 0; i < r.length; i++){\n                            var o = r[i];\n                            if (0 === o || o === n) break;\n                            if (At(o, n, e.zb + 16)) return pt = o, t;\n                        }\n                        return pt = n, t;\n                    },\n                    s: nt,\n                    L: function() {\n                        var t = J.pop();\n                        t || q(\"no exception to throw\");\n                        var e = t.Db;\n                        throw t.Lb() || (J.push(t), t.Jb(!0), t.Ib(!1), Q++), tt = e, e;\n                    },\n                    b: function(t, e, n) {\n                        throw new et(t).Rb(e, n), tt = t, Q++, t;\n                    },\n                    la: function() {\n                        return Q;\n                    },\n                    i: function(t) {\n                        throw tt || (tt = t), t;\n                    },\n                    H: function() {\n                        return 0;\n                    },\n                    Ba: function() {},\n                    pa: function() {},\n                    ra: function() {},\n                    ka: function() {\n                        return 0;\n                    },\n                    za: function() {},\n                    ua: function() {},\n                    ya: function() {},\n                    R: function() {},\n                    qa: function() {},\n                    na: function() {},\n                    Aa: function() {},\n                    oa: function() {},\n                    Ha: function() {},\n                    Ja: function() {\n                        q(\"To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking\");\n                    },\n                    Ia: function() {\n                        q(\"To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking\");\n                    },\n                    S: function() {\n                        return Date.now();\n                    },\n                    Ca: function() {\n                        return !0;\n                    },\n                    Da: function(t, e) {\n                        t = new Date(1e3 * (E[t >>> 2] + 4294967296 * A[t + 4 >>> 2])), A[e >> 2 >>> 0] = t.getUTCSeconds(), A[e + 4 >> 2 >>> 0] = t.getUTCMinutes(), A[e + 8 >> 2 >>> 0] = t.getUTCHours(), A[e + 12 >> 2 >>> 0] = t.getUTCDate(), A[e + 16 >> 2 >>> 0] = t.getUTCMonth(), A[e + 20 >> 2 >>> 0] = t.getUTCFullYear() - 1900, A[e + 24 >> 2 >>> 0] = t.getUTCDay(), A[e + 28 >> 2 >>> 0] = (t.getTime() - Date.UTC(t.getUTCFullYear(), 0, 1, 0, 0, 0, 0)) / 864e5 | 0;\n                    },\n                    Ea: function(t, e) {\n                        t = new Date(1e3 * (E[t >>> 2] + 4294967296 * A[t + 4 >>> 2])), A[e >> 2 >>> 0] = t.getSeconds(), A[e + 4 >> 2 >>> 0] = t.getMinutes(), A[e + 8 >> 2 >>> 0] = t.getHours(), A[e + 12 >> 2 >>> 0] = t.getDate(), A[e + 16 >> 2 >>> 0] = t.getMonth(), A[e + 20 >> 2 >>> 0] = t.getFullYear() - 1900, A[e + 24 >> 2 >>> 0] = t.getDay();\n                        var n = new Date(t.getFullYear(), 0, 1);\n                        A[e + 28 >> 2 >>> 0] = (t.getTime() - n.getTime()) / 864e5 | 0, A[e + 36 >> 2 >>> 0] = -60 * t.getTimezoneOffset();\n                        var r = new Date(t.getFullYear(), 6, 1).getTimezoneOffset();\n                        n = n.getTimezoneOffset(), A[e + 32 >> 2 >>> 0] = 0 | (r != n && t.getTimezoneOffset() == Math.min(n, r));\n                    },\n                    Fa: function(t) {\n                        var e = new Date(A[t + 20 >> 2 >>> 0] + 1900, A[t + 16 >> 2 >>> 0], A[t + 12 >> 2 >>> 0], A[t + 8 >> 2 >>> 0], A[t + 4 >> 2 >>> 0], A[t >> 2 >>> 0], 0), n = A[t + 32 >> 2 >>> 0], r = e.getTimezoneOffset(), i = new Date(e.getFullYear(), 0, 1), o = new Date(e.getFullYear(), 6, 1).getTimezoneOffset(), a = i.getTimezoneOffset(), s = Math.min(a, o);\n                        return 0 > n ? A[t + 32 >> 2 >>> 0] = Number(o != a && s == r) : 0 < n != (s == r) && (o = Math.max(a, o), e.setTime(e.getTime() + 6e4 * ((0 < n ? s : o) - r))), A[t + 24 >> 2 >>> 0] = e.getDay(), A[t + 28 >> 2 >>> 0] = (e.getTime() - i.getTime()) / 864e5 | 0, A[t >> 2 >>> 0] = e.getSeconds(), A[t + 4 >> 2 >>> 0] = e.getMinutes(), A[t + 8 >> 2 >>> 0] = e.getHours(), A[t + 12 >> 2 >>> 0] = e.getDate(), A[t + 16 >> 2 >>> 0] = e.getMonth(), e.getTime() / 1e3 | 0;\n                    },\n                    sa: function() {\n                        return -52;\n                    },\n                    ta: function() {},\n                    Ga: function t(e, n, r) {\n                        t.Vb || (t.Vb = !0, function(t, e, n) {\n                            function r(t) {\n                                return (t = t.toTimeString().match(/\\(([A-Za-z ]+)\\)$/)) ? t[1] : \"GMT\";\n                            }\n                            var i = (new Date).getFullYear(), o = new Date(i, 0, 1), a = new Date(i, 6, 1);\n                            i = o.getTimezoneOffset();\n                            var s = a.getTimezoneOffset();\n                            A[t >> 2 >>> 0] = 60 * Math.max(i, s), A[e >> 2 >>> 0] = Number(i != s), t = r(o), e = r(a), t = ot(t), e = ot(e), s < i ? (E[n >> 2 >>> 0] = t, E[n + 4 >> 2 >>> 0] = e) : (E[n >> 2 >>> 0] = e, E[n + 4 >> 2 >>> 0] = t);\n                        }(e, n, r));\n                    },\n                    B: function() {\n                        q(\"\");\n                    },\n                    ma: function() {\n                        return 4294901760;\n                    },\n                    I: b ? ()=>{\n                        var t = process.hrtime();\n                        return 1e3 * t[0] + t[1] / 1e6;\n                    } : ()=>performance.now(),\n                    xa: function(t, e, n) {\n                        O.copyWithin(t >>> 0, e >>> 0, e + n >>> 0);\n                    },\n                    G: function(t) {\n                        var e = O.length;\n                        if (4294901760 < (t >>>= 0)) return !1;\n                        for(var n = 1; 4 >= n; n *= 2){\n                            var r = e * (1 + .2 / n);\n                            r = Math.min(r, t + 100663296);\n                            var i = Math;\n                            r = Math.max(t, r), i = i.min.call(i, 4294901760, r + (65536 - r % 65536) % 65536);\n                            t: {\n                                try {\n                                    x.grow(i - T.byteLength + 65535 >>> 16), F();\n                                    var o = 1;\n                                    break t;\n                                } catch (t) {}\n                                o = void 0;\n                            }\n                            if (o) return !0;\n                        }\n                        return !1;\n                    },\n                    va: function(t, e) {\n                        var n = 0;\n                        return st().forEach(function(r, i) {\n                            var o = e + n;\n                            for(i = E[t + 4 * i >> 2 >>> 0] = o, o = 0; o < r.length; ++o)S[i++ >> 0 >>> 0] = r.charCodeAt(o);\n                            S[i >> 0 >>> 0] = 0, n += r.length + 1;\n                        }), 0;\n                    },\n                    wa: function(t, e) {\n                        var n = st();\n                        E[t >> 2 >>> 0] = n.length;\n                        var r = 0;\n                        return n.forEach(function(t) {\n                            r += t.length + 1;\n                        }), E[e >> 2 >>> 0] = r, 0;\n                    },\n                    ba: function(t) {\n                        w || 0 < U || (wt(), Z(M), vt(0), ct[1].length && lt(1, 10), ct[2].length && lt(2, 10)), w || 0 < U || (e.onExit && e.onExit(t), I = !0), d(t, new K(t));\n                    },\n                    E: function() {\n                        return 52;\n                    },\n                    Q: function() {\n                        return 52;\n                    },\n                    ca: function() {\n                        return 70;\n                    },\n                    P: function(t, e, n, r) {\n                        for(var i = 0, o = 0; o < n; o++){\n                            var a = E[e >> 2 >>> 0], s = E[e + 4 >> 2 >>> 0];\n                            e += 8;\n                            for(var u = 0; u < s; u++)lt(t, O[a + u >>> 0]);\n                            i += s;\n                        }\n                        return E[r >> 2 >>> 0] = i, 0;\n                    },\n                    c: function() {\n                        return pt;\n                    },\n                    ja: function t(e, r) {\n                        t.Mb || (t.Mb = function() {\n                            if (\"object\" == typeof crypto && \"function\" == typeof crypto.getRandomValues) {\n                                var t = new Uint8Array(1);\n                                return ()=>(crypto.getRandomValues(t), t[0]);\n                            }\n                            if (b) try {\n                                var e = n(6113);\n                                return ()=>e.randomBytes(1)[0];\n                            } catch (t) {}\n                            return ()=>q(\"randomDevice\");\n                        }());\n                        for(var i = 0; i < r; i++)S[e + i >> 0 >>> 0] = t.Mb();\n                        return 0;\n                    },\n                    ea: function(t, e, n) {\n                        var r = Tt();\n                        try {\n                            return it(t)(e, n);\n                        } catch (t) {\n                            if (St(r), t !== t + 0) throw t;\n                            xt(1, 0);\n                        }\n                    },\n                    fa: function(t, e, n) {\n                        var r = Tt();\n                        try {\n                            return it(t)(e, n);\n                        } catch (t) {\n                            if (St(r), t !== t + 0) throw t;\n                            xt(1, 0);\n                        }\n                    },\n                    J: function(t) {\n                        var e = Tt();\n                        try {\n                            return it(t)();\n                        } catch (t) {\n                            if (St(e), t !== t + 0) throw t;\n                            xt(1, 0);\n                        }\n                    },\n                    e: function(t, e) {\n                        var n = Tt();\n                        try {\n                            return it(t)(e);\n                        } catch (t) {\n                            if (St(n), t !== t + 0) throw t;\n                            xt(1, 0);\n                        }\n                    },\n                    N: function(t, e, n) {\n                        var r = Tt();\n                        try {\n                            return it(t)(e, n);\n                        } catch (t) {\n                            if (St(r), t !== t + 0) throw t;\n                            xt(1, 0);\n                        }\n                    },\n                    O: function(t, e, n) {\n                        var r = Tt();\n                        try {\n                            return it(t)(e, n);\n                        } catch (t) {\n                            if (St(r), t !== t + 0) throw t;\n                            xt(1, 0);\n                        }\n                    },\n                    j: function(t, e, n) {\n                        var r = Tt();\n                        try {\n                            return it(t)(e, n);\n                        } catch (t) {\n                            if (St(r), t !== t + 0) throw t;\n                            xt(1, 0);\n                        }\n                    },\n                    o: function(t, e, n, r) {\n                        var i = Tt();\n                        try {\n                            return it(t)(e, n, r);\n                        } catch (t) {\n                            if (St(i), t !== t + 0) throw t;\n                            xt(1, 0);\n                        }\n                    },\n                    p: function(t, e, n, r, i) {\n                        var o = Tt();\n                        try {\n                            return it(t)(e, n, r, i);\n                        } catch (t) {\n                            if (St(o), t !== t + 0) throw t;\n                            xt(1, 0);\n                        }\n                    },\n                    M: function(t, e, n, r, i, o) {\n                        var a = Tt();\n                        try {\n                            return it(t)(e, n, r, i, o);\n                        } catch (t) {\n                            if (St(a), t !== t + 0) throw t;\n                            xt(1, 0);\n                        }\n                    },\n                    r: function(t, e, n, r, i, o) {\n                        var a = Tt();\n                        try {\n                            return it(t)(e, n, r, i, o);\n                        } catch (t) {\n                            if (St(a), t !== t + 0) throw t;\n                            xt(1, 0);\n                        }\n                    },\n                    v: function(t, e, n, r, i, o, a) {\n                        var s = Tt();\n                        try {\n                            return it(t)(e, n, r, i, o, a);\n                        } catch (t) {\n                            if (St(s), t !== t + 0) throw t;\n                            xt(1, 0);\n                        }\n                    },\n                    K: function(t, e, n, r, i, o, a, s) {\n                        var u = Tt();\n                        try {\n                            return it(t)(e, n, r, i, o, a, s);\n                        } catch (t) {\n                            if (St(u), t !== t + 0) throw t;\n                            xt(1, 0);\n                        }\n                    },\n                    D: function(t, e, n, r, i, o, a, s, u, c, l, p) {\n                        var f = Tt();\n                        try {\n                            return it(t)(e, n, r, i, o, a, s, u, c, l, p);\n                        } catch (t) {\n                            if (St(f), t !== t + 0) throw t;\n                            xt(1, 0);\n                        }\n                    },\n                    X: function(t, e, n, r, i, o, a, s) {\n                        var u = Tt();\n                        try {\n                            return Rt(t, e, n, r, i, o, a, s);\n                        } catch (t) {\n                            if (St(u), t !== t + 0) throw t;\n                            xt(1, 0);\n                        }\n                    },\n                    V: function(t, e, n, r, i, o, a) {\n                        var s = Tt();\n                        try {\n                            return Pt(t, e, n, r, i, o, a);\n                        } catch (t) {\n                            if (St(s), t !== t + 0) throw t;\n                            xt(1, 0);\n                        }\n                    },\n                    U: function(t, e, n, r, i) {\n                        var o = Tt();\n                        try {\n                            return Lt(t, e, n, r, i);\n                        } catch (t) {\n                            if (St(o), t !== t + 0) throw t;\n                            xt(1, 0);\n                        }\n                    },\n                    Z: function(t, e, n, r) {\n                        var i = Tt();\n                        try {\n                            return Ft(t, e, n, r);\n                        } catch (t) {\n                            if (St(i), t !== t + 0) throw t;\n                            xt(1, 0);\n                        }\n                    },\n                    W: function(t) {\n                        var e = Tt();\n                        try {\n                            return It(t);\n                        } catch (t) {\n                            if (St(e), t !== t + 0) throw t;\n                            xt(1, 0);\n                        }\n                    },\n                    Y: function(t, e) {\n                        var n = Tt();\n                        try {\n                            return Nt(t, e);\n                        } catch (t) {\n                            if (St(n), t !== t + 0) throw t;\n                            xt(1, 0);\n                        }\n                    },\n                    T: function(t, e, n) {\n                        var r = Tt();\n                        try {\n                            return Dt(t, e, n);\n                        } catch (t) {\n                            if (St(r), t !== t + 0) throw t;\n                            xt(1, 0);\n                        }\n                    },\n                    f: function(t) {\n                        var e = Tt();\n                        try {\n                            it(t)();\n                        } catch (t) {\n                            if (St(e), t !== t + 0) throw t;\n                            xt(1, 0);\n                        }\n                    },\n                    q: function(t, e) {\n                        var n = Tt();\n                        try {\n                            it(t)(e);\n                        } catch (t) {\n                            if (St(n), t !== t + 0) throw t;\n                            xt(1, 0);\n                        }\n                    },\n                    h: function(t, e, n) {\n                        var r = Tt();\n                        try {\n                            it(t)(e, n);\n                        } catch (t) {\n                            if (St(r), t !== t + 0) throw t;\n                            xt(1, 0);\n                        }\n                    },\n                    da: function(t, e, n, r) {\n                        var i = Tt();\n                        try {\n                            it(t)(e, n, r);\n                        } catch (t) {\n                            if (St(i), t !== t + 0) throw t;\n                            xt(1, 0);\n                        }\n                    },\n                    l: function(t, e, n, r) {\n                        var i = Tt();\n                        try {\n                            it(t)(e, n, r);\n                        } catch (t) {\n                            if (St(i), t !== t + 0) throw t;\n                            xt(1, 0);\n                        }\n                    },\n                    t: function(t, e, n, r, i) {\n                        var o = Tt();\n                        try {\n                            it(t)(e, n, r, i);\n                        } catch (t) {\n                            if (St(o), t !== t + 0) throw t;\n                            xt(1, 0);\n                        }\n                    },\n                    u: function(t, e, n, r, i, o) {\n                        var a = Tt();\n                        try {\n                            it(t)(e, n, r, i, o);\n                        } catch (t) {\n                            if (St(a), t !== t + 0) throw t;\n                            xt(1, 0);\n                        }\n                    },\n                    x: function(t, e, n, r, i, o, a) {\n                        var s = Tt();\n                        try {\n                            it(t)(e, n, r, i, o, a);\n                        } catch (t) {\n                            if (St(s), t !== t + 0) throw t;\n                            xt(1, 0);\n                        }\n                    },\n                    z: function(t, e, n, r, i, o, a, s) {\n                        var u = Tt();\n                        try {\n                            it(t)(e, n, r, i, o, a, s);\n                        } catch (t) {\n                            if (St(u), t !== t + 0) throw t;\n                            xt(1, 0);\n                        }\n                    },\n                    ga: function(t, e, n, r, i, o, a, s, u) {\n                        var c = Tt();\n                        try {\n                            it(t)(e, n, r, i, o, a, s, u);\n                        } catch (t) {\n                            if (St(c), t !== t + 0) throw t;\n                            xt(1, 0);\n                        }\n                    },\n                    A: function(t, e, n, r, i, o, a, s, u, c, l) {\n                        var p = Tt();\n                        try {\n                            it(t)(e, n, r, i, o, a, s, u, c, l);\n                        } catch (t) {\n                            if (St(p), t !== t + 0) throw t;\n                            xt(1, 0);\n                        }\n                    },\n                    C: function(t, e, n, r, i, o, a, s, u, c, l, p, f, d, h, g) {\n                        var b = Tt();\n                        try {\n                            it(t)(e, n, r, i, o, a, s, u, c, l, p, f, d, h, g);\n                        } catch (t) {\n                            if (St(b), t !== t + 0) throw t;\n                            xt(1, 0);\n                        }\n                    },\n                    aa: function(t, e, n, r, i, o, a, s) {\n                        var u = Tt();\n                        try {\n                            $t(t, e, n, r, i, o, a, s);\n                        } catch (t) {\n                            if (St(u), t !== t + 0) throw t;\n                            xt(1, 0);\n                        }\n                    },\n                    _: function(t, e, n, r, i, o, a, s, u, c, l, p) {\n                        var f = Tt();\n                        try {\n                            Ct(t, e, n, r, i, o, a, s, u, c, l, p);\n                        } catch (t) {\n                            if (St(f), t !== t + 0) throw t;\n                            xt(1, 0);\n                        }\n                    },\n                    $: function(t, e, n, r, i, o) {\n                        var a = Tt();\n                        try {\n                            kt(t, e, n, r, i, o);\n                        } catch (t) {\n                            if (St(a), t !== t + 0) throw t;\n                            xt(1, 0);\n                        }\n                    },\n                    n: function(t) {\n                        return t;\n                    },\n                    F: function(t) {\n                        pt = t;\n                    },\n                    ha: gt,\n                    y: function(t, e, n, r) {\n                        return gt(t, e, n, r);\n                    }\n                };\n                !function() {\n                    function t(t) {\n                        e.asm = t.exports, x = e.asm.Ka, F(), N = e.asm.ib, L.unshift(e.asm.La), z--, e.monitorRunDependencies && e.monitorRunDependencies(z), 0 == z && (null !== G && (clearInterval(G), G = null), H && (t = H, H = null, t()));\n                    }\n                    function n(e) {\n                        t(e.instance);\n                    }\n                    function r(t) {\n                        return (function() {\n                            if (!y && (h || g)) {\n                                if (\"function\" == typeof fetch && !B.startsWith(\"file://\")) return fetch(B, {\n                                    credentials: \"same-origin\"\n                                }).then(function(t) {\n                                    if (!t.ok) throw \"failed to load wasm binary file at '\" + B + \"'\";\n                                    return t.arrayBuffer();\n                                }).catch(function() {\n                                    return Y();\n                                });\n                                if (a) return new Promise(function(t, e) {\n                                    a(B, function(e) {\n                                        t(new Uint8Array(e));\n                                    }, e);\n                                });\n                            }\n                            return Promise.resolve().then(function() {\n                                return Y();\n                            });\n                        })().then(function(t) {\n                            return WebAssembly.instantiate(t, o);\n                        }).then(function(t) {\n                            return t;\n                        }).then(t, function(t) {\n                            v(\"failed to asynchronously prepare wasm: \" + t), q(t);\n                        });\n                    }\n                    var o = {\n                        a: bt\n                    };\n                    if (z++, e.monitorRunDependencies && e.monitorRunDependencies(z), e.instantiateWasm) try {\n                        return e.instantiateWasm(o, t);\n                    } catch (t) {\n                        return v(\"Module.instantiateWasm callback failed with error: \" + t), !1;\n                    }\n                    (y || \"function\" != typeof WebAssembly.instantiateStreaming || W() || B.startsWith(\"file://\") || b || \"function\" != typeof fetch ? r(n) : fetch(B, {\n                        credentials: \"same-origin\"\n                    }).then(function(t) {\n                        return WebAssembly.instantiateStreaming(t, o).then(n, function(t) {\n                            return v(\"wasm streaming compile failed: \" + t), v(\"falling back to ArrayBuffer instantiation\"), r(n);\n                        });\n                    })).catch(i);\n                }(), e.___wasm_call_ctors = function() {\n                    return (e.___wasm_call_ctors = e.asm.La).apply(null, arguments);\n                }, e._OrtInit = function() {\n                    return (e._OrtInit = e.asm.Ma).apply(null, arguments);\n                }, e._OrtCreateSessionOptions = function() {\n                    return (e._OrtCreateSessionOptions = e.asm.Na).apply(null, arguments);\n                }, e._OrtAppendExecutionProvider = function() {\n                    return (e._OrtAppendExecutionProvider = e.asm.Oa).apply(null, arguments);\n                }, e._OrtAddSessionConfigEntry = function() {\n                    return (e._OrtAddSessionConfigEntry = e.asm.Pa).apply(null, arguments);\n                }, e._OrtReleaseSessionOptions = function() {\n                    return (e._OrtReleaseSessionOptions = e.asm.Qa).apply(null, arguments);\n                }, e._OrtCreateSession = function() {\n                    return (e._OrtCreateSession = e.asm.Ra).apply(null, arguments);\n                }, e._OrtReleaseSession = function() {\n                    return (e._OrtReleaseSession = e.asm.Sa).apply(null, arguments);\n                }, e._OrtGetInputCount = function() {\n                    return (e._OrtGetInputCount = e.asm.Ta).apply(null, arguments);\n                }, e._OrtGetOutputCount = function() {\n                    return (e._OrtGetOutputCount = e.asm.Ua).apply(null, arguments);\n                }, e._OrtGetInputName = function() {\n                    return (e._OrtGetInputName = e.asm.Va).apply(null, arguments);\n                }, e._OrtGetOutputName = function() {\n                    return (e._OrtGetOutputName = e.asm.Wa).apply(null, arguments);\n                }, e._OrtFree = function() {\n                    return (e._OrtFree = e.asm.Xa).apply(null, arguments);\n                }, e._OrtCreateTensor = function() {\n                    return (e._OrtCreateTensor = e.asm.Ya).apply(null, arguments);\n                }, e._OrtGetTensorData = function() {\n                    return (e._OrtGetTensorData = e.asm.Za).apply(null, arguments);\n                }, e._OrtReleaseTensor = function() {\n                    return (e._OrtReleaseTensor = e.asm._a).apply(null, arguments);\n                }, e._OrtCreateRunOptions = function() {\n                    return (e._OrtCreateRunOptions = e.asm.$a).apply(null, arguments);\n                }, e._OrtAddRunConfigEntry = function() {\n                    return (e._OrtAddRunConfigEntry = e.asm.ab).apply(null, arguments);\n                }, e._OrtReleaseRunOptions = function() {\n                    return (e._OrtReleaseRunOptions = e.asm.bb).apply(null, arguments);\n                }, e._OrtRun = function() {\n                    return (e._OrtRun = e.asm.cb).apply(null, arguments);\n                }, e._OrtEndProfiling = function() {\n                    return (e._OrtEndProfiling = e.asm.db).apply(null, arguments);\n                };\n                var mt, yt = e._malloc = function() {\n                    return (yt = e._malloc = e.asm.eb).apply(null, arguments);\n                }, _t = e._free = function() {\n                    return (_t = e._free = e.asm.fb).apply(null, arguments);\n                }, vt = e._fflush = function() {\n                    return (vt = e._fflush = e.asm.gb).apply(null, arguments);\n                }, wt = e.___funcs_on_exit = function() {\n                    return (wt = e.___funcs_on_exit = e.asm.hb).apply(null, arguments);\n                }, xt = e._setThrew = function() {\n                    return (xt = e._setThrew = e.asm.jb).apply(null, arguments);\n                }, Tt = e.stackSave = function() {\n                    return (Tt = e.stackSave = e.asm.kb).apply(null, arguments);\n                }, St = e.stackRestore = function() {\n                    return (St = e.stackRestore = e.asm.lb).apply(null, arguments);\n                }, Ot = e.stackAlloc = function() {\n                    return (Ot = e.stackAlloc = e.asm.mb).apply(null, arguments);\n                }, At = e.___cxa_can_catch = function() {\n                    return (At = e.___cxa_can_catch = e.asm.nb).apply(null, arguments);\n                }, Et = e.___cxa_is_pointer_type = function() {\n                    return (Et = e.___cxa_is_pointer_type = e.asm.ob).apply(null, arguments);\n                }, It = e.dynCall_j = function() {\n                    return (It = e.dynCall_j = e.asm.pb).apply(null, arguments);\n                }, Pt = e.dynCall_iiiiij = function() {\n                    return (Pt = e.dynCall_iiiiij = e.asm.qb).apply(null, arguments);\n                }, Dt = e.dynCall_jii = function() {\n                    return (Dt = e.dynCall_jii = e.asm.rb).apply(null, arguments);\n                }, $t = e.dynCall_viiiiij = function() {\n                    return ($t = e.dynCall_viiiiij = e.asm.sb).apply(null, arguments);\n                }, kt = e.dynCall_vjji = function() {\n                    return (kt = e.dynCall_vjji = e.asm.tb).apply(null, arguments);\n                }, Ct = e.dynCall_viiijjjii = function() {\n                    return (Ct = e.dynCall_viiijjjii = e.asm.ub).apply(null, arguments);\n                }, Ft = e.dynCall_iij = function() {\n                    return (Ft = e.dynCall_iij = e.asm.vb).apply(null, arguments);\n                }, Nt = e.dynCall_ji = function() {\n                    return (Nt = e.dynCall_ji = e.asm.wb).apply(null, arguments);\n                }, Rt = e.dynCall_iiiiiij = function() {\n                    return (Rt = e.dynCall_iiiiiij = e.asm.xb).apply(null, arguments);\n                }, Lt = e.dynCall_iiij = function() {\n                    return (Lt = e.dynCall_iiij = e.asm.yb).apply(null, arguments);\n                };\n                function Mt() {\n                    function t() {\n                        if (!mt && (mt = !0, e.calledRun = !0, !I)) {\n                            if (Z(L), r(e), e.onRuntimeInitialized && e.onRuntimeInitialized(), e.postRun) for(\"function\" == typeof e.postRun && (e.postRun = [\n                                e.postRun\n                            ]); e.postRun.length;){\n                                var t = e.postRun.shift();\n                                j.unshift(t);\n                            }\n                            Z(j);\n                        }\n                    }\n                    if (!(0 < z)) {\n                        if (e.preRun) for(\"function\" == typeof e.preRun && (e.preRun = [\n                            e.preRun\n                        ]); e.preRun.length;)V();\n                        Z(R), 0 < z || (e.setStatus ? (e.setStatus(\"Running...\"), setTimeout(function() {\n                            setTimeout(function() {\n                                e.setStatus(\"\");\n                            }, 1), t();\n                        }, 1)) : t());\n                    }\n                }\n                if (e.UTF8ToString = $, e.stringToUTF8 = function(t, e, n) {\n                    return k(t, O, e, n);\n                }, e.lengthBytesUTF8 = C, e.stackSave = Tt, e.stackRestore = St, e.stackAlloc = Ot, H = function t() {\n                    mt || Mt(), mt || (H = t);\n                }, e.preInit) for(\"function\" == typeof e.preInit && (e.preInit = [\n                    e.preInit\n                ]); 0 < e.preInit.length;)e.preInit.pop()();\n                return Mt(), t.ready;\n            });\n            t.exports = r;\n        },\n        4537: (t)=>{\n            \"use strict\";\n            t.exports = function(t, e) {\n                for(var n = new Array(arguments.length - 1), r = 0, i = 2, o = !0; i < arguments.length;)n[r++] = arguments[i++];\n                return new Promise(function(i, a) {\n                    n[r] = function(t) {\n                        if (o) if (o = !1, t) a(t);\n                        else {\n                            for(var e = new Array(arguments.length - 1), n = 0; n < e.length;)e[n++] = arguments[n];\n                            i.apply(null, e);\n                        }\n                    };\n                    try {\n                        t.apply(e || null, n);\n                    } catch (t) {\n                        o && (o = !1, a(t));\n                    }\n                });\n            };\n        },\n        7419: (t, e)=>{\n            \"use strict\";\n            var n = e;\n            n.length = function(t) {\n                var e = t.length;\n                if (!e) return 0;\n                for(var n = 0; --e % 4 > 1 && \"=\" === t.charAt(e);)++n;\n                return Math.ceil(3 * t.length) / 4 - n;\n            };\n            for(var r = new Array(64), i = new Array(123), o = 0; o < 64;)i[r[o] = o < 26 ? o + 65 : o < 52 ? o + 71 : o < 62 ? o - 4 : o - 59 | 43] = o++;\n            n.encode = function(t, e, n) {\n                for(var i, o = null, a = [], s = 0, u = 0; e < n;){\n                    var c = t[e++];\n                    switch(u){\n                        case 0:\n                            a[s++] = r[c >> 2], i = (3 & c) << 4, u = 1;\n                            break;\n                        case 1:\n                            a[s++] = r[i | c >> 4], i = (15 & c) << 2, u = 2;\n                            break;\n                        case 2:\n                            a[s++] = r[i | c >> 6], a[s++] = r[63 & c], u = 0;\n                    }\n                    s > 8191 && ((o || (o = [])).push(String.fromCharCode.apply(String, a)), s = 0);\n                }\n                return u && (a[s++] = r[i], a[s++] = 61, 1 === u && (a[s++] = 61)), o ? (s && o.push(String.fromCharCode.apply(String, a.slice(0, s))), o.join(\"\")) : String.fromCharCode.apply(String, a.slice(0, s));\n            };\n            var a = \"invalid encoding\";\n            n.decode = function(t, e, n) {\n                for(var r, o = n, s = 0, u = 0; u < t.length;){\n                    var c = t.charCodeAt(u++);\n                    if (61 === c && s > 1) break;\n                    if (void 0 === (c = i[c])) throw Error(a);\n                    switch(s){\n                        case 0:\n                            r = c, s = 1;\n                            break;\n                        case 1:\n                            e[n++] = r << 2 | (48 & c) >> 4, r = c, s = 2;\n                            break;\n                        case 2:\n                            e[n++] = (15 & r) << 4 | (60 & c) >> 2, r = c, s = 3;\n                            break;\n                        case 3:\n                            e[n++] = (3 & r) << 6 | c, s = 0;\n                    }\n                }\n                if (1 === s) throw Error(a);\n                return n - o;\n            }, n.test = function(t) {\n                return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(t);\n            };\n        },\n        9211: (t)=>{\n            \"use strict\";\n            function e() {\n                this._listeners = {};\n            }\n            t.exports = e, e.prototype.on = function(t, e, n) {\n                return (this._listeners[t] || (this._listeners[t] = [])).push({\n                    fn: e,\n                    ctx: n || this\n                }), this;\n            }, e.prototype.off = function(t, e) {\n                if (void 0 === t) this._listeners = {};\n                else if (void 0 === e) this._listeners[t] = [];\n                else for(var n = this._listeners[t], r = 0; r < n.length;)n[r].fn === e ? n.splice(r, 1) : ++r;\n                return this;\n            }, e.prototype.emit = function(t) {\n                var e = this._listeners[t];\n                if (e) {\n                    for(var n = [], r = 1; r < arguments.length;)n.push(arguments[r++]);\n                    for(r = 0; r < e.length;)e[r].fn.apply(e[r++].ctx, n);\n                }\n                return this;\n            };\n        },\n        945: (t)=>{\n            \"use strict\";\n            function e(t) {\n                return \"undefined\" != typeof Float32Array ? function() {\n                    var e = new Float32Array([\n                        -0\n                    ]), n = new Uint8Array(e.buffer), r = 128 === n[3];\n                    function i(t, r, i) {\n                        e[0] = t, r[i] = n[0], r[i + 1] = n[1], r[i + 2] = n[2], r[i + 3] = n[3];\n                    }\n                    function o(t, r, i) {\n                        e[0] = t, r[i] = n[3], r[i + 1] = n[2], r[i + 2] = n[1], r[i + 3] = n[0];\n                    }\n                    function a(t, r) {\n                        return n[0] = t[r], n[1] = t[r + 1], n[2] = t[r + 2], n[3] = t[r + 3], e[0];\n                    }\n                    function s(t, r) {\n                        return n[3] = t[r], n[2] = t[r + 1], n[1] = t[r + 2], n[0] = t[r + 3], e[0];\n                    }\n                    t.writeFloatLE = r ? i : o, t.writeFloatBE = r ? o : i, t.readFloatLE = r ? a : s, t.readFloatBE = r ? s : a;\n                }() : function() {\n                    function e(t, e, n, r) {\n                        var i = e < 0 ? 1 : 0;\n                        if (i && (e = -e), 0 === e) t(1 / e > 0 ? 0 : 2147483648, n, r);\n                        else if (isNaN(e)) t(2143289344, n, r);\n                        else if (e > 34028234663852886e22) t((i << 31 | 2139095040) >>> 0, n, r);\n                        else if (e < 11754943508222875e-54) t((i << 31 | Math.round(e / 1401298464324817e-60)) >>> 0, n, r);\n                        else {\n                            var o = Math.floor(Math.log(e) / Math.LN2);\n                            t((i << 31 | o + 127 << 23 | 8388607 & Math.round(e * Math.pow(2, -o) * 8388608)) >>> 0, n, r);\n                        }\n                    }\n                    function a(t, e, n) {\n                        var r = t(e, n), i = 2 * (r >> 31) + 1, o = r >>> 23 & 255, a = 8388607 & r;\n                        return 255 === o ? a ? NaN : i * (1 / 0) : 0 === o ? 1401298464324817e-60 * i * a : i * Math.pow(2, o - 150) * (a + 8388608);\n                    }\n                    t.writeFloatLE = e.bind(null, n), t.writeFloatBE = e.bind(null, r), t.readFloatLE = a.bind(null, i), t.readFloatBE = a.bind(null, o);\n                }(), \"undefined\" != typeof Float64Array ? function() {\n                    var e = new Float64Array([\n                        -0\n                    ]), n = new Uint8Array(e.buffer), r = 128 === n[7];\n                    function i(t, r, i) {\n                        e[0] = t, r[i] = n[0], r[i + 1] = n[1], r[i + 2] = n[2], r[i + 3] = n[3], r[i + 4] = n[4], r[i + 5] = n[5], r[i + 6] = n[6], r[i + 7] = n[7];\n                    }\n                    function o(t, r, i) {\n                        e[0] = t, r[i] = n[7], r[i + 1] = n[6], r[i + 2] = n[5], r[i + 3] = n[4], r[i + 4] = n[3], r[i + 5] = n[2], r[i + 6] = n[1], r[i + 7] = n[0];\n                    }\n                    function a(t, r) {\n                        return n[0] = t[r], n[1] = t[r + 1], n[2] = t[r + 2], n[3] = t[r + 3], n[4] = t[r + 4], n[5] = t[r + 5], n[6] = t[r + 6], n[7] = t[r + 7], e[0];\n                    }\n                    function s(t, r) {\n                        return n[7] = t[r], n[6] = t[r + 1], n[5] = t[r + 2], n[4] = t[r + 3], n[3] = t[r + 4], n[2] = t[r + 5], n[1] = t[r + 6], n[0] = t[r + 7], e[0];\n                    }\n                    t.writeDoubleLE = r ? i : o, t.writeDoubleBE = r ? o : i, t.readDoubleLE = r ? a : s, t.readDoubleBE = r ? s : a;\n                }() : function() {\n                    function e(t, e, n, r, i, o) {\n                        var a = r < 0 ? 1 : 0;\n                        if (a && (r = -r), 0 === r) t(0, i, o + e), t(1 / r > 0 ? 0 : 2147483648, i, o + n);\n                        else if (isNaN(r)) t(0, i, o + e), t(2146959360, i, o + n);\n                        else if (r > 17976931348623157e292) t(0, i, o + e), t((a << 31 | 2146435072) >>> 0, i, o + n);\n                        else {\n                            var s;\n                            if (r < 22250738585072014e-324) t((s = r / 5e-324) >>> 0, i, o + e), t((a << 31 | s / 4294967296) >>> 0, i, o + n);\n                            else {\n                                var u = Math.floor(Math.log(r) / Math.LN2);\n                                1024 === u && (u = 1023), t(4503599627370496 * (s = r * Math.pow(2, -u)) >>> 0, i, o + e), t((a << 31 | u + 1023 << 20 | 1048576 * s & 1048575) >>> 0, i, o + n);\n                            }\n                        }\n                    }\n                    function a(t, e, n, r, i) {\n                        var o = t(r, i + e), a = t(r, i + n), s = 2 * (a >> 31) + 1, u = a >>> 20 & 2047, c = 4294967296 * (1048575 & a) + o;\n                        return 2047 === u ? c ? NaN : s * (1 / 0) : 0 === u ? 5e-324 * s * c : s * Math.pow(2, u - 1075) * (c + 4503599627370496);\n                    }\n                    t.writeDoubleLE = e.bind(null, n, 0, 4), t.writeDoubleBE = e.bind(null, r, 4, 0), t.readDoubleLE = a.bind(null, i, 0, 4), t.readDoubleBE = a.bind(null, o, 4, 0);\n                }(), t;\n            }\n            function n(t, e, n) {\n                e[n] = 255 & t, e[n + 1] = t >>> 8 & 255, e[n + 2] = t >>> 16 & 255, e[n + 3] = t >>> 24;\n            }\n            function r(t, e, n) {\n                e[n] = t >>> 24, e[n + 1] = t >>> 16 & 255, e[n + 2] = t >>> 8 & 255, e[n + 3] = 255 & t;\n            }\n            function i(t, e) {\n                return (t[e] | t[e + 1] << 8 | t[e + 2] << 16 | t[e + 3] << 24) >>> 0;\n            }\n            function o(t, e) {\n                return (t[e] << 24 | t[e + 1] << 16 | t[e + 2] << 8 | t[e + 3]) >>> 0;\n            }\n            t.exports = e(e);\n        },\n        7199: (module)=>{\n            \"use strict\";\n            function inquire(moduleName) {\n                try {\n                    var mod = eval(\"quire\".replace(/^/, \"re\"))(moduleName);\n                    if (mod && (mod.length || Object.keys(mod).length)) return mod;\n                } catch (t) {}\n                return null;\n            }\n            module.exports = inquire;\n        },\n        6662: (t)=>{\n            \"use strict\";\n            t.exports = function(t, e, n) {\n                var r = n || 8192, i = r >>> 1, o = null, a = r;\n                return function(n) {\n                    if (n < 1 || n > i) return t(n);\n                    a + n > r && (o = t(r), a = 0);\n                    var s = e.call(o, a, a += n);\n                    return 7 & a && (a = 1 + (7 | a)), s;\n                };\n            };\n        },\n        4997: (t, e)=>{\n            \"use strict\";\n            var n = e;\n            n.length = function(t) {\n                for(var e = 0, n = 0, r = 0; r < t.length; ++r)(n = t.charCodeAt(r)) < 128 ? e += 1 : n < 2048 ? e += 2 : 55296 == (64512 & n) && 56320 == (64512 & t.charCodeAt(r + 1)) ? (++r, e += 4) : e += 3;\n                return e;\n            }, n.read = function(t, e, n) {\n                if (n - e < 1) return \"\";\n                for(var r, i = null, o = [], a = 0; e < n;)(r = t[e++]) < 128 ? o[a++] = r : r > 191 && r < 224 ? o[a++] = (31 & r) << 6 | 63 & t[e++] : r > 239 && r < 365 ? (r = ((7 & r) << 18 | (63 & t[e++]) << 12 | (63 & t[e++]) << 6 | 63 & t[e++]) - 65536, o[a++] = 55296 + (r >> 10), o[a++] = 56320 + (1023 & r)) : o[a++] = (15 & r) << 12 | (63 & t[e++]) << 6 | 63 & t[e++], a > 8191 && ((i || (i = [])).push(String.fromCharCode.apply(String, o)), a = 0);\n                return i ? (a && i.push(String.fromCharCode.apply(String, o.slice(0, a))), i.join(\"\")) : String.fromCharCode.apply(String, o.slice(0, a));\n            }, n.write = function(t, e, n) {\n                for(var r, i, o = n, a = 0; a < t.length; ++a)(r = t.charCodeAt(a)) < 128 ? e[n++] = r : r < 2048 ? (e[n++] = r >> 6 | 192, e[n++] = 63 & r | 128) : 55296 == (64512 & r) && 56320 == (64512 & (i = t.charCodeAt(a + 1))) ? (r = 65536 + ((1023 & r) << 10) + (1023 & i), ++a, e[n++] = r >> 18 | 240, e[n++] = r >> 12 & 63 | 128, e[n++] = r >> 6 & 63 | 128, e[n++] = 63 & r | 128) : (e[n++] = r >> 12 | 224, e[n++] = r >> 6 & 63 | 128, e[n++] = 63 & r | 128);\n                return n - o;\n            };\n        },\n        3442: (t, e)=>{\n            \"use strict\";\n            e.__esModule = !0;\n            var n = function() {\n                function t(e) {\n                    if (!e) throw new TypeError(\"Invalid argument; `value` has no value.\");\n                    this.value = t.EMPTY, e && t.isGuid(e) && (this.value = e);\n                }\n                return t.isGuid = function(e) {\n                    var n = e.toString();\n                    return e && (e instanceof t || t.validator.test(n));\n                }, t.create = function() {\n                    return new t([\n                        t.gen(2),\n                        t.gen(1),\n                        t.gen(1),\n                        t.gen(1),\n                        t.gen(3)\n                    ].join(\"-\"));\n                }, t.createEmpty = function() {\n                    return new t(\"emptyguid\");\n                }, t.parse = function(e) {\n                    return new t(e);\n                }, t.raw = function() {\n                    return [\n                        t.gen(2),\n                        t.gen(1),\n                        t.gen(1),\n                        t.gen(1),\n                        t.gen(3)\n                    ].join(\"-\");\n                }, t.gen = function(t) {\n                    for(var e = \"\", n = 0; n < t; n++)e += (65536 * (1 + Math.random()) | 0).toString(16).substring(1);\n                    return e;\n                }, t.prototype.equals = function(e) {\n                    return t.isGuid(e) && this.value === e.toString();\n                }, t.prototype.isEmpty = function() {\n                    return this.value === t.EMPTY;\n                }, t.prototype.toString = function() {\n                    return this.value;\n                }, t.prototype.toJSON = function() {\n                    return {\n                        value: this.value\n                    };\n                }, t.validator = new RegExp(\"^[a-z0-9]{8}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{12}$\", \"i\"), t.EMPTY = \"00000000-0000-0000-0000-000000000000\", t;\n            }();\n            e.Guid = n;\n        },\n        3720: (t)=>{\n            t.exports = n;\n            var e = null;\n            try {\n                e = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([\n                    0,\n                    97,\n                    115,\n                    109,\n                    1,\n                    0,\n                    0,\n                    0,\n                    1,\n                    13,\n                    2,\n                    96,\n                    0,\n                    1,\n                    127,\n                    96,\n                    4,\n                    127,\n                    127,\n                    127,\n                    127,\n                    1,\n                    127,\n                    3,\n                    7,\n                    6,\n                    0,\n                    1,\n                    1,\n                    1,\n                    1,\n                    1,\n                    6,\n                    6,\n                    1,\n                    127,\n                    1,\n                    65,\n                    0,\n                    11,\n                    7,\n                    50,\n                    6,\n                    3,\n                    109,\n                    117,\n                    108,\n                    0,\n                    1,\n                    5,\n                    100,\n                    105,\n                    118,\n                    95,\n                    115,\n                    0,\n                    2,\n                    5,\n                    100,\n                    105,\n                    118,\n                    95,\n                    117,\n                    0,\n                    3,\n                    5,\n                    114,\n                    101,\n                    109,\n                    95,\n                    115,\n                    0,\n                    4,\n                    5,\n                    114,\n                    101,\n                    109,\n                    95,\n                    117,\n                    0,\n                    5,\n                    8,\n                    103,\n                    101,\n                    116,\n                    95,\n                    104,\n                    105,\n                    103,\n                    104,\n                    0,\n                    0,\n                    10,\n                    191,\n                    1,\n                    6,\n                    4,\n                    0,\n                    35,\n                    0,\n                    11,\n                    36,\n                    1,\n                    1,\n                    126,\n                    32,\n                    0,\n                    173,\n                    32,\n                    1,\n                    173,\n                    66,\n                    32,\n                    134,\n                    132,\n                    32,\n                    2,\n                    173,\n                    32,\n                    3,\n                    173,\n                    66,\n                    32,\n                    134,\n                    132,\n                    126,\n                    34,\n                    4,\n                    66,\n                    32,\n                    135,\n                    167,\n                    36,\n                    0,\n                    32,\n                    4,\n                    167,\n                    11,\n                    36,\n                    1,\n                    1,\n                    126,\n                    32,\n                    0,\n                    173,\n                    32,\n                    1,\n                    173,\n                    66,\n                    32,\n                    134,\n                    132,\n                    32,\n                    2,\n                    173,\n                    32,\n                    3,\n                    173,\n                    66,\n                    32,\n                    134,\n                    132,\n                    127,\n                    34,\n                    4,\n                    66,\n                    32,\n                    135,\n                    167,\n                    36,\n                    0,\n                    32,\n                    4,\n                    167,\n                    11,\n                    36,\n                    1,\n                    1,\n                    126,\n                    32,\n                    0,\n                    173,\n                    32,\n                    1,\n                    173,\n                    66,\n                    32,\n                    134,\n                    132,\n                    32,\n                    2,\n                    173,\n                    32,\n                    3,\n                    173,\n                    66,\n                    32,\n                    134,\n                    132,\n                    128,\n                    34,\n                    4,\n                    66,\n                    32,\n                    135,\n                    167,\n                    36,\n                    0,\n                    32,\n                    4,\n                    167,\n                    11,\n                    36,\n                    1,\n                    1,\n                    126,\n                    32,\n                    0,\n                    173,\n                    32,\n                    1,\n                    173,\n                    66,\n                    32,\n                    134,\n                    132,\n                    32,\n                    2,\n                    173,\n                    32,\n                    3,\n                    173,\n                    66,\n                    32,\n                    134,\n                    132,\n                    129,\n                    34,\n                    4,\n                    66,\n                    32,\n                    135,\n                    167,\n                    36,\n                    0,\n                    32,\n                    4,\n                    167,\n                    11,\n                    36,\n                    1,\n                    1,\n                    126,\n                    32,\n                    0,\n                    173,\n                    32,\n                    1,\n                    173,\n                    66,\n                    32,\n                    134,\n                    132,\n                    32,\n                    2,\n                    173,\n                    32,\n                    3,\n                    173,\n                    66,\n                    32,\n                    134,\n                    132,\n                    130,\n                    34,\n                    4,\n                    66,\n                    32,\n                    135,\n                    167,\n                    36,\n                    0,\n                    32,\n                    4,\n                    167,\n                    11\n                ])), {}).exports;\n            } catch (t) {}\n            function n(t, e, n) {\n                this.low = 0 | t, this.high = 0 | e, this.unsigned = !!n;\n            }\n            function r(t) {\n                return !0 === (t && t.__isLong__);\n            }\n            n.prototype.__isLong__, Object.defineProperty(n.prototype, \"__isLong__\", {\n                value: !0\n            }), n.isLong = r;\n            var i = {}, o = {};\n            function a(t, e) {\n                var n, r, a;\n                return e ? (a = 0 <= (t >>>= 0) && t < 256) && (r = o[t]) ? r : (n = u(t, (0 | t) < 0 ? -1 : 0, !0), a && (o[t] = n), n) : (a = -128 <= (t |= 0) && t < 128) && (r = i[t]) ? r : (n = u(t, t < 0 ? -1 : 0, !1), a && (i[t] = n), n);\n            }\n            function s(t, e) {\n                if (isNaN(t)) return e ? m : b;\n                if (e) {\n                    if (t < 0) return m;\n                    if (t >= d) return x;\n                } else {\n                    if (t <= -h) return T;\n                    if (t + 1 >= h) return w;\n                }\n                return t < 0 ? s(-t, e).neg() : u(t % f | 0, t / f | 0, e);\n            }\n            function u(t, e, r) {\n                return new n(t, e, r);\n            }\n            n.fromInt = a, n.fromNumber = s, n.fromBits = u;\n            var c = Math.pow;\n            function l(t, e, n) {\n                if (0 === t.length) throw Error(\"empty string\");\n                if (\"NaN\" === t || \"Infinity\" === t || \"+Infinity\" === t || \"-Infinity\" === t) return b;\n                if (\"number\" == typeof e ? (n = e, e = !1) : e = !!e, (n = n || 10) < 2 || 36 < n) throw RangeError(\"radix\");\n                var r;\n                if ((r = t.indexOf(\"-\")) > 0) throw Error(\"interior hyphen\");\n                if (0 === r) return l(t.substring(1), e, n).neg();\n                for(var i = s(c(n, 8)), o = b, a = 0; a < t.length; a += 8){\n                    var u = Math.min(8, t.length - a), p = parseInt(t.substring(a, a + u), n);\n                    if (u < 8) {\n                        var f = s(c(n, u));\n                        o = o.mul(f).add(s(p));\n                    } else o = (o = o.mul(i)).add(s(p));\n                }\n                return o.unsigned = e, o;\n            }\n            function p(t, e) {\n                return \"number\" == typeof t ? s(t, e) : \"string\" == typeof t ? l(t, e) : u(t.low, t.high, \"boolean\" == typeof e ? e : t.unsigned);\n            }\n            n.fromString = l, n.fromValue = p;\n            var f = 4294967296, d = f * f, h = d / 2, g = a(1 << 24), b = a(0);\n            n.ZERO = b;\n            var m = a(0, !0);\n            n.UZERO = m;\n            var y = a(1);\n            n.ONE = y;\n            var _ = a(1, !0);\n            n.UONE = _;\n            var v = a(-1);\n            n.NEG_ONE = v;\n            var w = u(-1, 2147483647, !1);\n            n.MAX_VALUE = w;\n            var x = u(-1, -1, !0);\n            n.MAX_UNSIGNED_VALUE = x;\n            var T = u(0, -2147483648, !1);\n            n.MIN_VALUE = T;\n            var S = n.prototype;\n            S.toInt = function() {\n                return this.unsigned ? this.low >>> 0 : this.low;\n            }, S.toNumber = function() {\n                return this.unsigned ? (this.high >>> 0) * f + (this.low >>> 0) : this.high * f + (this.low >>> 0);\n            }, S.toString = function(t) {\n                if ((t = t || 10) < 2 || 36 < t) throw RangeError(\"radix\");\n                if (this.isZero()) return \"0\";\n                if (this.isNegative()) {\n                    if (this.eq(T)) {\n                        var e = s(t), n = this.div(e), r = n.mul(e).sub(this);\n                        return n.toString(t) + r.toInt().toString(t);\n                    }\n                    return \"-\" + this.neg().toString(t);\n                }\n                for(var i = s(c(t, 6), this.unsigned), o = this, a = \"\";;){\n                    var u = o.div(i), l = (o.sub(u.mul(i)).toInt() >>> 0).toString(t);\n                    if ((o = u).isZero()) return l + a;\n                    for(; l.length < 6;)l = \"0\" + l;\n                    a = \"\" + l + a;\n                }\n            }, S.getHighBits = function() {\n                return this.high;\n            }, S.getHighBitsUnsigned = function() {\n                return this.high >>> 0;\n            }, S.getLowBits = function() {\n                return this.low;\n            }, S.getLowBitsUnsigned = function() {\n                return this.low >>> 0;\n            }, S.getNumBitsAbs = function() {\n                if (this.isNegative()) return this.eq(T) ? 64 : this.neg().getNumBitsAbs();\n                for(var t = 0 != this.high ? this.high : this.low, e = 31; e > 0 && 0 == (t & 1 << e); e--);\n                return 0 != this.high ? e + 33 : e + 1;\n            }, S.isZero = function() {\n                return 0 === this.high && 0 === this.low;\n            }, S.eqz = S.isZero, S.isNegative = function() {\n                return !this.unsigned && this.high < 0;\n            }, S.isPositive = function() {\n                return this.unsigned || this.high >= 0;\n            }, S.isOdd = function() {\n                return 1 == (1 & this.low);\n            }, S.isEven = function() {\n                return 0 == (1 & this.low);\n            }, S.equals = function(t) {\n                return r(t) || (t = p(t)), (this.unsigned === t.unsigned || this.high >>> 31 != 1 || t.high >>> 31 != 1) && this.high === t.high && this.low === t.low;\n            }, S.eq = S.equals, S.notEquals = function(t) {\n                return !this.eq(t);\n            }, S.neq = S.notEquals, S.ne = S.notEquals, S.lessThan = function(t) {\n                return this.comp(t) < 0;\n            }, S.lt = S.lessThan, S.lessThanOrEqual = function(t) {\n                return this.comp(t) <= 0;\n            }, S.lte = S.lessThanOrEqual, S.le = S.lessThanOrEqual, S.greaterThan = function(t) {\n                return this.comp(t) > 0;\n            }, S.gt = S.greaterThan, S.greaterThanOrEqual = function(t) {\n                return this.comp(t) >= 0;\n            }, S.gte = S.greaterThanOrEqual, S.ge = S.greaterThanOrEqual, S.compare = function(t) {\n                if (r(t) || (t = p(t)), this.eq(t)) return 0;\n                var e = this.isNegative(), n = t.isNegative();\n                return e && !n ? -1 : !e && n ? 1 : this.unsigned ? t.high >>> 0 > this.high >>> 0 || t.high === this.high && t.low >>> 0 > this.low >>> 0 ? -1 : 1 : this.sub(t).isNegative() ? -1 : 1;\n            }, S.comp = S.compare, S.negate = function() {\n                return !this.unsigned && this.eq(T) ? T : this.not().add(y);\n            }, S.neg = S.negate, S.add = function(t) {\n                r(t) || (t = p(t));\n                var e = this.high >>> 16, n = 65535 & this.high, i = this.low >>> 16, o = 65535 & this.low, a = t.high >>> 16, s = 65535 & t.high, c = t.low >>> 16, l = 0, f = 0, d = 0, h = 0;\n                return d += (h += o + (65535 & t.low)) >>> 16, f += (d += i + c) >>> 16, l += (f += n + s) >>> 16, l += e + a, u((d &= 65535) << 16 | (h &= 65535), (l &= 65535) << 16 | (f &= 65535), this.unsigned);\n            }, S.subtract = function(t) {\n                return r(t) || (t = p(t)), this.add(t.neg());\n            }, S.sub = S.subtract, S.multiply = function(t) {\n                if (this.isZero()) return b;\n                if (r(t) || (t = p(t)), e) return u(e.mul(this.low, this.high, t.low, t.high), e.get_high(), this.unsigned);\n                if (t.isZero()) return b;\n                if (this.eq(T)) return t.isOdd() ? T : b;\n                if (t.eq(T)) return this.isOdd() ? T : b;\n                if (this.isNegative()) return t.isNegative() ? this.neg().mul(t.neg()) : this.neg().mul(t).neg();\n                if (t.isNegative()) return this.mul(t.neg()).neg();\n                if (this.lt(g) && t.lt(g)) return s(this.toNumber() * t.toNumber(), this.unsigned);\n                var n = this.high >>> 16, i = 65535 & this.high, o = this.low >>> 16, a = 65535 & this.low, c = t.high >>> 16, l = 65535 & t.high, f = t.low >>> 16, d = 65535 & t.low, h = 0, m = 0, y = 0, _ = 0;\n                return y += (_ += a * d) >>> 16, m += (y += o * d) >>> 16, y &= 65535, m += (y += a * f) >>> 16, h += (m += i * d) >>> 16, m &= 65535, h += (m += o * f) >>> 16, m &= 65535, h += (m += a * l) >>> 16, h += n * d + i * f + o * l + a * c, u((y &= 65535) << 16 | (_ &= 65535), (h &= 65535) << 16 | (m &= 65535), this.unsigned);\n            }, S.mul = S.multiply, S.divide = function(t) {\n                if (r(t) || (t = p(t)), t.isZero()) throw Error(\"division by zero\");\n                var n, i, o;\n                if (e) return this.unsigned || -2147483648 !== this.high || -1 !== t.low || -1 !== t.high ? u((this.unsigned ? e.div_u : e.div_s)(this.low, this.high, t.low, t.high), e.get_high(), this.unsigned) : this;\n                if (this.isZero()) return this.unsigned ? m : b;\n                if (this.unsigned) {\n                    if (t.unsigned || (t = t.toUnsigned()), t.gt(this)) return m;\n                    if (t.gt(this.shru(1))) return _;\n                    o = m;\n                } else {\n                    if (this.eq(T)) return t.eq(y) || t.eq(v) ? T : t.eq(T) ? y : (n = this.shr(1).div(t).shl(1)).eq(b) ? t.isNegative() ? y : v : (i = this.sub(t.mul(n)), o = n.add(i.div(t)));\n                    if (t.eq(T)) return this.unsigned ? m : b;\n                    if (this.isNegative()) return t.isNegative() ? this.neg().div(t.neg()) : this.neg().div(t).neg();\n                    if (t.isNegative()) return this.div(t.neg()).neg();\n                    o = b;\n                }\n                for(i = this; i.gte(t);){\n                    n = Math.max(1, Math.floor(i.toNumber() / t.toNumber()));\n                    for(var a = Math.ceil(Math.log(n) / Math.LN2), l = a <= 48 ? 1 : c(2, a - 48), f = s(n), d = f.mul(t); d.isNegative() || d.gt(i);)d = (f = s(n -= l, this.unsigned)).mul(t);\n                    f.isZero() && (f = y), o = o.add(f), i = i.sub(d);\n                }\n                return o;\n            }, S.div = S.divide, S.modulo = function(t) {\n                return r(t) || (t = p(t)), e ? u((this.unsigned ? e.rem_u : e.rem_s)(this.low, this.high, t.low, t.high), e.get_high(), this.unsigned) : this.sub(this.div(t).mul(t));\n            }, S.mod = S.modulo, S.rem = S.modulo, S.not = function() {\n                return u(~this.low, ~this.high, this.unsigned);\n            }, S.and = function(t) {\n                return r(t) || (t = p(t)), u(this.low & t.low, this.high & t.high, this.unsigned);\n            }, S.or = function(t) {\n                return r(t) || (t = p(t)), u(this.low | t.low, this.high | t.high, this.unsigned);\n            }, S.xor = function(t) {\n                return r(t) || (t = p(t)), u(this.low ^ t.low, this.high ^ t.high, this.unsigned);\n            }, S.shiftLeft = function(t) {\n                return r(t) && (t = t.toInt()), 0 == (t &= 63) ? this : t < 32 ? u(this.low << t, this.high << t | this.low >>> 32 - t, this.unsigned) : u(0, this.low << t - 32, this.unsigned);\n            }, S.shl = S.shiftLeft, S.shiftRight = function(t) {\n                return r(t) && (t = t.toInt()), 0 == (t &= 63) ? this : t < 32 ? u(this.low >>> t | this.high << 32 - t, this.high >> t, this.unsigned) : u(this.high >> t - 32, this.high >= 0 ? 0 : -1, this.unsigned);\n            }, S.shr = S.shiftRight, S.shiftRightUnsigned = function(t) {\n                if (r(t) && (t = t.toInt()), 0 == (t &= 63)) return this;\n                var e = this.high;\n                return t < 32 ? u(this.low >>> t | e << 32 - t, e >>> t, this.unsigned) : u(32 === t ? e : e >>> t - 32, 0, this.unsigned);\n            }, S.shru = S.shiftRightUnsigned, S.shr_u = S.shiftRightUnsigned, S.toSigned = function() {\n                return this.unsigned ? u(this.low, this.high, !1) : this;\n            }, S.toUnsigned = function() {\n                return this.unsigned ? this : u(this.low, this.high, !0);\n            }, S.toBytes = function(t) {\n                return t ? this.toBytesLE() : this.toBytesBE();\n            }, S.toBytesLE = function() {\n                var t = this.high, e = this.low;\n                return [\n                    255 & e,\n                    e >>> 8 & 255,\n                    e >>> 16 & 255,\n                    e >>> 24,\n                    255 & t,\n                    t >>> 8 & 255,\n                    t >>> 16 & 255,\n                    t >>> 24\n                ];\n            }, S.toBytesBE = function() {\n                var t = this.high, e = this.low;\n                return [\n                    t >>> 24,\n                    t >>> 16 & 255,\n                    t >>> 8 & 255,\n                    255 & t,\n                    e >>> 24,\n                    e >>> 16 & 255,\n                    e >>> 8 & 255,\n                    255 & e\n                ];\n            }, n.fromBytes = function(t, e, r) {\n                return r ? n.fromBytesLE(t, e) : n.fromBytesBE(t, e);\n            }, n.fromBytesLE = function(t, e) {\n                return new n(t[0] | t[1] << 8 | t[2] << 16 | t[3] << 24, t[4] | t[5] << 8 | t[6] << 16 | t[7] << 24, e);\n            }, n.fromBytesBE = function(t, e) {\n                return new n(t[4] << 24 | t[5] << 16 | t[6] << 8 | t[7], t[0] << 24 | t[1] << 16 | t[2] << 8 | t[3], e);\n            };\n        },\n        1446: (t, e, n)=>{\n            \"use strict\";\n            var r, i, o, a = n(2100), s = a.Reader, u = a.Writer, c = a.util, l = a.roots.default || (a.roots.default = {});\n            l.onnx = ((o = {}).Version = (r = {}, (i = Object.create(r))[r[0] = \"_START_VERSION\"] = 0, i[r[1] = \"IR_VERSION_2017_10_10\"] = 1, i[r[2] = \"IR_VERSION_2017_10_30\"] = 2, i[r[3] = \"IR_VERSION_2017_11_3\"] = 3, i[r[4] = \"IR_VERSION_2019_1_22\"] = 4, i[r[5] = \"IR_VERSION\"] = 5, i), o.AttributeProto = function() {\n                function t(t) {\n                    if (this.floats = [], this.ints = [], this.strings = [], this.tensors = [], this.graphs = [], t) for(var e = Object.keys(t), n = 0; n < e.length; ++n)null != t[e[n]] && (this[e[n]] = t[e[n]]);\n                }\n                return t.prototype.name = \"\", t.prototype.refAttrName = \"\", t.prototype.docString = \"\", t.prototype.type = 0, t.prototype.f = 0, t.prototype.i = c.Long ? c.Long.fromBits(0, 0, !1) : 0, t.prototype.s = c.newBuffer([]), t.prototype.t = null, t.prototype.g = null, t.prototype.floats = c.emptyArray, t.prototype.ints = c.emptyArray, t.prototype.strings = c.emptyArray, t.prototype.tensors = c.emptyArray, t.prototype.graphs = c.emptyArray, t.create = function(e) {\n                    return new t(e);\n                }, t.encode = function(t, e) {\n                    if (e || (e = u.create()), null != t.name && t.hasOwnProperty(\"name\") && e.uint32(10).string(t.name), null != t.f && t.hasOwnProperty(\"f\") && e.uint32(21).float(t.f), null != t.i && t.hasOwnProperty(\"i\") && e.uint32(24).int64(t.i), null != t.s && t.hasOwnProperty(\"s\") && e.uint32(34).bytes(t.s), null != t.t && t.hasOwnProperty(\"t\") && l.onnx.TensorProto.encode(t.t, e.uint32(42).fork()).ldelim(), null != t.g && t.hasOwnProperty(\"g\") && l.onnx.GraphProto.encode(t.g, e.uint32(50).fork()).ldelim(), null != t.floats && t.floats.length) {\n                        e.uint32(58).fork();\n                        for(var n = 0; n < t.floats.length; ++n)e.float(t.floats[n]);\n                        e.ldelim();\n                    }\n                    if (null != t.ints && t.ints.length) {\n                        for(e.uint32(66).fork(), n = 0; n < t.ints.length; ++n)e.int64(t.ints[n]);\n                        e.ldelim();\n                    }\n                    if (null != t.strings && t.strings.length) for(n = 0; n < t.strings.length; ++n)e.uint32(74).bytes(t.strings[n]);\n                    if (null != t.tensors && t.tensors.length) for(n = 0; n < t.tensors.length; ++n)l.onnx.TensorProto.encode(t.tensors[n], e.uint32(82).fork()).ldelim();\n                    if (null != t.graphs && t.graphs.length) for(n = 0; n < t.graphs.length; ++n)l.onnx.GraphProto.encode(t.graphs[n], e.uint32(90).fork()).ldelim();\n                    return null != t.docString && t.hasOwnProperty(\"docString\") && e.uint32(106).string(t.docString), null != t.type && t.hasOwnProperty(\"type\") && e.uint32(160).int32(t.type), null != t.refAttrName && t.hasOwnProperty(\"refAttrName\") && e.uint32(170).string(t.refAttrName), e;\n                }, t.encodeDelimited = function(t, e) {\n                    return this.encode(t, e).ldelim();\n                }, t.decode = function(t, e) {\n                    t instanceof s || (t = s.create(t));\n                    for(var n = void 0 === e ? t.len : t.pos + e, r = new l.onnx.AttributeProto; t.pos < n;){\n                        var i = t.uint32();\n                        switch(i >>> 3){\n                            case 1:\n                                r.name = t.string();\n                                break;\n                            case 21:\n                                r.refAttrName = t.string();\n                                break;\n                            case 13:\n                                r.docString = t.string();\n                                break;\n                            case 20:\n                                r.type = t.int32();\n                                break;\n                            case 2:\n                                r.f = t.float();\n                                break;\n                            case 3:\n                                r.i = t.int64();\n                                break;\n                            case 4:\n                                r.s = t.bytes();\n                                break;\n                            case 5:\n                                r.t = l.onnx.TensorProto.decode(t, t.uint32());\n                                break;\n                            case 6:\n                                r.g = l.onnx.GraphProto.decode(t, t.uint32());\n                                break;\n                            case 7:\n                                if (r.floats && r.floats.length || (r.floats = []), 2 == (7 & i)) for(var o = t.uint32() + t.pos; t.pos < o;)r.floats.push(t.float());\n                                else r.floats.push(t.float());\n                                break;\n                            case 8:\n                                if (r.ints && r.ints.length || (r.ints = []), 2 == (7 & i)) for(o = t.uint32() + t.pos; t.pos < o;)r.ints.push(t.int64());\n                                else r.ints.push(t.int64());\n                                break;\n                            case 9:\n                                r.strings && r.strings.length || (r.strings = []), r.strings.push(t.bytes());\n                                break;\n                            case 10:\n                                r.tensors && r.tensors.length || (r.tensors = []), r.tensors.push(l.onnx.TensorProto.decode(t, t.uint32()));\n                                break;\n                            case 11:\n                                r.graphs && r.graphs.length || (r.graphs = []), r.graphs.push(l.onnx.GraphProto.decode(t, t.uint32()));\n                                break;\n                            default:\n                                t.skipType(7 & i);\n                        }\n                    }\n                    return r;\n                }, t.decodeDelimited = function(t) {\n                    return t instanceof s || (t = new s(t)), this.decode(t, t.uint32());\n                }, t.verify = function(t) {\n                    if (\"object\" != typeof t || null === t) return \"object expected\";\n                    if (null != t.name && t.hasOwnProperty(\"name\") && !c.isString(t.name)) return \"name: string expected\";\n                    if (null != t.refAttrName && t.hasOwnProperty(\"refAttrName\") && !c.isString(t.refAttrName)) return \"refAttrName: string expected\";\n                    if (null != t.docString && t.hasOwnProperty(\"docString\") && !c.isString(t.docString)) return \"docString: string expected\";\n                    if (null != t.type && t.hasOwnProperty(\"type\")) switch(t.type){\n                        default:\n                            return \"type: enum value expected\";\n                        case 0:\n                        case 1:\n                        case 2:\n                        case 3:\n                        case 4:\n                        case 5:\n                        case 6:\n                        case 7:\n                        case 8:\n                        case 9:\n                        case 10:\n                    }\n                    if (null != t.f && t.hasOwnProperty(\"f\") && \"number\" != typeof t.f) return \"f: number expected\";\n                    if (null != t.i && t.hasOwnProperty(\"i\") && !(c.isInteger(t.i) || t.i && c.isInteger(t.i.low) && c.isInteger(t.i.high))) return \"i: integer|Long expected\";\n                    if (null != t.s && t.hasOwnProperty(\"s\") && !(t.s && \"number\" == typeof t.s.length || c.isString(t.s))) return \"s: buffer expected\";\n                    if (null != t.t && t.hasOwnProperty(\"t\") && (n = l.onnx.TensorProto.verify(t.t))) return \"t.\" + n;\n                    if (null != t.g && t.hasOwnProperty(\"g\") && (n = l.onnx.GraphProto.verify(t.g))) return \"g.\" + n;\n                    if (null != t.floats && t.hasOwnProperty(\"floats\")) {\n                        if (!Array.isArray(t.floats)) return \"floats: array expected\";\n                        for(var e = 0; e < t.floats.length; ++e)if (\"number\" != typeof t.floats[e]) return \"floats: number[] expected\";\n                    }\n                    if (null != t.ints && t.hasOwnProperty(\"ints\")) {\n                        if (!Array.isArray(t.ints)) return \"ints: array expected\";\n                        for(e = 0; e < t.ints.length; ++e)if (!(c.isInteger(t.ints[e]) || t.ints[e] && c.isInteger(t.ints[e].low) && c.isInteger(t.ints[e].high))) return \"ints: integer|Long[] expected\";\n                    }\n                    if (null != t.strings && t.hasOwnProperty(\"strings\")) {\n                        if (!Array.isArray(t.strings)) return \"strings: array expected\";\n                        for(e = 0; e < t.strings.length; ++e)if (!(t.strings[e] && \"number\" == typeof t.strings[e].length || c.isString(t.strings[e]))) return \"strings: buffer[] expected\";\n                    }\n                    if (null != t.tensors && t.hasOwnProperty(\"tensors\")) {\n                        if (!Array.isArray(t.tensors)) return \"tensors: array expected\";\n                        for(e = 0; e < t.tensors.length; ++e)if (n = l.onnx.TensorProto.verify(t.tensors[e])) return \"tensors.\" + n;\n                    }\n                    if (null != t.graphs && t.hasOwnProperty(\"graphs\")) {\n                        if (!Array.isArray(t.graphs)) return \"graphs: array expected\";\n                        for(e = 0; e < t.graphs.length; ++e){\n                            var n;\n                            if (n = l.onnx.GraphProto.verify(t.graphs[e])) return \"graphs.\" + n;\n                        }\n                    }\n                    return null;\n                }, t.fromObject = function(t) {\n                    if (t instanceof l.onnx.AttributeProto) return t;\n                    var e = new l.onnx.AttributeProto;\n                    switch(null != t.name && (e.name = String(t.name)), null != t.refAttrName && (e.refAttrName = String(t.refAttrName)), null != t.docString && (e.docString = String(t.docString)), t.type){\n                        case \"UNDEFINED\":\n                        case 0:\n                            e.type = 0;\n                            break;\n                        case \"FLOAT\":\n                        case 1:\n                            e.type = 1;\n                            break;\n                        case \"INT\":\n                        case 2:\n                            e.type = 2;\n                            break;\n                        case \"STRING\":\n                        case 3:\n                            e.type = 3;\n                            break;\n                        case \"TENSOR\":\n                        case 4:\n                            e.type = 4;\n                            break;\n                        case \"GRAPH\":\n                        case 5:\n                            e.type = 5;\n                            break;\n                        case \"FLOATS\":\n                        case 6:\n                            e.type = 6;\n                            break;\n                        case \"INTS\":\n                        case 7:\n                            e.type = 7;\n                            break;\n                        case \"STRINGS\":\n                        case 8:\n                            e.type = 8;\n                            break;\n                        case \"TENSORS\":\n                        case 9:\n                            e.type = 9;\n                            break;\n                        case \"GRAPHS\":\n                        case 10:\n                            e.type = 10;\n                    }\n                    if (null != t.f && (e.f = Number(t.f)), null != t.i && (c.Long ? (e.i = c.Long.fromValue(t.i)).unsigned = !1 : \"string\" == typeof t.i ? e.i = parseInt(t.i, 10) : \"number\" == typeof t.i ? e.i = t.i : \"object\" == typeof t.i && (e.i = new c.LongBits(t.i.low >>> 0, t.i.high >>> 0).toNumber())), null != t.s && (\"string\" == typeof t.s ? c.base64.decode(t.s, e.s = c.newBuffer(c.base64.length(t.s)), 0) : t.s.length && (e.s = t.s)), null != t.t) {\n                        if (\"object\" != typeof t.t) throw TypeError(\".onnx.AttributeProto.t: object expected\");\n                        e.t = l.onnx.TensorProto.fromObject(t.t);\n                    }\n                    if (null != t.g) {\n                        if (\"object\" != typeof t.g) throw TypeError(\".onnx.AttributeProto.g: object expected\");\n                        e.g = l.onnx.GraphProto.fromObject(t.g);\n                    }\n                    if (t.floats) {\n                        if (!Array.isArray(t.floats)) throw TypeError(\".onnx.AttributeProto.floats: array expected\");\n                        e.floats = [];\n                        for(var n = 0; n < t.floats.length; ++n)e.floats[n] = Number(t.floats[n]);\n                    }\n                    if (t.ints) {\n                        if (!Array.isArray(t.ints)) throw TypeError(\".onnx.AttributeProto.ints: array expected\");\n                        for(e.ints = [], n = 0; n < t.ints.length; ++n)c.Long ? (e.ints[n] = c.Long.fromValue(t.ints[n])).unsigned = !1 : \"string\" == typeof t.ints[n] ? e.ints[n] = parseInt(t.ints[n], 10) : \"number\" == typeof t.ints[n] ? e.ints[n] = t.ints[n] : \"object\" == typeof t.ints[n] && (e.ints[n] = new c.LongBits(t.ints[n].low >>> 0, t.ints[n].high >>> 0).toNumber());\n                    }\n                    if (t.strings) {\n                        if (!Array.isArray(t.strings)) throw TypeError(\".onnx.AttributeProto.strings: array expected\");\n                        for(e.strings = [], n = 0; n < t.strings.length; ++n)\"string\" == typeof t.strings[n] ? c.base64.decode(t.strings[n], e.strings[n] = c.newBuffer(c.base64.length(t.strings[n])), 0) : t.strings[n].length && (e.strings[n] = t.strings[n]);\n                    }\n                    if (t.tensors) {\n                        if (!Array.isArray(t.tensors)) throw TypeError(\".onnx.AttributeProto.tensors: array expected\");\n                        for(e.tensors = [], n = 0; n < t.tensors.length; ++n){\n                            if (\"object\" != typeof t.tensors[n]) throw TypeError(\".onnx.AttributeProto.tensors: object expected\");\n                            e.tensors[n] = l.onnx.TensorProto.fromObject(t.tensors[n]);\n                        }\n                    }\n                    if (t.graphs) {\n                        if (!Array.isArray(t.graphs)) throw TypeError(\".onnx.AttributeProto.graphs: array expected\");\n                        for(e.graphs = [], n = 0; n < t.graphs.length; ++n){\n                            if (\"object\" != typeof t.graphs[n]) throw TypeError(\".onnx.AttributeProto.graphs: object expected\");\n                            e.graphs[n] = l.onnx.GraphProto.fromObject(t.graphs[n]);\n                        }\n                    }\n                    return e;\n                }, t.toObject = function(t, e) {\n                    e || (e = {});\n                    var n = {};\n                    if ((e.arrays || e.defaults) && (n.floats = [], n.ints = [], n.strings = [], n.tensors = [], n.graphs = []), e.defaults) {\n                        if (n.name = \"\", n.f = 0, c.Long) {\n                            var r = new c.Long(0, 0, !1);\n                            n.i = e.longs === String ? r.toString() : e.longs === Number ? r.toNumber() : r;\n                        } else n.i = e.longs === String ? \"0\" : 0;\n                        e.bytes === String ? n.s = \"\" : (n.s = [], e.bytes !== Array && (n.s = c.newBuffer(n.s))), n.t = null, n.g = null, n.docString = \"\", n.type = e.enums === String ? \"UNDEFINED\" : 0, n.refAttrName = \"\";\n                    }\n                    if (null != t.name && t.hasOwnProperty(\"name\") && (n.name = t.name), null != t.f && t.hasOwnProperty(\"f\") && (n.f = e.json && !isFinite(t.f) ? String(t.f) : t.f), null != t.i && t.hasOwnProperty(\"i\") && (\"number\" == typeof t.i ? n.i = e.longs === String ? String(t.i) : t.i : n.i = e.longs === String ? c.Long.prototype.toString.call(t.i) : e.longs === Number ? new c.LongBits(t.i.low >>> 0, t.i.high >>> 0).toNumber() : t.i), null != t.s && t.hasOwnProperty(\"s\") && (n.s = e.bytes === String ? c.base64.encode(t.s, 0, t.s.length) : e.bytes === Array ? Array.prototype.slice.call(t.s) : t.s), null != t.t && t.hasOwnProperty(\"t\") && (n.t = l.onnx.TensorProto.toObject(t.t, e)), null != t.g && t.hasOwnProperty(\"g\") && (n.g = l.onnx.GraphProto.toObject(t.g, e)), t.floats && t.floats.length) {\n                        n.floats = [];\n                        for(var i = 0; i < t.floats.length; ++i)n.floats[i] = e.json && !isFinite(t.floats[i]) ? String(t.floats[i]) : t.floats[i];\n                    }\n                    if (t.ints && t.ints.length) for(n.ints = [], i = 0; i < t.ints.length; ++i)\"number\" == typeof t.ints[i] ? n.ints[i] = e.longs === String ? String(t.ints[i]) : t.ints[i] : n.ints[i] = e.longs === String ? c.Long.prototype.toString.call(t.ints[i]) : e.longs === Number ? new c.LongBits(t.ints[i].low >>> 0, t.ints[i].high >>> 0).toNumber() : t.ints[i];\n                    if (t.strings && t.strings.length) for(n.strings = [], i = 0; i < t.strings.length; ++i)n.strings[i] = e.bytes === String ? c.base64.encode(t.strings[i], 0, t.strings[i].length) : e.bytes === Array ? Array.prototype.slice.call(t.strings[i]) : t.strings[i];\n                    if (t.tensors && t.tensors.length) for(n.tensors = [], i = 0; i < t.tensors.length; ++i)n.tensors[i] = l.onnx.TensorProto.toObject(t.tensors[i], e);\n                    if (t.graphs && t.graphs.length) for(n.graphs = [], i = 0; i < t.graphs.length; ++i)n.graphs[i] = l.onnx.GraphProto.toObject(t.graphs[i], e);\n                    return null != t.docString && t.hasOwnProperty(\"docString\") && (n.docString = t.docString), null != t.type && t.hasOwnProperty(\"type\") && (n.type = e.enums === String ? l.onnx.AttributeProto.AttributeType[t.type] : t.type), null != t.refAttrName && t.hasOwnProperty(\"refAttrName\") && (n.refAttrName = t.refAttrName), n;\n                }, t.prototype.toJSON = function() {\n                    return this.constructor.toObject(this, a.util.toJSONOptions);\n                }, t.AttributeType = function() {\n                    var t = {}, e = Object.create(t);\n                    return e[t[0] = \"UNDEFINED\"] = 0, e[t[1] = \"FLOAT\"] = 1, e[t[2] = \"INT\"] = 2, e[t[3] = \"STRING\"] = 3, e[t[4] = \"TENSOR\"] = 4, e[t[5] = \"GRAPH\"] = 5, e[t[6] = \"FLOATS\"] = 6, e[t[7] = \"INTS\"] = 7, e[t[8] = \"STRINGS\"] = 8, e[t[9] = \"TENSORS\"] = 9, e[t[10] = \"GRAPHS\"] = 10, e;\n                }(), t;\n            }(), o.ValueInfoProto = function() {\n                function t(t) {\n                    if (t) for(var e = Object.keys(t), n = 0; n < e.length; ++n)null != t[e[n]] && (this[e[n]] = t[e[n]]);\n                }\n                return t.prototype.name = \"\", t.prototype.type = null, t.prototype.docString = \"\", t.create = function(e) {\n                    return new t(e);\n                }, t.encode = function(t, e) {\n                    return e || (e = u.create()), null != t.name && t.hasOwnProperty(\"name\") && e.uint32(10).string(t.name), null != t.type && t.hasOwnProperty(\"type\") && l.onnx.TypeProto.encode(t.type, e.uint32(18).fork()).ldelim(), null != t.docString && t.hasOwnProperty(\"docString\") && e.uint32(26).string(t.docString), e;\n                }, t.encodeDelimited = function(t, e) {\n                    return this.encode(t, e).ldelim();\n                }, t.decode = function(t, e) {\n                    t instanceof s || (t = s.create(t));\n                    for(var n = void 0 === e ? t.len : t.pos + e, r = new l.onnx.ValueInfoProto; t.pos < n;){\n                        var i = t.uint32();\n                        switch(i >>> 3){\n                            case 1:\n                                r.name = t.string();\n                                break;\n                            case 2:\n                                r.type = l.onnx.TypeProto.decode(t, t.uint32());\n                                break;\n                            case 3:\n                                r.docString = t.string();\n                                break;\n                            default:\n                                t.skipType(7 & i);\n                        }\n                    }\n                    return r;\n                }, t.decodeDelimited = function(t) {\n                    return t instanceof s || (t = new s(t)), this.decode(t, t.uint32());\n                }, t.verify = function(t) {\n                    if (\"object\" != typeof t || null === t) return \"object expected\";\n                    if (null != t.name && t.hasOwnProperty(\"name\") && !c.isString(t.name)) return \"name: string expected\";\n                    if (null != t.type && t.hasOwnProperty(\"type\")) {\n                        var e = l.onnx.TypeProto.verify(t.type);\n                        if (e) return \"type.\" + e;\n                    }\n                    return null != t.docString && t.hasOwnProperty(\"docString\") && !c.isString(t.docString) ? \"docString: string expected\" : null;\n                }, t.fromObject = function(t) {\n                    if (t instanceof l.onnx.ValueInfoProto) return t;\n                    var e = new l.onnx.ValueInfoProto;\n                    if (null != t.name && (e.name = String(t.name)), null != t.type) {\n                        if (\"object\" != typeof t.type) throw TypeError(\".onnx.ValueInfoProto.type: object expected\");\n                        e.type = l.onnx.TypeProto.fromObject(t.type);\n                    }\n                    return null != t.docString && (e.docString = String(t.docString)), e;\n                }, t.toObject = function(t, e) {\n                    e || (e = {});\n                    var n = {};\n                    return e.defaults && (n.name = \"\", n.type = null, n.docString = \"\"), null != t.name && t.hasOwnProperty(\"name\") && (n.name = t.name), null != t.type && t.hasOwnProperty(\"type\") && (n.type = l.onnx.TypeProto.toObject(t.type, e)), null != t.docString && t.hasOwnProperty(\"docString\") && (n.docString = t.docString), n;\n                }, t.prototype.toJSON = function() {\n                    return this.constructor.toObject(this, a.util.toJSONOptions);\n                }, t;\n            }(), o.NodeProto = function() {\n                function t(t) {\n                    if (this.input = [], this.output = [], this.attribute = [], t) for(var e = Object.keys(t), n = 0; n < e.length; ++n)null != t[e[n]] && (this[e[n]] = t[e[n]]);\n                }\n                return t.prototype.input = c.emptyArray, t.prototype.output = c.emptyArray, t.prototype.name = \"\", t.prototype.opType = \"\", t.prototype.domain = \"\", t.prototype.attribute = c.emptyArray, t.prototype.docString = \"\", t.create = function(e) {\n                    return new t(e);\n                }, t.encode = function(t, e) {\n                    if (e || (e = u.create()), null != t.input && t.input.length) for(var n = 0; n < t.input.length; ++n)e.uint32(10).string(t.input[n]);\n                    if (null != t.output && t.output.length) for(n = 0; n < t.output.length; ++n)e.uint32(18).string(t.output[n]);\n                    if (null != t.name && t.hasOwnProperty(\"name\") && e.uint32(26).string(t.name), null != t.opType && t.hasOwnProperty(\"opType\") && e.uint32(34).string(t.opType), null != t.attribute && t.attribute.length) for(n = 0; n < t.attribute.length; ++n)l.onnx.AttributeProto.encode(t.attribute[n], e.uint32(42).fork()).ldelim();\n                    return null != t.docString && t.hasOwnProperty(\"docString\") && e.uint32(50).string(t.docString), null != t.domain && t.hasOwnProperty(\"domain\") && e.uint32(58).string(t.domain), e;\n                }, t.encodeDelimited = function(t, e) {\n                    return this.encode(t, e).ldelim();\n                }, t.decode = function(t, e) {\n                    t instanceof s || (t = s.create(t));\n                    for(var n = void 0 === e ? t.len : t.pos + e, r = new l.onnx.NodeProto; t.pos < n;){\n                        var i = t.uint32();\n                        switch(i >>> 3){\n                            case 1:\n                                r.input && r.input.length || (r.input = []), r.input.push(t.string());\n                                break;\n                            case 2:\n                                r.output && r.output.length || (r.output = []), r.output.push(t.string());\n                                break;\n                            case 3:\n                                r.name = t.string();\n                                break;\n                            case 4:\n                                r.opType = t.string();\n                                break;\n                            case 7:\n                                r.domain = t.string();\n                                break;\n                            case 5:\n                                r.attribute && r.attribute.length || (r.attribute = []), r.attribute.push(l.onnx.AttributeProto.decode(t, t.uint32()));\n                                break;\n                            case 6:\n                                r.docString = t.string();\n                                break;\n                            default:\n                                t.skipType(7 & i);\n                        }\n                    }\n                    return r;\n                }, t.decodeDelimited = function(t) {\n                    return t instanceof s || (t = new s(t)), this.decode(t, t.uint32());\n                }, t.verify = function(t) {\n                    if (\"object\" != typeof t || null === t) return \"object expected\";\n                    if (null != t.input && t.hasOwnProperty(\"input\")) {\n                        if (!Array.isArray(t.input)) return \"input: array expected\";\n                        for(var e = 0; e < t.input.length; ++e)if (!c.isString(t.input[e])) return \"input: string[] expected\";\n                    }\n                    if (null != t.output && t.hasOwnProperty(\"output\")) {\n                        if (!Array.isArray(t.output)) return \"output: array expected\";\n                        for(e = 0; e < t.output.length; ++e)if (!c.isString(t.output[e])) return \"output: string[] expected\";\n                    }\n                    if (null != t.name && t.hasOwnProperty(\"name\") && !c.isString(t.name)) return \"name: string expected\";\n                    if (null != t.opType && t.hasOwnProperty(\"opType\") && !c.isString(t.opType)) return \"opType: string expected\";\n                    if (null != t.domain && t.hasOwnProperty(\"domain\") && !c.isString(t.domain)) return \"domain: string expected\";\n                    if (null != t.attribute && t.hasOwnProperty(\"attribute\")) {\n                        if (!Array.isArray(t.attribute)) return \"attribute: array expected\";\n                        for(e = 0; e < t.attribute.length; ++e){\n                            var n = l.onnx.AttributeProto.verify(t.attribute[e]);\n                            if (n) return \"attribute.\" + n;\n                        }\n                    }\n                    return null != t.docString && t.hasOwnProperty(\"docString\") && !c.isString(t.docString) ? \"docString: string expected\" : null;\n                }, t.fromObject = function(t) {\n                    if (t instanceof l.onnx.NodeProto) return t;\n                    var e = new l.onnx.NodeProto;\n                    if (t.input) {\n                        if (!Array.isArray(t.input)) throw TypeError(\".onnx.NodeProto.input: array expected\");\n                        e.input = [];\n                        for(var n = 0; n < t.input.length; ++n)e.input[n] = String(t.input[n]);\n                    }\n                    if (t.output) {\n                        if (!Array.isArray(t.output)) throw TypeError(\".onnx.NodeProto.output: array expected\");\n                        for(e.output = [], n = 0; n < t.output.length; ++n)e.output[n] = String(t.output[n]);\n                    }\n                    if (null != t.name && (e.name = String(t.name)), null != t.opType && (e.opType = String(t.opType)), null != t.domain && (e.domain = String(t.domain)), t.attribute) {\n                        if (!Array.isArray(t.attribute)) throw TypeError(\".onnx.NodeProto.attribute: array expected\");\n                        for(e.attribute = [], n = 0; n < t.attribute.length; ++n){\n                            if (\"object\" != typeof t.attribute[n]) throw TypeError(\".onnx.NodeProto.attribute: object expected\");\n                            e.attribute[n] = l.onnx.AttributeProto.fromObject(t.attribute[n]);\n                        }\n                    }\n                    return null != t.docString && (e.docString = String(t.docString)), e;\n                }, t.toObject = function(t, e) {\n                    e || (e = {});\n                    var n = {};\n                    if ((e.arrays || e.defaults) && (n.input = [], n.output = [], n.attribute = []), e.defaults && (n.name = \"\", n.opType = \"\", n.docString = \"\", n.domain = \"\"), t.input && t.input.length) {\n                        n.input = [];\n                        for(var r = 0; r < t.input.length; ++r)n.input[r] = t.input[r];\n                    }\n                    if (t.output && t.output.length) for(n.output = [], r = 0; r < t.output.length; ++r)n.output[r] = t.output[r];\n                    if (null != t.name && t.hasOwnProperty(\"name\") && (n.name = t.name), null != t.opType && t.hasOwnProperty(\"opType\") && (n.opType = t.opType), t.attribute && t.attribute.length) for(n.attribute = [], r = 0; r < t.attribute.length; ++r)n.attribute[r] = l.onnx.AttributeProto.toObject(t.attribute[r], e);\n                    return null != t.docString && t.hasOwnProperty(\"docString\") && (n.docString = t.docString), null != t.domain && t.hasOwnProperty(\"domain\") && (n.domain = t.domain), n;\n                }, t.prototype.toJSON = function() {\n                    return this.constructor.toObject(this, a.util.toJSONOptions);\n                }, t;\n            }(), o.ModelProto = function() {\n                function t(t) {\n                    if (this.opsetImport = [], this.metadataProps = [], t) for(var e = Object.keys(t), n = 0; n < e.length; ++n)null != t[e[n]] && (this[e[n]] = t[e[n]]);\n                }\n                return t.prototype.irVersion = c.Long ? c.Long.fromBits(0, 0, !1) : 0, t.prototype.opsetImport = c.emptyArray, t.prototype.producerName = \"\", t.prototype.producerVersion = \"\", t.prototype.domain = \"\", t.prototype.modelVersion = c.Long ? c.Long.fromBits(0, 0, !1) : 0, t.prototype.docString = \"\", t.prototype.graph = null, t.prototype.metadataProps = c.emptyArray, t.create = function(e) {\n                    return new t(e);\n                }, t.encode = function(t, e) {\n                    if (e || (e = u.create()), null != t.irVersion && t.hasOwnProperty(\"irVersion\") && e.uint32(8).int64(t.irVersion), null != t.producerName && t.hasOwnProperty(\"producerName\") && e.uint32(18).string(t.producerName), null != t.producerVersion && t.hasOwnProperty(\"producerVersion\") && e.uint32(26).string(t.producerVersion), null != t.domain && t.hasOwnProperty(\"domain\") && e.uint32(34).string(t.domain), null != t.modelVersion && t.hasOwnProperty(\"modelVersion\") && e.uint32(40).int64(t.modelVersion), null != t.docString && t.hasOwnProperty(\"docString\") && e.uint32(50).string(t.docString), null != t.graph && t.hasOwnProperty(\"graph\") && l.onnx.GraphProto.encode(t.graph, e.uint32(58).fork()).ldelim(), null != t.opsetImport && t.opsetImport.length) for(var n = 0; n < t.opsetImport.length; ++n)l.onnx.OperatorSetIdProto.encode(t.opsetImport[n], e.uint32(66).fork()).ldelim();\n                    if (null != t.metadataProps && t.metadataProps.length) for(n = 0; n < t.metadataProps.length; ++n)l.onnx.StringStringEntryProto.encode(t.metadataProps[n], e.uint32(114).fork()).ldelim();\n                    return e;\n                }, t.encodeDelimited = function(t, e) {\n                    return this.encode(t, e).ldelim();\n                }, t.decode = function(t, e) {\n                    t instanceof s || (t = s.create(t));\n                    for(var n = void 0 === e ? t.len : t.pos + e, r = new l.onnx.ModelProto; t.pos < n;){\n                        var i = t.uint32();\n                        switch(i >>> 3){\n                            case 1:\n                                r.irVersion = t.int64();\n                                break;\n                            case 8:\n                                r.opsetImport && r.opsetImport.length || (r.opsetImport = []), r.opsetImport.push(l.onnx.OperatorSetIdProto.decode(t, t.uint32()));\n                                break;\n                            case 2:\n                                r.producerName = t.string();\n                                break;\n                            case 3:\n                                r.producerVersion = t.string();\n                                break;\n                            case 4:\n                                r.domain = t.string();\n                                break;\n                            case 5:\n                                r.modelVersion = t.int64();\n                                break;\n                            case 6:\n                                r.docString = t.string();\n                                break;\n                            case 7:\n                                r.graph = l.onnx.GraphProto.decode(t, t.uint32());\n                                break;\n                            case 14:\n                                r.metadataProps && r.metadataProps.length || (r.metadataProps = []), r.metadataProps.push(l.onnx.StringStringEntryProto.decode(t, t.uint32()));\n                                break;\n                            default:\n                                t.skipType(7 & i);\n                        }\n                    }\n                    return r;\n                }, t.decodeDelimited = function(t) {\n                    return t instanceof s || (t = new s(t)), this.decode(t, t.uint32());\n                }, t.verify = function(t) {\n                    if (\"object\" != typeof t || null === t) return \"object expected\";\n                    if (null != t.irVersion && t.hasOwnProperty(\"irVersion\") && !(c.isInteger(t.irVersion) || t.irVersion && c.isInteger(t.irVersion.low) && c.isInteger(t.irVersion.high))) return \"irVersion: integer|Long expected\";\n                    if (null != t.opsetImport && t.hasOwnProperty(\"opsetImport\")) {\n                        if (!Array.isArray(t.opsetImport)) return \"opsetImport: array expected\";\n                        for(var e = 0; e < t.opsetImport.length; ++e)if (n = l.onnx.OperatorSetIdProto.verify(t.opsetImport[e])) return \"opsetImport.\" + n;\n                    }\n                    if (null != t.producerName && t.hasOwnProperty(\"producerName\") && !c.isString(t.producerName)) return \"producerName: string expected\";\n                    if (null != t.producerVersion && t.hasOwnProperty(\"producerVersion\") && !c.isString(t.producerVersion)) return \"producerVersion: string expected\";\n                    if (null != t.domain && t.hasOwnProperty(\"domain\") && !c.isString(t.domain)) return \"domain: string expected\";\n                    if (null != t.modelVersion && t.hasOwnProperty(\"modelVersion\") && !(c.isInteger(t.modelVersion) || t.modelVersion && c.isInteger(t.modelVersion.low) && c.isInteger(t.modelVersion.high))) return \"modelVersion: integer|Long expected\";\n                    if (null != t.docString && t.hasOwnProperty(\"docString\") && !c.isString(t.docString)) return \"docString: string expected\";\n                    if (null != t.graph && t.hasOwnProperty(\"graph\") && (n = l.onnx.GraphProto.verify(t.graph))) return \"graph.\" + n;\n                    if (null != t.metadataProps && t.hasOwnProperty(\"metadataProps\")) {\n                        if (!Array.isArray(t.metadataProps)) return \"metadataProps: array expected\";\n                        for(e = 0; e < t.metadataProps.length; ++e){\n                            var n;\n                            if (n = l.onnx.StringStringEntryProto.verify(t.metadataProps[e])) return \"metadataProps.\" + n;\n                        }\n                    }\n                    return null;\n                }, t.fromObject = function(t) {\n                    if (t instanceof l.onnx.ModelProto) return t;\n                    var e = new l.onnx.ModelProto;\n                    if (null != t.irVersion && (c.Long ? (e.irVersion = c.Long.fromValue(t.irVersion)).unsigned = !1 : \"string\" == typeof t.irVersion ? e.irVersion = parseInt(t.irVersion, 10) : \"number\" == typeof t.irVersion ? e.irVersion = t.irVersion : \"object\" == typeof t.irVersion && (e.irVersion = new c.LongBits(t.irVersion.low >>> 0, t.irVersion.high >>> 0).toNumber())), t.opsetImport) {\n                        if (!Array.isArray(t.opsetImport)) throw TypeError(\".onnx.ModelProto.opsetImport: array expected\");\n                        e.opsetImport = [];\n                        for(var n = 0; n < t.opsetImport.length; ++n){\n                            if (\"object\" != typeof t.opsetImport[n]) throw TypeError(\".onnx.ModelProto.opsetImport: object expected\");\n                            e.opsetImport[n] = l.onnx.OperatorSetIdProto.fromObject(t.opsetImport[n]);\n                        }\n                    }\n                    if (null != t.producerName && (e.producerName = String(t.producerName)), null != t.producerVersion && (e.producerVersion = String(t.producerVersion)), null != t.domain && (e.domain = String(t.domain)), null != t.modelVersion && (c.Long ? (e.modelVersion = c.Long.fromValue(t.modelVersion)).unsigned = !1 : \"string\" == typeof t.modelVersion ? e.modelVersion = parseInt(t.modelVersion, 10) : \"number\" == typeof t.modelVersion ? e.modelVersion = t.modelVersion : \"object\" == typeof t.modelVersion && (e.modelVersion = new c.LongBits(t.modelVersion.low >>> 0, t.modelVersion.high >>> 0).toNumber())), null != t.docString && (e.docString = String(t.docString)), null != t.graph) {\n                        if (\"object\" != typeof t.graph) throw TypeError(\".onnx.ModelProto.graph: object expected\");\n                        e.graph = l.onnx.GraphProto.fromObject(t.graph);\n                    }\n                    if (t.metadataProps) {\n                        if (!Array.isArray(t.metadataProps)) throw TypeError(\".onnx.ModelProto.metadataProps: array expected\");\n                        for(e.metadataProps = [], n = 0; n < t.metadataProps.length; ++n){\n                            if (\"object\" != typeof t.metadataProps[n]) throw TypeError(\".onnx.ModelProto.metadataProps: object expected\");\n                            e.metadataProps[n] = l.onnx.StringStringEntryProto.fromObject(t.metadataProps[n]);\n                        }\n                    }\n                    return e;\n                }, t.toObject = function(t, e) {\n                    e || (e = {});\n                    var n = {};\n                    if ((e.arrays || e.defaults) && (n.opsetImport = [], n.metadataProps = []), e.defaults) {\n                        if (c.Long) {\n                            var r = new c.Long(0, 0, !1);\n                            n.irVersion = e.longs === String ? r.toString() : e.longs === Number ? r.toNumber() : r;\n                        } else n.irVersion = e.longs === String ? \"0\" : 0;\n                        n.producerName = \"\", n.producerVersion = \"\", n.domain = \"\", c.Long ? (r = new c.Long(0, 0, !1), n.modelVersion = e.longs === String ? r.toString() : e.longs === Number ? r.toNumber() : r) : n.modelVersion = e.longs === String ? \"0\" : 0, n.docString = \"\", n.graph = null;\n                    }\n                    if (null != t.irVersion && t.hasOwnProperty(\"irVersion\") && (\"number\" == typeof t.irVersion ? n.irVersion = e.longs === String ? String(t.irVersion) : t.irVersion : n.irVersion = e.longs === String ? c.Long.prototype.toString.call(t.irVersion) : e.longs === Number ? new c.LongBits(t.irVersion.low >>> 0, t.irVersion.high >>> 0).toNumber() : t.irVersion), null != t.producerName && t.hasOwnProperty(\"producerName\") && (n.producerName = t.producerName), null != t.producerVersion && t.hasOwnProperty(\"producerVersion\") && (n.producerVersion = t.producerVersion), null != t.domain && t.hasOwnProperty(\"domain\") && (n.domain = t.domain), null != t.modelVersion && t.hasOwnProperty(\"modelVersion\") && (\"number\" == typeof t.modelVersion ? n.modelVersion = e.longs === String ? String(t.modelVersion) : t.modelVersion : n.modelVersion = e.longs === String ? c.Long.prototype.toString.call(t.modelVersion) : e.longs === Number ? new c.LongBits(t.modelVersion.low >>> 0, t.modelVersion.high >>> 0).toNumber() : t.modelVersion), null != t.docString && t.hasOwnProperty(\"docString\") && (n.docString = t.docString), null != t.graph && t.hasOwnProperty(\"graph\") && (n.graph = l.onnx.GraphProto.toObject(t.graph, e)), t.opsetImport && t.opsetImport.length) {\n                        n.opsetImport = [];\n                        for(var i = 0; i < t.opsetImport.length; ++i)n.opsetImport[i] = l.onnx.OperatorSetIdProto.toObject(t.opsetImport[i], e);\n                    }\n                    if (t.metadataProps && t.metadataProps.length) for(n.metadataProps = [], i = 0; i < t.metadataProps.length; ++i)n.metadataProps[i] = l.onnx.StringStringEntryProto.toObject(t.metadataProps[i], e);\n                    return n;\n                }, t.prototype.toJSON = function() {\n                    return this.constructor.toObject(this, a.util.toJSONOptions);\n                }, t;\n            }(), o.StringStringEntryProto = function() {\n                function t(t) {\n                    if (t) for(var e = Object.keys(t), n = 0; n < e.length; ++n)null != t[e[n]] && (this[e[n]] = t[e[n]]);\n                }\n                return t.prototype.key = \"\", t.prototype.value = \"\", t.create = function(e) {\n                    return new t(e);\n                }, t.encode = function(t, e) {\n                    return e || (e = u.create()), null != t.key && t.hasOwnProperty(\"key\") && e.uint32(10).string(t.key), null != t.value && t.hasOwnProperty(\"value\") && e.uint32(18).string(t.value), e;\n                }, t.encodeDelimited = function(t, e) {\n                    return this.encode(t, e).ldelim();\n                }, t.decode = function(t, e) {\n                    t instanceof s || (t = s.create(t));\n                    for(var n = void 0 === e ? t.len : t.pos + e, r = new l.onnx.StringStringEntryProto; t.pos < n;){\n                        var i = t.uint32();\n                        switch(i >>> 3){\n                            case 1:\n                                r.key = t.string();\n                                break;\n                            case 2:\n                                r.value = t.string();\n                                break;\n                            default:\n                                t.skipType(7 & i);\n                        }\n                    }\n                    return r;\n                }, t.decodeDelimited = function(t) {\n                    return t instanceof s || (t = new s(t)), this.decode(t, t.uint32());\n                }, t.verify = function(t) {\n                    return \"object\" != typeof t || null === t ? \"object expected\" : null != t.key && t.hasOwnProperty(\"key\") && !c.isString(t.key) ? \"key: string expected\" : null != t.value && t.hasOwnProperty(\"value\") && !c.isString(t.value) ? \"value: string expected\" : null;\n                }, t.fromObject = function(t) {\n                    if (t instanceof l.onnx.StringStringEntryProto) return t;\n                    var e = new l.onnx.StringStringEntryProto;\n                    return null != t.key && (e.key = String(t.key)), null != t.value && (e.value = String(t.value)), e;\n                }, t.toObject = function(t, e) {\n                    e || (e = {});\n                    var n = {};\n                    return e.defaults && (n.key = \"\", n.value = \"\"), null != t.key && t.hasOwnProperty(\"key\") && (n.key = t.key), null != t.value && t.hasOwnProperty(\"value\") && (n.value = t.value), n;\n                }, t.prototype.toJSON = function() {\n                    return this.constructor.toObject(this, a.util.toJSONOptions);\n                }, t;\n            }(), o.TensorAnnotation = function() {\n                function t(t) {\n                    if (this.quantParameterTensorNames = [], t) for(var e = Object.keys(t), n = 0; n < e.length; ++n)null != t[e[n]] && (this[e[n]] = t[e[n]]);\n                }\n                return t.prototype.tensorName = \"\", t.prototype.quantParameterTensorNames = c.emptyArray, t.create = function(e) {\n                    return new t(e);\n                }, t.encode = function(t, e) {\n                    if (e || (e = u.create()), null != t.tensorName && t.hasOwnProperty(\"tensorName\") && e.uint32(10).string(t.tensorName), null != t.quantParameterTensorNames && t.quantParameterTensorNames.length) for(var n = 0; n < t.quantParameterTensorNames.length; ++n)l.onnx.StringStringEntryProto.encode(t.quantParameterTensorNames[n], e.uint32(18).fork()).ldelim();\n                    return e;\n                }, t.encodeDelimited = function(t, e) {\n                    return this.encode(t, e).ldelim();\n                }, t.decode = function(t, e) {\n                    t instanceof s || (t = s.create(t));\n                    for(var n = void 0 === e ? t.len : t.pos + e, r = new l.onnx.TensorAnnotation; t.pos < n;){\n                        var i = t.uint32();\n                        switch(i >>> 3){\n                            case 1:\n                                r.tensorName = t.string();\n                                break;\n                            case 2:\n                                r.quantParameterTensorNames && r.quantParameterTensorNames.length || (r.quantParameterTensorNames = []), r.quantParameterTensorNames.push(l.onnx.StringStringEntryProto.decode(t, t.uint32()));\n                                break;\n                            default:\n                                t.skipType(7 & i);\n                        }\n                    }\n                    return r;\n                }, t.decodeDelimited = function(t) {\n                    return t instanceof s || (t = new s(t)), this.decode(t, t.uint32());\n                }, t.verify = function(t) {\n                    if (\"object\" != typeof t || null === t) return \"object expected\";\n                    if (null != t.tensorName && t.hasOwnProperty(\"tensorName\") && !c.isString(t.tensorName)) return \"tensorName: string expected\";\n                    if (null != t.quantParameterTensorNames && t.hasOwnProperty(\"quantParameterTensorNames\")) {\n                        if (!Array.isArray(t.quantParameterTensorNames)) return \"quantParameterTensorNames: array expected\";\n                        for(var e = 0; e < t.quantParameterTensorNames.length; ++e){\n                            var n = l.onnx.StringStringEntryProto.verify(t.quantParameterTensorNames[e]);\n                            if (n) return \"quantParameterTensorNames.\" + n;\n                        }\n                    }\n                    return null;\n                }, t.fromObject = function(t) {\n                    if (t instanceof l.onnx.TensorAnnotation) return t;\n                    var e = new l.onnx.TensorAnnotation;\n                    if (null != t.tensorName && (e.tensorName = String(t.tensorName)), t.quantParameterTensorNames) {\n                        if (!Array.isArray(t.quantParameterTensorNames)) throw TypeError(\".onnx.TensorAnnotation.quantParameterTensorNames: array expected\");\n                        e.quantParameterTensorNames = [];\n                        for(var n = 0; n < t.quantParameterTensorNames.length; ++n){\n                            if (\"object\" != typeof t.quantParameterTensorNames[n]) throw TypeError(\".onnx.TensorAnnotation.quantParameterTensorNames: object expected\");\n                            e.quantParameterTensorNames[n] = l.onnx.StringStringEntryProto.fromObject(t.quantParameterTensorNames[n]);\n                        }\n                    }\n                    return e;\n                }, t.toObject = function(t, e) {\n                    e || (e = {});\n                    var n = {};\n                    if ((e.arrays || e.defaults) && (n.quantParameterTensorNames = []), e.defaults && (n.tensorName = \"\"), null != t.tensorName && t.hasOwnProperty(\"tensorName\") && (n.tensorName = t.tensorName), t.quantParameterTensorNames && t.quantParameterTensorNames.length) {\n                        n.quantParameterTensorNames = [];\n                        for(var r = 0; r < t.quantParameterTensorNames.length; ++r)n.quantParameterTensorNames[r] = l.onnx.StringStringEntryProto.toObject(t.quantParameterTensorNames[r], e);\n                    }\n                    return n;\n                }, t.prototype.toJSON = function() {\n                    return this.constructor.toObject(this, a.util.toJSONOptions);\n                }, t;\n            }(), o.GraphProto = function() {\n                function t(t) {\n                    if (this.node = [], this.initializer = [], this.input = [], this.output = [], this.valueInfo = [], this.quantizationAnnotation = [], t) for(var e = Object.keys(t), n = 0; n < e.length; ++n)null != t[e[n]] && (this[e[n]] = t[e[n]]);\n                }\n                return t.prototype.node = c.emptyArray, t.prototype.name = \"\", t.prototype.initializer = c.emptyArray, t.prototype.docString = \"\", t.prototype.input = c.emptyArray, t.prototype.output = c.emptyArray, t.prototype.valueInfo = c.emptyArray, t.prototype.quantizationAnnotation = c.emptyArray, t.create = function(e) {\n                    return new t(e);\n                }, t.encode = function(t, e) {\n                    if (e || (e = u.create()), null != t.node && t.node.length) for(var n = 0; n < t.node.length; ++n)l.onnx.NodeProto.encode(t.node[n], e.uint32(10).fork()).ldelim();\n                    if (null != t.name && t.hasOwnProperty(\"name\") && e.uint32(18).string(t.name), null != t.initializer && t.initializer.length) for(n = 0; n < t.initializer.length; ++n)l.onnx.TensorProto.encode(t.initializer[n], e.uint32(42).fork()).ldelim();\n                    if (null != t.docString && t.hasOwnProperty(\"docString\") && e.uint32(82).string(t.docString), null != t.input && t.input.length) for(n = 0; n < t.input.length; ++n)l.onnx.ValueInfoProto.encode(t.input[n], e.uint32(90).fork()).ldelim();\n                    if (null != t.output && t.output.length) for(n = 0; n < t.output.length; ++n)l.onnx.ValueInfoProto.encode(t.output[n], e.uint32(98).fork()).ldelim();\n                    if (null != t.valueInfo && t.valueInfo.length) for(n = 0; n < t.valueInfo.length; ++n)l.onnx.ValueInfoProto.encode(t.valueInfo[n], e.uint32(106).fork()).ldelim();\n                    if (null != t.quantizationAnnotation && t.quantizationAnnotation.length) for(n = 0; n < t.quantizationAnnotation.length; ++n)l.onnx.TensorAnnotation.encode(t.quantizationAnnotation[n], e.uint32(114).fork()).ldelim();\n                    return e;\n                }, t.encodeDelimited = function(t, e) {\n                    return this.encode(t, e).ldelim();\n                }, t.decode = function(t, e) {\n                    t instanceof s || (t = s.create(t));\n                    for(var n = void 0 === e ? t.len : t.pos + e, r = new l.onnx.GraphProto; t.pos < n;){\n                        var i = t.uint32();\n                        switch(i >>> 3){\n                            case 1:\n                                r.node && r.node.length || (r.node = []), r.node.push(l.onnx.NodeProto.decode(t, t.uint32()));\n                                break;\n                            case 2:\n                                r.name = t.string();\n                                break;\n                            case 5:\n                                r.initializer && r.initializer.length || (r.initializer = []), r.initializer.push(l.onnx.TensorProto.decode(t, t.uint32()));\n                                break;\n                            case 10:\n                                r.docString = t.string();\n                                break;\n                            case 11:\n                                r.input && r.input.length || (r.input = []), r.input.push(l.onnx.ValueInfoProto.decode(t, t.uint32()));\n                                break;\n                            case 12:\n                                r.output && r.output.length || (r.output = []), r.output.push(l.onnx.ValueInfoProto.decode(t, t.uint32()));\n                                break;\n                            case 13:\n                                r.valueInfo && r.valueInfo.length || (r.valueInfo = []), r.valueInfo.push(l.onnx.ValueInfoProto.decode(t, t.uint32()));\n                                break;\n                            case 14:\n                                r.quantizationAnnotation && r.quantizationAnnotation.length || (r.quantizationAnnotation = []), r.quantizationAnnotation.push(l.onnx.TensorAnnotation.decode(t, t.uint32()));\n                                break;\n                            default:\n                                t.skipType(7 & i);\n                        }\n                    }\n                    return r;\n                }, t.decodeDelimited = function(t) {\n                    return t instanceof s || (t = new s(t)), this.decode(t, t.uint32());\n                }, t.verify = function(t) {\n                    if (\"object\" != typeof t || null === t) return \"object expected\";\n                    if (null != t.node && t.hasOwnProperty(\"node\")) {\n                        if (!Array.isArray(t.node)) return \"node: array expected\";\n                        for(var e = 0; e < t.node.length; ++e)if (n = l.onnx.NodeProto.verify(t.node[e])) return \"node.\" + n;\n                    }\n                    if (null != t.name && t.hasOwnProperty(\"name\") && !c.isString(t.name)) return \"name: string expected\";\n                    if (null != t.initializer && t.hasOwnProperty(\"initializer\")) {\n                        if (!Array.isArray(t.initializer)) return \"initializer: array expected\";\n                        for(e = 0; e < t.initializer.length; ++e)if (n = l.onnx.TensorProto.verify(t.initializer[e])) return \"initializer.\" + n;\n                    }\n                    if (null != t.docString && t.hasOwnProperty(\"docString\") && !c.isString(t.docString)) return \"docString: string expected\";\n                    if (null != t.input && t.hasOwnProperty(\"input\")) {\n                        if (!Array.isArray(t.input)) return \"input: array expected\";\n                        for(e = 0; e < t.input.length; ++e)if (n = l.onnx.ValueInfoProto.verify(t.input[e])) return \"input.\" + n;\n                    }\n                    if (null != t.output && t.hasOwnProperty(\"output\")) {\n                        if (!Array.isArray(t.output)) return \"output: array expected\";\n                        for(e = 0; e < t.output.length; ++e)if (n = l.onnx.ValueInfoProto.verify(t.output[e])) return \"output.\" + n;\n                    }\n                    if (null != t.valueInfo && t.hasOwnProperty(\"valueInfo\")) {\n                        if (!Array.isArray(t.valueInfo)) return \"valueInfo: array expected\";\n                        for(e = 0; e < t.valueInfo.length; ++e)if (n = l.onnx.ValueInfoProto.verify(t.valueInfo[e])) return \"valueInfo.\" + n;\n                    }\n                    if (null != t.quantizationAnnotation && t.hasOwnProperty(\"quantizationAnnotation\")) {\n                        if (!Array.isArray(t.quantizationAnnotation)) return \"quantizationAnnotation: array expected\";\n                        for(e = 0; e < t.quantizationAnnotation.length; ++e){\n                            var n;\n                            if (n = l.onnx.TensorAnnotation.verify(t.quantizationAnnotation[e])) return \"quantizationAnnotation.\" + n;\n                        }\n                    }\n                    return null;\n                }, t.fromObject = function(t) {\n                    if (t instanceof l.onnx.GraphProto) return t;\n                    var e = new l.onnx.GraphProto;\n                    if (t.node) {\n                        if (!Array.isArray(t.node)) throw TypeError(\".onnx.GraphProto.node: array expected\");\n                        e.node = [];\n                        for(var n = 0; n < t.node.length; ++n){\n                            if (\"object\" != typeof t.node[n]) throw TypeError(\".onnx.GraphProto.node: object expected\");\n                            e.node[n] = l.onnx.NodeProto.fromObject(t.node[n]);\n                        }\n                    }\n                    if (null != t.name && (e.name = String(t.name)), t.initializer) {\n                        if (!Array.isArray(t.initializer)) throw TypeError(\".onnx.GraphProto.initializer: array expected\");\n                        for(e.initializer = [], n = 0; n < t.initializer.length; ++n){\n                            if (\"object\" != typeof t.initializer[n]) throw TypeError(\".onnx.GraphProto.initializer: object expected\");\n                            e.initializer[n] = l.onnx.TensorProto.fromObject(t.initializer[n]);\n                        }\n                    }\n                    if (null != t.docString && (e.docString = String(t.docString)), t.input) {\n                        if (!Array.isArray(t.input)) throw TypeError(\".onnx.GraphProto.input: array expected\");\n                        for(e.input = [], n = 0; n < t.input.length; ++n){\n                            if (\"object\" != typeof t.input[n]) throw TypeError(\".onnx.GraphProto.input: object expected\");\n                            e.input[n] = l.onnx.ValueInfoProto.fromObject(t.input[n]);\n                        }\n                    }\n                    if (t.output) {\n                        if (!Array.isArray(t.output)) throw TypeError(\".onnx.GraphProto.output: array expected\");\n                        for(e.output = [], n = 0; n < t.output.length; ++n){\n                            if (\"object\" != typeof t.output[n]) throw TypeError(\".onnx.GraphProto.output: object expected\");\n                            e.output[n] = l.onnx.ValueInfoProto.fromObject(t.output[n]);\n                        }\n                    }\n                    if (t.valueInfo) {\n                        if (!Array.isArray(t.valueInfo)) throw TypeError(\".onnx.GraphProto.valueInfo: array expected\");\n                        for(e.valueInfo = [], n = 0; n < t.valueInfo.length; ++n){\n                            if (\"object\" != typeof t.valueInfo[n]) throw TypeError(\".onnx.GraphProto.valueInfo: object expected\");\n                            e.valueInfo[n] = l.onnx.ValueInfoProto.fromObject(t.valueInfo[n]);\n                        }\n                    }\n                    if (t.quantizationAnnotation) {\n                        if (!Array.isArray(t.quantizationAnnotation)) throw TypeError(\".onnx.GraphProto.quantizationAnnotation: array expected\");\n                        for(e.quantizationAnnotation = [], n = 0; n < t.quantizationAnnotation.length; ++n){\n                            if (\"object\" != typeof t.quantizationAnnotation[n]) throw TypeError(\".onnx.GraphProto.quantizationAnnotation: object expected\");\n                            e.quantizationAnnotation[n] = l.onnx.TensorAnnotation.fromObject(t.quantizationAnnotation[n]);\n                        }\n                    }\n                    return e;\n                }, t.toObject = function(t, e) {\n                    e || (e = {});\n                    var n = {};\n                    if ((e.arrays || e.defaults) && (n.node = [], n.initializer = [], n.input = [], n.output = [], n.valueInfo = [], n.quantizationAnnotation = []), e.defaults && (n.name = \"\", n.docString = \"\"), t.node && t.node.length) {\n                        n.node = [];\n                        for(var r = 0; r < t.node.length; ++r)n.node[r] = l.onnx.NodeProto.toObject(t.node[r], e);\n                    }\n                    if (null != t.name && t.hasOwnProperty(\"name\") && (n.name = t.name), t.initializer && t.initializer.length) for(n.initializer = [], r = 0; r < t.initializer.length; ++r)n.initializer[r] = l.onnx.TensorProto.toObject(t.initializer[r], e);\n                    if (null != t.docString && t.hasOwnProperty(\"docString\") && (n.docString = t.docString), t.input && t.input.length) for(n.input = [], r = 0; r < t.input.length; ++r)n.input[r] = l.onnx.ValueInfoProto.toObject(t.input[r], e);\n                    if (t.output && t.output.length) for(n.output = [], r = 0; r < t.output.length; ++r)n.output[r] = l.onnx.ValueInfoProto.toObject(t.output[r], e);\n                    if (t.valueInfo && t.valueInfo.length) for(n.valueInfo = [], r = 0; r < t.valueInfo.length; ++r)n.valueInfo[r] = l.onnx.ValueInfoProto.toObject(t.valueInfo[r], e);\n                    if (t.quantizationAnnotation && t.quantizationAnnotation.length) for(n.quantizationAnnotation = [], r = 0; r < t.quantizationAnnotation.length; ++r)n.quantizationAnnotation[r] = l.onnx.TensorAnnotation.toObject(t.quantizationAnnotation[r], e);\n                    return n;\n                }, t.prototype.toJSON = function() {\n                    return this.constructor.toObject(this, a.util.toJSONOptions);\n                }, t;\n            }(), o.TensorProto = function() {\n                function t(t) {\n                    if (this.dims = [], this.floatData = [], this.int32Data = [], this.stringData = [], this.int64Data = [], this.externalData = [], this.doubleData = [], this.uint64Data = [], t) for(var e = Object.keys(t), n = 0; n < e.length; ++n)null != t[e[n]] && (this[e[n]] = t[e[n]]);\n                }\n                return t.prototype.dims = c.emptyArray, t.prototype.dataType = 0, t.prototype.segment = null, t.prototype.floatData = c.emptyArray, t.prototype.int32Data = c.emptyArray, t.prototype.stringData = c.emptyArray, t.prototype.int64Data = c.emptyArray, t.prototype.name = \"\", t.prototype.docString = \"\", t.prototype.rawData = c.newBuffer([]), t.prototype.externalData = c.emptyArray, t.prototype.dataLocation = 0, t.prototype.doubleData = c.emptyArray, t.prototype.uint64Data = c.emptyArray, t.create = function(e) {\n                    return new t(e);\n                }, t.encode = function(t, e) {\n                    if (e || (e = u.create()), null != t.dims && t.dims.length) {\n                        e.uint32(10).fork();\n                        for(var n = 0; n < t.dims.length; ++n)e.int64(t.dims[n]);\n                        e.ldelim();\n                    }\n                    if (null != t.dataType && t.hasOwnProperty(\"dataType\") && e.uint32(16).int32(t.dataType), null != t.segment && t.hasOwnProperty(\"segment\") && l.onnx.TensorProto.Segment.encode(t.segment, e.uint32(26).fork()).ldelim(), null != t.floatData && t.floatData.length) {\n                        for(e.uint32(34).fork(), n = 0; n < t.floatData.length; ++n)e.float(t.floatData[n]);\n                        e.ldelim();\n                    }\n                    if (null != t.int32Data && t.int32Data.length) {\n                        for(e.uint32(42).fork(), n = 0; n < t.int32Data.length; ++n)e.int32(t.int32Data[n]);\n                        e.ldelim();\n                    }\n                    if (null != t.stringData && t.stringData.length) for(n = 0; n < t.stringData.length; ++n)e.uint32(50).bytes(t.stringData[n]);\n                    if (null != t.int64Data && t.int64Data.length) {\n                        for(e.uint32(58).fork(), n = 0; n < t.int64Data.length; ++n)e.int64(t.int64Data[n]);\n                        e.ldelim();\n                    }\n                    if (null != t.name && t.hasOwnProperty(\"name\") && e.uint32(66).string(t.name), null != t.rawData && t.hasOwnProperty(\"rawData\") && e.uint32(74).bytes(t.rawData), null != t.doubleData && t.doubleData.length) {\n                        for(e.uint32(82).fork(), n = 0; n < t.doubleData.length; ++n)e.double(t.doubleData[n]);\n                        e.ldelim();\n                    }\n                    if (null != t.uint64Data && t.uint64Data.length) {\n                        for(e.uint32(90).fork(), n = 0; n < t.uint64Data.length; ++n)e.uint64(t.uint64Data[n]);\n                        e.ldelim();\n                    }\n                    if (null != t.docString && t.hasOwnProperty(\"docString\") && e.uint32(98).string(t.docString), null != t.externalData && t.externalData.length) for(n = 0; n < t.externalData.length; ++n)l.onnx.StringStringEntryProto.encode(t.externalData[n], e.uint32(106).fork()).ldelim();\n                    return null != t.dataLocation && t.hasOwnProperty(\"dataLocation\") && e.uint32(112).int32(t.dataLocation), e;\n                }, t.encodeDelimited = function(t, e) {\n                    return this.encode(t, e).ldelim();\n                }, t.decode = function(t, e) {\n                    t instanceof s || (t = s.create(t));\n                    for(var n = void 0 === e ? t.len : t.pos + e, r = new l.onnx.TensorProto; t.pos < n;){\n                        var i = t.uint32();\n                        switch(i >>> 3){\n                            case 1:\n                                if (r.dims && r.dims.length || (r.dims = []), 2 == (7 & i)) for(var o = t.uint32() + t.pos; t.pos < o;)r.dims.push(t.int64());\n                                else r.dims.push(t.int64());\n                                break;\n                            case 2:\n                                r.dataType = t.int32();\n                                break;\n                            case 3:\n                                r.segment = l.onnx.TensorProto.Segment.decode(t, t.uint32());\n                                break;\n                            case 4:\n                                if (r.floatData && r.floatData.length || (r.floatData = []), 2 == (7 & i)) for(o = t.uint32() + t.pos; t.pos < o;)r.floatData.push(t.float());\n                                else r.floatData.push(t.float());\n                                break;\n                            case 5:\n                                if (r.int32Data && r.int32Data.length || (r.int32Data = []), 2 == (7 & i)) for(o = t.uint32() + t.pos; t.pos < o;)r.int32Data.push(t.int32());\n                                else r.int32Data.push(t.int32());\n                                break;\n                            case 6:\n                                r.stringData && r.stringData.length || (r.stringData = []), r.stringData.push(t.bytes());\n                                break;\n                            case 7:\n                                if (r.int64Data && r.int64Data.length || (r.int64Data = []), 2 == (7 & i)) for(o = t.uint32() + t.pos; t.pos < o;)r.int64Data.push(t.int64());\n                                else r.int64Data.push(t.int64());\n                                break;\n                            case 8:\n                                r.name = t.string();\n                                break;\n                            case 12:\n                                r.docString = t.string();\n                                break;\n                            case 9:\n                                r.rawData = t.bytes();\n                                break;\n                            case 13:\n                                r.externalData && r.externalData.length || (r.externalData = []), r.externalData.push(l.onnx.StringStringEntryProto.decode(t, t.uint32()));\n                                break;\n                            case 14:\n                                r.dataLocation = t.int32();\n                                break;\n                            case 10:\n                                if (r.doubleData && r.doubleData.length || (r.doubleData = []), 2 == (7 & i)) for(o = t.uint32() + t.pos; t.pos < o;)r.doubleData.push(t.double());\n                                else r.doubleData.push(t.double());\n                                break;\n                            case 11:\n                                if (r.uint64Data && r.uint64Data.length || (r.uint64Data = []), 2 == (7 & i)) for(o = t.uint32() + t.pos; t.pos < o;)r.uint64Data.push(t.uint64());\n                                else r.uint64Data.push(t.uint64());\n                                break;\n                            default:\n                                t.skipType(7 & i);\n                        }\n                    }\n                    return r;\n                }, t.decodeDelimited = function(t) {\n                    return t instanceof s || (t = new s(t)), this.decode(t, t.uint32());\n                }, t.verify = function(t) {\n                    if (\"object\" != typeof t || null === t) return \"object expected\";\n                    if (null != t.dims && t.hasOwnProperty(\"dims\")) {\n                        if (!Array.isArray(t.dims)) return \"dims: array expected\";\n                        for(var e = 0; e < t.dims.length; ++e)if (!(c.isInteger(t.dims[e]) || t.dims[e] && c.isInteger(t.dims[e].low) && c.isInteger(t.dims[e].high))) return \"dims: integer|Long[] expected\";\n                    }\n                    if (null != t.dataType && t.hasOwnProperty(\"dataType\") && !c.isInteger(t.dataType)) return \"dataType: integer expected\";\n                    if (null != t.segment && t.hasOwnProperty(\"segment\") && (n = l.onnx.TensorProto.Segment.verify(t.segment))) return \"segment.\" + n;\n                    if (null != t.floatData && t.hasOwnProperty(\"floatData\")) {\n                        if (!Array.isArray(t.floatData)) return \"floatData: array expected\";\n                        for(e = 0; e < t.floatData.length; ++e)if (\"number\" != typeof t.floatData[e]) return \"floatData: number[] expected\";\n                    }\n                    if (null != t.int32Data && t.hasOwnProperty(\"int32Data\")) {\n                        if (!Array.isArray(t.int32Data)) return \"int32Data: array expected\";\n                        for(e = 0; e < t.int32Data.length; ++e)if (!c.isInteger(t.int32Data[e])) return \"int32Data: integer[] expected\";\n                    }\n                    if (null != t.stringData && t.hasOwnProperty(\"stringData\")) {\n                        if (!Array.isArray(t.stringData)) return \"stringData: array expected\";\n                        for(e = 0; e < t.stringData.length; ++e)if (!(t.stringData[e] && \"number\" == typeof t.stringData[e].length || c.isString(t.stringData[e]))) return \"stringData: buffer[] expected\";\n                    }\n                    if (null != t.int64Data && t.hasOwnProperty(\"int64Data\")) {\n                        if (!Array.isArray(t.int64Data)) return \"int64Data: array expected\";\n                        for(e = 0; e < t.int64Data.length; ++e)if (!(c.isInteger(t.int64Data[e]) || t.int64Data[e] && c.isInteger(t.int64Data[e].low) && c.isInteger(t.int64Data[e].high))) return \"int64Data: integer|Long[] expected\";\n                    }\n                    if (null != t.name && t.hasOwnProperty(\"name\") && !c.isString(t.name)) return \"name: string expected\";\n                    if (null != t.docString && t.hasOwnProperty(\"docString\") && !c.isString(t.docString)) return \"docString: string expected\";\n                    if (null != t.rawData && t.hasOwnProperty(\"rawData\") && !(t.rawData && \"number\" == typeof t.rawData.length || c.isString(t.rawData))) return \"rawData: buffer expected\";\n                    if (null != t.externalData && t.hasOwnProperty(\"externalData\")) {\n                        if (!Array.isArray(t.externalData)) return \"externalData: array expected\";\n                        for(e = 0; e < t.externalData.length; ++e){\n                            var n;\n                            if (n = l.onnx.StringStringEntryProto.verify(t.externalData[e])) return \"externalData.\" + n;\n                        }\n                    }\n                    if (null != t.dataLocation && t.hasOwnProperty(\"dataLocation\")) switch(t.dataLocation){\n                        default:\n                            return \"dataLocation: enum value expected\";\n                        case 0:\n                        case 1:\n                    }\n                    if (null != t.doubleData && t.hasOwnProperty(\"doubleData\")) {\n                        if (!Array.isArray(t.doubleData)) return \"doubleData: array expected\";\n                        for(e = 0; e < t.doubleData.length; ++e)if (\"number\" != typeof t.doubleData[e]) return \"doubleData: number[] expected\";\n                    }\n                    if (null != t.uint64Data && t.hasOwnProperty(\"uint64Data\")) {\n                        if (!Array.isArray(t.uint64Data)) return \"uint64Data: array expected\";\n                        for(e = 0; e < t.uint64Data.length; ++e)if (!(c.isInteger(t.uint64Data[e]) || t.uint64Data[e] && c.isInteger(t.uint64Data[e].low) && c.isInteger(t.uint64Data[e].high))) return \"uint64Data: integer|Long[] expected\";\n                    }\n                    return null;\n                }, t.fromObject = function(t) {\n                    if (t instanceof l.onnx.TensorProto) return t;\n                    var e = new l.onnx.TensorProto;\n                    if (t.dims) {\n                        if (!Array.isArray(t.dims)) throw TypeError(\".onnx.TensorProto.dims: array expected\");\n                        e.dims = [];\n                        for(var n = 0; n < t.dims.length; ++n)c.Long ? (e.dims[n] = c.Long.fromValue(t.dims[n])).unsigned = !1 : \"string\" == typeof t.dims[n] ? e.dims[n] = parseInt(t.dims[n], 10) : \"number\" == typeof t.dims[n] ? e.dims[n] = t.dims[n] : \"object\" == typeof t.dims[n] && (e.dims[n] = new c.LongBits(t.dims[n].low >>> 0, t.dims[n].high >>> 0).toNumber());\n                    }\n                    if (null != t.dataType && (e.dataType = 0 | t.dataType), null != t.segment) {\n                        if (\"object\" != typeof t.segment) throw TypeError(\".onnx.TensorProto.segment: object expected\");\n                        e.segment = l.onnx.TensorProto.Segment.fromObject(t.segment);\n                    }\n                    if (t.floatData) {\n                        if (!Array.isArray(t.floatData)) throw TypeError(\".onnx.TensorProto.floatData: array expected\");\n                        for(e.floatData = [], n = 0; n < t.floatData.length; ++n)e.floatData[n] = Number(t.floatData[n]);\n                    }\n                    if (t.int32Data) {\n                        if (!Array.isArray(t.int32Data)) throw TypeError(\".onnx.TensorProto.int32Data: array expected\");\n                        for(e.int32Data = [], n = 0; n < t.int32Data.length; ++n)e.int32Data[n] = 0 | t.int32Data[n];\n                    }\n                    if (t.stringData) {\n                        if (!Array.isArray(t.stringData)) throw TypeError(\".onnx.TensorProto.stringData: array expected\");\n                        for(e.stringData = [], n = 0; n < t.stringData.length; ++n)\"string\" == typeof t.stringData[n] ? c.base64.decode(t.stringData[n], e.stringData[n] = c.newBuffer(c.base64.length(t.stringData[n])), 0) : t.stringData[n].length && (e.stringData[n] = t.stringData[n]);\n                    }\n                    if (t.int64Data) {\n                        if (!Array.isArray(t.int64Data)) throw TypeError(\".onnx.TensorProto.int64Data: array expected\");\n                        for(e.int64Data = [], n = 0; n < t.int64Data.length; ++n)c.Long ? (e.int64Data[n] = c.Long.fromValue(t.int64Data[n])).unsigned = !1 : \"string\" == typeof t.int64Data[n] ? e.int64Data[n] = parseInt(t.int64Data[n], 10) : \"number\" == typeof t.int64Data[n] ? e.int64Data[n] = t.int64Data[n] : \"object\" == typeof t.int64Data[n] && (e.int64Data[n] = new c.LongBits(t.int64Data[n].low >>> 0, t.int64Data[n].high >>> 0).toNumber());\n                    }\n                    if (null != t.name && (e.name = String(t.name)), null != t.docString && (e.docString = String(t.docString)), null != t.rawData && (\"string\" == typeof t.rawData ? c.base64.decode(t.rawData, e.rawData = c.newBuffer(c.base64.length(t.rawData)), 0) : t.rawData.length && (e.rawData = t.rawData)), t.externalData) {\n                        if (!Array.isArray(t.externalData)) throw TypeError(\".onnx.TensorProto.externalData: array expected\");\n                        for(e.externalData = [], n = 0; n < t.externalData.length; ++n){\n                            if (\"object\" != typeof t.externalData[n]) throw TypeError(\".onnx.TensorProto.externalData: object expected\");\n                            e.externalData[n] = l.onnx.StringStringEntryProto.fromObject(t.externalData[n]);\n                        }\n                    }\n                    switch(t.dataLocation){\n                        case \"DEFAULT\":\n                        case 0:\n                            e.dataLocation = 0;\n                            break;\n                        case \"EXTERNAL\":\n                        case 1:\n                            e.dataLocation = 1;\n                    }\n                    if (t.doubleData) {\n                        if (!Array.isArray(t.doubleData)) throw TypeError(\".onnx.TensorProto.doubleData: array expected\");\n                        for(e.doubleData = [], n = 0; n < t.doubleData.length; ++n)e.doubleData[n] = Number(t.doubleData[n]);\n                    }\n                    if (t.uint64Data) {\n                        if (!Array.isArray(t.uint64Data)) throw TypeError(\".onnx.TensorProto.uint64Data: array expected\");\n                        for(e.uint64Data = [], n = 0; n < t.uint64Data.length; ++n)c.Long ? (e.uint64Data[n] = c.Long.fromValue(t.uint64Data[n])).unsigned = !0 : \"string\" == typeof t.uint64Data[n] ? e.uint64Data[n] = parseInt(t.uint64Data[n], 10) : \"number\" == typeof t.uint64Data[n] ? e.uint64Data[n] = t.uint64Data[n] : \"object\" == typeof t.uint64Data[n] && (e.uint64Data[n] = new c.LongBits(t.uint64Data[n].low >>> 0, t.uint64Data[n].high >>> 0).toNumber(!0));\n                    }\n                    return e;\n                }, t.toObject = function(t, e) {\n                    e || (e = {});\n                    var n = {};\n                    if ((e.arrays || e.defaults) && (n.dims = [], n.floatData = [], n.int32Data = [], n.stringData = [], n.int64Data = [], n.doubleData = [], n.uint64Data = [], n.externalData = []), e.defaults && (n.dataType = 0, n.segment = null, n.name = \"\", e.bytes === String ? n.rawData = \"\" : (n.rawData = [], e.bytes !== Array && (n.rawData = c.newBuffer(n.rawData))), n.docString = \"\", n.dataLocation = e.enums === String ? \"DEFAULT\" : 0), t.dims && t.dims.length) {\n                        n.dims = [];\n                        for(var r = 0; r < t.dims.length; ++r)\"number\" == typeof t.dims[r] ? n.dims[r] = e.longs === String ? String(t.dims[r]) : t.dims[r] : n.dims[r] = e.longs === String ? c.Long.prototype.toString.call(t.dims[r]) : e.longs === Number ? new c.LongBits(t.dims[r].low >>> 0, t.dims[r].high >>> 0).toNumber() : t.dims[r];\n                    }\n                    if (null != t.dataType && t.hasOwnProperty(\"dataType\") && (n.dataType = t.dataType), null != t.segment && t.hasOwnProperty(\"segment\") && (n.segment = l.onnx.TensorProto.Segment.toObject(t.segment, e)), t.floatData && t.floatData.length) for(n.floatData = [], r = 0; r < t.floatData.length; ++r)n.floatData[r] = e.json && !isFinite(t.floatData[r]) ? String(t.floatData[r]) : t.floatData[r];\n                    if (t.int32Data && t.int32Data.length) for(n.int32Data = [], r = 0; r < t.int32Data.length; ++r)n.int32Data[r] = t.int32Data[r];\n                    if (t.stringData && t.stringData.length) for(n.stringData = [], r = 0; r < t.stringData.length; ++r)n.stringData[r] = e.bytes === String ? c.base64.encode(t.stringData[r], 0, t.stringData[r].length) : e.bytes === Array ? Array.prototype.slice.call(t.stringData[r]) : t.stringData[r];\n                    if (t.int64Data && t.int64Data.length) for(n.int64Data = [], r = 0; r < t.int64Data.length; ++r)\"number\" == typeof t.int64Data[r] ? n.int64Data[r] = e.longs === String ? String(t.int64Data[r]) : t.int64Data[r] : n.int64Data[r] = e.longs === String ? c.Long.prototype.toString.call(t.int64Data[r]) : e.longs === Number ? new c.LongBits(t.int64Data[r].low >>> 0, t.int64Data[r].high >>> 0).toNumber() : t.int64Data[r];\n                    if (null != t.name && t.hasOwnProperty(\"name\") && (n.name = t.name), null != t.rawData && t.hasOwnProperty(\"rawData\") && (n.rawData = e.bytes === String ? c.base64.encode(t.rawData, 0, t.rawData.length) : e.bytes === Array ? Array.prototype.slice.call(t.rawData) : t.rawData), t.doubleData && t.doubleData.length) for(n.doubleData = [], r = 0; r < t.doubleData.length; ++r)n.doubleData[r] = e.json && !isFinite(t.doubleData[r]) ? String(t.doubleData[r]) : t.doubleData[r];\n                    if (t.uint64Data && t.uint64Data.length) for(n.uint64Data = [], r = 0; r < t.uint64Data.length; ++r)\"number\" == typeof t.uint64Data[r] ? n.uint64Data[r] = e.longs === String ? String(t.uint64Data[r]) : t.uint64Data[r] : n.uint64Data[r] = e.longs === String ? c.Long.prototype.toString.call(t.uint64Data[r]) : e.longs === Number ? new c.LongBits(t.uint64Data[r].low >>> 0, t.uint64Data[r].high >>> 0).toNumber(!0) : t.uint64Data[r];\n                    if (null != t.docString && t.hasOwnProperty(\"docString\") && (n.docString = t.docString), t.externalData && t.externalData.length) for(n.externalData = [], r = 0; r < t.externalData.length; ++r)n.externalData[r] = l.onnx.StringStringEntryProto.toObject(t.externalData[r], e);\n                    return null != t.dataLocation && t.hasOwnProperty(\"dataLocation\") && (n.dataLocation = e.enums === String ? l.onnx.TensorProto.DataLocation[t.dataLocation] : t.dataLocation), n;\n                }, t.prototype.toJSON = function() {\n                    return this.constructor.toObject(this, a.util.toJSONOptions);\n                }, t.DataType = function() {\n                    var t = {}, e = Object.create(t);\n                    return e[t[0] = \"UNDEFINED\"] = 0, e[t[1] = \"FLOAT\"] = 1, e[t[2] = \"UINT8\"] = 2, e[t[3] = \"INT8\"] = 3, e[t[4] = \"UINT16\"] = 4, e[t[5] = \"INT16\"] = 5, e[t[6] = \"INT32\"] = 6, e[t[7] = \"INT64\"] = 7, e[t[8] = \"STRING\"] = 8, e[t[9] = \"BOOL\"] = 9, e[t[10] = \"FLOAT16\"] = 10, e[t[11] = \"DOUBLE\"] = 11, e[t[12] = \"UINT32\"] = 12, e[t[13] = \"UINT64\"] = 13, e[t[14] = \"COMPLEX64\"] = 14, e[t[15] = \"COMPLEX128\"] = 15, e[t[16] = \"BFLOAT16\"] = 16, e;\n                }(), t.Segment = function() {\n                    function t(t) {\n                        if (t) for(var e = Object.keys(t), n = 0; n < e.length; ++n)null != t[e[n]] && (this[e[n]] = t[e[n]]);\n                    }\n                    return t.prototype.begin = c.Long ? c.Long.fromBits(0, 0, !1) : 0, t.prototype.end = c.Long ? c.Long.fromBits(0, 0, !1) : 0, t.create = function(e) {\n                        return new t(e);\n                    }, t.encode = function(t, e) {\n                        return e || (e = u.create()), null != t.begin && t.hasOwnProperty(\"begin\") && e.uint32(8).int64(t.begin), null != t.end && t.hasOwnProperty(\"end\") && e.uint32(16).int64(t.end), e;\n                    }, t.encodeDelimited = function(t, e) {\n                        return this.encode(t, e).ldelim();\n                    }, t.decode = function(t, e) {\n                        t instanceof s || (t = s.create(t));\n                        for(var n = void 0 === e ? t.len : t.pos + e, r = new l.onnx.TensorProto.Segment; t.pos < n;){\n                            var i = t.uint32();\n                            switch(i >>> 3){\n                                case 1:\n                                    r.begin = t.int64();\n                                    break;\n                                case 2:\n                                    r.end = t.int64();\n                                    break;\n                                default:\n                                    t.skipType(7 & i);\n                            }\n                        }\n                        return r;\n                    }, t.decodeDelimited = function(t) {\n                        return t instanceof s || (t = new s(t)), this.decode(t, t.uint32());\n                    }, t.verify = function(t) {\n                        return \"object\" != typeof t || null === t ? \"object expected\" : null != t.begin && t.hasOwnProperty(\"begin\") && !(c.isInteger(t.begin) || t.begin && c.isInteger(t.begin.low) && c.isInteger(t.begin.high)) ? \"begin: integer|Long expected\" : null != t.end && t.hasOwnProperty(\"end\") && !(c.isInteger(t.end) || t.end && c.isInteger(t.end.low) && c.isInteger(t.end.high)) ? \"end: integer|Long expected\" : null;\n                    }, t.fromObject = function(t) {\n                        if (t instanceof l.onnx.TensorProto.Segment) return t;\n                        var e = new l.onnx.TensorProto.Segment;\n                        return null != t.begin && (c.Long ? (e.begin = c.Long.fromValue(t.begin)).unsigned = !1 : \"string\" == typeof t.begin ? e.begin = parseInt(t.begin, 10) : \"number\" == typeof t.begin ? e.begin = t.begin : \"object\" == typeof t.begin && (e.begin = new c.LongBits(t.begin.low >>> 0, t.begin.high >>> 0).toNumber())), null != t.end && (c.Long ? (e.end = c.Long.fromValue(t.end)).unsigned = !1 : \"string\" == typeof t.end ? e.end = parseInt(t.end, 10) : \"number\" == typeof t.end ? e.end = t.end : \"object\" == typeof t.end && (e.end = new c.LongBits(t.end.low >>> 0, t.end.high >>> 0).toNumber())), e;\n                    }, t.toObject = function(t, e) {\n                        e || (e = {});\n                        var n = {};\n                        if (e.defaults) {\n                            if (c.Long) {\n                                var r = new c.Long(0, 0, !1);\n                                n.begin = e.longs === String ? r.toString() : e.longs === Number ? r.toNumber() : r;\n                            } else n.begin = e.longs === String ? \"0\" : 0;\n                            c.Long ? (r = new c.Long(0, 0, !1), n.end = e.longs === String ? r.toString() : e.longs === Number ? r.toNumber() : r) : n.end = e.longs === String ? \"0\" : 0;\n                        }\n                        return null != t.begin && t.hasOwnProperty(\"begin\") && (\"number\" == typeof t.begin ? n.begin = e.longs === String ? String(t.begin) : t.begin : n.begin = e.longs === String ? c.Long.prototype.toString.call(t.begin) : e.longs === Number ? new c.LongBits(t.begin.low >>> 0, t.begin.high >>> 0).toNumber() : t.begin), null != t.end && t.hasOwnProperty(\"end\") && (\"number\" == typeof t.end ? n.end = e.longs === String ? String(t.end) : t.end : n.end = e.longs === String ? c.Long.prototype.toString.call(t.end) : e.longs === Number ? new c.LongBits(t.end.low >>> 0, t.end.high >>> 0).toNumber() : t.end), n;\n                    }, t.prototype.toJSON = function() {\n                        return this.constructor.toObject(this, a.util.toJSONOptions);\n                    }, t;\n                }(), t.DataLocation = function() {\n                    var t = {}, e = Object.create(t);\n                    return e[t[0] = \"DEFAULT\"] = 0, e[t[1] = \"EXTERNAL\"] = 1, e;\n                }(), t;\n            }(), o.TensorShapeProto = function() {\n                function t(t) {\n                    if (this.dim = [], t) for(var e = Object.keys(t), n = 0; n < e.length; ++n)null != t[e[n]] && (this[e[n]] = t[e[n]]);\n                }\n                return t.prototype.dim = c.emptyArray, t.create = function(e) {\n                    return new t(e);\n                }, t.encode = function(t, e) {\n                    if (e || (e = u.create()), null != t.dim && t.dim.length) for(var n = 0; n < t.dim.length; ++n)l.onnx.TensorShapeProto.Dimension.encode(t.dim[n], e.uint32(10).fork()).ldelim();\n                    return e;\n                }, t.encodeDelimited = function(t, e) {\n                    return this.encode(t, e).ldelim();\n                }, t.decode = function(t, e) {\n                    t instanceof s || (t = s.create(t));\n                    for(var n = void 0 === e ? t.len : t.pos + e, r = new l.onnx.TensorShapeProto; t.pos < n;){\n                        var i = t.uint32();\n                        i >>> 3 == 1 ? (r.dim && r.dim.length || (r.dim = []), r.dim.push(l.onnx.TensorShapeProto.Dimension.decode(t, t.uint32()))) : t.skipType(7 & i);\n                    }\n                    return r;\n                }, t.decodeDelimited = function(t) {\n                    return t instanceof s || (t = new s(t)), this.decode(t, t.uint32());\n                }, t.verify = function(t) {\n                    if (\"object\" != typeof t || null === t) return \"object expected\";\n                    if (null != t.dim && t.hasOwnProperty(\"dim\")) {\n                        if (!Array.isArray(t.dim)) return \"dim: array expected\";\n                        for(var e = 0; e < t.dim.length; ++e){\n                            var n = l.onnx.TensorShapeProto.Dimension.verify(t.dim[e]);\n                            if (n) return \"dim.\" + n;\n                        }\n                    }\n                    return null;\n                }, t.fromObject = function(t) {\n                    if (t instanceof l.onnx.TensorShapeProto) return t;\n                    var e = new l.onnx.TensorShapeProto;\n                    if (t.dim) {\n                        if (!Array.isArray(t.dim)) throw TypeError(\".onnx.TensorShapeProto.dim: array expected\");\n                        e.dim = [];\n                        for(var n = 0; n < t.dim.length; ++n){\n                            if (\"object\" != typeof t.dim[n]) throw TypeError(\".onnx.TensorShapeProto.dim: object expected\");\n                            e.dim[n] = l.onnx.TensorShapeProto.Dimension.fromObject(t.dim[n]);\n                        }\n                    }\n                    return e;\n                }, t.toObject = function(t, e) {\n                    e || (e = {});\n                    var n = {};\n                    if ((e.arrays || e.defaults) && (n.dim = []), t.dim && t.dim.length) {\n                        n.dim = [];\n                        for(var r = 0; r < t.dim.length; ++r)n.dim[r] = l.onnx.TensorShapeProto.Dimension.toObject(t.dim[r], e);\n                    }\n                    return n;\n                }, t.prototype.toJSON = function() {\n                    return this.constructor.toObject(this, a.util.toJSONOptions);\n                }, t.Dimension = function() {\n                    function t(t) {\n                        if (t) for(var e = Object.keys(t), n = 0; n < e.length; ++n)null != t[e[n]] && (this[e[n]] = t[e[n]]);\n                    }\n                    var e;\n                    return t.prototype.dimValue = c.Long ? c.Long.fromBits(0, 0, !1) : 0, t.prototype.dimParam = \"\", t.prototype.denotation = \"\", Object.defineProperty(t.prototype, \"value\", {\n                        get: c.oneOfGetter(e = [\n                            \"dimValue\",\n                            \"dimParam\"\n                        ]),\n                        set: c.oneOfSetter(e)\n                    }), t.create = function(e) {\n                        return new t(e);\n                    }, t.encode = function(t, e) {\n                        return e || (e = u.create()), null != t.dimValue && t.hasOwnProperty(\"dimValue\") && e.uint32(8).int64(t.dimValue), null != t.dimParam && t.hasOwnProperty(\"dimParam\") && e.uint32(18).string(t.dimParam), null != t.denotation && t.hasOwnProperty(\"denotation\") && e.uint32(26).string(t.denotation), e;\n                    }, t.encodeDelimited = function(t, e) {\n                        return this.encode(t, e).ldelim();\n                    }, t.decode = function(t, e) {\n                        t instanceof s || (t = s.create(t));\n                        for(var n = void 0 === e ? t.len : t.pos + e, r = new l.onnx.TensorShapeProto.Dimension; t.pos < n;){\n                            var i = t.uint32();\n                            switch(i >>> 3){\n                                case 1:\n                                    r.dimValue = t.int64();\n                                    break;\n                                case 2:\n                                    r.dimParam = t.string();\n                                    break;\n                                case 3:\n                                    r.denotation = t.string();\n                                    break;\n                                default:\n                                    t.skipType(7 & i);\n                            }\n                        }\n                        return r;\n                    }, t.decodeDelimited = function(t) {\n                        return t instanceof s || (t = new s(t)), this.decode(t, t.uint32());\n                    }, t.verify = function(t) {\n                        if (\"object\" != typeof t || null === t) return \"object expected\";\n                        var e = {};\n                        if (null != t.dimValue && t.hasOwnProperty(\"dimValue\") && (e.value = 1, !(c.isInteger(t.dimValue) || t.dimValue && c.isInteger(t.dimValue.low) && c.isInteger(t.dimValue.high)))) return \"dimValue: integer|Long expected\";\n                        if (null != t.dimParam && t.hasOwnProperty(\"dimParam\")) {\n                            if (1 === e.value) return \"value: multiple values\";\n                            if (e.value = 1, !c.isString(t.dimParam)) return \"dimParam: string expected\";\n                        }\n                        return null != t.denotation && t.hasOwnProperty(\"denotation\") && !c.isString(t.denotation) ? \"denotation: string expected\" : null;\n                    }, t.fromObject = function(t) {\n                        if (t instanceof l.onnx.TensorShapeProto.Dimension) return t;\n                        var e = new l.onnx.TensorShapeProto.Dimension;\n                        return null != t.dimValue && (c.Long ? (e.dimValue = c.Long.fromValue(t.dimValue)).unsigned = !1 : \"string\" == typeof t.dimValue ? e.dimValue = parseInt(t.dimValue, 10) : \"number\" == typeof t.dimValue ? e.dimValue = t.dimValue : \"object\" == typeof t.dimValue && (e.dimValue = new c.LongBits(t.dimValue.low >>> 0, t.dimValue.high >>> 0).toNumber())), null != t.dimParam && (e.dimParam = String(t.dimParam)), null != t.denotation && (e.denotation = String(t.denotation)), e;\n                    }, t.toObject = function(t, e) {\n                        e || (e = {});\n                        var n = {};\n                        return e.defaults && (n.denotation = \"\"), null != t.dimValue && t.hasOwnProperty(\"dimValue\") && (\"number\" == typeof t.dimValue ? n.dimValue = e.longs === String ? String(t.dimValue) : t.dimValue : n.dimValue = e.longs === String ? c.Long.prototype.toString.call(t.dimValue) : e.longs === Number ? new c.LongBits(t.dimValue.low >>> 0, t.dimValue.high >>> 0).toNumber() : t.dimValue, e.oneofs && (n.value = \"dimValue\")), null != t.dimParam && t.hasOwnProperty(\"dimParam\") && (n.dimParam = t.dimParam, e.oneofs && (n.value = \"dimParam\")), null != t.denotation && t.hasOwnProperty(\"denotation\") && (n.denotation = t.denotation), n;\n                    }, t.prototype.toJSON = function() {\n                        return this.constructor.toObject(this, a.util.toJSONOptions);\n                    }, t;\n                }(), t;\n            }(), o.TypeProto = function() {\n                function t(t) {\n                    if (t) for(var e = Object.keys(t), n = 0; n < e.length; ++n)null != t[e[n]] && (this[e[n]] = t[e[n]]);\n                }\n                var e;\n                return t.prototype.tensorType = null, t.prototype.denotation = \"\", Object.defineProperty(t.prototype, \"value\", {\n                    get: c.oneOfGetter(e = [\n                        \"tensorType\"\n                    ]),\n                    set: c.oneOfSetter(e)\n                }), t.create = function(e) {\n                    return new t(e);\n                }, t.encode = function(t, e) {\n                    return e || (e = u.create()), null != t.tensorType && t.hasOwnProperty(\"tensorType\") && l.onnx.TypeProto.Tensor.encode(t.tensorType, e.uint32(10).fork()).ldelim(), null != t.denotation && t.hasOwnProperty(\"denotation\") && e.uint32(50).string(t.denotation), e;\n                }, t.encodeDelimited = function(t, e) {\n                    return this.encode(t, e).ldelim();\n                }, t.decode = function(t, e) {\n                    t instanceof s || (t = s.create(t));\n                    for(var n = void 0 === e ? t.len : t.pos + e, r = new l.onnx.TypeProto; t.pos < n;){\n                        var i = t.uint32();\n                        switch(i >>> 3){\n                            case 1:\n                                r.tensorType = l.onnx.TypeProto.Tensor.decode(t, t.uint32());\n                                break;\n                            case 6:\n                                r.denotation = t.string();\n                                break;\n                            default:\n                                t.skipType(7 & i);\n                        }\n                    }\n                    return r;\n                }, t.decodeDelimited = function(t) {\n                    return t instanceof s || (t = new s(t)), this.decode(t, t.uint32());\n                }, t.verify = function(t) {\n                    if (\"object\" != typeof t || null === t) return \"object expected\";\n                    if (null != t.tensorType && t.hasOwnProperty(\"tensorType\")) {\n                        var e = l.onnx.TypeProto.Tensor.verify(t.tensorType);\n                        if (e) return \"tensorType.\" + e;\n                    }\n                    return null != t.denotation && t.hasOwnProperty(\"denotation\") && !c.isString(t.denotation) ? \"denotation: string expected\" : null;\n                }, t.fromObject = function(t) {\n                    if (t instanceof l.onnx.TypeProto) return t;\n                    var e = new l.onnx.TypeProto;\n                    if (null != t.tensorType) {\n                        if (\"object\" != typeof t.tensorType) throw TypeError(\".onnx.TypeProto.tensorType: object expected\");\n                        e.tensorType = l.onnx.TypeProto.Tensor.fromObject(t.tensorType);\n                    }\n                    return null != t.denotation && (e.denotation = String(t.denotation)), e;\n                }, t.toObject = function(t, e) {\n                    e || (e = {});\n                    var n = {};\n                    return e.defaults && (n.denotation = \"\"), null != t.tensorType && t.hasOwnProperty(\"tensorType\") && (n.tensorType = l.onnx.TypeProto.Tensor.toObject(t.tensorType, e), e.oneofs && (n.value = \"tensorType\")), null != t.denotation && t.hasOwnProperty(\"denotation\") && (n.denotation = t.denotation), n;\n                }, t.prototype.toJSON = function() {\n                    return this.constructor.toObject(this, a.util.toJSONOptions);\n                }, t.Tensor = function() {\n                    function t(t) {\n                        if (t) for(var e = Object.keys(t), n = 0; n < e.length; ++n)null != t[e[n]] && (this[e[n]] = t[e[n]]);\n                    }\n                    return t.prototype.elemType = 0, t.prototype.shape = null, t.create = function(e) {\n                        return new t(e);\n                    }, t.encode = function(t, e) {\n                        return e || (e = u.create()), null != t.elemType && t.hasOwnProperty(\"elemType\") && e.uint32(8).int32(t.elemType), null != t.shape && t.hasOwnProperty(\"shape\") && l.onnx.TensorShapeProto.encode(t.shape, e.uint32(18).fork()).ldelim(), e;\n                    }, t.encodeDelimited = function(t, e) {\n                        return this.encode(t, e).ldelim();\n                    }, t.decode = function(t, e) {\n                        t instanceof s || (t = s.create(t));\n                        for(var n = void 0 === e ? t.len : t.pos + e, r = new l.onnx.TypeProto.Tensor; t.pos < n;){\n                            var i = t.uint32();\n                            switch(i >>> 3){\n                                case 1:\n                                    r.elemType = t.int32();\n                                    break;\n                                case 2:\n                                    r.shape = l.onnx.TensorShapeProto.decode(t, t.uint32());\n                                    break;\n                                default:\n                                    t.skipType(7 & i);\n                            }\n                        }\n                        return r;\n                    }, t.decodeDelimited = function(t) {\n                        return t instanceof s || (t = new s(t)), this.decode(t, t.uint32());\n                    }, t.verify = function(t) {\n                        if (\"object\" != typeof t || null === t) return \"object expected\";\n                        if (null != t.elemType && t.hasOwnProperty(\"elemType\") && !c.isInteger(t.elemType)) return \"elemType: integer expected\";\n                        if (null != t.shape && t.hasOwnProperty(\"shape\")) {\n                            var e = l.onnx.TensorShapeProto.verify(t.shape);\n                            if (e) return \"shape.\" + e;\n                        }\n                        return null;\n                    }, t.fromObject = function(t) {\n                        if (t instanceof l.onnx.TypeProto.Tensor) return t;\n                        var e = new l.onnx.TypeProto.Tensor;\n                        if (null != t.elemType && (e.elemType = 0 | t.elemType), null != t.shape) {\n                            if (\"object\" != typeof t.shape) throw TypeError(\".onnx.TypeProto.Tensor.shape: object expected\");\n                            e.shape = l.onnx.TensorShapeProto.fromObject(t.shape);\n                        }\n                        return e;\n                    }, t.toObject = function(t, e) {\n                        e || (e = {});\n                        var n = {};\n                        return e.defaults && (n.elemType = 0, n.shape = null), null != t.elemType && t.hasOwnProperty(\"elemType\") && (n.elemType = t.elemType), null != t.shape && t.hasOwnProperty(\"shape\") && (n.shape = l.onnx.TensorShapeProto.toObject(t.shape, e)), n;\n                    }, t.prototype.toJSON = function() {\n                        return this.constructor.toObject(this, a.util.toJSONOptions);\n                    }, t;\n                }(), t;\n            }(), o.OperatorSetIdProto = function() {\n                function t(t) {\n                    if (t) for(var e = Object.keys(t), n = 0; n < e.length; ++n)null != t[e[n]] && (this[e[n]] = t[e[n]]);\n                }\n                return t.prototype.domain = \"\", t.prototype.version = c.Long ? c.Long.fromBits(0, 0, !1) : 0, t.create = function(e) {\n                    return new t(e);\n                }, t.encode = function(t, e) {\n                    return e || (e = u.create()), null != t.domain && t.hasOwnProperty(\"domain\") && e.uint32(10).string(t.domain), null != t.version && t.hasOwnProperty(\"version\") && e.uint32(16).int64(t.version), e;\n                }, t.encodeDelimited = function(t, e) {\n                    return this.encode(t, e).ldelim();\n                }, t.decode = function(t, e) {\n                    t instanceof s || (t = s.create(t));\n                    for(var n = void 0 === e ? t.len : t.pos + e, r = new l.onnx.OperatorSetIdProto; t.pos < n;){\n                        var i = t.uint32();\n                        switch(i >>> 3){\n                            case 1:\n                                r.domain = t.string();\n                                break;\n                            case 2:\n                                r.version = t.int64();\n                                break;\n                            default:\n                                t.skipType(7 & i);\n                        }\n                    }\n                    return r;\n                }, t.decodeDelimited = function(t) {\n                    return t instanceof s || (t = new s(t)), this.decode(t, t.uint32());\n                }, t.verify = function(t) {\n                    return \"object\" != typeof t || null === t ? \"object expected\" : null != t.domain && t.hasOwnProperty(\"domain\") && !c.isString(t.domain) ? \"domain: string expected\" : null != t.version && t.hasOwnProperty(\"version\") && !(c.isInteger(t.version) || t.version && c.isInteger(t.version.low) && c.isInteger(t.version.high)) ? \"version: integer|Long expected\" : null;\n                }, t.fromObject = function(t) {\n                    if (t instanceof l.onnx.OperatorSetIdProto) return t;\n                    var e = new l.onnx.OperatorSetIdProto;\n                    return null != t.domain && (e.domain = String(t.domain)), null != t.version && (c.Long ? (e.version = c.Long.fromValue(t.version)).unsigned = !1 : \"string\" == typeof t.version ? e.version = parseInt(t.version, 10) : \"number\" == typeof t.version ? e.version = t.version : \"object\" == typeof t.version && (e.version = new c.LongBits(t.version.low >>> 0, t.version.high >>> 0).toNumber())), e;\n                }, t.toObject = function(t, e) {\n                    e || (e = {});\n                    var n = {};\n                    if (e.defaults) if (n.domain = \"\", c.Long) {\n                        var r = new c.Long(0, 0, !1);\n                        n.version = e.longs === String ? r.toString() : e.longs === Number ? r.toNumber() : r;\n                    } else n.version = e.longs === String ? \"0\" : 0;\n                    return null != t.domain && t.hasOwnProperty(\"domain\") && (n.domain = t.domain), null != t.version && t.hasOwnProperty(\"version\") && (\"number\" == typeof t.version ? n.version = e.longs === String ? String(t.version) : t.version : n.version = e.longs === String ? c.Long.prototype.toString.call(t.version) : e.longs === Number ? new c.LongBits(t.version.low >>> 0, t.version.high >>> 0).toNumber() : t.version), n;\n                }, t.prototype.toJSON = function() {\n                    return this.constructor.toObject(this, a.util.toJSONOptions);\n                }, t;\n            }(), o), t.exports = l;\n        },\n        2100: (t, e, n)=>{\n            \"use strict\";\n            t.exports = n(9482);\n        },\n        9482: (t, e, n)=>{\n            \"use strict\";\n            var r = e;\n            function i() {\n                r.util._configure(), r.Writer._configure(r.BufferWriter), r.Reader._configure(r.BufferReader);\n            }\n            r.build = \"minimal\", r.Writer = n(1173), r.BufferWriter = n(3155), r.Reader = n(1408), r.BufferReader = n(593), r.util = n(9693), r.rpc = n(5994), r.roots = n(5054), r.configure = i, i();\n        },\n        1408: (t, e, n)=>{\n            \"use strict\";\n            t.exports = u;\n            var r, i = n(9693), o = i.LongBits, a = i.utf8;\n            function s(t, e) {\n                return RangeError(\"index out of range: \" + t.pos + \" + \" + (e || 1) + \" > \" + t.len);\n            }\n            function u(t) {\n                this.buf = t, this.pos = 0, this.len = t.length;\n            }\n            var c, l = \"undefined\" != typeof Uint8Array ? function(t) {\n                if (t instanceof Uint8Array || Array.isArray(t)) return new u(t);\n                throw Error(\"illegal buffer\");\n            } : function(t) {\n                if (Array.isArray(t)) return new u(t);\n                throw Error(\"illegal buffer\");\n            }, p = function() {\n                return i.Buffer ? function(t) {\n                    return (u.create = function(t) {\n                        return i.Buffer.isBuffer(t) ? new r(t) : l(t);\n                    })(t);\n                } : l;\n            };\n            function f() {\n                var t = new o(0, 0), e = 0;\n                if (!(this.len - this.pos > 4)) {\n                    for(; e < 3; ++e){\n                        if (this.pos >= this.len) throw s(this);\n                        if (t.lo = (t.lo | (127 & this.buf[this.pos]) << 7 * e) >>> 0, this.buf[this.pos++] < 128) return t;\n                    }\n                    return t.lo = (t.lo | (127 & this.buf[this.pos++]) << 7 * e) >>> 0, t;\n                }\n                for(; e < 4; ++e)if (t.lo = (t.lo | (127 & this.buf[this.pos]) << 7 * e) >>> 0, this.buf[this.pos++] < 128) return t;\n                if (t.lo = (t.lo | (127 & this.buf[this.pos]) << 28) >>> 0, t.hi = (t.hi | (127 & this.buf[this.pos]) >> 4) >>> 0, this.buf[this.pos++] < 128) return t;\n                if (e = 0, this.len - this.pos > 4) {\n                    for(; e < 5; ++e)if (t.hi = (t.hi | (127 & this.buf[this.pos]) << 7 * e + 3) >>> 0, this.buf[this.pos++] < 128) return t;\n                } else for(; e < 5; ++e){\n                    if (this.pos >= this.len) throw s(this);\n                    if (t.hi = (t.hi | (127 & this.buf[this.pos]) << 7 * e + 3) >>> 0, this.buf[this.pos++] < 128) return t;\n                }\n                throw Error(\"invalid varint encoding\");\n            }\n            function d(t, e) {\n                return (t[e - 4] | t[e - 3] << 8 | t[e - 2] << 16 | t[e - 1] << 24) >>> 0;\n            }\n            function h() {\n                if (this.pos + 8 > this.len) throw s(this, 8);\n                return new o(d(this.buf, this.pos += 4), d(this.buf, this.pos += 4));\n            }\n            u.create = p(), u.prototype._slice = i.Array.prototype.subarray || i.Array.prototype.slice, u.prototype.uint32 = (c = 4294967295, function() {\n                if (c = (127 & this.buf[this.pos]) >>> 0, this.buf[this.pos++] < 128) return c;\n                if (c = (c | (127 & this.buf[this.pos]) << 7) >>> 0, this.buf[this.pos++] < 128) return c;\n                if (c = (c | (127 & this.buf[this.pos]) << 14) >>> 0, this.buf[this.pos++] < 128) return c;\n                if (c = (c | (127 & this.buf[this.pos]) << 21) >>> 0, this.buf[this.pos++] < 128) return c;\n                if (c = (c | (15 & this.buf[this.pos]) << 28) >>> 0, this.buf[this.pos++] < 128) return c;\n                if ((this.pos += 5) > this.len) throw this.pos = this.len, s(this, 10);\n                return c;\n            }), u.prototype.int32 = function() {\n                return 0 | this.uint32();\n            }, u.prototype.sint32 = function() {\n                var t = this.uint32();\n                return t >>> 1 ^ -(1 & t) | 0;\n            }, u.prototype.bool = function() {\n                return 0 !== this.uint32();\n            }, u.prototype.fixed32 = function() {\n                if (this.pos + 4 > this.len) throw s(this, 4);\n                return d(this.buf, this.pos += 4);\n            }, u.prototype.sfixed32 = function() {\n                if (this.pos + 4 > this.len) throw s(this, 4);\n                return 0 | d(this.buf, this.pos += 4);\n            }, u.prototype.float = function() {\n                if (this.pos + 4 > this.len) throw s(this, 4);\n                var t = i.float.readFloatLE(this.buf, this.pos);\n                return this.pos += 4, t;\n            }, u.prototype.double = function() {\n                if (this.pos + 8 > this.len) throw s(this, 4);\n                var t = i.float.readDoubleLE(this.buf, this.pos);\n                return this.pos += 8, t;\n            }, u.prototype.bytes = function() {\n                var t = this.uint32(), e = this.pos, n = this.pos + t;\n                if (n > this.len) throw s(this, t);\n                return this.pos += t, Array.isArray(this.buf) ? this.buf.slice(e, n) : e === n ? new this.buf.constructor(0) : this._slice.call(this.buf, e, n);\n            }, u.prototype.string = function() {\n                var t = this.bytes();\n                return a.read(t, 0, t.length);\n            }, u.prototype.skip = function(t) {\n                if (\"number\" == typeof t) {\n                    if (this.pos + t > this.len) throw s(this, t);\n                    this.pos += t;\n                } else do {\n                    if (this.pos >= this.len) throw s(this);\n                }while (128 & this.buf[this.pos++]);\n                return this;\n            }, u.prototype.skipType = function(t) {\n                switch(t){\n                    case 0:\n                        this.skip();\n                        break;\n                    case 1:\n                        this.skip(8);\n                        break;\n                    case 2:\n                        this.skip(this.uint32());\n                        break;\n                    case 3:\n                        for(; 4 != (t = 7 & this.uint32());)this.skipType(t);\n                        break;\n                    case 5:\n                        this.skip(4);\n                        break;\n                    default:\n                        throw Error(\"invalid wire type \" + t + \" at offset \" + this.pos);\n                }\n                return this;\n            }, u._configure = function(t) {\n                r = t, u.create = p(), r._configure();\n                var e = i.Long ? \"toLong\" : \"toNumber\";\n                i.merge(u.prototype, {\n                    int64: function() {\n                        return f.call(this)[e](!1);\n                    },\n                    uint64: function() {\n                        return f.call(this)[e](!0);\n                    },\n                    sint64: function() {\n                        return f.call(this).zzDecode()[e](!1);\n                    },\n                    fixed64: function() {\n                        return h.call(this)[e](!0);\n                    },\n                    sfixed64: function() {\n                        return h.call(this)[e](!1);\n                    }\n                });\n            };\n        },\n        593: (t, e, n)=>{\n            \"use strict\";\n            t.exports = o;\n            var r = n(1408);\n            (o.prototype = Object.create(r.prototype)).constructor = o;\n            var i = n(9693);\n            function o(t) {\n                r.call(this, t);\n            }\n            o._configure = function() {\n                i.Buffer && (o.prototype._slice = i.Buffer.prototype.slice);\n            }, o.prototype.string = function() {\n                var t = this.uint32();\n                return this.buf.utf8Slice ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + t, this.len)) : this.buf.toString(\"utf-8\", this.pos, this.pos = Math.min(this.pos + t, this.len));\n            }, o._configure();\n        },\n        5054: (t)=>{\n            \"use strict\";\n            t.exports = {};\n        },\n        5994: (t, e, n)=>{\n            \"use strict\";\n            e.Service = n(7948);\n        },\n        7948: (t, e, n)=>{\n            \"use strict\";\n            t.exports = i;\n            var r = n(9693);\n            function i(t, e, n) {\n                if (\"function\" != typeof t) throw TypeError(\"rpcImpl must be a function\");\n                r.EventEmitter.call(this), this.rpcImpl = t, this.requestDelimited = Boolean(e), this.responseDelimited = Boolean(n);\n            }\n            (i.prototype = Object.create(r.EventEmitter.prototype)).constructor = i, i.prototype.rpcCall = function t(e, n, i, o, a) {\n                if (!o) throw TypeError(\"request must be specified\");\n                var s = this;\n                if (!a) return r.asPromise(t, s, e, n, i, o);\n                if (s.rpcImpl) try {\n                    return s.rpcImpl(e, n[s.requestDelimited ? \"encodeDelimited\" : \"encode\"](o).finish(), function(t, n) {\n                        if (t) return s.emit(\"error\", t, e), a(t);\n                        if (null !== n) {\n                            if (!(n instanceof i)) try {\n                                n = i[s.responseDelimited ? \"decodeDelimited\" : \"decode\"](n);\n                            } catch (t) {\n                                return s.emit(\"error\", t, e), a(t);\n                            }\n                            return s.emit(\"data\", n, e), a(null, n);\n                        }\n                        s.end(!0);\n                    });\n                } catch (t) {\n                    return s.emit(\"error\", t, e), void setTimeout(function() {\n                        a(t);\n                    }, 0);\n                }\n                else setTimeout(function() {\n                    a(Error(\"already ended\"));\n                }, 0);\n            }, i.prototype.end = function(t) {\n                return this.rpcImpl && (t || this.rpcImpl(null, null, null), this.rpcImpl = null, this.emit(\"end\").off()), this;\n            };\n        },\n        1945: (t, e, n)=>{\n            \"use strict\";\n            t.exports = i;\n            var r = n(9693);\n            function i(t, e) {\n                this.lo = t >>> 0, this.hi = e >>> 0;\n            }\n            var o = i.zero = new i(0, 0);\n            o.toNumber = function() {\n                return 0;\n            }, o.zzEncode = o.zzDecode = function() {\n                return this;\n            }, o.length = function() {\n                return 1;\n            };\n            var a = i.zeroHash = \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\";\n            i.fromNumber = function(t) {\n                if (0 === t) return o;\n                var e = t < 0;\n                e && (t = -t);\n                var n = t >>> 0, r = (t - n) / 4294967296 >>> 0;\n                return e && (r = ~r >>> 0, n = ~n >>> 0, ++n > 4294967295 && (n = 0, ++r > 4294967295 && (r = 0))), new i(n, r);\n            }, i.from = function(t) {\n                if (\"number\" == typeof t) return i.fromNumber(t);\n                if (r.isString(t)) {\n                    if (!r.Long) return i.fromNumber(parseInt(t, 10));\n                    t = r.Long.fromString(t);\n                }\n                return t.low || t.high ? new i(t.low >>> 0, t.high >>> 0) : o;\n            }, i.prototype.toNumber = function(t) {\n                if (!t && this.hi >>> 31) {\n                    var e = 1 + ~this.lo >>> 0, n = ~this.hi >>> 0;\n                    return e || (n = n + 1 >>> 0), -(e + 4294967296 * n);\n                }\n                return this.lo + 4294967296 * this.hi;\n            }, i.prototype.toLong = function(t) {\n                return r.Long ? new r.Long(0 | this.lo, 0 | this.hi, Boolean(t)) : {\n                    low: 0 | this.lo,\n                    high: 0 | this.hi,\n                    unsigned: Boolean(t)\n                };\n            };\n            var s = String.prototype.charCodeAt;\n            i.fromHash = function(t) {\n                return t === a ? o : new i((s.call(t, 0) | s.call(t, 1) << 8 | s.call(t, 2) << 16 | s.call(t, 3) << 24) >>> 0, (s.call(t, 4) | s.call(t, 5) << 8 | s.call(t, 6) << 16 | s.call(t, 7) << 24) >>> 0);\n            }, i.prototype.toHash = function() {\n                return String.fromCharCode(255 & this.lo, this.lo >>> 8 & 255, this.lo >>> 16 & 255, this.lo >>> 24, 255 & this.hi, this.hi >>> 8 & 255, this.hi >>> 16 & 255, this.hi >>> 24);\n            }, i.prototype.zzEncode = function() {\n                var t = this.hi >> 31;\n                return this.hi = ((this.hi << 1 | this.lo >>> 31) ^ t) >>> 0, this.lo = (this.lo << 1 ^ t) >>> 0, this;\n            }, i.prototype.zzDecode = function() {\n                var t = -(1 & this.lo);\n                return this.lo = ((this.lo >>> 1 | this.hi << 31) ^ t) >>> 0, this.hi = (this.hi >>> 1 ^ t) >>> 0, this;\n            }, i.prototype.length = function() {\n                var t = this.lo, e = (this.lo >>> 28 | this.hi << 4) >>> 0, n = this.hi >>> 24;\n                return 0 === n ? 0 === e ? t < 16384 ? t < 128 ? 1 : 2 : t < 2097152 ? 3 : 4 : e < 16384 ? e < 128 ? 5 : 6 : e < 2097152 ? 7 : 8 : n < 128 ? 9 : 10;\n            };\n        },\n        9693: function(t, e, n) {\n            \"use strict\";\n            var r = e;\n            function i(t, e, n) {\n                for(var r = Object.keys(e), i = 0; i < r.length; ++i)void 0 !== t[r[i]] && n || (t[r[i]] = e[r[i]]);\n                return t;\n            }\n            function o(t) {\n                function e(t, n) {\n                    if (!(this instanceof e)) return new e(t, n);\n                    Object.defineProperty(this, \"message\", {\n                        get: function() {\n                            return t;\n                        }\n                    }), Error.captureStackTrace ? Error.captureStackTrace(this, e) : Object.defineProperty(this, \"stack\", {\n                        value: (new Error).stack || \"\"\n                    }), n && i(this, n);\n                }\n                return (e.prototype = Object.create(Error.prototype)).constructor = e, Object.defineProperty(e.prototype, \"name\", {\n                    get: function() {\n                        return t;\n                    }\n                }), e.prototype.toString = function() {\n                    return this.name + \": \" + this.message;\n                }, e;\n            }\n            r.asPromise = n(4537), r.base64 = n(7419), r.EventEmitter = n(9211), r.float = n(945), r.inquire = n(7199), r.utf8 = n(4997), r.pool = n(6662), r.LongBits = n(1945), r.isNode = Boolean(\"undefined\" != typeof global && global && global.process && global.process.versions && global.process.versions.node), r.global = r.isNode && global ||  false && 0 || \"undefined\" != typeof self && self || this, r.emptyArray = Object.freeze ? Object.freeze([]) : [], r.emptyObject = Object.freeze ? Object.freeze({}) : {}, r.isInteger = Number.isInteger || function(t) {\n                return \"number\" == typeof t && isFinite(t) && Math.floor(t) === t;\n            }, r.isString = function(t) {\n                return \"string\" == typeof t || t instanceof String;\n            }, r.isObject = function(t) {\n                return t && \"object\" == typeof t;\n            }, r.isset = r.isSet = function(t, e) {\n                var n = t[e];\n                return !(null == n || !t.hasOwnProperty(e)) && (\"object\" != typeof n || (Array.isArray(n) ? n.length : Object.keys(n).length) > 0);\n            }, r.Buffer = function() {\n                try {\n                    var t = r.inquire(\"buffer\").Buffer;\n                    return t.prototype.utf8Write ? t : null;\n                } catch (t) {\n                    return null;\n                }\n            }(), r._Buffer_from = null, r._Buffer_allocUnsafe = null, r.newBuffer = function(t) {\n                return \"number\" == typeof t ? r.Buffer ? r._Buffer_allocUnsafe(t) : new r.Array(t) : r.Buffer ? r._Buffer_from(t) : \"undefined\" == typeof Uint8Array ? t : new Uint8Array(t);\n            }, r.Array = \"undefined\" != typeof Uint8Array ? Uint8Array : Array, r.Long = r.global.dcodeIO && r.global.dcodeIO.Long || r.global.Long || r.inquire(\"long\"), r.key2Re = /^true|false|0|1$/, r.key32Re = /^-?(?:0|[1-9][0-9]*)$/, r.key64Re = /^(?:[\\\\x00-\\\\xff]{8}|-?(?:0|[1-9][0-9]*))$/, r.longToHash = function(t) {\n                return t ? r.LongBits.from(t).toHash() : r.LongBits.zeroHash;\n            }, r.longFromHash = function(t, e) {\n                var n = r.LongBits.fromHash(t);\n                return r.Long ? r.Long.fromBits(n.lo, n.hi, e) : n.toNumber(Boolean(e));\n            }, r.merge = i, r.lcFirst = function(t) {\n                return t.charAt(0).toLowerCase() + t.substring(1);\n            }, r.newError = o, r.ProtocolError = o(\"ProtocolError\"), r.oneOfGetter = function(t) {\n                for(var e = {}, n = 0; n < t.length; ++n)e[t[n]] = 1;\n                return function() {\n                    for(var t = Object.keys(this), n = t.length - 1; n > -1; --n)if (1 === e[t[n]] && void 0 !== this[t[n]] && null !== this[t[n]]) return t[n];\n                };\n            }, r.oneOfSetter = function(t) {\n                return function(e) {\n                    for(var n = 0; n < t.length; ++n)t[n] !== e && delete this[t[n]];\n                };\n            }, r.toJSONOptions = {\n                longs: String,\n                enums: String,\n                bytes: String,\n                json: !0\n            }, r._configure = function() {\n                var t = r.Buffer;\n                t ? (r._Buffer_from = t.from !== Uint8Array.from && t.from || function(e, n) {\n                    return new t(e, n);\n                }, r._Buffer_allocUnsafe = t.allocUnsafe || function(e) {\n                    return new t(e);\n                }) : r._Buffer_from = r._Buffer_allocUnsafe = null;\n            };\n        },\n        1173: (t, e, n)=>{\n            \"use strict\";\n            t.exports = p;\n            var r, i = n(9693), o = i.LongBits, a = i.base64, s = i.utf8;\n            function u(t, e, n) {\n                this.fn = t, this.len = e, this.next = void 0, this.val = n;\n            }\n            function c() {}\n            function l(t) {\n                this.head = t.head, this.tail = t.tail, this.len = t.len, this.next = t.states;\n            }\n            function p() {\n                this.len = 0, this.head = new u(c, 0, 0), this.tail = this.head, this.states = null;\n            }\n            var f = function() {\n                return i.Buffer ? function() {\n                    return (p.create = function() {\n                        return new r;\n                    })();\n                } : function() {\n                    return new p;\n                };\n            };\n            function d(t, e, n) {\n                e[n] = 255 & t;\n            }\n            function h(t, e) {\n                this.len = t, this.next = void 0, this.val = e;\n            }\n            function g(t, e, n) {\n                for(; t.hi;)e[n++] = 127 & t.lo | 128, t.lo = (t.lo >>> 7 | t.hi << 25) >>> 0, t.hi >>>= 7;\n                for(; t.lo > 127;)e[n++] = 127 & t.lo | 128, t.lo = t.lo >>> 7;\n                e[n++] = t.lo;\n            }\n            function b(t, e, n) {\n                e[n] = 255 & t, e[n + 1] = t >>> 8 & 255, e[n + 2] = t >>> 16 & 255, e[n + 3] = t >>> 24;\n            }\n            p.create = f(), p.alloc = function(t) {\n                return new i.Array(t);\n            }, i.Array !== Array && (p.alloc = i.pool(p.alloc, i.Array.prototype.subarray)), p.prototype._push = function(t, e, n) {\n                return this.tail = this.tail.next = new u(t, e, n), this.len += e, this;\n            }, h.prototype = Object.create(u.prototype), h.prototype.fn = function(t, e, n) {\n                for(; t > 127;)e[n++] = 127 & t | 128, t >>>= 7;\n                e[n] = t;\n            }, p.prototype.uint32 = function(t) {\n                return this.len += (this.tail = this.tail.next = new h((t >>>= 0) < 128 ? 1 : t < 16384 ? 2 : t < 2097152 ? 3 : t < 268435456 ? 4 : 5, t)).len, this;\n            }, p.prototype.int32 = function(t) {\n                return t < 0 ? this._push(g, 10, o.fromNumber(t)) : this.uint32(t);\n            }, p.prototype.sint32 = function(t) {\n                return this.uint32((t << 1 ^ t >> 31) >>> 0);\n            }, p.prototype.uint64 = function(t) {\n                var e = o.from(t);\n                return this._push(g, e.length(), e);\n            }, p.prototype.int64 = p.prototype.uint64, p.prototype.sint64 = function(t) {\n                var e = o.from(t).zzEncode();\n                return this._push(g, e.length(), e);\n            }, p.prototype.bool = function(t) {\n                return this._push(d, 1, t ? 1 : 0);\n            }, p.prototype.fixed32 = function(t) {\n                return this._push(b, 4, t >>> 0);\n            }, p.prototype.sfixed32 = p.prototype.fixed32, p.prototype.fixed64 = function(t) {\n                var e = o.from(t);\n                return this._push(b, 4, e.lo)._push(b, 4, e.hi);\n            }, p.prototype.sfixed64 = p.prototype.fixed64, p.prototype.float = function(t) {\n                return this._push(i.float.writeFloatLE, 4, t);\n            }, p.prototype.double = function(t) {\n                return this._push(i.float.writeDoubleLE, 8, t);\n            };\n            var m = i.Array.prototype.set ? function(t, e, n) {\n                e.set(t, n);\n            } : function(t, e, n) {\n                for(var r = 0; r < t.length; ++r)e[n + r] = t[r];\n            };\n            p.prototype.bytes = function(t) {\n                var e = t.length >>> 0;\n                if (!e) return this._push(d, 1, 0);\n                if (i.isString(t)) {\n                    var n = p.alloc(e = a.length(t));\n                    a.decode(t, n, 0), t = n;\n                }\n                return this.uint32(e)._push(m, e, t);\n            }, p.prototype.string = function(t) {\n                var e = s.length(t);\n                return e ? this.uint32(e)._push(s.write, e, t) : this._push(d, 1, 0);\n            }, p.prototype.fork = function() {\n                return this.states = new l(this), this.head = this.tail = new u(c, 0, 0), this.len = 0, this;\n            }, p.prototype.reset = function() {\n                return this.states ? (this.head = this.states.head, this.tail = this.states.tail, this.len = this.states.len, this.states = this.states.next) : (this.head = this.tail = new u(c, 0, 0), this.len = 0), this;\n            }, p.prototype.ldelim = function() {\n                var t = this.head, e = this.tail, n = this.len;\n                return this.reset().uint32(n), n && (this.tail.next = t.next, this.tail = e, this.len += n), this;\n            }, p.prototype.finish = function() {\n                for(var t = this.head.next, e = this.constructor.alloc(this.len), n = 0; t;)t.fn(t.val, e, n), n += t.len, t = t.next;\n                return e;\n            }, p._configure = function(t) {\n                r = t, p.create = f(), r._configure();\n            };\n        },\n        3155: (t, e, n)=>{\n            \"use strict\";\n            t.exports = o;\n            var r = n(1173);\n            (o.prototype = Object.create(r.prototype)).constructor = o;\n            var i = n(9693);\n            function o() {\n                r.call(this);\n            }\n            function a(t, e, n) {\n                t.length < 40 ? i.utf8.write(t, e, n) : e.utf8Write ? e.utf8Write(t, n) : e.write(t, n);\n            }\n            o._configure = function() {\n                o.alloc = i._Buffer_allocUnsafe, o.writeBytesBuffer = i.Buffer && i.Buffer.prototype instanceof Uint8Array && \"set\" === i.Buffer.prototype.set.name ? function(t, e, n) {\n                    e.set(t, n);\n                } : function(t, e, n) {\n                    if (t.copy) t.copy(e, n, 0, t.length);\n                    else for(var r = 0; r < t.length;)e[n++] = t[r++];\n                };\n            }, o.prototype.bytes = function(t) {\n                i.isString(t) && (t = i._Buffer_from(t, \"base64\"));\n                var e = t.length >>> 0;\n                return this.uint32(e), e && this._push(o.writeBytesBuffer, e, t), this;\n            }, o.prototype.string = function(t) {\n                var e = i.Buffer.byteLength(t);\n                return this.uint32(e), e && this._push(a, e, t), this;\n            }, o._configure();\n        },\n        7714: (t, e, n)=>{\n            \"use strict\";\n            e.R = void 0;\n            const r = n(6919), i = n(7448);\n            e.R = new class {\n                async init() {}\n                async createSessionHandler(t, e) {\n                    const n = new r.Session(e);\n                    return await n.loadModel(t), new i.OnnxjsSessionHandler(n);\n                }\n            };\n        },\n        4200: (t, e, n)=>{\n            \"use strict\";\n            e.c8 = e.rX = void 0;\n            const r = n(6207), i = n(9719), o = n(2157), a = n(2306);\n            e.rX = ()=>{\n                if ((\"number\" != typeof r.env.wasm.initTimeout || r.env.wasm.initTimeout < 0) && (r.env.wasm.initTimeout = 0), \"boolean\" != typeof r.env.wasm.simd && (r.env.wasm.simd = !0), \"boolean\" != typeof r.env.wasm.proxy && (r.env.wasm.proxy = !1), \"number\" != typeof r.env.wasm.numThreads || !Number.isInteger(r.env.wasm.numThreads) || r.env.wasm.numThreads <= 0) {\n                    const t = \"undefined\" == typeof navigator ? (0, i.cpus)().length : navigator.hardwareConcurrency;\n                    r.env.wasm.numThreads = Math.min(4, Math.ceil((t || 1) / 2));\n                }\n            }, e.c8 = new class {\n                async init() {\n                    (0, e.rX)(), await (0, o.initWasm)();\n                }\n                async createSessionHandler(t, e) {\n                    const n = new a.OnnxruntimeWebAssemblySessionHandler;\n                    return await n.loadModel(t, e), Promise.resolve(n);\n                }\n            };\n        },\n        6018: function(t, e, n) {\n            \"use strict\";\n            var r = this && this.__createBinding || (Object.create ? function(t, e, n, r) {\n                void 0 === r && (r = n);\n                var i = Object.getOwnPropertyDescriptor(e, n);\n                i && !(\"get\" in i ? !e.__esModule : i.writable || i.configurable) || (i = {\n                    enumerable: !0,\n                    get: function() {\n                        return e[n];\n                    }\n                }), Object.defineProperty(t, r, i);\n            } : function(t, e, n, r) {\n                void 0 === r && (r = n), t[r] = e[n];\n            }), i = this && this.__exportStar || function(t, e) {\n                for(var n in t)\"default\" === n || Object.prototype.hasOwnProperty.call(e, n) || r(e, t, n);\n            };\n            Object.defineProperty(e, \"__esModule\", {\n                value: !0\n            }), i(n(6207), e);\n            const o = n(6207);\n            {\n                const t = n(7714).R;\n                (0, o.registerBackend)(\"webgl\", t, -10);\n            }\n            {\n                const t = n(4200).c8;\n                (0, o.registerBackend)(\"cpu\", t, 10), (0, o.registerBackend)(\"wasm\", t, 10), (0, o.registerBackend)(\"xnnpack\", t, 9);\n            }\n        },\n        246: (t, e)=>{\n            \"use strict\";\n            Object.defineProperty(e, \"__esModule\", {\n                value: !0\n            }), e.createAttributeWithCacheKey = void 0;\n            class n {\n                constructor(t){\n                    Object.assign(this, t);\n                }\n                get cacheKey() {\n                    return this._cacheKey || (this._cacheKey = Object.getOwnPropertyNames(this).sort().map((t)=>`${this[t]}`).join(\";\")), this._cacheKey;\n                }\n            }\n            e.createAttributeWithCacheKey = (t)=>new n(t);\n        },\n        7778: (t, e, n)=>{\n            \"use strict\";\n            Object.defineProperty(e, \"__esModule\", {\n                value: !0\n            }), e.Attribute = void 0;\n            const r = n(1446), i = n(9395), o = n(9162), a = n(2517);\n            var s = i.onnxruntime.experimental.fbs;\n            class u {\n                constructor(t){\n                    if (this._attributes = new Map, null != t) {\n                        for (const e of t)e instanceof r.onnx.AttributeProto ? this._attributes.set(e.name, [\n                            u.getValue(e),\n                            u.getType(e)\n                        ]) : e instanceof s.Attribute && this._attributes.set(e.name(), [\n                            u.getValue(e),\n                            u.getType(e)\n                        ]);\n                        if (this._attributes.size < t.length) throw new Error(\"duplicated attribute names\");\n                    }\n                }\n                set(t, e, n) {\n                    this._attributes.set(t, [\n                        n,\n                        e\n                    ]);\n                }\n                delete(t) {\n                    this._attributes.delete(t);\n                }\n                getFloat(t, e) {\n                    return this.get(t, \"float\", e);\n                }\n                getInt(t, e) {\n                    return this.get(t, \"int\", e);\n                }\n                getString(t, e) {\n                    return this.get(t, \"string\", e);\n                }\n                getTensor(t, e) {\n                    return this.get(t, \"tensor\", e);\n                }\n                getFloats(t, e) {\n                    return this.get(t, \"floats\", e);\n                }\n                getInts(t, e) {\n                    return this.get(t, \"ints\", e);\n                }\n                getStrings(t, e) {\n                    return this.get(t, \"strings\", e);\n                }\n                getTensors(t, e) {\n                    return this.get(t, \"tensors\", e);\n                }\n                get(t, e, n) {\n                    const r = this._attributes.get(t);\n                    if (void 0 === r) {\n                        if (void 0 !== n) return n;\n                        throw new Error(`required attribute not found: ${t}`);\n                    }\n                    if (r[1] !== e) throw new Error(`type mismatch: expected ${e} but got ${r[1]}`);\n                    return r[0];\n                }\n                static getType(t) {\n                    const e = t instanceof r.onnx.AttributeProto ? t.type : t.type();\n                    switch(e){\n                        case r.onnx.AttributeProto.AttributeType.FLOAT:\n                            return \"float\";\n                        case r.onnx.AttributeProto.AttributeType.INT:\n                            return \"int\";\n                        case r.onnx.AttributeProto.AttributeType.STRING:\n                            return \"string\";\n                        case r.onnx.AttributeProto.AttributeType.TENSOR:\n                            return \"tensor\";\n                        case r.onnx.AttributeProto.AttributeType.FLOATS:\n                            return \"floats\";\n                        case r.onnx.AttributeProto.AttributeType.INTS:\n                            return \"ints\";\n                        case r.onnx.AttributeProto.AttributeType.STRINGS:\n                            return \"strings\";\n                        case r.onnx.AttributeProto.AttributeType.TENSORS:\n                            return \"tensors\";\n                        default:\n                            throw new Error(`attribute type is not supported yet: ${r.onnx.AttributeProto.AttributeType[e]}`);\n                    }\n                }\n                static getValue(t) {\n                    const e = t instanceof r.onnx.AttributeProto ? t.type : t.type();\n                    if (e === r.onnx.AttributeProto.AttributeType.GRAPH || e === r.onnx.AttributeProto.AttributeType.GRAPHS) throw new Error(\"graph attribute is not supported yet\");\n                    const n = this.getValueNoCheck(t);\n                    if (e === r.onnx.AttributeProto.AttributeType.INT && a.LongUtil.isLong(n)) return a.LongUtil.longToNumber(n);\n                    if (e === r.onnx.AttributeProto.AttributeType.INTS) {\n                        const t = n, e = new Array(t.length);\n                        for(let n = 0; n < t.length; n++){\n                            const r = t[n];\n                            e[n] = a.LongUtil.longToNumber(r);\n                        }\n                        return e;\n                    }\n                    if (e === r.onnx.AttributeProto.AttributeType.TENSOR) return t instanceof r.onnx.AttributeProto ? o.Tensor.fromProto(n) : o.Tensor.fromOrtTensor(n);\n                    if (e === r.onnx.AttributeProto.AttributeType.TENSORS) {\n                        if (t instanceof r.onnx.AttributeProto) return n.map((t)=>o.Tensor.fromProto(t));\n                        if (t instanceof s.Attribute) return n.map((t)=>o.Tensor.fromOrtTensor(t));\n                    }\n                    if (e === r.onnx.AttributeProto.AttributeType.STRING && t instanceof r.onnx.AttributeProto) {\n                        const t = n;\n                        return (0, a.decodeUtf8String)(t);\n                    }\n                    return e === r.onnx.AttributeProto.AttributeType.STRINGS && t instanceof r.onnx.AttributeProto ? n.map(a.decodeUtf8String) : n;\n                }\n                static getValueNoCheck(t) {\n                    return t instanceof r.onnx.AttributeProto ? this.getValueNoCheckFromOnnxFormat(t) : this.getValueNoCheckFromOrtFormat(t);\n                }\n                static getValueNoCheckFromOnnxFormat(t) {\n                    switch(t.type){\n                        case r.onnx.AttributeProto.AttributeType.FLOAT:\n                            return t.f;\n                        case r.onnx.AttributeProto.AttributeType.INT:\n                            return t.i;\n                        case r.onnx.AttributeProto.AttributeType.STRING:\n                            return t.s;\n                        case r.onnx.AttributeProto.AttributeType.TENSOR:\n                            return t.t;\n                        case r.onnx.AttributeProto.AttributeType.GRAPH:\n                            return t.g;\n                        case r.onnx.AttributeProto.AttributeType.FLOATS:\n                            return t.floats;\n                        case r.onnx.AttributeProto.AttributeType.INTS:\n                            return t.ints;\n                        case r.onnx.AttributeProto.AttributeType.STRINGS:\n                            return t.strings;\n                        case r.onnx.AttributeProto.AttributeType.TENSORS:\n                            return t.tensors;\n                        case r.onnx.AttributeProto.AttributeType.GRAPHS:\n                            return t.graphs;\n                        default:\n                            throw new Error(`unsupported attribute type: ${r.onnx.AttributeProto.AttributeType[t.type]}`);\n                    }\n                }\n                static getValueNoCheckFromOrtFormat(t) {\n                    switch(t.type()){\n                        case s.AttributeType.FLOAT:\n                            return t.f();\n                        case s.AttributeType.INT:\n                            return t.i();\n                        case s.AttributeType.STRING:\n                            return t.s();\n                        case s.AttributeType.TENSOR:\n                            return t.t();\n                        case s.AttributeType.GRAPH:\n                            return t.g();\n                        case s.AttributeType.FLOATS:\n                            return t.floatsArray();\n                        case s.AttributeType.INTS:\n                            {\n                                const e = [];\n                                for(let n = 0; n < t.intsLength(); n++)e.push(t.ints(n));\n                                return e;\n                            }\n                        case s.AttributeType.STRINGS:\n                            {\n                                const e = [];\n                                for(let n = 0; n < t.stringsLength(); n++)e.push(t.strings(n));\n                                return e;\n                            }\n                        case s.AttributeType.TENSORS:\n                            {\n                                const e = [];\n                                for(let n = 0; n < t.tensorsLength(); n++)e.push(t.tensors(n));\n                                return e;\n                            }\n                        default:\n                            throw new Error(`unsupported attribute type: ${s.AttributeType[t.type()]}`);\n                    }\n                }\n            }\n            e.Attribute = u;\n        },\n        7091: (t, e, n)=>{\n            \"use strict\";\n            Object.defineProperty(e, \"__esModule\", {\n                value: !0\n            }), e.resolveBackend = e.backend = void 0;\n            const r = n(5038), i = new Map;\n            async function o(t) {\n                const n = e.backend;\n                if (void 0 !== n[t] && function(t) {\n                    const e = t;\n                    return \"initialize\" in e && \"function\" == typeof e.initialize && \"createSessionHandler\" in e && \"function\" == typeof e.createSessionHandler && \"dispose\" in e && \"function\" == typeof e.dispose;\n                }(n[t])) {\n                    const e = n[t];\n                    let r = e.initialize();\n                    if (\"object\" == typeof r && \"then\" in r && (r = await r), r) return i.set(t, e), e;\n                }\n            }\n            e.backend = {\n                webgl: new r.WebGLBackend\n            }, e.resolveBackend = async function t(e) {\n                if (!e) return t([\n                    \"webgl\"\n                ]);\n                {\n                    const t = \"string\" == typeof e ? [\n                        e\n                    ] : e;\n                    for (const e of t){\n                        const t = i.get(e);\n                        if (t) return t;\n                        const n = await o(e);\n                        if (n) return n;\n                    }\n                }\n                throw new Error(\"no available backend to use\");\n            };\n        },\n        5038: (t, e, n)=>{\n            \"use strict\";\n            Object.defineProperty(e, \"__esModule\", {\n                value: !0\n            }), e.WebGLBackend = void 0;\n            const r = n(6207), i = n(3694), o = n(6416), a = n(7305);\n            e.WebGLBackend = class {\n                get contextId() {\n                    return r.env.webgl.contextId;\n                }\n                set contextId(t) {\n                    r.env.webgl.contextId = t;\n                }\n                get matmulMaxBatchSize() {\n                    return r.env.webgl.matmulMaxBatchSize;\n                }\n                set matmulMaxBatchSize(t) {\n                    r.env.webgl.matmulMaxBatchSize = t;\n                }\n                get textureCacheMode() {\n                    return r.env.webgl.textureCacheMode;\n                }\n                set textureCacheMode(t) {\n                    r.env.webgl.textureCacheMode = t;\n                }\n                get pack() {\n                    return r.env.webgl.pack;\n                }\n                set pack(t) {\n                    r.env.webgl.pack = t;\n                }\n                get async() {\n                    return r.env.webgl.async;\n                }\n                set async(t) {\n                    r.env.webgl.async = t;\n                }\n                initialize() {\n                    try {\n                        return this.glContext = (0, a.createWebGLContext)(this.contextId), \"number\" != typeof this.matmulMaxBatchSize && (this.matmulMaxBatchSize = 16), \"string\" != typeof this.textureCacheMode && (this.textureCacheMode = \"full\"), \"boolean\" != typeof this.pack && (this.pack = !1), \"boolean\" != typeof this.async && (this.async = !1), i.Logger.setWithEnv(r.env), i.Logger.verbose(\"WebGLBackend\", `Created WebGLContext: ${typeof this.glContext} with matmulMaxBatchSize: ${this.matmulMaxBatchSize}; textureCacheMode: ${this.textureCacheMode}; pack: ${this.pack}; async: ${this.async}.`), !0;\n                    } catch (t) {\n                        return i.Logger.warning(\"WebGLBackend\", `Unable to initialize WebGLBackend. ${t}`), !1;\n                    }\n                }\n                createSessionHandler(t) {\n                    return new o.WebGLSessionHandler(this, t);\n                }\n                dispose() {\n                    this.glContext.dispose();\n                }\n            };\n        },\n        5107: (t, e, n)=>{\n            \"use strict\";\n            Object.defineProperty(e, \"__esModule\", {\n                value: !0\n            }), e.CoordsGlslLib = void 0;\n            const r = n(2517), i = n(8520), o = n(5060), a = n(7859), s = n(9390);\n            class u extends i.GlslLib {\n                constructor(t){\n                    super(t);\n                }\n                getFunctions() {\n                    return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, this.offsetToCoords()), this.coordsToOffset()), this.toVec()), this.valueFrom()), this.getCommonUtilFuncs()), this.getInputsSamplingSnippets()), this.getOutputSamplingSnippet());\n                }\n                getCustomTypes() {\n                    return {};\n                }\n                offsetToCoords() {\n                    return {\n                        offsetToCoords: new i.GlslLibRoutine(\"\\n      vec2 offsetToCoords(int offset, int width, int height) {\\n        int t = offset / width;\\n        int s = offset - t*width;\\n        vec2 coords = (vec2(s,t) + vec2(0.5,0.5)) / vec2(width, height);\\n        return coords;\\n      }\\n      \")\n                    };\n                }\n                coordsToOffset() {\n                    return {\n                        coordsToOffset: new i.GlslLibRoutine(\"\\n      int coordsToOffset(vec2 coords, int width, int height) {\\n        float s = coords.s * float(width);\\n        float t = coords.t * float(height);\\n        int offset = int(t) * width + int(s);\\n        return offset;\\n      }\\n      \")\n                    };\n                }\n                getOutputSamplingSnippet() {\n                    const t = this.context.outputTextureLayout;\n                    return t.isPacked ? this.getPackedOutputSamplingSnippet(t) : this.getUnpackedOutputSamplingSnippet(t);\n                }\n                getPackedOutputSamplingSnippet(t) {\n                    const e = t.unpackedShape, n = [\n                        t.width,\n                        t.height\n                    ], r = {}, a = \"getOutputCoords\";\n                    switch(e.length){\n                        case 0:\n                            r[a] = this.getOutputScalarCoords();\n                            break;\n                        case 1:\n                            r[a] = this.getOutputPacked1DCoords(e, n);\n                            break;\n                        case 2:\n                            r[a] = this.getOutputPacked2DCoords(e, n);\n                            break;\n                        case 3:\n                            r[a] = this.getOutputPacked3DCoords(e, n);\n                            break;\n                        default:\n                            r[a] = this.getOutputPackedNDCoords(e, n);\n                    }\n                    const s = `\\n      void setOutput(vec4 val) {\\n        ${(0, o.getGlsl)(this.context.glContext.version).output} = val;\\n      }\\n    `;\n                    return r.floatTextureSetRGBA = new i.GlslLibRoutine(s), r;\n                }\n                getUnpackedOutputSamplingSnippet(t) {\n                    const e = t.unpackedShape, n = [\n                        t.width,\n                        t.height\n                    ], r = {}, a = \"getOutputCoords\";\n                    switch(e.length){\n                        case 0:\n                            r[a] = this.getOutputScalarCoords();\n                            break;\n                        case 1:\n                            r[a] = this.getOutputUnpacked1DCoords(e, n);\n                            break;\n                        case 2:\n                            r[a] = this.getOutputUnpacked2DCoords(e, n);\n                            break;\n                        case 3:\n                            r[a] = this.getOutputUnpacked3DCoords(e, n);\n                            break;\n                        case 4:\n                            r[a] = this.getOutputUnpacked4DCoords(e, n);\n                            break;\n                        case 5:\n                            r[a] = this.getOutputUnpacked5DCoords(e, n);\n                            break;\n                        case 6:\n                            r[a] = this.getOutputUnpacked6DCoords(e, n);\n                            break;\n                        default:\n                            throw new Error(`Unsupported output dimensionality: ${e.length}`);\n                    }\n                    const s = `\\n        void setOutput(float val) {\\n          ${(0, o.getGlsl)(this.context.glContext.version).output} = vec4(val, 0, 0, 0);\\n        }\\n    `;\n                    return r.floatTextureSetR = new i.GlslLibRoutine(s), r;\n                }\n                getOutputScalarCoords() {\n                    return new i.GlslLibRoutine(\"\\n      int getOutputCoords() {\\n        return 0;\\n      }\\n    \");\n                }\n                getOutputPacked1DCoords(t, e) {\n                    const n = e;\n                    let r = \"\";\n                    return 1 === n[0] ? (r = `\\n          int getOutputCoords() {\\n            return 2 * int(TexCoords.y * ${n[1]}.0);\\n          }\\n        `, new i.GlslLibRoutine(r)) : 1 === n[1] ? (r = `\\n          int getOutputCoords() {\\n            return 2 * int(TexCoords.x * ${n[0]}.0);\\n          }\\n        `, new i.GlslLibRoutine(r)) : (r = `\\n        int getOutputCoords() {\\n          ivec2 resTexRC = ivec2(TexCoords.xy *\\n                                 vec2(${n[0]}, ${n[1]}));\\n          return 2 * (resTexRC.y * ${n[0]} + resTexRC.x);\\n        }\\n      `, new i.GlslLibRoutine(r));\n                }\n                getOutputPacked2DCoords(t, e) {\n                    let n = \"\";\n                    if (r.ArrayUtil.arraysEqual(t, e)) return n = `\\n        ivec2 getOutputCoords() {\\n          return 2 * ivec2(TexCoords.xy * vec2(${e[0]}, ${e[1]}));\\n        }\\n      `, new i.GlslLibRoutine(n);\n                    const o = e, a = Math.ceil(t[1] / 2);\n                    return n = `\\n        ivec2 getOutputCoords() {\\n          ivec2 resTexRC = ivec2(TexCoords.xy *\\n                                vec2(${o[0]}, ${o[1]}));\\n\\n          int index = resTexRC.y * ${o[0]} + resTexRC.x;\\n\\n          // reverse r and c order for packed texture\\n          int r = imod(index, ${a}) * 2;\\n          int c = 2 * (index / ${a});\\n\\n          return ivec2(r, c);\\n        }\\n      `, new i.GlslLibRoutine(n);\n                }\n                getOutputPacked3DCoords(t, e) {\n                    const n = [\n                        e[0],\n                        e[1]\n                    ], r = Math.ceil(t[2] / 2), o = r * Math.ceil(t[1] / 2), a = `\\n        ivec3 getOutputCoords() {\\n          ivec2 resTexRC = ivec2(TexCoords.xy *\\n                                vec2(${n[0]}, ${n[1]}));\\n          int index = resTexRC.y * ${n[0]} + resTexRC.x;\\n\\n          int b = index / ${o};\\n          index -= b * ${o};\\n\\n          // reverse r and c order for packed texture\\n          int r = imod(index, ${r}) * 2;\\n          int c = 2 * (index / ${r});\\n\\n          return ivec3(b, r, c);\\n        }\\n      `;\n                    return new i.GlslLibRoutine(a);\n                }\n                getOutputPackedNDCoords(t, e) {\n                    const n = [\n                        e[0],\n                        e[1]\n                    ], r = Math.ceil(t[t.length - 1] / 2), o = r * Math.ceil(t[t.length - 2] / 2);\n                    let a = o, s = \"\", u = \"b, r, c\";\n                    for(let e = 2; e < t.length - 1; e++)a *= t[t.length - e - 1], s = `\\n      int b${e} = index / ${a};\\n      index -= b${e} * ${a};\\n    ` + s, u = `b${e}, ` + u;\n                    const c = `\\n      ivec${t.length} getOutputCoords() {\\n        ivec2 resTexRC = ivec2(TexCoords.xy *\\n                              vec2(${n[0]}, ${n[1]}));\\n        int index = resTexRC.y * ${n[0]} + resTexRC.x;\\n\\n        ${s}\\n\\n        int b = index / ${o};\\n        index -= b * ${o};\\n\\n        // reverse r and c order for packed texture\\n        int r = imod(index, ${r}) * 2;\\n        int c = 2 * (index / ${r});\\n\\n        return ivec${t.length}(${u});\\n      }\\n    `;\n                    return new i.GlslLibRoutine(c);\n                }\n                getOutputUnpacked1DCoords(t, e) {\n                    const n = `\\n        int getOutputCoords() {\\n          ivec2 resTexRC = ivec2(TexCoords.xy *\\n                                vec2(${e[0]}, ${e[1]}));\\n          return resTexRC.y * ${e[0]} + resTexRC.x;\\n        }\\n      `;\n                    return new i.GlslLibRoutine(n);\n                }\n                getOutputUnpacked2DCoords(t, e) {\n                    const n = `\\n        ivec2 getOutputCoords() {\\n          ivec2 resTexRC = ivec2(TexCoords.xy *\\n                                vec2(${e[0]}, ${e[1]}));\\n          int index = resTexRC.y * ${e[0]} + resTexRC.x;\\n          int r = index / ${t[1]};\\n          int c = index - r * ${t[1]};\\n          return ivec2(r, c);\\n        }\\n      `;\n                    return new i.GlslLibRoutine(n);\n                }\n                getOutputUnpacked3DCoords(t, e) {\n                    let n = \"\";\n                    const r = t.length;\n                    let o = null;\n                    r < 2 && (o = []), o = new Array(r - 1), o[r - 2] = t[r - 1];\n                    for(let e = r - 3; e >= 0; --e)o[e] = o[e + 1] * t[e + 1];\n                    const a = [\n                        \"r\",\n                        \"c\",\n                        \"d\"\n                    ], s = o.map((t, e)=>`int ${a[e]} = index / ${t}; ${e === o.length - 1 ? `int ${a[e + 1]} = index - ${a[e]} * ${t}` : `index -= ${a[e]} * ${t}`};`).join(\"\");\n                    return n = `\\n        ivec3 getOutputCoords() {\\n          ivec2 resTexRC = ivec2(TexCoords.xy *\\n                                vec2(${e[0]}, ${e[1]}));\\n          int index = resTexRC.y * ${e[0]} + resTexRC.x;\\n          ${s}\\n          return ivec3(r, c, d);\\n        }\\n      `, new i.GlslLibRoutine(n);\n                }\n                getOutputUnpacked4DCoords(t, e) {\n                    let n = \"\";\n                    const r = t.length;\n                    let o = null;\n                    r < 2 && (o = []), o = new Array(r - 1), o[r - 2] = t[r - 1];\n                    for(let e = r - 3; e >= 0; --e)o[e] = o[e + 1] * t[e + 1];\n                    const a = [\n                        \"r\",\n                        \"c\",\n                        \"d\",\n                        \"d2\"\n                    ], s = o.map((t, e)=>`int ${a[e]} = index / ${t}; ${e === o.length - 1 ? `int ${a[e + 1]} = index - ${a[e]} * ${t}` : `index -= ${a[e]} * ${t}`};`).join(\"\");\n                    return n = `\\n      ivec4 getOutputCoords() {\\n          ivec2 resTexRC = ivec2(TexCoords.xy *\\n                                vec2(${e[0]}, ${e[1]}));\\n          int index = resTexRC.y * ${e[0]} + resTexRC.x;\\n          ${s}\\n          return ivec4(r, c, d, d2);\\n        }\\n      `, new i.GlslLibRoutine(n);\n                }\n                getOutputUnpacked5DCoords(t, e) {\n                    let n = \"\";\n                    const r = t.length;\n                    let o = null;\n                    r < 2 && (o = []), o = new Array(r - 1), o[r - 2] = t[r - 1];\n                    for(let e = r - 3; e >= 0; --e)o[e] = o[e + 1] * t[e + 1];\n                    const a = [\n                        \"r\",\n                        \"c\",\n                        \"d\",\n                        \"d2\",\n                        \"d3\"\n                    ], s = o.map((t, e)=>`int ${a[e]} = index / ${t}; ${e === o.length - 1 ? `int ${a[e + 1]} = index - ${a[e]} * ${t}` : `index -= ${a[e]} * ${t}`};`).join(\"\");\n                    return n = `\\n      ivec5 getOutputCoords() {\\n          ivec2 resTexRC = ivec2(TexCoords.xy *\\n                                vec2(${e[0]}, ${e[1]}));\\n          int index = resTexRC.y * ${e[0]} + resTexRC.x;\\n          ${s}\\n          return ivec5(r, c, d, d2, d3);\\n        }\\n      `, new i.GlslLibRoutine(n);\n                }\n                getOutputUnpacked6DCoords(t, e) {\n                    let n = \"\";\n                    const r = t.length;\n                    let o = null;\n                    r < 2 && (o = []), o = new Array(r - 1), o[r - 2] = t[r - 1];\n                    for(let e = r - 3; e >= 0; --e)o[e] = o[e + 1] * t[e + 1];\n                    const a = [\n                        \"r\",\n                        \"c\",\n                        \"d\",\n                        \"d2\",\n                        \"d3\",\n                        \"d4\"\n                    ], s = o.map((t, e)=>`int ${a[e]} = index / ${t}; ${e === o.length - 1 ? `int ${a[e + 1]} = index - ${a[e]} * ${t}` : `index -= ${a[e]} * ${t}`};`).join(\"\");\n                    return n = `\\n     ivec6 getOutputCoords() {\\n         ivec2 resTexRC = ivec2(TexCoords.xy *\\n                               vec2(${e[0]}, ${e[1]}));\\n         int index = resTexRC.y * ${e[0]} + resTexRC.x;\\n         ${s}\\n         return ivec6(r, c, d, d2, d3, d4);\\n       }\\n     `, new i.GlslLibRoutine(n);\n                }\n                getCommonUtilFuncs() {\n                    const t = {};\n                    let e = \"uvFromFlat\";\n                    t[e] = new i.GlslLibRoutine(\"\\n    vec2 uvFromFlat(int texNumR, int texNumC, int index) {\\n      int texC = index / texNumR;\\n      int texR = index - texC * texNumR;\\n      // TODO: swap texR, texC order in following function so row is corresponding to u and column is corresponding to\\n      //       v.\\n      return (vec2(texR, texC) + halfCR) / vec2(texNumR, texNumC);\\n    }\\n    \"), e = \"packedUVfrom1D\", t[e] = new i.GlslLibRoutine(\"\\n      vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\\n        int texelIndex = index / 2;\\n        int texR = texelIndex / texNumC;\\n        int texC = texelIndex - texR * texNumC;\\n        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\\n      }\\n      \"), e = \"packedUVfrom2D\", t[e] = new i.GlslLibRoutine(\"\\n      vec2 packedUVfrom2D(int texNumR, int texNumC, int texelsInLogicalRow, int row, int col) {\\n        int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\\n        int texR = texelIndex / texNumC;\\n        int texC = texelIndex - texR * texNumC;\\n        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\\n      }\\n      \"), e = \"packedUVfrom3D\", t[e] = new i.GlslLibRoutine(\"\\n      vec2 packedUVfrom3D(int texNumR, int texNumC,\\n          int texelsInBatch, int texelsInLogicalRow, int b,\\n          int row, int col) {\\n        int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\\n        int texR = index / texNumC;\\n        int texC = index - texR * texNumC;\\n        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\\n      }\\n      \"), e = \"sampleTexture\";\n                    const n = (0, o.getGlsl)(this.context.glContext.version);\n                    return t[e] = new i.GlslLibRoutine(`\\n        float sampleTexture(sampler2D textureSampler, vec2 uv) {\\n            return ${n.texture2D}(textureSampler, uv).r;\\n        }`), t;\n                }\n                getInputsSamplingSnippets() {\n                    const t = {}, e = this.context.outputTextureLayout;\n                    return this.context.programInfo.inputNames.forEach((n, r)=>{\n                        const i = this.context.inputTextureLayouts[r], o = (0, s.generateShaderFuncNameFromInputSamplerName)(n);\n                        i.isPacked ? t[o] = this.getPackedSamplerFromInput(o, n, i) : t[o] = this.getUnpackedSamplerFromInput(o, n, i);\n                        const a = (0, s.generateShaderFuncNameFromInputSamplerNameAtOutCoords)(n);\n                        i.unpackedShape.length <= e.unpackedShape.length && (i.isPacked ? t[a] = this.getPackedSamplerAtOutputCoords(a, i, e, n) : t[a] = this.getUnpackedSamplerAtOutputCoords(a, i, e, n));\n                    }), t;\n                }\n                getPackedSamplerAtOutputCoords(t, e, n, o) {\n                    const a = e.unpackedShape, u = n.unpackedShape, c = o, l = (0, s.generateShaderFuncNameFromInputSamplerName)(c), p = a.length, f = u.length, d = r.BroadcastUtil.getBroadcastDims(a, u), h = (0, s.getCoordsDataType)(f), g = f - p;\n                    let b;\n                    const m = (0, s.getGlChannels)();\n                    b = 0 === p ? \"\" : f < 2 && d.length >= 1 ? \"coords = 0;\" : d.map((t)=>`coords.${m[t + g]} = 0;`).join(\"\\n\");\n                    let y = \"\";\n                    y = f < 2 && p > 0 ? \"coords\" : a.map((t, e)=>`coords.${m[e + g]}`).join(\", \");\n                    let _ = \"return outputValue;\";\n                    const v = 1 === r.ShapeUtil.size(a), w = 1 === r.ShapeUtil.size(u);\n                    if (1 !== p || v || w) {\n                        if (v && !w) _ = 1 === f ? \"\\n          return vec4(outputValue.x, outputValue.x, 0., 0.);\\n        \" : \"\\n          return vec4(outputValue.x);\\n        \";\n                        else if (d.length) {\n                            const t = p - 2, e = p - 1;\n                            d.indexOf(t) > -1 && d.indexOf(e) > -1 ? _ = \"return vec4(outputValue.x);\" : d.indexOf(t) > -1 ? _ = \"return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);\" : d.indexOf(e) > -1 && (_ = \"return vec4(outputValue.xx, outputValue.zz);\");\n                        }\n                    } else _ = \"\\n        return vec4(outputValue.xy, outputValue.xy);\\n      \";\n                    const x = `\\n      vec4 ${t}() {\\n        ${h} coords = getOutputCoords();\\n        \\n        int lastDim = coords.${m[f - 1]};\\n        coords.${m[f - 1]} = coords.${m[f - 2]};\\n        coords.${m[f - 2]} = lastDim;\\n      \\n        ${b}\\n        vec4 outputValue = ${l}(${y});\\n        ${_}\\n      }\\n    `;\n                    return new i.GlslLibRoutine(x, [\n                        \"coordinates.getOutputCoords\"\n                    ]);\n                }\n                getUnpackedSamplerAtOutputCoords(t, e, n, o) {\n                    const a = [\n                        n.width,\n                        n.height\n                    ], u = [\n                        e.width,\n                        e.height\n                    ], c = e.unpackedShape.length, l = n.unpackedShape.length, p = e.unpackedShape, f = n.unpackedShape, d = (0, s.generateShaderFuncNameFromInputSamplerName)(o);\n                    if (c === l && r.ArrayUtil.arraysEqual(u, a)) {\n                        const e = `\\n          float ${t}() {\\n            return sampleTexture(${o}, TexCoords);\\n          }\\n        `;\n                        return new i.GlslLibRoutine(e, [\n                            \"coordinates.sampleTexture\"\n                        ]);\n                    }\n                    const h = (0, s.getCoordsDataType)(l), g = r.BroadcastUtil.getBroadcastDims(p, f), b = l - c;\n                    let m;\n                    const y = (0, s.getGlChannels)();\n                    m = 0 === c ? \"\" : l < 2 && g.length >= 1 ? \"coords = 0;\" : g.map((t)=>`coords.${y[t + b]} = 0;`).join(\"\\n\");\n                    let _ = \"\";\n                    _ = l < 2 && c > 0 ? \"coords\" : e.unpackedShape.map((t, e)=>`coords.${y[e + b]}`).join(\", \");\n                    const v = `\\n        float ${t}() {\\n          ${h} coords = getOutputCoords();\\n          ${m}\\n          return ${d}(${_});\\n        }\\n      `;\n                    return new i.GlslLibRoutine(v, [\n                        \"coordinates.getOutputCoords\"\n                    ]);\n                }\n                getPackedSamplerFromInput(t, e, n) {\n                    switch(n.unpackedShape.length){\n                        case 0:\n                            return this.getPackedSamplerScalar(t, e);\n                        case 1:\n                            return this.getPackedSampler1D(t, e, n);\n                        case 2:\n                            return this.getPackedSampler2D(t, e, n);\n                        case 3:\n                            return this.getPackedSampler3D(t, e, n);\n                        default:\n                            return this.getPackedSamplerND(t, e, n);\n                    }\n                }\n                getUnpackedSamplerFromInput(t, e, n) {\n                    const r = n.unpackedShape;\n                    switch(r.length){\n                        case 0:\n                            return this.getUnpackedSamplerScalar(t, e, n);\n                        case 1:\n                            return this.getUnpackedSampler1D(t, e, n);\n                        case 2:\n                            return this.getUnpackedSampler2D(t, e, n);\n                        case 3:\n                            return this.getUnpackedSampler3D(t, e, n);\n                        case 4:\n                            return this.getUnpackedSampler4D(t, e, n);\n                        case 5:\n                            return this.getUnpackedSampler5D(t, e, n);\n                        case 6:\n                            return this.getUnpackedSampler6D(t, e, n);\n                        default:\n                            throw new Error(`Unsupported dimension ${r.length}-D`);\n                    }\n                }\n                getPackedSamplerScalar(t, e) {\n                    const n = `\\n          vec4 ${t}() {\\n            return ${(0, o.getGlsl)(this.context.glContext.version).texture2D}(${e}, halfCR);\\n          }\\n        `;\n                    return new i.GlslLibRoutine(n);\n                }\n                getPackedSampler1D(t, e, n) {\n                    const r = [\n                        n.width,\n                        n.height\n                    ], a = [\n                        r[1],\n                        r[0]\n                    ], s = (0, o.getGlsl)(this.context.glContext.version), u = `vec4 ${t}(int index) {\\n      vec2 uv = packedUVfrom1D(\\n      ${a[0]}, ${a[1]}, index);\\n      return ${s.texture2D}(${e}, uv);\\n    }`;\n                    return new i.GlslLibRoutine(u, [\n                        \"coordinates.packedUVfrom1D\"\n                    ]);\n                }\n                getPackedSampler2D(t, e, n) {\n                    const a = n.unpackedShape, s = [\n                        n.width,\n                        n.height\n                    ], u = (0, o.getGlsl)(this.context.glContext.version), c = s[0], l = s[1];\n                    if (null != s && r.ArrayUtil.arraysEqual(a, s)) {\n                        const n = `vec4 ${t}(int row, int col) {\\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${l}.0, ${c}.0);\\n        return ${u.texture2D}(${e}, uv);\\n      }`;\n                        return new i.GlslLibRoutine(n);\n                    }\n                    const p = s, f = Math.ceil(a[1] / 2), d = `vec4 ${t}(int row, int col) {\\n      vec2 uv = packedUVfrom2D(${p[1]}, ${p[0]}, ${f}, row, col);\\n      return ${u.texture2D}(${e}, uv);\\n    }`;\n                    return new i.GlslLibRoutine(d, [\n                        \"coordinates.packedUVfrom2D\"\n                    ]);\n                }\n                getPackedSampler3D(t, e, n) {\n                    const r = n.unpackedShape, a = [\n                        n.width,\n                        n.height\n                    ], u = [\n                        a[0],\n                        a[1]\n                    ], c = (0, o.getGlsl)(this.context.glContext.version);\n                    if (1 === r[0]) {\n                        const o = r.slice(1), a = [\n                            1,\n                            2\n                        ], u = (0, s.squeezeInputShape)(r, o), c = [\n                            \"b\",\n                            \"row\",\n                            \"col\"\n                        ], l = JSON.parse(JSON.stringify(n));\n                        l.unpackedShape = u;\n                        const p = this.getPackedSamplerFromInput(t, e, l), f = `${p.routineBody}\\n      vec4 ${t}(int b, int row, int col) {\\n        return ${t}(${(0, s.getSqueezedParams)(c, a)});\\n      } `;\n                        return new i.GlslLibRoutine(f, p.dependencies);\n                    }\n                    const l = u[0], p = u[1], f = Math.ceil(r[2] / 2), d = `vec4 ${t}(int b, int row, int col) {\\n      vec2 uv = packedUVfrom3D(\\n        ${p}, ${l}, ${f * Math.ceil(r[1] / 2)}, ${f}, b, row, col);\\n      return ${c.texture2D}(${e}, uv);}`;\n                    return new i.GlslLibRoutine(d, [\n                        \"coordinates.packedUVfrom3D\"\n                    ]);\n                }\n                getPackedSamplerND(t, e, n) {\n                    const r = n.unpackedShape, a = r.length, s = [\n                        n.width,\n                        n.height\n                    ], u = (0, o.getGlsl)(this.context.glContext.version), c = [\n                        s[0],\n                        s[1]\n                    ], l = c[1], p = c[0], f = Math.ceil(r[a - 1] / 2);\n                    let d = f * Math.ceil(r[a - 2] / 2), h = \"int b, int row, int col\", g = `b * ${d} + (row / 2) * ${f} + (col / 2)`;\n                    for(let t = 2; t < a - 1; t++)h = `int b${t}, ` + h, d *= r[a - t - 1], g = `b${t} * ${d} + ` + g;\n                    const b = `vec4 ${t}(${h}) {\\n      int index = ${g};\\n      int texR = index / ${p};\\n      int texC = index - texR * ${p};\\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${p}, ${l});\\n      return ${u.texture2D}(${e}, uv);\\n    }`;\n                    return new i.GlslLibRoutine(b);\n                }\n                getUnpackedSamplerScalar(t, e, n) {\n                    const [r, o] = [\n                        n.width,\n                        n.height\n                    ];\n                    if (1 === r && 1 === o) {\n                        const n = `\\n          float ${t}() {\\n            return sampleTexture(${e}, halfCR);\\n          }\\n        `;\n                        return new i.GlslLibRoutine(n, [\n                            \"coordinates.sampleTexture\"\n                        ]);\n                    }\n                    const a = `\\n        float ${t}() {\\n          int offset_${e} = coordsToOffset(TexCoords, ${r}, ${o});\\n          vec2 uv = uvFromFlat(${r}, ${o}, offset_${e});\\n          return sampleTexture(${e}, uv);\\n        }\\n      `;\n                    return new i.GlslLibRoutine(a, [\n                        \"coordinates.uvFromFlat\",\n                        \"coordinates.sampleTexture\",\n                        \"coordinates.coordsToOffset\"\n                    ]);\n                }\n                getUnpackedSampler1D(t, e, n) {\n                    const r = n.width, o = n.height;\n                    if (1 === o && 1 === r) {\n                        const n = `\\n        float ${t}(int index) {\\n          return sampleTexture(${e}, halfCR);\\n        }\\n      `;\n                        return new i.GlslLibRoutine(n, [\n                            \"coordinates.sampleTexture\"\n                        ]);\n                    }\n                    if (1 === o) {\n                        const n = `\\n          float ${t}(int index) {\\n            vec2 uv = vec2((float(index) + 0.5) / ${r}.0, 0.5);\\n            return sampleTexture(${e}, uv);\\n          }\\n        `;\n                        return new i.GlslLibRoutine(n, [\n                            \"coordinates.sampleTexture\"\n                        ]);\n                    }\n                    if (1 === r) {\n                        const n = `\\n          float ${t}(int index) {\\n            vec2 uv = vec2(0.5, (float(index) + 0.5) / ${o}.0);\\n            return sampleTexture(${e}, uv);\\n          }\\n        `;\n                        return new i.GlslLibRoutine(n, [\n                            \"coordinates.sampleTexture\"\n                        ]);\n                    }\n                    const a = `\\n        float ${t}(int index) {\\n          vec2 uv = uvFromFlat(${r}, ${o}, index);\\n          return sampleTexture(${e}, uv);\\n        }\\n      `;\n                    return new i.GlslLibRoutine(a, [\n                        \"coordinates.uvFromFlat\",\n                        \"coordinates.sampleTexture\"\n                    ]);\n                }\n                getUnpackedSampler2D(t, e, n) {\n                    const o = n.unpackedShape, u = [\n                        n.height,\n                        n.width\n                    ];\n                    if (null != u && r.ArrayUtil.arraysEqual(o, u)) {\n                        const n = `\\n          float ${t}(int row, int col) {\\n            vec2 uv = (vec2(row, col) + halfCR) / vec2(${u[1]}.0, ${u[0]}.0);\\n            return sampleTexture(${e}, uv);\\n          }\\n        `;\n                        return new i.GlslLibRoutine(n, [\n                            \"coordinates.sampleTexture\"\n                        ]);\n                    }\n                    const { newShape: c, keptDims: l } = (0, a.squeezeShape)(o), p = c;\n                    if (p.length < o.length) {\n                        const r = (0, s.squeezeInputShape)(o, p), a = JSON.parse(JSON.stringify(n));\n                        a.unpackedShape = r;\n                        const u = [\n                            \"col\",\n                            \"row\"\n                        ], c = `\\n          ${this.getUnpackedSamplerFromInput(t, e, a).routineBody}\\n          float ${t}(int row, int col) {\\n            return ${t}(${(0, s.getSqueezedParams)(u, l)});\\n          }\\n        `;\n                        return new i.GlslLibRoutine(c, [\n                            \"coordinates.sampleTexture\"\n                        ]);\n                    }\n                    const f = u[1], d = u[0];\n                    if (1 === d) {\n                        const n = `\\n          float ${t}(int row, int col) {\\n            int offset_${e} = coordsToOffset(TexCoords, ${f}, ${d});\\n            float index = dot(vec3(row, col, offset_${e}), vec3(${o[1]}, 1, 1));\\n            vec2 uv = vec2(0.5, (index + 0.5) / ${f}.0);\\n            return sampleTexture(${e}, uv);\\n          }\\n        `;\n                        return new i.GlslLibRoutine(n, [\n                            \"coordinates.sampleTexture\",\n                            \"coordinates.coordsToOffset\"\n                        ]);\n                    }\n                    if (1 === f) {\n                        const n = `\\n          float ${t}(int row, int col) {\\n            int offset_${e} = coordsToOffset(TexCoords, ${f}, ${d});\\n            float index = dot(vec3(row, col, offset_${e}), vec3(${o[1]}, 1, 1));\\n            vec2 uv = vec2((index + 0.5) / ${d}.0, 0.5);\\n            return sampleTexture(${e}, uv);\\n          }\\n        `;\n                        return new i.GlslLibRoutine(n, [\n                            \"coordinates.sampleTexture\",\n                            \"coordinates.coordsToOffset\"\n                        ]);\n                    }\n                    const h = `\\n        float ${t}(int row, int col) {\\n          int index = col * ${o[1]} + row;\\n          vec2 uv = uvFromFlat(${f}, ${d}, index);\\n          return sampleTexture(${e}, uv);\\n        }\\n      `;\n                    return new i.GlslLibRoutine(h, [\n                        \"coordinates.uvFromFlat\",\n                        \"coordinates.sampleTexture\",\n                        \"coordinates.coordsToOffset\"\n                    ]);\n                }\n                getUnpackedSampler3D(t, e, n) {\n                    const r = n.unpackedShape, o = r[1] * r[2], u = r[2], { newShape: c, keptDims: l } = (0, a.squeezeShape)(r), p = c;\n                    if (p.length < r.length) {\n                        const o = (0, s.squeezeInputShape)(r, p), a = [\n                            \"batch\",\n                            \"col\",\n                            \"row\"\n                        ], u = JSON.parse(JSON.stringify(n));\n                        u.unpackedShape = o;\n                        const c = this.getUnpackedSamplerFromInput(t, e, u), f = l.reverse(), d = `\\n          ${c.routineBody}\\n          float ${t}(int batch, int row, int col) {\\n            return ${t}(${(0, s.getSqueezedParams)(a, f)});\\n          }\\n        `;\n                        return new i.GlslLibRoutine(d, c.dependencies);\n                    }\n                    const f = `\\n          float ${t}(int depth, int row, int col) {\\n            // Explicitly use integer operations as dot() only works on floats.\\n            int index = depth * ${o} + col * ${u} + row;\\n            vec2 uv = uvFromFlat(${n.width}, ${n.height}, index);\\n            return sampleTexture(${e}, uv);\\n          }\\n      `;\n                    return new i.GlslLibRoutine(f, [\n                        \"coordinates.uvFromFlat\",\n                        \"coordinates.sampleTexture\",\n                        \"coordinates.coordsToOffset\"\n                    ]);\n                }\n                getUnpackedSampler4D(t, e, n) {\n                    const r = n.unpackedShape, o = r[3], a = r[2] * o, s = `\\n        float ${t}(int row, int col, int depth, int depth2) {\\n          int index = row * ${r[1] * a} + col * ${a} +\\n              depth2 * ${o} + depth;\\n          vec2 uv = uvFromFlat(${n.width}, ${n.height}, index);\\n          return sampleTexture(${e}, uv);\\n        }\\n      `;\n                    return new i.GlslLibRoutine(s, [\n                        \"coordinates.uvFromFlat\",\n                        \"coordinates.sampleTexture\"\n                    ]);\n                }\n                getUnpackedSampler5D(t, e, n) {\n                    const r = n.unpackedShape, o = r[4], u = r[3] * o, c = r[2] * u, l = r[1] * c, { newShape: p, keptDims: f } = (0, a.squeezeShape)(r);\n                    if (p.length < r.length) {\n                        const o = (0, s.squeezeInputShape)(r, p), a = [\n                            \"row\",\n                            \"col\",\n                            \"depth\",\n                            \"depth2\",\n                            \"depth3\"\n                        ], u = JSON.parse(JSON.stringify(n));\n                        u.unpackedShape = o;\n                        const c = `\\n          ${this.getUnpackedSamplerFromInput(t, e, u).routineBody}\\n          float ${t}(int row, int col, int depth, int depth2, int depth3) {\\n            return ${t}(${(0, s.getSqueezedParams)(a, f)});\\n          }\\n        `;\n                        return new i.GlslLibRoutine(c, [\n                            \"coordinates.sampleTexture\",\n                            \"coordinates.uvFromFlat\"\n                        ]);\n                    }\n                    const d = `\\n        float ${t}(int row, int col, int depth, int depth2, int depth3) {\\n          int index = row * ${l} + col * ${c} + depth * ${u} +\\n          depth3 * ${o} + depth2;\\n          vec2 uv = uvFromFlat(${n.width}, ${n.height}, index);\\n          return sampleTexture(${e}, uv);\\n        }\\n      `;\n                    return new i.GlslLibRoutine(d, [\n                        \"coordinates.sampleTexture\",\n                        \"coordinates.uvFromFlat\"\n                    ]);\n                }\n                getUnpackedSampler6D(t, e, n) {\n                    const r = n.unpackedShape, o = r[5], u = r[4] * o, c = r[3] * u, l = r[2] * c, p = r[1] * l, { newShape: f, keptDims: d } = (0, a.squeezeShape)(r);\n                    if (f.length < r.length) {\n                        const o = (0, s.squeezeInputShape)(r, f), a = [\n                            \"row\",\n                            \"col\",\n                            \"depth\",\n                            \"depth2\",\n                            \"depth3\",\n                            \"depth4\"\n                        ], u = JSON.parse(JSON.stringify(n));\n                        u.unpackedShape = o;\n                        const c = `\\n            ${this.getUnpackedSamplerFromInput(t, e, u).routineBody}\\n            float ${t}(int row, int col, int depth,\\n              int depth2, int depth3, int depth4) {\\n              return ${t}(${(0, s.getSqueezedParams)(a, d)});\\n            }\\n          `;\n                        return new i.GlslLibRoutine(c, [\n                            \"coordinates.sampleTexture\",\n                            \"coordinates.uvFromFlat\"\n                        ]);\n                    }\n                    const h = `\\n          float ${t}(int row, int col, int depth,\\n            int depth2, int depth3, int depth4) {\\n            int index = row * ${p} + col * ${l} + depth * ${c} +\\n            depth2 * ${u} + depth3 * ${o} + depth4;\\n            vec2 uv = uvFromFlat(${n.width}, ${n.height}, index);\\n            return sampleTexture(${e}, uv);\\n          }\\n        `;\n                    return new i.GlslLibRoutine(h, [\n                        \"coordinates.uvFromFlat\",\n                        \"coordinates.sampleTexture\",\n                        \"coordinates.coordsToOffset\"\n                    ]);\n                }\n                toVec() {\n                    const t = this.context.outputTextureLayout, e = t.shape.length, n = t.strides, r = t.width, o = t.height, a = [];\n                    for(let t = 0; t < e - 1; ++t)a.push(`\\n        c[${t}] = offset / ${n[t]};`), a.push(`\\n        offset -= c[${t}] * ${n[t]};`);\n                    a.push(`\\n        c[${e - 1}] = offset;`);\n                    const s = `\\n      void toVec(vec2 texCoords, out int c[${e}]) {\\n        int offset = coordsToOffset(texCoords, ${r}, ${o});\\n        ${a.join(\"\")}\\n      }\\n      void toVec(int offset, out int c[${e}]) {\\n        ${a.join(\"\")}\\n      }\\n    `;\n                    return {\n                        toVec: new i.GlslLibRoutine(s, [\n                            \"coordinates.coordsToOffset\"\n                        ])\n                    };\n                }\n                valueFrom() {\n                    const t = {};\n                    return this.context.programInfo.inputNames.forEach((e, n)=>{\n                        const r = this.context.inputTextureLayouts[n], o = (r.unpackedShape.length > 0 ? r.unpackedShape : r.shape).length;\n                        let a = `_${e}`;\n                        t[a] = new i.GlslLibRoutine(this.getValueFromSingle(e, o, r.width, r.height, !1), [\n                            `shapeUtils.indicesToOffset${a}`,\n                            \"coordinates.offsetToCoords\",\n                            \"fragcolor.getColorAsFloat\"\n                        ]), a += \"_T\", t[a] = new i.GlslLibRoutine(this.getValueFromSingle(e, o, r.width, r.height, !0), [\n                            `shapeUtils.indicesToOffset${a}`,\n                            \"coordinates.offsetToCoords\",\n                            \"fragcolor.getColorAsFloat\"\n                        ]);\n                    }), t;\n                }\n                getValueFromSingle(t, e, n, r, i) {\n                    let a = `_${t}`;\n                    return i && (a += \"_T\"), `\\n        float ${a}(int m[${e}]) {\\n          int offset = indicesToOffset${a}(m);\\n          vec2 coords = offsetToCoords(offset, ${n}, ${r});\\n          float value = getColorAsFloat(${(0, o.getGlsl)(this.context.glContext.version).texture2D}(${t}, coords));\\n          return value;\\n        }\\n        `;\n                }\n                getPackedValueFrom(t, e, n, r, i) {\n                    let a = `_${t}_Pack`;\n                    return i && (a += \"_T\"), `\\n        vec4 ${a}(int m[${e}]) {\\n          int offset = indicesToOffset_${t}(m);\\n          vec2 coords = offsetToCoords(offset, ${n}, ${r});\\n          return ${(0, o.getGlsl)(this.context.glContext.version).texture2D}(${t}, coords);\\n        }\\n        `;\n                }\n            }\n            e.CoordsGlslLib = u;\n        },\n        8520: (t, e)=>{\n            \"use strict\";\n            var n;\n            Object.defineProperty(e, \"__esModule\", {\n                value: !0\n            }), e.TopologicalSortGlslRoutines = e.GlslLibRoutineNode = e.GlslLibRoutine = e.GlslLib = e.GlslContext = e.FunctionType = void 0, (n = e.FunctionType || (e.FunctionType = {}))[n.ValueBased = 0] = \"ValueBased\", n[n.Positional = 1] = \"Positional\", e.GlslContext = class {\n                constructor(t, e, n, r){\n                    this.glContext = t, this.programInfo = e, this.inputTextureLayouts = n, this.outputTextureLayout = r;\n                }\n            }, e.GlslLib = class {\n                constructor(t){\n                    this.context = t;\n                }\n            }, e.GlslLibRoutine = class {\n                constructor(t, e){\n                    this.routineBody = t, this.dependencies = e;\n                }\n            }, e.GlslLibRoutineNode = class {\n                constructor(t, e, n){\n                    this.name = t, this.dependencies = n || [], e && (this.routineBody = e);\n                }\n                addDependency(t) {\n                    t && this.dependencies.push(t);\n                }\n            }, e.TopologicalSortGlslRoutines = class {\n                static returnOrderedNodes(t) {\n                    if (!t || 0 === t.length) return [];\n                    if (1 === t.length) return t;\n                    const e = new Set, n = new Set, r = new Array;\n                    return this.createOrderedNodes(t, e, n, r), r;\n                }\n                static createOrderedNodes(t, e, n, r) {\n                    for(let i = 0; i < t.length; ++i)this.dfsTraverse(t[i], e, n, r);\n                }\n                static dfsTraverse(t, e, n, r) {\n                    if (!t || n.has(t.name)) return;\n                    if (e.has(t.name)) throw new Error(\"Cyclic dependency detected. Can't topologically sort routines needed for shader.\");\n                    e.add(t.name);\n                    const i = t.dependencies;\n                    if (i && i.length > 0) for(let t = 0; t < i.length; ++t)this.dfsTraverse(i[t], e, n, r);\n                    r.push(t), n.add(t.name), e.delete(t.name);\n                }\n            };\n        },\n        7341: (t, e, n)=>{\n            \"use strict\";\n            Object.defineProperty(e, \"__esModule\", {\n                value: !0\n            }), e.EncodingGlslLib = void 0;\n            const r = n(8520);\n            class i extends r.GlslLib {\n                constructor(t){\n                    super(t);\n                }\n                getFunctions() {\n                    return Object.assign(Object.assign({}, this.encodeFloat32()), this.decodeFloat32());\n                }\n                getCustomTypes() {\n                    return {};\n                }\n                encodeFloat32() {\n                    return {\n                        encode: new r.GlslLibRoutine(\"highp vec4 encode(highp float f) {\\n        return vec4(f, 0.0, 0.0, 0.0);\\n      }\\n        \")\n                    };\n                }\n                decodeFloat32() {\n                    return {\n                        decode: new r.GlslLibRoutine(\"highp float decode(highp vec4 rgba) {\\n        return rgba.r;\\n      }\\n        \")\n                    };\n                }\n                encodeUint8() {\n                    const t = i.isLittleEndian() ? \"rgba.rgba=rgba.abgr;\" : \"\";\n                    return {\n                        encode: new r.GlslLibRoutine(`\\n      highp vec4 encode(highp float f) {\\n        highp float F = abs(f);\\n        highp float Sign = step(0.0,-f);\\n        highp float Exponent = floor(log2(F));\\n        highp float Mantissa = (exp2(- Exponent) * F);\\n        Exponent = floor(log2(F) + 127.0) + floor(log2(Mantissa));\\n        highp vec4 rgba;\\n        rgba[0] = 128.0 * Sign  + floor(Exponent*exp2(-1.0));\\n        rgba[1] = 128.0 * mod(Exponent,2.0) + mod(floor(Mantissa*128.0),128.0);\\n        rgba[2] = floor(mod(floor(Mantissa*exp2(23.0 -8.0)),exp2(8.0)));\\n        rgba[3] = floor(exp2(23.0)*mod(Mantissa,exp2(-15.0)));\\n        ${t}\\n        rgba = rgba / 255.0; // values need to be normalized to [0,1]\\n        return rgba;\\n    }\\n        `)\n                    };\n                }\n                decodeUint8() {\n                    const t = i.isLittleEndian() ? \"rgba.rgba=rgba.abgr;\" : \"\";\n                    return {\n                        decode: new r.GlslLibRoutine(`\\n        highp float decode(highp vec4 rgba) {\\n          rgba = rgba * 255.0; // values need to be de-normalized from [0,1] to [0,255]\\n          ${t}\\n          highp float Sign = 1.0 - step(128.0,rgba[0])*2.0;\\n          highp float Exponent = 2.0 * mod(rgba[0],128.0) + step(128.0,rgba[1]) - 127.0;\\n          highp float Mantissa = mod(rgba[1],128.0)*65536.0 + rgba[2]*256.0 +rgba[3] + float(0x800000);\\n          highp float Result =  Sign * exp2(Exponent) * (Mantissa * exp2(-23.0 ));\\n          return Result;\\n      }\\n        `)\n                    };\n                }\n                static isLittleEndian() {\n                    const t = new ArrayBuffer(4), e = new Uint32Array(t), n = new Uint8Array(t);\n                    if (e[0] = 3735928559, 239 === n[0]) return !0;\n                    if (222 === n[0]) return !1;\n                    throw new Error(\"unknown endianness\");\n                }\n            }\n            e.EncodingGlslLib = i;\n        },\n        9894: (t, e, n)=>{\n            \"use strict\";\n            Object.defineProperty(e, \"__esModule\", {\n                value: !0\n            }), e.FragColorGlslLib = void 0;\n            const r = n(8520), i = n(5060);\n            class o extends r.GlslLib {\n                constructor(t){\n                    super(t);\n                }\n                getFunctions() {\n                    return Object.assign(Object.assign({}, this.setFragColor()), this.getColorAsFloat());\n                }\n                getCustomTypes() {\n                    return {};\n                }\n                setFragColor() {\n                    const t = (0, i.getGlsl)(this.context.glContext.version);\n                    return {\n                        setFragColor: new r.GlslLibRoutine(`\\n        void setFragColor(float value) {\\n            ${t.output} = encode(value);\\n        }\\n        `, [\n                            \"encoding.encode\"\n                        ])\n                    };\n                }\n                getColorAsFloat() {\n                    return {\n                        getColorAsFloat: new r.GlslLibRoutine(\"\\n        float getColorAsFloat(vec4 color) {\\n            return decode(color);\\n        }\\n        \", [\n                            \"encoding.decode\"\n                        ])\n                    };\n                }\n            }\n            e.FragColorGlslLib = o;\n        },\n        2848: (t, e)=>{\n            \"use strict\";\n            Object.defineProperty(e, \"__esModule\", {\n                value: !0\n            }), e.replaceInlines = void 0;\n            const n = /@inline[\\s\\n\\r]+(\\w+)[\\s\\n\\r]+([0-9a-zA-Z_]+)\\s*\\(([^)]*)\\)\\s*{(([^}]|[\\n\\r])*)}/gm;\n            e.replaceInlines = function(t) {\n                const e = {};\n                let r;\n                for(; null !== (r = n.exec(t));){\n                    const t = r[3].split(\",\").map((t)=>{\n                        const e = t.trim().split(\" \");\n                        return e && 2 === e.length ? {\n                            type: e[0],\n                            name: e[1]\n                        } : null;\n                    }).filter((t)=>null !== t);\n                    e[r[2]] = {\n                        params: t,\n                        body: r[4]\n                    };\n                }\n                for(const n in e){\n                    const i = \"(\\\\w+)?\\\\s+([_0-9a-zA-Z]+)\\\\s+=\\\\s+__FUNC__\\\\((.*)\\\\)\\\\s*;\".replace(\"__FUNC__\", n), o = new RegExp(i, \"gm\");\n                    for(; null !== (r = o.exec(t));){\n                        const i = r[1], o = r[2], a = r[3].split(\",\"), s = i ? `${i} ${o};` : \"\";\n                        let u = e[n].body, c = \"\";\n                        e[n].params.forEach((t, e)=>{\n                            t && (c += `${t.type} ${t.name} = ${a[e]};\\n`);\n                        }), u = `${c}\\n ${u}`, u = u.replace(\"return\", `${o} = `);\n                        const l = `\\n      ${s}\\n      {\\n        ${u}\\n      }\\n      `;\n                        t = t.replace(r[0], l);\n                    }\n                }\n                return t.replace(n, \"\");\n            };\n        },\n        8879: (t, e, n)=>{\n            \"use strict\";\n            Object.defineProperty(e, \"__esModule\", {\n                value: !0\n            }), e.GlslPreprocessor = void 0;\n            const r = n(8520), i = n(2848), o = n(5483), a = n(5060);\n            e.GlslPreprocessor = class {\n                constructor(t, e, n, i){\n                    this.libs = {}, this.glslLibRoutineDependencyGraph = {}, this.context = new r.GlslContext(t, e, n, i), Object.keys(o.glslRegistry).forEach((t)=>{\n                        const e = new o.glslRegistry[t](this.context);\n                        this.libs[t] = e;\n                    });\n                    const a = this.glslLibRoutineDependencyGraph;\n                    for(const t in this.libs){\n                        const e = this.libs[t].getFunctions();\n                        for(const n in e){\n                            const i = t + \".\" + n;\n                            let o;\n                            a[i] ? (o = a[i], o.routineBody = e[n].routineBody) : (o = new r.GlslLibRoutineNode(i, e[n].routineBody), a[i] = o);\n                            const s = e[n].dependencies;\n                            if (s) for(let t = 0; t < s.length; ++t)if (a[s[t]]) o.addDependency(a[s[t]]);\n                            else {\n                                const e = new r.GlslLibRoutineNode(s[t]);\n                                a[s[t]] = e, o.addDependency(e);\n                            }\n                        }\n                    }\n                }\n                preprocess() {\n                    const t = this.context.programInfo;\n                    let e = t.shaderSource;\n                    return this.context.programInfo.hasMain || (e = `${e}\\n      ${(0, a.getDefaultFragShaderMain)(this.context.glContext.version, this.context.outputTextureLayout.shape.length)}`), e = (0, i.replaceInlines)(e), `${(0, a.getFragShaderPreamble)(this.context.glContext.version)}\\n    ${this.getUniforms(t.inputNames, t.variables)}\\n    ${this.getImports(e)}\\n    ${e}`;\n                }\n                getImports(t) {\n                    const e = this.selectGlslLibRoutinesToBeIncluded(t);\n                    if (0 === e.length) return \"\";\n                    let n = \"\";\n                    for(let t = 0; t < e.length; ++t){\n                        if (!e[t].routineBody) throw new Error(`Missing body for the Glsl Library routine: ${e[t].name}`);\n                        n += e[t].routineBody + \"\\n\";\n                    }\n                    return n;\n                }\n                selectGlslLibRoutinesToBeIncluded(t) {\n                    const e = [];\n                    return Object.keys(this.glslLibRoutineDependencyGraph).forEach((n)=>{\n                        const r = n.split(\".\")[1];\n                        -1 !== t.indexOf(r) && e.push(this.glslLibRoutineDependencyGraph[n]);\n                    }), r.TopologicalSortGlslRoutines.returnOrderedNodes(e);\n                }\n                getUniforms(t, e) {\n                    const n = [];\n                    if (t) for (const e of t)n.push(`uniform sampler2D ${e};`);\n                    if (e) for (const t of e)n.push(`uniform ${t.type} ${t.name}${t.arrayLength ? `[${t.arrayLength}]` : \"\"};`);\n                    return n.join(\"\\n\");\n                }\n            };\n        },\n        5483: (t, e, n)=>{\n            \"use strict\";\n            Object.defineProperty(e, \"__esModule\", {\n                value: !0\n            }), e.glslRegistry = void 0;\n            const r = n(5107), i = n(7341), o = n(9894), a = n(2655), s = n(3891);\n            e.glslRegistry = {\n                encoding: i.EncodingGlslLib,\n                fragcolor: o.FragColorGlslLib,\n                vec: s.VecGlslLib,\n                shapeUtils: a.ShapeUtilsGlslLib,\n                coordinates: r.CoordsGlslLib\n            };\n        },\n        2655: (t, e, n)=>{\n            \"use strict\";\n            Object.defineProperty(e, \"__esModule\", {\n                value: !0\n            }), e.ShapeUtilsGlslLib = void 0;\n            const r = n(8520);\n            class i extends r.GlslLib {\n                constructor(t){\n                    super(t);\n                }\n                getFunctions() {\n                    return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, this.bcastIndex()), this.bcastMatmulIndex()), this.offsetToIndices()), this.indicesToOffset()), this.incrementIndices());\n                }\n                getCustomTypes() {\n                    return {};\n                }\n                bcastIndex() {\n                    const t = this.context.outputTextureLayout.shape.length, e = {};\n                    return this.context.programInfo.inputNames.forEach((n, i)=>{\n                        const o = this.context.inputTextureLayouts[i].unpackedShape;\n                        if (o.length <= t) {\n                            const i = o.length, a = t - i, s = `bcastIndices_${n}`;\n                            let u = \"\";\n                            for(let t = 0; t < i; ++t)u += `\\n          realIndices[${t}] = int( mod(float(bcastedIndices[${a + t}]), ${o[t]}.0) );\\n          `;\n                            const c = `\\n        void ${s} (int bcastedIndices[${t}], out int realIndices[${i}]) {\\n          ${u}\\n        }\\n        `;\n                            e[s] = new r.GlslLibRoutine(c);\n                        }\n                    }), e;\n                }\n                bcastMatmulIndex() {\n                    const t = this.context.outputTextureLayout.shape.length, e = {};\n                    return this.context.programInfo.inputNames.forEach((n, i)=>{\n                        const o = this.context.inputTextureLayouts[i].shape;\n                        if (!(o.length < 2 || o.length > t)) {\n                            const i = o.length, a = t - i, s = `bcastMatmulIndices_${n}`;\n                            let u = \"\";\n                            for(let t = 0; t < i - 2; ++t)u += `\\n          realIndices[${t}] = int( mod(float(bcastedIndices[${a + t}]), ${o[t]}.0) );\\n          `;\n                            const c = `\\n        void ${s}(int bcastedIndices[${t}], out int realIndices[${i}]) {\\n          ${u}\\n          realIndices[${i - 1}] = bcastedIndices[${t - 1}];\\n          realIndices[${i - 2}] = bcastedIndices[${t - 2}];\\n        }\\n        `;\n                            e[s] = new r.GlslLibRoutine(c);\n                        }\n                    }), e;\n                }\n                indicesToOffset() {\n                    const t = {};\n                    return this.context.programInfo.inputNames.forEach((e, n)=>{\n                        const o = this.context.inputTextureLayouts[n].shape, a = this.context.inputTextureLayouts[n].strides, s = o.length;\n                        let u = `indicesToOffset_${e}`;\n                        t[u] = new r.GlslLibRoutine(i.indexToOffsetSingle(u, s, a)), u = `indicesToOffset_${e}_T`, t[u] = new r.GlslLibRoutine(i.indexToOffsetSingle(u, s, a.slice().reverse()));\n                    }), t;\n                }\n                static indexToOffsetSingle(t, e, n) {\n                    let r = \"\";\n                    for(let t = e - 1; t >= 0; --t)r += `\\n        offset += indices[${t}] * ${n[t]};\\n        `;\n                    return `\\n      int ${t}(int indices[${e}]) {\\n        int offset = 0;\\n        ${r}\\n        return offset;\\n      }\\n      `;\n                }\n                offsetToIndices() {\n                    const t = {};\n                    return this.context.programInfo.inputNames.forEach((e, n)=>{\n                        const o = this.context.inputTextureLayouts[n].shape, a = this.context.inputTextureLayouts[n].strides, s = o.length;\n                        let u = `offsetToIndices_${e}`;\n                        t[u] = new r.GlslLibRoutine(i.offsetToIndicesSingle(u, s, a)), u = `offsetToIndices_${e}_T`, t[u] = new r.GlslLibRoutine(i.offsetToIndicesSingle(u, s, a.slice().reverse()));\n                    }), t;\n                }\n                static offsetToIndicesSingle(t, e, n) {\n                    const r = [];\n                    for(let t = 0; t < e - 1; ++t)r.push(`\\n      indices[${t}] = offset / ${n[t]};`), r.push(`\\n        offset -= indices[${t}] * ${n[t]};`);\n                    return r.push(`\\n      indices[${e - 1}] = offset;`), `\\n      void ${t}(int offset, out int indices[${e}]) {\\n        ${r.join(\"\")}\\n      }\\n      `;\n                }\n                incrementIndices() {\n                    const t = {};\n                    return this.context.programInfo.inputNames.forEach((e, n)=>{\n                        const i = this.context.inputTextureLayouts[n].shape, o = i.length, a = `incrementIndices_${e}`;\n                        let s = \"\";\n                        for(let t = 0; t < o; ++t)s += `\\n        shape[${t}] = ${i[t]};`;\n                        const u = `\\n        void ${a}(int axis, out int indices[${o}]) {\\n          int shape[${o}];\\n          ${s};\\n          for(int i = ${o} -1 ; i >= 0; --i) {\\n            if(i > axis) continue;\\n            indices[i] += 1;\\n            if(indices[i] < shape[i]) {\\n              break;\\n            }\\n            indices[i] = 0;\\n          }\\n        }\\n        `;\n                        t[a] = new r.GlslLibRoutine(u);\n                    }), t;\n                }\n            }\n            e.ShapeUtilsGlslLib = i;\n        },\n        5060: (t, e)=>{\n            \"use strict\";\n            Object.defineProperty(e, \"__esModule\", {\n                value: !0\n            }), e.getDefaultFragShaderMain = e.getFragShaderPreamble = e.getVertexShaderSource = e.getGlsl = void 0;\n            const n = {\n                version: \"\",\n                attribute: \"attribute\",\n                varyingVertex: \"varying\",\n                varyingFrag: \"varying\",\n                texture2D: \"texture2D\",\n                output: \"gl_FragColor\",\n                outputDeclaration: \"\"\n            }, r = {\n                version: \"#version 300 es\",\n                attribute: \"in\",\n                varyingVertex: \"out\",\n                varyingFrag: \"in\",\n                texture2D: \"texture\",\n                output: \"outputColor\",\n                outputDeclaration: \"out vec4 outputColor;\"\n            };\n            function i(t) {\n                return 1 === t ? n : r;\n            }\n            e.getGlsl = i, e.getVertexShaderSource = function(t) {\n                const e = i(t);\n                return `${e.version}\\n      precision highp float;\\n      ${e.attribute} vec3 position;\\n      ${e.attribute} vec2 textureCoord;\\n\\n      ${e.varyingVertex} vec2 TexCoords;\\n\\n      void main()\\n      {\\n          gl_Position = vec4(position, 1.0);\\n          TexCoords = textureCoord;\\n      }`;\n            }, e.getFragShaderPreamble = function(t) {\n                const e = i(t);\n                return `${e.version}\\n    precision highp float;\\n    precision highp int;\\n    precision highp sampler2D;\\n    ${e.varyingFrag} vec2 TexCoords;\\n    ${e.outputDeclaration}\\n    const vec2 halfCR = vec2(0.5, 0.5);\\n\\n    // Custom vector types to handle higher dimenalities.\\n    struct ivec5\\n    {\\n      int x;\\n      int y;\\n      int z;\\n      int w;\\n      int u;\\n    };\\n\\n    struct ivec6\\n    {\\n      int x;\\n      int y;\\n      int z;\\n      int w;\\n      int u;\\n      int v;\\n    };\\n\\n    int imod(int x, int y) {\\n      return x - y * (x / y);\\n    }\\n\\n    `;\n            }, e.getDefaultFragShaderMain = function(t, e) {\n                return `\\n  void main() {\\n    int indices[${e}];\\n    toVec(TexCoords, indices);\\n    vec4 result = vec4(process(indices));\\n    ${i(t).output} = result;\\n  }\\n  `;\n            };\n        },\n        3891: (t, e, n)=>{\n            \"use strict\";\n            Object.defineProperty(e, \"__esModule\", {\n                value: !0\n            }), e.VecGlslLib = void 0;\n            const r = n(8520);\n            class i extends r.GlslLib {\n                constructor(t){\n                    super(t);\n                }\n                getCustomTypes() {\n                    return {};\n                }\n                getFunctions() {\n                    return Object.assign(Object.assign(Object.assign(Object.assign({}, this.binaryVecFunctions()), this.copyVec()), this.setVecItem()), this.getVecItem());\n                }\n                binaryVecFunctions() {\n                    const t = this.context.outputTextureLayout.shape.length, e = {\n                        add: \"+=\",\n                        sub: \"-=\",\n                        mul: \"*=\",\n                        div: \"/=\"\n                    }, n = {};\n                    for(const i in e){\n                        const o = `${i}Vec`;\n                        let a = \"\";\n                        for(let n = 0; n < t; ++n)a += `\\n          dest[${n}] ${e[i]} src[${n}];\\n          `;\n                        const s = `\\n        void ${o}(int src[${t}], out int dest[${t}]) {\\n          ${a}\\n        }\\n        `;\n                        n[o] = new r.GlslLibRoutine(s);\n                    }\n                    return n;\n                }\n                copyVec() {\n                    const t = this.context.outputTextureLayout.shape.length;\n                    let e = \"\";\n                    for(let n = 0; n < t; ++n)e += `\\n        dest[${n}] = src[${n}];\\n        `;\n                    const n = `\\n      void copyVec(int src[${t}], out int dest[${t}]) {\\n        ${e}\\n      }\\n      `;\n                    return {\n                        copyVec: new r.GlslLibRoutine(n)\n                    };\n                }\n                setVecItem() {\n                    const t = this.context.outputTextureLayout.shape.length;\n                    let e = `\\n        if(index < 0)\\n            index =${t} + index;\\n        if (index == 0)\\n            m[0] = value;\\n        `;\n                    for(let n = 1; n < t - 1; ++n)e += `\\n        else if (index == ${n})\\n            m[${n}] = value;\\n            `;\n                    e += `\\n        else\\n            m[${t - 1}] = value;\\n        `;\n                    const n = `\\n      void setVecItem(out int m[${t}], int index, int value) {\\n        ${e}\\n      }\\n        `;\n                    return {\n                        setVecItem: new r.GlslLibRoutine(n)\n                    };\n                }\n                getVecItem() {\n                    const t = this.context.outputTextureLayout.shape.length;\n                    let e = `\\n        if(index < 0)\\n            index = ${t} + index;\\n        if (index == 0)\\n            return m[0];\\n      `;\n                    for(let n = 1; n < t - 1; ++n)e += `\\n        else if (index == ${n})\\n            return m[${n}];\\n      `;\n                    e += `\\n        else\\n            return m[${t - 1}];\\n        `;\n                    const n = `\\n      int getVecItem(int m[${t}], int index) {\\n        ${e}\\n      }\\n    `;\n                    return {\n                        getVecItem: new r.GlslLibRoutine(n)\n                    };\n                }\n            }\n            e.VecGlslLib = i;\n        },\n        8316: (t, e, n)=>{\n            \"use strict\";\n            Object.defineProperty(e, \"__esModule\", {\n                value: !0\n            }), e.WebGLInferenceHandler = void 0;\n            const r = n(3694), i = n(9162), o = n(2517), a = n(2403), s = n(7019), u = n(8710), c = n(5611), l = n(4057), p = n(2039);\n            e.WebGLInferenceHandler = class {\n                constructor(t){\n                    this.session = t, this.packedTextureDataCache = new Map, this.unpackedTextureDataCache = new Map;\n                }\n                calculateTextureWidthAndHeight(t, e) {\n                    return (0, l.calculateTextureWidthAndHeight)(this.session.layoutStrategy, t, e);\n                }\n                executeProgram(t, e) {\n                    if (e.length < t.inputNames.length) throw new Error(`Input size mustn't be less than ${t.inputNames.length}.`);\n                    if (t.inputNames.length !== t.inputTypes.length) throw new Error(\"input names size does not match input types\");\n                    const n = [];\n                    for(let r = 0; r < t.inputNames.length; ++r)n[r] = this.getOrCreateTextureData(e[r], t.inputTypes[r]);\n                    const r = ((t, e)=>{\n                        const n = e.map((t)=>`${t.unpackedShape.join(\",\")};${t.width}x${t.height}`).join(\"_\");\n                        let r = t.name;\n                        return t.cacheHint && (r += \"[\" + t.cacheHint + \"]\"), r += \":\" + n, r;\n                    })(t, n);\n                    let i = this.session.programManager.getArtifact(r);\n                    const o = i ? i.programInfo : \"function\" == typeof t.get ? t.get() : t, a = (0, l.createTextureLayoutFromTextureType)(this.session.layoutStrategy, o.output.dims, o.output.textureType), s = this.createTextureData(a, o.output.type);\n                    return i || (i = this.session.programManager.build(o, n, s), this.session.programManager.setArtifact(r, i)), this.runProgram(i, n, s), s;\n                }\n                run(t, e) {\n                    return this.executeProgram(t, e).tensor;\n                }\n                runProgram(t, e, n) {\n                    for(let n = 0; n < e.length; ++n)if (!!e[n].isPacked != (t.programInfo.inputTypes[n] === p.TextureType.packed)) throw new Error(`input[${n}] property packed inconsistent`);\n                    if (!!n.isPacked != (t.programInfo.output.textureType === p.TextureType.packed)) throw new Error(\"output property packed inconsistent\");\n                    this.session.programManager.run(t, e, n);\n                }\n                getOrCreateTextureData(t, e) {\n                    let n = this.getTextureData(t.dataId, e === p.TextureType.packed);\n                    if (!n && (n = this.getTextureData(t.dataId, e !== p.TextureType.packed), n)) return e === p.TextureType.packed ? this.pack(n) : this.unpack(n);\n                    if (!n) {\n                        const r = (0, l.createTextureLayoutFromTextureType)(this.session.layoutStrategy, t.dims, e);\n                        if (e === p.TextureType.packedLastDimension) {\n                            const n = 1, r = 4, i = t.dims;\n                            if (4 === i.length) {\n                                const o = [\n                                    i[0],\n                                    Math.ceil(i[1] * i[2] * i[3] / r)\n                                ], a = (0, l.createTextureLayoutFromTextureType)(this.session.layoutStrategy, o, e);\n                                let s = t.numberData;\n                                if (i[1] * i[2] * i[3] % r != 0) {\n                                    const e = i[0], o = i[1] * i[2] * i[3], a = Math.ceil(o * n / r) * r;\n                                    s = new Float32Array(e * a);\n                                    for(let r = 0; r < e; ++r){\n                                        const e = r * o, i = r * a + r % n * o;\n                                        s.set(t.numberData.subarray(e, e + o), i);\n                                    }\n                                }\n                                return this.createTextureData(a, t.type, s, t, 1);\n                            }\n                        }\n                        if (e === p.TextureType.packed) {\n                            const e = (0, l.createTextureLayoutFromShape)(this.session.layoutStrategy, t.dims, 1, [], {\n                                reverseWH: !0\n                            }), r = this.createTextureData(e, t.type, t.numberData, t, 1);\n                            n = this.pack(r);\n                        } else n = this.createTextureData(r, t.type, t.numberData, t, 1);\n                    }\n                    return n;\n                }\n                createTextureDataFromLayoutBindTensor(t, e, n, r) {\n                    return this.createTextureData(t, e, n, r, 1);\n                }\n                createTextureData(t, e, n, i, o) {\n                    r.Logger.verbose(\"InferenceHandler\", `Creating TextureData: layout:[${JSON.stringify(t)}]`);\n                    const a = this.session.textureManager.createTextureFromLayout(e, t, n, o);\n                    return this.createTextureDataFromTexture(t, e, a, i);\n                }\n                reshapeUnpacked(t, e) {\n                    const n = this.getOrCreateTextureData(t, p.TextureType.unpacked), r = {\n                        channels: n.channels,\n                        height: n.height,\n                        width: n.width,\n                        shape: 0 !== e.length ? e : [\n                            1\n                        ],\n                        strides: o.ShapeUtil.computeStrides(e),\n                        unpackedShape: e\n                    };\n                    return this.createTextureDataFromTexture(r, t.type, n.texture).tensor;\n                }\n                reshapePacked(t, e) {\n                    const n = this.getOrCreateTextureData(t, p.TextureType.packed);\n                    if ((0, s.isReshapeCheap)(t.dims, e)) {\n                        const r = {\n                            channels: n.channels,\n                            height: n.height,\n                            width: n.width,\n                            shape: 0 !== e.length ? e : [\n                                1\n                            ],\n                            strides: o.ShapeUtil.computeStrides(e),\n                            unpackedShape: e,\n                            isPacked: !0\n                        };\n                        return this.createTextureDataFromTexture(r, t.type, n.texture).tensor;\n                    }\n                    const r = (0, s.processDims3D)(t.dims), i = (0, s.processDims3D)(e), a = this.reshapePacked(t, r), u = this.run((0, s.createPackedReshape3DProgramInfoLoader)(this, a, i), [\n                        a\n                    ]);\n                    return this.reshapePacked(u, e);\n                }\n                cast(t, e) {\n                    const n = this.getOrCreateTextureData(t, p.TextureType.unpacked);\n                    return this.createTextureDataFromTexture(n, e, n.texture).tensor;\n                }\n                createTextureDataFromTexture(t, e, n, r, o) {\n                    const a = Object.assign(Object.assign({}, t), {\n                        tensor: r || new i.Tensor(t.unpackedShape, e, (t)=>this.readTexture(a), async (t)=>this.readTextureAsync(a), void 0, o),\n                        texture: n\n                    });\n                    return this.setTextureData(a.tensor.dataId, a, t.isPacked), a;\n                }\n                getTextureData(t, e = !1) {\n                    return this.session.isInitializer(t) ? this.session.getTextureData(t, e) : e ? this.packedTextureDataCache.get(t) : this.unpackedTextureDataCache.get(t);\n                }\n                setTextureData(t, e, n = !1) {\n                    this.session.isInitializer(t) ? this.session.setTextureData(t, e, n) : (n ? this.packedTextureDataCache : this.unpackedTextureDataCache).set(t, e);\n                }\n                isTextureLayoutCached(t, e = !1) {\n                    return !!this.getTextureData(t.dataId, e);\n                }\n                dispose() {\n                    this.session.textureManager.clearActiveTextures(), this.packedTextureDataCache.forEach((t)=>this.session.textureManager.releaseTexture(t)), this.packedTextureDataCache = new Map, this.unpackedTextureDataCache.forEach((t)=>this.session.textureManager.releaseTexture(t)), this.unpackedTextureDataCache = new Map;\n                }\n                readTexture(t) {\n                    return t.isPacked ? this.readTexture(this.unpack(t)) : this.session.backend.glContext.isFloat32DownloadSupported ? this.session.textureManager.readTexture(t, t.tensor.type, t.channels) : this.session.textureManager.readUint8TextureAsFloat((0, u.encodeAsUint8)(this, t));\n                }\n                async readTextureAsync(t) {\n                    return t.isPacked ? this.readTextureAsync(this.unpack(t)) : this.session.backend.glContext.isFloat32DownloadSupported ? this.session.textureManager.readTextureAsync(t, t.tensor.type, t.channels) : this.session.textureManager.readUint8TextureAsFloat((0, u.encodeAsUint8)(this, t));\n                }\n                pack(t) {\n                    return this.executeProgram((0, a.createPackProgramInfoLoader)(this, t.tensor), [\n                        t.tensor\n                    ]);\n                }\n                unpack(t) {\n                    return this.executeProgram((0, c.createUnpackProgramInfoLoader)(this, t.tensor), [\n                        t.tensor\n                    ]);\n                }\n            };\n        },\n        1640: function(t, e, n) {\n            \"use strict\";\n            var r = this && this.__createBinding || (Object.create ? function(t, e, n, r) {\n                void 0 === r && (r = n);\n                var i = Object.getOwnPropertyDescriptor(e, n);\n                i && !(\"get\" in i ? !e.__esModule : i.writable || i.configurable) || (i = {\n                    enumerable: !0,\n                    get: function() {\n                        return e[n];\n                    }\n                }), Object.defineProperty(t, r, i);\n            } : function(t, e, n, r) {\n                void 0 === r && (r = n), t[r] = e[n];\n            }), i = this && this.__setModuleDefault || (Object.create ? function(t, e) {\n                Object.defineProperty(t, \"default\", {\n                    enumerable: !0,\n                    value: e\n                });\n            } : function(t, e) {\n                t.default = e;\n            }), o = this && this.__importStar || function(t) {\n                if (t && t.__esModule) return t;\n                var e = {};\n                if (null != t) for(var n in t)\"default\" !== n && Object.prototype.hasOwnProperty.call(t, n) && r(e, t, n);\n                return i(e, t), e;\n            };\n            Object.defineProperty(e, \"__esModule\", {\n                value: !0\n            }), e.WEBGL_OP_RESOLVE_RULES = void 0;\n            const a = n(2898), s = o(n(7839)), u = n(4196), c = n(2069), l = n(8138), p = n(9663), f = n(5193), d = n(7992), h = n(1253), g = n(4776), b = n(6572), m = n(3346), y = n(5623), _ = n(2870), v = n(2143), w = n(4939), x = n(718), T = n(2268), S = n(8117), O = n(2278), A = n(5524), E = n(5975), I = n(3933), P = n(6558), D = n(5723), $ = n(3738), k = o(n(4909)), C = n(8428), F = n(9793);\n            e.WEBGL_OP_RESOLVE_RULES = [\n                [\n                    \"Abs\",\n                    \"\",\n                    \"6+\",\n                    k.abs\n                ],\n                [\n                    \"Acos\",\n                    \"\",\n                    \"7+\",\n                    k.acos\n                ],\n                [\n                    \"Add\",\n                    \"\",\n                    \"7+\",\n                    s.add\n                ],\n                [\n                    \"And\",\n                    \"\",\n                    \"7+\",\n                    s.and\n                ],\n                [\n                    \"Asin\",\n                    \"\",\n                    \"7+\",\n                    k.asin\n                ],\n                [\n                    \"Atan\",\n                    \"\",\n                    \"7+\",\n                    k.atan\n                ],\n                [\n                    \"AveragePool\",\n                    \"\",\n                    \"7+\",\n                    v.averagePool,\n                    v.parseAveragePoolAttributes\n                ],\n                [\n                    \"BatchNormalization\",\n                    \"\",\n                    \"7+\",\n                    a.batchNormalization,\n                    a.parseBatchNormalizationAttributes\n                ],\n                [\n                    \"Cast\",\n                    \"\",\n                    \"6+\",\n                    u.cast,\n                    u.parseCastAttributes\n                ],\n                [\n                    \"Ceil\",\n                    \"\",\n                    \"6+\",\n                    k.ceil\n                ],\n                [\n                    \"Clip\",\n                    \"\",\n                    \"6-10\",\n                    k.clip,\n                    k.parseClipAttributes\n                ],\n                [\n                    \"Clip\",\n                    \"\",\n                    \"11+\",\n                    k.clipV11\n                ],\n                [\n                    \"Concat\",\n                    \"\",\n                    \"4+\",\n                    c.concat,\n                    c.parseConcatAttributes\n                ],\n                [\n                    \"Conv\",\n                    \"\",\n                    \"1+\",\n                    l.conv,\n                    l.parseConvAttributes\n                ],\n                [\n                    \"ConvTranspose\",\n                    \"\",\n                    \"1+\",\n                    p.convTranspose,\n                    p.parseConvTransposeAttributes\n                ],\n                [\n                    \"Cos\",\n                    \"\",\n                    \"7+\",\n                    k.cos\n                ],\n                [\n                    \"Div\",\n                    \"\",\n                    \"7+\",\n                    s.div\n                ],\n                [\n                    \"Dropout\",\n                    \"\",\n                    \"7+\",\n                    k.identity\n                ],\n                [\n                    \"DepthToSpace\",\n                    \"\",\n                    \"1+\",\n                    f.depthToSpace,\n                    f.parseDepthToSpaceAttributes\n                ],\n                [\n                    \"Equal\",\n                    \"\",\n                    \"7+\",\n                    s.equal\n                ],\n                [\n                    \"Elu\",\n                    \"\",\n                    \"6+\",\n                    k.elu,\n                    k.parseEluAttributes\n                ],\n                [\n                    \"Exp\",\n                    \"\",\n                    \"6+\",\n                    k.exp\n                ],\n                [\n                    \"Flatten\",\n                    \"\",\n                    \"1+\",\n                    d.flatten,\n                    d.parseFlattenAttributes\n                ],\n                [\n                    \"Floor\",\n                    \"\",\n                    \"6+\",\n                    k.floor\n                ],\n                [\n                    \"FusedConv\",\n                    \"com.microsoft\",\n                    \"1+\",\n                    l.conv,\n                    l.parseConvAttributes\n                ],\n                [\n                    \"Gather\",\n                    \"\",\n                    \"1+\",\n                    h.gather,\n                    h.parseGatherAttributes\n                ],\n                [\n                    \"Gemm\",\n                    \"\",\n                    \"7-10\",\n                    g.gemm,\n                    g.parseGemmAttributesV7\n                ],\n                [\n                    \"Gemm\",\n                    \"\",\n                    \"11+\",\n                    g.gemm,\n                    g.parseGemmAttributesV11\n                ],\n                [\n                    \"GlobalAveragePool\",\n                    \"\",\n                    \"1+\",\n                    v.globalAveragePool,\n                    v.parseGlobalAveragePoolAttributes\n                ],\n                [\n                    \"GlobalMaxPool\",\n                    \"\",\n                    \"1+\",\n                    v.globalMaxPool\n                ],\n                [\n                    \"Greater\",\n                    \"\",\n                    \"7+\",\n                    s.greater\n                ],\n                [\n                    \"Identity\",\n                    \"\",\n                    \"1+\",\n                    k.identity\n                ],\n                [\n                    \"ImageScaler\",\n                    \"\",\n                    \"1+\",\n                    b.imageScaler,\n                    b.parseImageScalerAttributes\n                ],\n                [\n                    \"InstanceNormalization\",\n                    \"\",\n                    \"6+\",\n                    m.instanceNormalization,\n                    m.parseInstanceNormalizationAttributes\n                ],\n                [\n                    \"LeakyRelu\",\n                    \"\",\n                    \"6+\",\n                    k.leakyRelu,\n                    k.parseLeakyReluAttributes\n                ],\n                [\n                    \"Less\",\n                    \"\",\n                    \"7+\",\n                    s.less\n                ],\n                [\n                    \"Log\",\n                    \"\",\n                    \"6+\",\n                    k.log\n                ],\n                [\n                    \"MatMul\",\n                    \"\",\n                    \"1+\",\n                    y.matMul,\n                    y.parseMatMulAttributes\n                ],\n                [\n                    \"MaxPool\",\n                    \"\",\n                    \"1+\",\n                    v.maxPool,\n                    v.parseMaxPoolAttributes\n                ],\n                [\n                    \"Mul\",\n                    \"\",\n                    \"7+\",\n                    s.mul\n                ],\n                [\n                    \"Neg\",\n                    \"\",\n                    \"6+\",\n                    k.neg\n                ],\n                [\n                    \"Not\",\n                    \"\",\n                    \"1+\",\n                    k.not\n                ],\n                [\n                    \"Or\",\n                    \"\",\n                    \"7+\",\n                    s.or\n                ],\n                [\n                    \"Pad\",\n                    \"\",\n                    \"2-10\",\n                    _.padV2,\n                    _.parsePadAttributesV2\n                ],\n                [\n                    \"Pad\",\n                    \"\",\n                    \"11+\",\n                    _.padV11,\n                    _.parsePadAttributesV11\n                ],\n                [\n                    \"Pow\",\n                    \"\",\n                    \"7+\",\n                    s.pow\n                ],\n                [\n                    \"PRelu\",\n                    \"\",\n                    \"7+\",\n                    s.pRelu\n                ],\n                [\n                    \"ReduceLogSum\",\n                    \"\",\n                    \"1+\",\n                    w.reduceLogSum,\n                    w.parseReduceAttributes\n                ],\n                [\n                    \"ReduceMax\",\n                    \"\",\n                    \"1+\",\n                    w.reduceMax,\n                    w.parseReduceAttributes\n                ],\n                [\n                    \"ReduceMean\",\n                    \"\",\n                    \"1+\",\n                    w.reduceMean,\n                    w.parseReduceAttributes\n                ],\n                [\n                    \"ReduceMin\",\n                    \"\",\n                    \"1+\",\n                    w.reduceMin,\n                    w.parseReduceAttributes\n                ],\n                [\n                    \"ReduceProd\",\n                    \"\",\n                    \"1+\",\n                    w.reduceProd,\n                    w.parseReduceAttributes\n                ],\n                [\n                    \"ReduceSum\",\n                    \"\",\n                    \"1-12\",\n                    w.reduceSum,\n                    w.parseReduceAttributes\n                ],\n                [\n                    \"ReduceSumSquare\",\n                    \"\",\n                    \"1+\",\n                    w.reduceLogSumSquare,\n                    w.parseReduceAttributes\n                ],\n                [\n                    \"Relu\",\n                    \"\",\n                    \"6+\",\n                    k.relu\n                ],\n                [\n                    \"Reshape\",\n                    \"\",\n                    \"5+\",\n                    x.reshape\n                ],\n                [\n                    \"Resize\",\n                    \"\",\n                    \"10\",\n                    T.resize,\n                    T.parseResizeAttributesV10\n                ],\n                [\n                    \"Resize\",\n                    \"\",\n                    \"11+\",\n                    T.resize,\n                    T.parseResizeAttributesV11\n                ],\n                [\n                    \"Shape\",\n                    \"\",\n                    \"1+\",\n                    S.shape\n                ],\n                [\n                    \"Sigmoid\",\n                    \"\",\n                    \"6+\",\n                    k.sigmoid\n                ],\n                [\n                    \"Sin\",\n                    \"\",\n                    \"7+\",\n                    k.sin\n                ],\n                [\n                    \"Slice\",\n                    \"\",\n                    \"10+\",\n                    O.sliceV10\n                ],\n                [\n                    \"Slice\",\n                    \"\",\n                    \"1-9\",\n                    O.slice,\n                    O.parseSliceAttributes\n                ],\n                [\n                    \"Softmax\",\n                    \"\",\n                    \"1-12\",\n                    A.softmax,\n                    A.parseSoftmaxAttributes\n                ],\n                [\n                    \"Softmax\",\n                    \"\",\n                    \"13+\",\n                    A.softmaxV13,\n                    A.parseSoftmaxAttributesV13\n                ],\n                [\n                    \"Split\",\n                    \"\",\n                    \"2-12\",\n                    E.split,\n                    E.parseSplitAttributes\n                ],\n                [\n                    \"Sqrt\",\n                    \"\",\n                    \"6+\",\n                    k.sqrt\n                ],\n                [\n                    \"Squeeze\",\n                    \"\",\n                    \"1-12\",\n                    I.squeeze,\n                    I.parseSqueezeAttributes\n                ],\n                [\n                    \"Squeeze\",\n                    \"\",\n                    \"13+\",\n                    I.squeezeV13\n                ],\n                [\n                    \"Sub\",\n                    \"\",\n                    \"7+\",\n                    s.sub\n                ],\n                [\n                    \"Sum\",\n                    \"\",\n                    \"6+\",\n                    P.sum\n                ],\n                [\n                    \"Tan\",\n                    \"\",\n                    \"7+\",\n                    k.tan\n                ],\n                [\n                    \"Tanh\",\n                    \"\",\n                    \"6+\",\n                    k.tanh\n                ],\n                [\n                    \"Tile\",\n                    \"\",\n                    \"6+\",\n                    D.tile\n                ],\n                [\n                    \"Transpose\",\n                    \"\",\n                    \"1+\",\n                    $.transpose,\n                    $.parseTransposeAttributes\n                ],\n                [\n                    \"Upsample\",\n                    \"\",\n                    \"7-8\",\n                    F.upsample,\n                    F.parseUpsampleAttributesV7\n                ],\n                [\n                    \"Upsample\",\n                    \"\",\n                    \"9\",\n                    F.upsample,\n                    F.parseUpsampleAttributesV9\n                ],\n                [\n                    \"Unsqueeze\",\n                    \"\",\n                    \"1-12\",\n                    C.unsqueeze,\n                    C.parseUnsqueezeAttributes\n                ],\n                [\n                    \"Unsqueeze\",\n                    \"\",\n                    \"13+\",\n                    C.unsqueezeV13\n                ],\n                [\n                    \"Xor\",\n                    \"\",\n                    \"7+\",\n                    s.xor\n                ]\n            ];\n        },\n        2898: (t, e, n)=>{\n            \"use strict\";\n            Object.defineProperty(e, \"__esModule\", {\n                value: !0\n            }), e.parseBatchNormalizationAttributes = e.batchNormalization = void 0;\n            const r = n(246), i = n(5060), o = n(2039), a = {\n                name: \"BatchNormalization\",\n                inputNames: [\n                    \"A\",\n                    \"Scale\",\n                    \"B\",\n                    \"Mean\",\n                    \"Variance\"\n                ],\n                inputTypes: [\n                    o.TextureType.unpacked,\n                    o.TextureType.unpacked,\n                    o.TextureType.unpacked,\n                    o.TextureType.unpacked,\n                    o.TextureType.unpacked\n                ]\n            };\n            e.batchNormalization = (t, e, n)=>(u(e), [\n                    t.run(Object.assign(Object.assign({}, a), {\n                        cacheHint: n.cacheKey,\n                        get: ()=>s(t, e, n)\n                    }), e)\n                ]), e.parseBatchNormalizationAttributes = (t)=>{\n                const e = t.attributes.getFloat(\"epsilon\", 1e-5), n = t.attributes.getFloat(\"momentum\", .9), i = t.attributes.getInt(\"spatial\", 1);\n                return (0, r.createAttributeWithCacheKey)({\n                    epsilon: e,\n                    momentum: n,\n                    spatial: i\n                });\n            };\n            const s = (t, e, n)=>{\n                const r = (0, i.getGlsl)(t.session.backend.glContext.version), s = e[0].dims.length, [u, c] = t.calculateTextureWidthAndHeight(e[1].dims, o.TextureType.unpacked), l = `\\n  float process(int[${s}] indices) {\\n    vec2 position = offsetToCoords(indices[1], ${u}, ${c});\\n    float scale = getColorAsFloat(${r.texture2D}(Scale, position));\\n    float mean = getColorAsFloat(${r.texture2D}(Mean, position));\\n    float variance = getColorAsFloat(${r.texture2D}(Variance, position));\\n    float b = getColorAsFloat(${r.texture2D}(B, position));\\n\\n    return scale * ( (_A(indices) - mean) / sqrt(variance + float(${n.epsilon})) ) + b;\\n  }`;\n                return Object.assign(Object.assign({}, a), {\n                    output: {\n                        dims: e[0].dims,\n                        type: e[0].type,\n                        textureType: o.TextureType.unpacked\n                    },\n                    shaderSource: l\n                });\n            }, u = (t)=>{\n                if (!t || 5 !== t.length) throw new Error(\"BatchNormalization requires 5 inputs.\");\n                const e = t[0], n = t[1], r = t[2], i = t[3], o = t[4];\n                if (e.dims.length < 3 || 1 !== n.dims.length || 1 !== r.dims.length || 1 !== i.dims.length || 1 !== o.dims.length) throw new Error(\"invalid input shape.\");\n                if (n.dims[0] !== e.dims[1] || r.dims[0] !== e.dims[1] || i.dims[0] !== e.dims[1] || o.dims[0] !== e.dims[1]) throw new Error(\"invalid input shape.\");\n                if (\"float32\" !== e.type && \"float64\" !== e.type || \"float32\" !== n.type && \"float64\" !== n.type || \"float32\" !== r.type && \"float64\" !== r.type || \"float32\" !== i.type && \"float64\" !== i.type || \"float32\" !== o.type && \"float64\" !== o.type) throw new Error(\"invalid input tensor types.\");\n            };\n        },\n        7839: (t, e, n)=>{\n            \"use strict\";\n            Object.defineProperty(e, \"__esModule\", {\n                value: !0\n            }), e.xor = e.sub = e.pRelu = e.pow = e.or = e.mul = e.less = e.greater = e.equal = e.div = e.and = e.add = e.glslPRelu = e.glslPow = e.glslXor = e.glslOr = e.glslAnd = e.glslLess = e.glslGreater = e.glslEqual = e.glslSub = e.glslMul = e.glslDiv = e.glslAdd = void 0;\n            const r = n(2517), i = n(8520), o = n(5060), a = n(2039);\n            function s() {\n                const t = \"add_\";\n                return {\n                    body: `\\n  float ${t}(float a, float b) {\\n    return a + b;\\n  }\\n  vec4 ${t}(vec4 v1, vec4 v2) {\\n    return v1 + v2;\\n  }\\n  `,\n                    name: t,\n                    type: i.FunctionType.ValueBased\n                };\n            }\n            function u() {\n                const t = \"div_\";\n                return {\n                    body: `\\n  float ${t}(float a, float b) {\\n    return a / b;\\n  }\\n  vec4 ${t}(vec4 v1, vec4 v2) {\\n    return v1 / v2;\\n  }\\n  `,\n                    name: t,\n                    type: i.FunctionType.ValueBased\n                };\n            }\n            function c() {\n                const t = \"mul_\";\n                return {\n                    body: `\\n  float ${t}(float a, float b) {\\n    return a * b;\\n  }\\n  vec4 ${t}(vec4 v1, vec4 v2) {\\n    return v1 * v2;\\n  }\\n  `,\n                    name: t,\n                    type: i.FunctionType.ValueBased\n                };\n            }\n            function l() {\n                const t = \"sub_\";\n                return {\n                    body: `\\n  float ${t}(float a, float b) {\\n    return a - b;\\n  }\\n  vec4 ${t}(vec4 v1, vec4 v2) {\\n    return v1 - v2;\\n  }\\n  `,\n                    name: t,\n                    type: i.FunctionType.ValueBased\n                };\n            }\n            function p() {\n                const t = \"equal_\";\n                return {\n                    body: `\\n  float ${t}(float a, float b) {\\n    return float(a == b);\\n  }\\n  vec4 ${t}(vec4 v1, vec4 v2) {\\n    return vec4(equal(v1, v2));\\n  }\\n  `,\n                    name: t,\n                    type: i.FunctionType.ValueBased\n                };\n            }\n            function f() {\n                const t = \"greater_\";\n                return {\n                    body: `\\n  float ${t}(float a, float b) {\\n    return float(a > b);\\n  }\\n  vec4 ${t}(vec4 v1, vec4 v2) {\\n    return vec4( v1.r > v2.r ,\\n      v1.g > v2.g,\\n      v1.b > v2.b,\\n      v1.a > v2.a );\\n  }\\n  `,\n                    name: t,\n                    type: i.FunctionType.ValueBased\n                };\n            }\n            function d() {\n                const t = \"less_\";\n                return {\n                    body: `\\n  float ${t}(float a, float b) {\\n    return float(a < b);\\n  }\\n  vec4 ${t}(vec4 v1, vec4 v2) {\\n    return vec4( v1.r < v2.r ,\\n                v1.g < v2.g,\\n                v1.b < v2.b,\\n                v1.a < v2.a );\\n  }\\n  `,\n                    name: t,\n                    type: i.FunctionType.ValueBased\n                };\n            }\n            function h() {\n                const t = \"and_\";\n                return {\n                    body: `\\n  float ${t}(float a, float b) {\\n    return float( bool(a) && bool(b) );\\n  }\\n  vec4 ${t}(vec4 v1, vec4 v2) {\\n    bvec4 b1 = bvec4(v1);\\n    bvec4 b2 = bvec4(v2);\\n    return vec4( b1.r && b2.r ,\\n                b1.g && b2.g,\\n                b1.b && b2.b,\\n                b1.a && b2.a );\\n  }\\n  `,\n                    name: t,\n                    type: i.FunctionType.ValueBased\n                };\n            }\n            function g() {\n                const t = \"or_\";\n                return {\n                    body: `\\n  float ${t}(float a, float b) {\\n    return float( bool(a) || bool(b) );\\n  }\\n  vec4 ${t}(vec4 v1, vec4 v2) {\\n    bvec4 b1 = bvec4(v1);\\n    bvec4 b2 = bvec4(v2);\\n    return vec4( b1.r || b2.r ,\\n                b1.g || b2.g,\\n                b1.b || b2.b,\\n                b1.a || b2.a );\\n  }\\n  `,\n                    name: t,\n                    type: i.FunctionType.ValueBased\n                };\n            }\n            function b() {\n                const t = \"xor_\";\n                return {\n                    body: `\\n  float ${t}(float a, float b) {\\n    return float( bool(a) ^^ bool(b) );\\n  }\\n  vec4 ${t}(vec4 v1, vec4 v2) {\\n    bvec4 b1 = bvec4(v1);\\n    bvec4 b2 = bvec4(v2);\\n    return vec4( b1.r ^^ b2.r ,\\n                b1.g ^^ b2.g,\\n                b1.b ^^ b2.b,\\n                b1.a ^^ b2.a );\\n  }\\n  `,\n                    name: t,\n                    type: i.FunctionType.ValueBased\n                };\n            }\n            function m() {\n                return function(t) {\n                    const e = `${t}_`;\n                    return {\n                        body: `\\n  float ${e}(float a, float b) {\\n    return ${t}(a, b);\\n  }\\n  vec4 ${e}(vec4 v1, vec4 v2) {\\n    return ${t}(v1, v2);\\n  }\\n  `,\n                        name: e,\n                        type: i.FunctionType.ValueBased\n                    };\n                }(\"pow\");\n            }\n            function y() {\n                const t = \"prelu_\";\n                return {\n                    body: `\\n  float ${t}(float a, float b) {\\n    return a < 0.0 ? a * b: a;\\n  }\\n  vec4 ${t}(vec4 v1, vec4 v2) {\\n    return vec4(\\n      v1.r < 0.0 ? v1.r * v2.r: v1.r,\\n      v1.g < 0.0 ? v1.g * v2.g: v1.g,\\n      v1.b < 0.0 ? v1.b * v2.b: v1.b,\\n      v1.a < 0.0 ? v1.a * v2.a: v1.a\\n      );\\n  }\\n  `,\n                    name: t,\n                    type: i.FunctionType.ValueBased\n                };\n            }\n            e.glslAdd = s, e.glslDiv = u, e.glslMul = c, e.glslSub = l, e.glslEqual = p, e.glslGreater = f, e.glslLess = d, e.glslAnd = h, e.glslOr = g, e.glslXor = b, e.glslPow = m, e.glslPRelu = y;\n            const _ = (t, e, n, r = e[0].type, i)=>{\n                const o = t.session.pack ? a.TextureType.packed : a.TextureType.unpacked;\n                return {\n                    name: n.name,\n                    inputNames: [\n                        \"A\",\n                        \"B\"\n                    ],\n                    inputTypes: [\n                        o,\n                        o\n                    ],\n                    cacheHint: i,\n                    get: ()=>v(t, e, n, r)\n                };\n            }, v = (t, e, n, i = e[0].type)=>{\n                const s = t.session.pack ? a.TextureType.packed : a.TextureType.unpacked, u = !r.ShapeUtil.areEqual(e[0].dims, e[1].dims);\n                let c = e[0].dims;\n                const l = t.session.pack;\n                if (u) {\n                    const a = r.BroadcastUtil.calcShape(e[0].dims, e[1].dims, !1);\n                    if (!a) throw new Error(\"Can't perform binary op on the given tensors\");\n                    c = a;\n                    const u = c.length, p = 0 !== e[0].dims.length ? e[0].dims.length : 1, f = 0 !== e[1].dims.length ? e[1].dims.length : 1, d = 0 !== e[0].dims.length ? \"bcastIndices_A(indices, aindices);\" : \"aindices[0] = 0;\", h = 0 !== e[1].dims.length ? \"bcastIndices_B(indices, bindices);\" : \"bindices[0] = 0;\", g = (0, o.getGlsl)(t.session.backend.glContext.version), b = l ? `\\n      ${n.body}\\n      void main() {\\n        vec4 a = getAAtOutCoords();\\n        vec4 b = getBAtOutCoords();\\n        vec4 result = ${n.name}(a, b);\\n        ${g.output} = result;\\n      }` : `\\n      ${n.body}\\n      float process(int indices[${u}]) {\\n        int aindices[${p}];\\n        int bindices[${f}];\\n        ${d}\\n        ${h}\\n        return ${n.name}(_A(aindices), _B(bindices));\\n      }`;\n                    return {\n                        name: n.name,\n                        inputNames: [\n                            \"A\",\n                            \"B\"\n                        ],\n                        inputTypes: [\n                            s,\n                            s\n                        ],\n                        output: {\n                            dims: c,\n                            type: i,\n                            textureType: s\n                        },\n                        shaderSource: b,\n                        hasMain: l\n                    };\n                }\n                const p = (0, o.getGlsl)(t.session.backend.glContext.version), f = `\\n    ${n.body}\\n    void main() {\\n      vec4 v1 = ${p.texture2D}(A, TexCoords);\\n      vec4 v2 = ${p.texture2D}(B, TexCoords);\\n      vec4 result = ${n.name}(v1, v2);\\n      ${p.output} = result;\\n    }\\n    `;\n                return {\n                    name: n.name,\n                    inputNames: [\n                        \"A\",\n                        \"B\"\n                    ],\n                    inputTypes: [\n                        s,\n                        s\n                    ],\n                    output: {\n                        dims: e[0].dims,\n                        type: i,\n                        textureType: s\n                    },\n                    shaderSource: f,\n                    hasMain: !0\n                };\n            };\n            e.add = (t, e)=>[\n                    t.run(_(t, e, s()), e)\n                ], e.and = (t, e)=>[\n                    t.run(_(t, e, h(), \"bool\"), e)\n                ], e.div = (t, e)=>[\n                    t.run(_(t, e, u()), e)\n                ], e.equal = (t, e)=>[\n                    t.run(_(t, e, p(), \"bool\"), e)\n                ], e.greater = (t, e)=>[\n                    t.run(_(t, e, f(), \"bool\"), e)\n                ], e.less = (t, e)=>[\n                    t.run(_(t, e, d(), \"bool\"), e)\n                ], e.mul = (t, e)=>[\n                    t.run(_(t, e, c()), e)\n                ], e.or = (t, e)=>[\n                    t.run(_(t, e, g(), \"bool\"), e)\n                ], e.pow = (t, e)=>[\n                    t.run(_(t, e, m()), e)\n                ], e.pRelu = (t, e)=>[\n                    t.run(_(t, e, y()), e)\n                ], e.sub = (t, e)=>[\n                    t.run(_(t, e, l()), e)\n                ], e.xor = (t, e)=>[\n                    t.run(_(t, e, b(), \"bool\"), e)\n                ];\n        },\n        4196: (t, e, n)=>{\n            \"use strict\";\n            Object.defineProperty(e, \"__esModule\", {\n                value: !0\n            }), e.parseCastAttributes = e.cast = void 0;\n            const r = n(2517);\n            e.cast = (t, e, n)=>(i(e), [\n                    t.cast(e[0], n)\n                ]), e.parseCastAttributes = (t)=>r.ProtoUtil.tensorDataTypeFromProto(t.attributes.getInt(\"to\"));\n            const i = (t)=>{\n                if (!t || 1 !== t.length) throw new Error(\"Cast requires 1 input.\");\n                if (\"string\" === t[0].type) throw new Error(\"Invalid input type.\");\n            };\n        },\n        1163: (t, e, n)=>{\n            \"use strict\";\n            Object.defineProperty(e, \"__esModule\", {\n                value: !0\n            }), e.createPackedConcatProgramInfoLoader = void 0;\n            const r = n(5060), i = n(2039), o = n(9390), a = n(2827);\n            e.createPackedConcatProgramInfoLoader = (t, e, n)=>{\n                const u = (c = e.length, l = n.cacheKey, {\n                    name: \"Concat (packed)\",\n                    inputNames: Array.from({\n                        length: c\n                    }, (t, e)=>`X${e}`),\n                    inputTypes: Array(c).fill(i.TextureType.packed),\n                    cacheHint: l\n                });\n                var c, l;\n                return Object.assign(Object.assign({}, u), {\n                    get: ()=>((t, e, n, u)=>{\n                            const c = n[0].dims.slice();\n                            if (u >= c.length || u < -1 * c.length) throw new Error(\"axis specified for concat doesn't match input dimensionality\");\n                            u < 0 && (u = c.length + u);\n                            const l = c.slice(0);\n                            for(let t = 1; t < n.length; t++){\n                                const e = n[t].dims.slice();\n                                for(let t = 0; t < c.length; t++)if (t === u) l[u] += e[t];\n                                else if (c[t] !== e[t]) throw new Error(\"non concat dimensions must match\");\n                            }\n                            const p = l.length, f = (0, a.getChannels)(\"coords\", p), d = (0, o.getCoordsDataType)(p), h = (0, a.unpackFromChannel)(), g = n.map((t)=>t.dims), b = (0, o.getGlChannels)(p), m = new Array(g.length - 1);\n                            m[0] = g[0][u];\n                            for(let t = 1; t < m.length; t++)m[t] = m[t - 1] + g[t][u];\n                            const y = b[u], _ = b.slice(-2), v = b.join();\n                            let w = `if (${y} < ${m[0]}) {\\n        return getChannel(\\n            getX0(${v}), vec2(${_.join()}));\\n        }`;\n                            for(let t = 1; t < m.length; t++){\n                                const e = m[t - 1];\n                                w += `\\n            if (${y} < ${m[t]}  && ${y} >= ${m[t - 1]}) {\\n              return getChannel(\\n                getX${t}(${s(b, y, e)}),\\n                vec2(${s(_, y, e)}));\\n            }`;\n                            }\n                            const x = m.length, T = m[m.length - 1];\n                            w += `\\n            return getChannel(\\n              getX${x}(${s(b, y, T)}),\\n              vec2(${s(_, y, T)}));`;\n                            const S = (0, r.getGlsl)(t.session.backend.glContext.version), O = `\\n          ${h}\\n          float getValue(${b.map((t)=>\"int \" + t)}) {\\n            ${w}\\n          }\\n\\n          void main() {\\n            ${d} coords = getOutputCoords();\\n            int lastDim = coords.${b[p - 1]};\\n            coords.${b[p - 1]} = coords.${b[p - 2]};\\n            coords.${b[p - 2]} = lastDim;\\n\\n            vec4 result = vec4(getValue(${f}), 0., 0., 0.);\\n\\n            ${f[p - 1]} = ${f[p - 1]} + 1;\\n            if (${f[p - 1]} < ${l[p - 1]}) {\\n              result.g = getValue(${f});\\n            }\\n\\n            ${f[p - 2]} = ${f[p - 2]} + 1;\\n            if (${f[p - 2]} < ${l[p - 2]}) {\\n              result.a = getValue(${f});\\n            }\\n\\n            ${f[p - 1]} = ${f[p - 1]} - 1;\\n            if (${f[p - 2]} < ${l[p - 2]} &&\\n                ${f[p - 1]} < ${l[p - 1]}) {\\n              result.b = getValue(${f});\\n            }\\n            ${S.output} = result;\\n          }\\n        `;\n                            return Object.assign(Object.assign({}, e), {\n                                output: {\n                                    dims: l,\n                                    type: n[0].type,\n                                    textureType: i.TextureType.packed\n                                },\n                                shaderSource: O,\n                                hasMain: !0\n                            });\n                        })(t, u, e, n.axis)\n                });\n            };\n            const s = (t, e, n)=>{\n                const r = t.indexOf(e);\n                return t.map((t, e)=>e === r ? `${t} - ${n}` : t).join();\n            };\n        },\n        2069: (t, e, n)=>{\n            \"use strict\";\n            Object.defineProperty(e, \"__esModule\", {\n                value: !0\n            }), e.parseConcatAttributes = e.concat = void 0;\n            const r = n(246), i = n(2039), o = n(1163);\n            e.concat = (t, e, n)=>(p(e), t.session.pack && e[0].dims.length > 1 ? [\n                    t.run((0, o.createPackedConcatProgramInfoLoader)(t, e, n), e)\n                ] : [\n                    t.run(a(t, e, n), e)\n                ]);\n            const a = (t, e, n)=>{\n                const r = (o = e.length, a = n.cacheKey, {\n                    name: \"Concat\",\n                    inputNames: Array.from({\n                        length: o\n                    }, (t, e)=>`X${e}`),\n                    inputTypes: Array(o).fill(i.TextureType.unpacked),\n                    cacheHint: a\n                });\n                var o, a;\n                return Object.assign(Object.assign({}, r), {\n                    get: ()=>((t, e, n, r)=>{\n                            const o = n[0].dims.slice();\n                            if (r >= o.length || r < -1 * o.length) throw new Error(\"axis specified for concat doesn't match input dimensionality\");\n                            r < 0 && (r = o.length + r);\n                            const a = o.slice(0);\n                            for(let t = 1; t < n.length; t++){\n                                const e = n[t].dims.slice();\n                                for(let t = 0; t < o.length; t++)if (t === r) a[r] += e[t];\n                                else if (o[t] !== e[t]) throw new Error(\"non concat dimensions must match\");\n                            }\n                            const p = a.length, f = new Array(n.length);\n                            let d = 0;\n                            for(let t = 0; t < f.length; ++t)d += n[t].dims[r], f[t] = d;\n                            let h = \"\";\n                            h = n.length < 5 ? s(f) : u(f);\n                            const g = `\\n        ${c(n.length, p)}\\n        ${l(f)}\\n        ${h}\\n        float process(int indices[${p}]) {\\n          int textureIndex = getTextureWhereDataResides (indices[${r}]);\\n\\n          if(textureIndex != 0) {\\n            indices[${r}] = indices[${r}] - int(getSizeInConcatAxisValueFromIndex(textureIndex-int(1)));\\n          }\\n\\n          return fetchDataFromCorrectTexture(textureIndex, indices);\\n        }`;\n                            return Object.assign(Object.assign({}, e), {\n                                output: {\n                                    dims: a,\n                                    type: n[0].type,\n                                    textureType: i.TextureType.unpacked\n                                },\n                                shaderSource: g\n                            });\n                        })(0, r, e, n.axis)\n                });\n            }, s = (t)=>{\n                const e = t.map((t, e)=>`if(index<${t}) {return ${e};}\\n`);\n                return `int getTextureWhereDataResides(int index) {\\n      ${e.join(\"\")}\\n    }`;\n            }, u = (t)=>s(t), c = (t, e)=>{\n                const n = [\n                    `float fetchDataFromCorrectTexture(int textureIndex, int indices[${e}]) {`\n                ];\n                for(let e = 0; e < t; ++e)0 === e ? n.push(`\\tif (textureIndex == ${e}) { return _X${e}(indices); }`) : e === t - 1 ? n.push(`\\telse { return _X${e}(indices); }`) : n.push(`\\telse if (textureIndex == ${e}) { return _X${e}(indices); }`);\n                return n.push(\"\t}\"), n.join(\"\\n\");\n            }, l = (t)=>{\n                const e = [\n                    \"int getSizeInConcatAxisValueFromIndex(int index) {\"\n                ];\n                for(let n = 0; n < t.length; ++n)0 === n ? e.push(`\\tif (index == ${n}) { return ${t[n]}; }`) : n === t.length - 1 ? e.push(`\\telse { return ${t[n]}; }`) : e.push(`\\telse if (index == ${n}) { return ${t[n]}; }`);\n                return e.push(\"\t}\"), e.join(\"\\n\");\n            };\n            e.parseConcatAttributes = (t)=>(0, r.createAttributeWithCacheKey)({\n                    axis: t.attributes.getInt(\"axis\")\n                });\n            const p = (t)=>{\n                if (!t || t.length < 1) throw new Error(\"too few inputs\");\n                const e = t[0].type, n = t[0].dims.length;\n                if (\"string\" === e) throw new Error(\"string tensor is not supported yet\");\n                for (const r of t){\n                    if (r.type !== e) throw new Error(\"input tensors should be one type\");\n                    if (r.dims.length !== n) throw new Error(\"input tensors should have the same shape\");\n                }\n            };\n        },\n        4770: (t, e, n)=>{\n            \"use strict\";\n            Object.defineProperty(e, \"__esModule\", {\n                value: !0\n            }), e.createUnpackedGroupedConvProgramInfoLoader = void 0;\n            const r = n(3694), i = n(5060), o = n(2039), a = n(8138), s = n(2823);\n            e.createUnpackedGroupedConvProgramInfoLoader = (t, e, n)=>{\n                const u = (c = e.length > 2, l = n.cacheKey, {\n                    name: \"GroupedConv\",\n                    inputNames: c ? [\n                        \"X\",\n                        \"W\",\n                        \"Bias\"\n                    ] : [\n                        \"X\",\n                        \"W\"\n                    ],\n                    inputTypes: c ? [\n                        o.TextureType.unpacked,\n                        o.TextureType.unpacked,\n                        o.TextureType.unpacked\n                    ] : [\n                        o.TextureType.unpacked,\n                        o.TextureType.unpacked\n                    ],\n                    cacheHint: l\n                });\n                var c, l;\n                return Object.assign(Object.assign({}, u), {\n                    get: ()=>((t, e, n, u)=>{\n                            const c = e.length > 2 ? \"value += getBias(output_channel);\" : \"\", l = e[0].dims.slice(), p = e[1].dims.slice(), f = p[0] / u.group;\n                            r.Logger.verbose(\"GroupedConv\", `autpPad:${u.autoPad}, dilations:${u.dilations}, group:${u.group}, kernelShape:${u.kernelShape}, pads:${u.pads}, strides:${u.strides}`);\n                            const d = (0, a.calculateOutputShape)(l, p, u.dilations, u.pads, u.strides), h = (0, i.getGlsl)(t.session.backend.glContext.version), { activationFunction: g, applyActivation: b } = (0, s.getActivationSnippet)(u), m = `\\n  const ivec2 strides = ivec2(${u.strides[0]}, ${u.strides[1]});\\n  const ivec2 pads = ivec2(${u.pads[0]}, ${u.pads[1]});\\n  ${g}\\n  void main() {\\n    ivec4 coords = getOutputCoords();\\n    int batch = coords.x;\\n    int output_channel = coords.y;\\n    ivec2 xRCCorner = coords.zw * strides - pads;\\n    int group_id = output_channel / ${f};\\n\\n    float value = 0.0;\\n    for (int wInChannel = 0; wInChannel < ${p[1]}; wInChannel++) {\\n      int input_channel = group_id * ${p[1]} + wInChannel;\\n      for (int wHeight = 0; wHeight < ${p[2]}; wHeight++) {\\n        int xHeight = xRCCorner.x + wHeight * ${u.dilations[0]};\\n\\n        if (xHeight < 0 || xHeight >= ${l[2]}) {\\n          continue;\\n        }\\n\\n        for (int wWidth = 0; wWidth < ${p[3]}; wWidth++) {\\n          int xWidth = xRCCorner.y + wWidth * ${u.dilations[1]};\\n          if (xWidth < 0 || xWidth >= ${l[3]}) {\\n            continue;\\n          }\\n\\n          float xVal = getX(batch, input_channel, xWidth, xHeight);\\n          float wVal = getW(output_channel, wInChannel, wWidth, wHeight);\\n          value += xVal*wVal;\\n        }\\n      }\\n    }\\n    ${c}\\n    ${b}\\n    ${h.output} = vec4(value, .0, .0, .0);\\n  }\\n`;\n                            return Object.assign(Object.assign({}, n), {\n                                output: {\n                                    dims: d,\n                                    type: e[0].type,\n                                    textureType: o.TextureType.unpacked\n                                },\n                                shaderSource: m,\n                                hasMain: !0\n                            });\n                        })(t, e, u, n)\n                });\n            };\n        },\n        1386: (t, e, n)=>{\n            \"use strict\";\n            Object.defineProperty(e, \"__esModule\", {\n                value: !0\n            }), e.conv2DPacked = e.conv2DPackedPointwise = void 0;\n            const r = n(8138), i = n(8555), o = n(708);\n            e.conv2DPackedPointwise = (t, e, n)=>{\n                const i = e[0].dims, a = e[1].dims, s = (0, r.calculateOutputShape)(i, a, n.dilations, n.pads, n.strides), u = t.reshapePacked(e[0], [\n                    i[1],\n                    i[2] * i[3]\n                ]), c = t.reshapePacked(e[1], [\n                    a[0],\n                    a[1]\n                ]), l = e.length > 2 ? [\n                    c,\n                    u,\n                    e[2]\n                ] : [\n                    c,\n                    u\n                ], p = t.run((0, o.createPackedMatmulProgramInfoLoader)(t, l, n), l);\n                return t.reshapePacked(p, s);\n            }, e.conv2DPacked = (t, e, n)=>{\n                const a = e[0].dims, s = e[1].dims, u = (0, r.calculateOutputShape)(a, s, n.dilations, n.pads, n.strides), c = t.run((0, i.createPackedIm2ColProgramInfoLoader)(t, e[0], e[1], u, n), [\n                    e[0]\n                ]), l = t.reshapePacked(e[1], [\n                    s[0],\n                    s[1] * s[2] * s[3]\n                ]), p = 3 === e.length ? [\n                    l,\n                    c,\n                    e[2]\n                ] : [\n                    l,\n                    c\n                ], f = t.run((0, o.createPackedMatmulProgramInfoLoader)(t, p, n), p);\n                return t.reshapePacked(f, u);\n            };\n        },\n        9663: (t, e, n)=>{\n            \"use strict\";\n            Object.defineProperty(e, \"__esModule\", {\n                value: !0\n            }), e.parseConvTransposeAttributes = e.convTranspose = void 0;\n            const r = n(246), i = n(5060), o = n(2039), a = n(2823), s = (t, e, n, r, i, o)=>(t - 1) * e + n + (r - 1) * i + 1 - o, u = (t, e, n, r, i)=>{\n                const o = Math.floor(t / 2);\n                \"SAME_UPPER\" === e ? (n[r] = o, n[i] = t - o) : \"SAME_LOWER\" === e && (n[r] = t - o, n[i] = o);\n            };\n            e.convTranspose = (t, e, n)=>(f(e, n), c(t, e, n));\n            const c = (t, e, n)=>{\n                const r = p(n, e);\n                return [\n                    l(t, e, r)\n                ];\n            }, l = (t, e, n)=>t.run(((t, e, n)=>{\n                    const r = (s = e.length > 2, u = n.cacheKey, {\n                        name: \"ConvTranspose\",\n                        inputNames: s ? [\n                            \"X\",\n                            \"W\",\n                            \"B\"\n                        ] : [\n                            \"X\",\n                            \"W\"\n                        ],\n                        inputTypes: s ? [\n                            o.TextureType.unpacked,\n                            o.TextureType.unpacked,\n                            o.TextureType.unpacked\n                        ] : [\n                            o.TextureType.unpacked,\n                            o.TextureType.unpacked\n                        ],\n                        cacheHint: u\n                    });\n                    var s, u;\n                    return Object.assign(Object.assign({}, r), {\n                        get: ()=>((t, e, n, r)=>{\n                                const s = e.length > 2 ? \"getB(output_channel)\" : \"0.0\", u = e[0].dims, c = e[1].dims, l = c[1], p = c[0] / r.group, f = [\n                                    e[0].dims[0],\n                                    e[1].dims[1] * r.group,\n                                    ...r.outputShape\n                                ], d = (0, i.getGlsl)(t.session.backend.glContext.version), { activationFunction: h, applyActivation: g } = (0, a.getActivationSnippet)(r), b = `\\n  const ivec2 strides = ivec2(${r.strides[0]}, ${r.strides[1]});\\n  const ivec2 pads = ivec2(${r.pads[0]}, ${r.pads[1]});\\n  ${h}\\n  void main() {\\n    ivec4 coords = getOutputCoords();\\n    int batch = coords.x;\\n    int output_channel = coords.y;\\n\\n    ivec2 loc = coords.zw + pads;\\n\\n    int group_id = output_channel / ${l};\\n    int wOutChannel = output_channel - group_id * ${l};\\n\\n    float value = ${s};\\n    for (int inChannelOffset = 0; inChannelOffset < ${p}; inChannelOffset++) {\\n      int input_channel = group_id * ${p} + inChannelOffset;\\n      for (int wWOff = 0; wWOff < ${c[2]}; wWOff++) {\\n        for (int wHOff = 0; wHOff < ${c[3]}; wHOff++) {\\n          ivec2 wOff = ivec2(wWOff * ${r.dilations[0]}, wHOff * ${r.dilations[1]});\\n          ivec2 wLoc = loc - wOff;\\n          ivec2 wLocIn = wLoc / strides;\\n          if (\\n            wLocIn * strides == wLoc &&\\n            wLocIn.x >= 0 && wLocIn.x < ${u[2]} &&\\n            wLocIn.y >= 0 && wLocIn.y < ${u[3]}\\n          ) {\\n            float xVal = getX(batch, input_channel, wLocIn.y, wLocIn.x);\\n            float wVal = getW(input_channel, wOutChannel, wHOff, wWOff);\\n            value += xVal * wVal;\\n          }\\n        }\\n      }\\n    }\\n    ${g}\\n    ${d.output} = vec4(value, .0, .0, .0);\\n  }\\n`;\n                                return Object.assign(Object.assign({}, n), {\n                                    output: {\n                                        dims: f,\n                                        type: e[0].type,\n                                        textureType: o.TextureType.unpacked\n                                    },\n                                    shaderSource: b,\n                                    hasMain: !0\n                                });\n                            })(t, e, r, n)\n                    });\n                })(t, e, n), e), p = (t, e)=>{\n                const n = t.kernelShape.slice();\n                if (0 === t.kernelShape.length) for(let t = 2; t < e[1].dims.length; ++t)n.push(e[1].dims[t]);\n                const r = t.pads.slice(), i = t.outputShape.slice();\n                ((t, e, n, r, i, o, a, c)=>{\n                    const l = t.length - 2, p = 0 === c.length;\n                    for(let f = 0; f < l; ++f){\n                        const d = p ? t[f + 2] * o[f] : c[f], h = s(t[f + 2], o[f], i[f], e[f], n[f], d);\n                        u(h, r, i, f, f + l), p && c.push(o[f] * (t[f + 2] - 1) + a[f] + (e[f] - 1) * n[f] + 1 - i[f] - i[f + l]);\n                    }\n                })(e[0].dims, n, t.dilations, t.autoPad, r, t.strides, t.outputPadding, i);\n                const o = Object.assign({}, t);\n                return Object.assign(o, {\n                    kernelShape: n,\n                    pads: r,\n                    outputShape: i,\n                    cacheKey: t.cacheKey\n                }), o;\n            };\n            e.parseConvTransposeAttributes = (t)=>{\n                const e = t.attributes, n = (0, a.parseInternalActivationAttributes)(e), i = e.getString(\"auto_pad\", \"NOTSET\"), o = e.getInts(\"dilations\", [\n                    1,\n                    1\n                ]), s = e.getInt(\"group\", 1), u = e.getInts(\"kernel_shape\", []), c = e.getInts(\"output_padding\", [\n                    0,\n                    0\n                ]), l = e.getInts(\"output_shape\", []), p = e.getInts(\"pads\", [\n                    0,\n                    0,\n                    0,\n                    0\n                ]), f = e.getInts(\"strides\", [\n                    1,\n                    1\n                ]);\n                return (0, r.createAttributeWithCacheKey)(Object.assign({\n                    autoPad: i,\n                    dilations: o,\n                    group: s,\n                    kernelShape: u,\n                    outputPadding: c,\n                    outputShape: l,\n                    pads: p,\n                    strides: f\n                }, n));\n            };\n            const f = (t, e)=>{\n                if (!t || 2 !== t.length && 3 !== t.length) throw new Error(\"Conv requires 2 or 3 inputs\");\n                if (4 !== t[0].dims.length || 4 !== t[1].dims.length) throw new Error(\"currently only support 2-dimensional conv\");\n                if (t[0].dims[1] !== t[1].dims[0]) throw new Error(\"FILTER_IN_CHANNEL should be equal to DATA_CHANNEL\");\n                const n = t[1].dims[1] * e.group;\n                if (3 === t.length && (1 !== t[2].dims.length || t[2].dims[0] !== n)) throw new Error(\"invalid bias\");\n                const r = t[0].dims.length - 2;\n                if (e.dilations.length !== r) throw new Error(`dilations should be ${r}D`);\n                if (e.strides.length !== r) throw new Error(`strides should be ${r}D`);\n                if (e.pads.length !== 2 * r) throw new Error(`pads should be ${2 * r}D`);\n                if (e.outputPadding.length !== r) throw new Error(`output_padding should be ${r}D`);\n                if (0 !== e.kernelShape.length && e.kernelShape.length !== t[1].dims.length - 2) throw new Error(\"invalid kernel shape\");\n                if (0 !== e.outputShape.length && e.outputShape.length !== t[0].dims.length - 2) throw new Error(\"invalid output shape\");\n                if (\"float32\" !== t[0].type || \"float32\" !== t[1].type) throw new Error(\"ConvTranspose input(X,W) should be float tensor\");\n                if (3 === t.length && \"float32\" !== t[2].type) throw new Error(\"ConvTranspose input(bias) should be float tensor\");\n            };\n        },\n        8138: (t, e, n)=>{\n            \"use strict\";\n            Object.defineProperty(e, \"__esModule\", {\n                value: !0\n            }), e.parseConvAttributes = e.conv = e.calculateOutputShape = void 0;\n            const r = n(246), i = n(2517), o = n(4770), a = n(1386), s = n(9828), u = n(2823), c = n(3248), l = n(5623);\n            e.calculateOutputShape = (t, e, n, r, i)=>{\n                const o = t[0], a = t.slice(2), s = a.length, u = e[0], c = e.slice(2).map((t, e)=>t + (t - 1) * (n[e] - 1)), l = a.map((t, e)=>t + r[e] + r[e + s]), p = l.map((t, e)=>Math.floor((t - c[e] + i[e]) / i[e]));\n                return [\n                    o,\n                    u\n                ].concat(...p);\n            }, e.conv = (t, e, n)=>(g(e, n), p(t, e, n));\n            const p = (t, e, n)=>{\n                const r = h(n, e), i = t.session.pack, s = 1 === r.kernelShape[0] && 1 === r.kernelShape[1];\n                return r.group > 1 ? [\n                    t.run((0, o.createUnpackedGroupedConvProgramInfoLoader)(t, e, r), e)\n                ] : s && i ? [\n                    f(t, e, r)\n                ] : i && 4 === e[0].dims.length && 1 === e[0].dims[0] && !s ? [\n                    (0, a.conv2DPacked)(t, e, r)\n                ] : [\n                    d(t, e, r)\n                ];\n            }, f = (t, n, r)=>{\n                const i = n[0].dims, o = n[1].dims, a = (0, e.calculateOutputShape)(i, o, r.dilations, r.pads, r.strides), s = t.reshapeUnpacked(n[0], [\n                    i[1],\n                    i[2] * i[3]\n                ]), u = t.reshapeUnpacked(n[1], [\n                    o[0],\n                    o[1]\n                ]), c = n.length > 2 ? [\n                    u,\n                    s,\n                    n[2]\n                ] : [\n                    u,\n                    s\n                ], p = t.run((0, l.createMatmulProgramInfoLoader)(c, r), c);\n                return t.reshapeUnpacked(p, a);\n            }, d = (t, n, r)=>{\n                const i = n[0].dims, o = n[1].dims, a = (0, e.calculateOutputShape)(i, o, r.dilations, r.pads, r.strides), u = t.run((0, c.createIm2ColProgramInfoLoader)(t, n[0], n[1], a, r), [\n                    n[0]\n                ]), l = 3 === n.length ? [\n                    u,\n                    n[1],\n                    n[2]\n                ] : [\n                    u,\n                    n[1]\n                ];\n                return t.run((0, s.createDotProductProgramInfoLoader)(t, n, a, r), l);\n            }, h = (t, e)=>{\n                const n = t.kernelShape.slice();\n                if (0 === t.kernelShape.length) for(let t = 2; t < e[1].dims.length; ++t)n.push(e[1].dims[t]);\n                const r = t.pads.slice();\n                i.PoolConvUtil.adjustPadsBasedOnAutoPad(e[0].dims, t.strides, t.dilations, n, r, t.autoPad);\n                const o = Object.assign({}, t);\n                return Object.assign(o, {\n                    kernelShape: n,\n                    pads: r,\n                    cacheKey: t.cacheKey\n                }), o;\n            };\n            e.parseConvAttributes = (t)=>{\n                const e = t.attributes, n = (0, u.parseInternalActivationAttributes)(e), i = e.getString(\"auto_pad\", \"NOTSET\"), o = e.getInts(\"dilations\", [\n                    1,\n                    1\n                ]), a = e.getInt(\"group\", 1), s = e.getInts(\"kernel_shape\", []), c = e.getInts(\"pads\", [\n                    0,\n                    0,\n                    0,\n                    0\n                ]), l = e.getInts(\"strides\", [\n                    1,\n                    1\n                ]);\n                return (0, r.createAttributeWithCacheKey)(Object.assign({\n                    autoPad: i,\n                    dilations: o,\n                    group: a,\n                    kernelShape: s,\n                    pads: c,\n                    strides: l\n                }, n));\n            };\n            const g = (t, e)=>{\n                if (!t || 2 !== t.length && 3 !== t.length) throw new Error(\"Conv requires 2 or 3 inputs\");\n                if (4 !== t[0].dims.length || 4 !== t[1].dims.length) throw new Error(\"currently only support 2-dimensional conv\");\n                if (t[0].dims[1] !== t[1].dims[1] * e.group) throw new Error(\"FILTER_IN_CHANNEL should be equal to DATA_CHANNEL\");\n                if (3 === t.length && (1 !== t[2].dims.length || t[1].dims[0] !== t[2].dims[0])) throw new Error(\"invalid bias\");\n                const n = t[0].dims.length - 2;\n                if (e.dilations.length !== n) throw new Error(`dilations should be ${n}D`);\n                if (e.strides.length !== n) throw new Error(`strides should be ${n}D`);\n                if (e.pads.length !== 2 * n) throw new Error(`pads should be ${2 * n}D`);\n                if (0 !== e.kernelShape.length && e.kernelShape.length !== t[1].dims.length - 2) throw new Error(\"invalid kernel shape\");\n                if (\"float32\" !== t[0].type || \"float32\" !== t[1].type) throw new Error(\"Conv input(X,W) should be float tensor\");\n                if (3 === t.length && \"float32\" !== t[2].type) throw new Error(\"Conv input(bias) should be float tensor\");\n            };\n        },\n        5193: (t, e, n)=>{\n            \"use strict\";\n            Object.defineProperty(e, \"__esModule\", {\n                value: !0\n            }), e.parseDepthToSpaceAttributes = e.depthToSpace = void 0;\n            const r = n(3738);\n            e.depthToSpace = (t, e, n)=>{\n                i(e);\n                const o = n.blocksize, a = o * o, s = \"DCR\" === n.mode ? [\n                    0,\n                    3,\n                    4,\n                    1,\n                    5,\n                    2\n                ] : [\n                    0,\n                    1,\n                    4,\n                    2,\n                    5,\n                    3\n                ], u = \"DCR\" === n.mode ? [\n                    e[0].dims[0],\n                    o,\n                    o,\n                    e[0].dims[1] / a,\n                    e[0].dims[2],\n                    e[0].dims[3]\n                ] : [\n                    e[0].dims[0],\n                    e[0].dims[1] / a,\n                    o,\n                    o,\n                    e[0].dims[2],\n                    e[0].dims[3]\n                ], c = t.reshapeUnpacked(e[0], u), l = {\n                    perm: s,\n                    cacheKey: `${s}`\n                }, [p] = (0, r.transpose)(t, [\n                    c\n                ], l), f = [\n                    e[0].dims[0],\n                    e[0].dims[1] / a,\n                    e[0].dims[2] * o,\n                    e[0].dims[3] * o\n                ];\n                return [\n                    t.reshapeUnpacked(p, f)\n                ];\n            }, e.parseDepthToSpaceAttributes = (t)=>{\n                const e = t.attributes.getInt(\"blocksize\");\n                if (e < 1) throw new Error(`blocksize must be >= 1, but got : ${e} for DepthToSpace`);\n                const n = t.attributes.getString(\"mode\", \"DCR\");\n                if (\"DCR\" !== n && \"CRD\" !== n) throw new Error(`unrecognized mode: ${n} for DepthToSpace`);\n                return {\n                    mode: n,\n                    blocksize: e\n                };\n            };\n            const i = (t)=>{\n                if (1 !== t.length) throw new Error(`DepthToSpace expect 1 inputs, but got ${t.length}`);\n                if (\"string\" === t[0].type || 4 !== t[0].dims.length) throw new TypeError(\"DepthToSpace input should be a 4-D numeric tensor\");\n            };\n        },\n        9828: (t, e, n)=>{\n            \"use strict\";\n            Object.defineProperty(e, \"__esModule\", {\n                value: !0\n            }), e.createDotProductProgramInfoLoader = void 0;\n            const r = n(2517), i = n(5060), o = n(2039), a = n(2823), s = n(3248);\n            e.createDotProductProgramInfoLoader = (t, e, n, u)=>{\n                const c = ((t, e)=>({\n                        name: \"ConvDotProduct\",\n                        inputNames: t ? [\n                            \"Im2Col\",\n                            \"K\",\n                            \"B\"\n                        ] : [\n                            \"Im2Col\",\n                            \"K\"\n                        ],\n                        inputTypes: t ? [\n                            o.TextureType.unpacked,\n                            o.TextureType.packedLastDimension,\n                            o.TextureType.unpacked\n                        ] : [\n                            o.TextureType.unpacked,\n                            o.TextureType.packedLastDimension\n                        ],\n                        cacheKey: e.activationCacheKey\n                    }))(e.length > 2, u);\n                return Object.assign(Object.assign({}, c), {\n                    get: ()=>((t, e, n, u, c)=>{\n                            const l = n[0].dims, p = n[1].dims, f = [\n                                p[0],\n                                Math.ceil(l[1] * p[2] * p[3] / 4)\n                            ], d = (0, s.calculateIm2ColDims)(l, p, u), [h, g] = t.calculateTextureWidthAndHeight(f, o.TextureType.packedLastDimension), b = r.ShapeUtil.computeStrides(d), [m, y] = t.calculateTextureWidthAndHeight(d, o.TextureType.packedLastDimension), _ = u.length, v = n.length < 3 ? \"0.0\" : \"_B(b)\", w = Math.ceil(l[1] * p[2] * p[3] / 4), { activationFunction: x, applyActivation: T } = (0, a.getActivationSnippet)(c), S = (0, i.getGlsl)(t.session.backend.glContext.version), O = `\\n${x}\\nfloat process(int indices[${_}]) {\\n  int b[1];\\n  b[0] = indices[1];\\n  int im2col[4];\\n  im2col[0] = indices[0];\\n  im2col[1] = indices[2];\\n  im2col[2] = indices[3];\\n  int im2colOffset = im2col[0] * ${b[0]} + im2col[1] * ${b[1]} + im2col[2] * ${b[2]};\\n  int kernelOffset = indices[1] * ${f[1]};\\n  float value = ${v};\\n  for (int i = 0; i < ${w}; ++i) {\\n    vec2 im2colCoords = offsetToCoords(im2colOffset, ${m}, ${y});\\n    vec2 kernelCoords = offsetToCoords(kernelOffset, ${h}, ${g});\\n    value += dot(${S.texture2D}(Im2Col, im2colCoords), ${S.texture2D}(K, kernelCoords));\\n    ++im2colOffset;\\n    ++kernelOffset;\\n  }\\n  ${T}\\n  return value;\\n}`;\n                            return Object.assign(Object.assign({}, e), {\n                                output: {\n                                    dims: u,\n                                    type: n[0].type,\n                                    textureType: o.TextureType.unpacked\n                                },\n                                shaderSource: O\n                            });\n                        })(t, c, e, n, u)\n                });\n            };\n        },\n        7992: (t, e, n)=>{\n            \"use strict\";\n            Object.defineProperty(e, \"__esModule\", {\n                value: !0\n            }), e.parseFlattenAttributes = e.flatten = void 0;\n            const r = n(2517);\n            e.flatten = (t, e, n)=>{\n                i(e, n);\n                const o = r.ShapeUtil.flattenShape(e[0].dims, n);\n                return [\n                    t.reshapeUnpacked(e[0], o)\n                ];\n            }, e.parseFlattenAttributes = (t)=>t.attributes.getInt(\"axis\", 1);\n            const i = (t, e)=>{\n                if (!t || 1 !== t.length) throw new Error(\"Flatten requires 1 input.\");\n                const n = t[0].dims.length;\n                if (0 === n) throw new Error(\"scalar tensor is not supported.\");\n                if (e < -n || e > n) throw new Error(\"Invalid axis\");\n                if (\"string\" === t[0].type) throw new Error(\"string tensor is not supported.\");\n            };\n        },\n        2823: (t, e, n)=>{\n            \"use strict\";\n            Object.defineProperty(e, \"__esModule\", {\n                value: !0\n            }), e.parseInternalActivationAttributes = e.getActivationSnippet = void 0;\n            const r = n(2517), i = n(4909);\n            e.getActivationSnippet = function(t) {\n                let e;\n                switch(t.activation){\n                    case \"Relu\":\n                        e = (0, i.glslRelu)();\n                        break;\n                    case \"Sigmoid\":\n                        e = (0, i.glslSigmoid)();\n                        break;\n                    case \"Clip\":\n                        e = (0, i.glslClip)(t.clipMin, t.clipMax);\n                        break;\n                    default:\n                        return {\n                            activationFunction: \"\",\n                            applyActivation: \"\"\n                        };\n                }\n                const n = e.name;\n                return {\n                    activationFunction: e.body,\n                    applyActivation: `value = ${n}_(value);`\n                };\n            }, e.parseInternalActivationAttributes = (t)=>{\n                const e = t.getString(\"activation\", \"\");\n                if (\"Clip\" === e) {\n                    const [n, i] = t.getFloats(\"activation_params\", [\n                        r.MIN_CLIP,\n                        r.MAX_CLIP\n                    ]);\n                    return {\n                        activation: e,\n                        clipMax: i,\n                        clipMin: n,\n                        activationCacheKey: `${e}:${n},${i}`\n                    };\n                }\n                return {\n                    activation: e,\n                    activationCacheKey: e\n                };\n            };\n        },\n        1253: (t, e, n)=>{\n            \"use strict\";\n            Object.defineProperty(e, \"__esModule\", {\n                value: !0\n            }), e.parseGatherAttributes = e.gather = void 0;\n            const r = n(246), i = n(782), o = n(2517), a = n(2039);\n            e.gather = (t, e, n)=>(c(e, n.axis), [\n                    t.run(u(t, e, n), e)\n                ]), e.parseGatherAttributes = (t)=>(0, r.createAttributeWithCacheKey)({\n                    axis: t.attributes.getInt(\"axis\", 0)\n                });\n            const s = {\n                name: \"Gather\",\n                inputNames: [\n                    \"A\",\n                    \"B\"\n                ],\n                inputTypes: [\n                    a.TextureType.unpacked,\n                    a.TextureType.unpacked\n                ]\n            }, u = (t, e, n)=>{\n                const r = Object.assign(Object.assign({}, s), {\n                    cacheHint: n.cacheKey\n                });\n                return Object.assign(Object.assign({}, r), {\n                    get: ()=>((t, e, n, r)=>{\n                            const i = n[0].dims.slice(), s = n[1].dims.slice(), u = new Array(i.length + s.length - 1);\n                            r = o.ShapeUtil.normalizeAxis(r, i.length);\n                            const c = [];\n                            for(let t = 0; t < u.length; t++)t < r ? (u[t] = i[t], c.push(`inputIdx[${t}] = outputIdx[${t}];`)) : t < r + s.length ? (u[t] = s[t - r], c.push(`indexDataIdx[${t - r}] = outputIdx[${t}];`)) : (u[t] = i[t - s.length + 1], c.push(`inputIdx[${t - s.length + 1}] = outputIdx[${t}];`));\n                            const l = `\\n      float process(int outputIdx[${u.length || 1}]) {\\n        int inputIdx[${i.length}];\\n        int indexDataIdx[${s.length || 1}];\\n        indexDataIdx[0] = 0;\\n        ${c.join(\"\\n        \")}\\n        int idx = int(_B(indexDataIdx));\\n        inputIdx[${r}] = idx < 0 ? idx + ${i[r]} : idx;\\n        return _A(inputIdx);\\n      }`;\n                            return Object.assign(Object.assign({}, e), {\n                                output: {\n                                    dims: u,\n                                    type: n[0].type,\n                                    textureType: a.TextureType.unpacked\n                                },\n                                shaderSource: l\n                            });\n                        })(0, r, e, n.axis)\n                });\n            }, c = (t, e)=>{\n                if (!t || 2 !== t.length) throw new Error(\"Gather requires 2 inputs.\");\n                const n = t[0].dims.length;\n                if (n < 1) throw new Error(\"Invalid input shape.\");\n                if (e < -n || e > n - 1) throw new Error(\"Invalid axis.\");\n                if (-1 === i.NUMBER_TYPES.indexOf(t[0].type)) throw new Error(\"Invaid input type.\");\n                if (\"int32\" !== t[1].type && \"int16\" !== t[1].type) throw new Error(\"Invaid input type.\");\n            };\n        },\n        4776: (t, e, n)=>{\n            \"use strict\";\n            Object.defineProperty(e, \"__esModule\", {\n                value: !0\n            }), e.parseGemmAttributesV11 = e.parseGemmAttributesV7 = e.gemm = void 0;\n            const r = n(246), i = n(2517), o = n(2039);\n            e.gemm = (t, e, n)=>(c(e, n), [\n                    t.run(s(e, n), e)\n                ]);\n            const a = (t, e)=>{\n                const n = 0 !== t.attributes.getInt(\"transA\", 0), i = 0 !== t.attributes.getInt(\"transB\", 0), o = t.attributes.getFloat(\"alpha\", 1), a = t.attributes.getFloat(\"beta\", 1);\n                return (0, r.createAttributeWithCacheKey)({\n                    transA: n,\n                    transB: i,\n                    alpha: o,\n                    beta: a,\n                    isOptionalC: e\n                });\n            };\n            e.parseGemmAttributesV7 = (t)=>a(t, !1), e.parseGemmAttributesV11 = (t)=>a(t, !0);\n            const s = (t, e)=>{\n                const n = {\n                    name: \"Gemm\",\n                    inputNames: 3 === t.length ? [\n                        \"A\",\n                        \"B\",\n                        \"C\"\n                    ] : [\n                        \"A\",\n                        \"B\"\n                    ],\n                    inputTypes: 3 === t.length ? [\n                        o.TextureType.unpacked,\n                        o.TextureType.unpacked,\n                        o.TextureType.unpacked\n                    ] : [\n                        o.TextureType.unpacked,\n                        o.TextureType.unpacked\n                    ],\n                    key: e.cacheKey\n                };\n                return Object.assign(Object.assign({}, n), {\n                    get: ()=>u(n, t, e)\n                });\n            }, u = (t, e, n)=>{\n                const r = e[0].dims.slice(), a = e[1].dims.slice(), [s, u] = i.GemmUtil.getShapeOfGemmResult(r, n.transA, a, n.transB, 3 === e.length ? e[2].dims : void 0), c = [\n                    s,\n                    u\n                ];\n                if (!c) throw new Error(\"Can't use gemm on the given tensors\");\n                let l = r[r.length - 1], p = \"\";\n                n.transA && (l = r[0]), n.transA && n.transB ? p = \"value += _A_T(a) * _B_T(b);\" : n.transA && !n.transB ? p = \"value += _A_T(a) * _B(b);\" : !n.transA && n.transB ? p = \"value += _A(a) * _B_T(b);\" : n.transA || n.transB || (p = \"value += _A(a) * _B(b);\");\n                const f = c.length, d = `\\n      float process(int indices[${f}]) {\\n          int a[${f}];\\n          int b[${f}];\\n          ${3 === e.length ? `int c[${e[2].dims.length}];` : \"\"}\\n\\n          copyVec(indices, a);\\n          copyVec(indices, b);\\n          ${3 === e.length ? \"bcastIndices_C(indices, c);\" : \"\"}\\n\\n          float value = 0.0;\\n          for (int k=0; k<${l}; ++k) {\\n              a[${f - 1}] = k;\\n              b[${f - 2}] = k;\\n              ${p}\\n          }\\n\\n          value = value * alpha;\\n          ${3 === e.length ? \"value += beta * _C(c);\" : \"\"}\\n          return value;\\n      }`;\n                return Object.assign(Object.assign({}, t), {\n                    output: {\n                        dims: c,\n                        type: e[0].type,\n                        textureType: o.TextureType.unpacked\n                    },\n                    variables: [\n                        {\n                            name: \"alpha\",\n                            type: \"float\",\n                            data: n.alpha\n                        },\n                        {\n                            name: \"beta\",\n                            type: \"float\",\n                            data: n.beta\n                        }\n                    ],\n                    shaderSource: d\n                });\n            }, c = (t, e)=>{\n                if (!t) throw new Error(\"Input is missing\");\n                if (e.isOptionalC && (t.length < 2 || t.length > 3)) throw new Error(\"Invaid input shape.\");\n                if (!e.isOptionalC && 3 !== t.length) throw new Error(\"Gemm requires 3 inputs\");\n                if (3 === t.length && 1 !== t[2].dims.length && 2 !== t[2].dims.length) throw new Error(\"Invalid input shape of C\");\n                if (\"float32\" !== t[0].type && \"float64\" !== t[0].type || \"float32\" !== t[1].type && \"float64\" !== t[1].type || 3 === t.length && \"float32\" !== t[2].type && \"float64\" !== t[2].type) throw new Error(\"Invalid input type.\");\n                if (t[0].type !== t[1].type || 3 === t.length && t[0].type !== t[2].type) throw new Error(\"Input types are mismatched\");\n            };\n        },\n        8555: (t, e, n)=>{\n            \"use strict\";\n            Object.defineProperty(e, \"__esModule\", {\n                value: !0\n            }), e.createPackedIm2ColProgramInfoLoader = void 0;\n            const r = n(5060), i = n(2039), o = n(2827);\n            e.createPackedIm2ColProgramInfoLoader = (t, e, n, a, s)=>{\n                const u = (c = s.cacheKey, {\n                    name: \"Im2Col (packed)\",\n                    inputNames: [\n                        \"A\"\n                    ],\n                    inputTypes: [\n                        i.TextureType.packed\n                    ],\n                    cacheHint: c\n                });\n                var c;\n                return Object.assign(Object.assign({}, u), {\n                    get: ()=>((t, e, n, a, s, u)=>{\n                            const c = n.dims, l = a.dims, p = s.length, f = [\n                                l[1] * l[2] * l[3],\n                                s[2] * s[3]\n                            ], d = l[2] * l[3], h = (0, o.unpackFromChannel)(), g = (0, r.getGlsl)(t.session.backend.glContext.version);\n                            let b = \"\";\n                            for(let t = 0; t <= 1; t++)for(let e = 0; e <= 1; e++)b += `\\n            blockIndex = rc.x + ${e};\\n            pos = rc.y + ${t};\\n\\n            if(blockIndex < ${f[1]} && pos < ${f[0]}) {\\n              offsetY = int(blockIndex / (${s[p - 1]})) * ${u.strides[0]} -\\n                ${u.pads[0]};\\n              d0 = offsetY + ${u.dilations[0]} * (imod(pos, ${d}) / ${l[2]});\\n\\n              if(d0 < ${c[2]} && d0 >= 0) {\\n                offsetX = imod(blockIndex, ${s[p - 1]}) * ${u.strides[1]} -\\n                  ${u.pads[1]};\\n                d1 = offsetX + ${u.dilations[1]} * imod(imod(pos, ${d}), ${l[2]});\\n\\n                if(d1 < ${c[3]} && d1 >= 0) {\\n\\n                  ch = int(float(pos)/ ${d}.);\\n                    innerDims = vec2(d0, d1);\\n                    result[${2 * t + e}] = getChannel(\\n                      getA(0, ch, int(innerDims.x),\\n                      int(innerDims.y)), innerDims);\\n                }\\n              }\\n            }\\n\\n          `;\n                            const m = `\\n      ${h}\\n\\n      void main() {\\n        ivec2 rc = getOutputCoords();\\n          vec4 result = vec4(0.0);\\n          int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\\n          vec2 innerDims;\\n          ${b}\\n          ${g.output} = result;\\n      }\\n            `;\n                            return Object.assign(Object.assign({}, e), {\n                                output: {\n                                    dims: f,\n                                    type: n.type,\n                                    textureType: i.TextureType.packed\n                                },\n                                shaderSource: m,\n                                hasMain: !0\n                            });\n                        })(t, u, e, n, a, s)\n                });\n            };\n        },\n        3248: (t, e, n)=>{\n            \"use strict\";\n            Object.defineProperty(e, \"__esModule\", {\n                value: !0\n            }), e.calculateIm2ColDims = e.createIm2ColProgramInfoLoader = void 0;\n            const r = n(2039);\n            e.createIm2ColProgramInfoLoader = (t, n, i, o, a)=>{\n                const s = (u = a.cacheKey, {\n                    name: \"Im2Col\",\n                    inputNames: [\n                        \"X\"\n                    ],\n                    inputTypes: [\n                        r.TextureType.unpacked\n                    ],\n                    cacheHint: u\n                });\n                var u;\n                return Object.assign(Object.assign({}, s), {\n                    get: ()=>((t, n, i, o, a, s)=>{\n                            const u = i.dims, c = o.dims, l = a.length, p = (0, e.calculateIm2ColDims)(u, c, a, 4), f = `\\n        const int XC = ${u[1]};\\n        const int XH = ${u[2]};\\n        const int XW = ${u[3]};\\n        const int KH = ${s.kernelShape[0]};\\n        const int KW = ${s.kernelShape[1]};\\n        const int dilationH = ${s.dilations[0]};\\n        const int dilationW = ${s.dilations[1]};\\n        const int strideH = ${s.strides[0]};\\n        const int strideW = ${s.strides[1]};\\n        const int padH = ${s.pads[0]};\\n        const int padW = ${s.pads[1]};\\n        const int KHKW = KH*KW;\\n        const int XCKHKW = XC * KHKW;\\n        const int outputChannels = 4;\\n        vec4 process(int indices[${l}]) {\\n          int b  = indices[0]; // batch size\\n          int oh = indices[1] * strideH - padH; //output height\\n          int ow = indices[2] * strideW - padW; //output width\\n          int p = indices[3] * outputChannels; //patch\\n          vec4 value = vec4(0.0);\\n          for(int i=0; i < outputChannels; ++i) {\\n            if(p < XCKHKW) {\\n              int patchC = p / KHKW;\\n              int patchH = (p - patchC*KHKW) / KW;\\n              int patchW = (p - patchC*KHKW) - patchH * KW;\\n              int xh2 = oh + patchH * dilationH;\\n              int xw2 = ow + patchW * dilationW;\\n              int x[${u.length}];\\n              x[0] = b;\\n              x[1] = patchC;\\n              x[2] = xh2;\\n              x[3] = xw2;\\n              if(xh2 >= 0 &&\\n                  xh2 < XH &&\\n                  xw2 >= 0 &&\\n                  xw2 < XW) {\\n                value[i] = _X(x);\\n              }\\n            }\\n            ++p;\\n          }\\n          return value;\\n        }\\n        `;\n                            return Object.assign(Object.assign({}, n), {\n                                output: {\n                                    dims: p,\n                                    type: i.type,\n                                    textureType: r.TextureType.packedLastDimension\n                                },\n                                shaderSource: f\n                            });\n                        })(0, s, n, i, o, a)\n                });\n            }, e.calculateIm2ColDims = (t, e, n, r = 4)=>[\n                    n[0],\n                    n[2],\n                    n[3],\n                    Math.ceil(t[1] * e[2] * e[3] / r)\n                ];\n        },\n        6572: (t, e, n)=>{\n            \"use strict\";\n            Object.defineProperty(e, \"__esModule\", {\n                value: !0\n            }), e.parseImageScalerAttributes = e.imageScaler = void 0;\n            const r = n(246), i = n(2039);\n            e.imageScaler = (t, e, n)=>(u(e), [\n                    t.run(a(t, e, n), e)\n                ]), e.parseImageScalerAttributes = (t)=>{\n                const e = t.attributes.getFloat(\"scale\"), n = t.attributes.getFloats(\"bias\");\n                return (0, r.createAttributeWithCacheKey)({\n                    scale: e,\n                    bias: n\n                });\n            };\n            const o = {\n                name: \"ImageScaler\",\n                inputNames: [\n                    \"X\"\n                ],\n                inputTypes: [\n                    i.TextureType.unpacked\n                ]\n            }, a = (t, e, n)=>{\n                const r = Object.assign(Object.assign({}, o), {\n                    cacheHint: n.cacheKey\n                });\n                return Object.assign(Object.assign({}, r), {\n                    get: ()=>((t, e, n, r)=>{\n                            const o = n[0].dims.slice(), a = o.length, u = `\\n      ${s(r.bias.length)}\\n      float process(int indices[${a}]) {\\n        return _X(indices) * scale + getBias(bias, indices[1]);\\n      }`;\n                            return Object.assign(Object.assign({}, e), {\n                                output: {\n                                    dims: o,\n                                    type: n[0].type,\n                                    textureType: i.TextureType.unpacked\n                                },\n                                variables: [\n                                    {\n                                        name: \"bias\",\n                                        type: \"float\",\n                                        arrayLength: r.bias.length,\n                                        data: r.bias\n                                    },\n                                    {\n                                        name: \"scale\",\n                                        type: \"float\",\n                                        data: r.scale\n                                    }\n                                ],\n                                shaderSource: u\n                            });\n                        })(0, r, e, n)\n                });\n            }, s = (t)=>{\n                const e = [\n                    `float getBias(float bias[${t}], int channel) {`\n                ];\n                for(let n = 0; n < t; ++n)0 === n ? e.push(`\\tif (channel == ${n}) { return bias[${n}]; }`) : n === t - 1 ? e.push(`\\telse { return bias[${n}]; }`) : e.push(`\\telse if (channel == ${n}) { return bias[${n}]; }`);\n                return e.push(\"\t}\"), e.join(\"\\n\");\n            }, u = (t)=>{\n                if (!t || 1 !== t.length) throw new Error(\"ImageScaler requires 1 input.\");\n                if (4 !== t[0].dims.length) throw new Error(\"Invalid input shape.\");\n                if (\"float32\" !== t[0].type && \"float64\" !== t[0].type) throw new Error(\"Invalid input type.\");\n            };\n        },\n        3346: (t, e, n)=>{\n            \"use strict\";\n            Object.defineProperty(e, \"__esModule\", {\n                value: !0\n            }), e.parseInstanceNormalizationAttributes = e.instanceNormalization = void 0;\n            const r = n(5060), i = n(2039);\n            e.instanceNormalization = (t, e, n)=>{\n                c(e);\n                const r = t.run(a(e[0]), e);\n                return [\n                    t.run(u(t, e[0], n, r.dims), [\n                        e[0],\n                        r,\n                        e[1],\n                        e[2]\n                    ])\n                ];\n            }, e.parseInstanceNormalizationAttributes = (t)=>t.attributes.getFloat(\"epsilon\", 1e-5);\n            const o = {\n                name: \"InstanceNormalization_MeanAndVariance\",\n                inputNames: [\n                    \"X\"\n                ],\n                inputTypes: [\n                    i.TextureType.unpacked\n                ]\n            }, a = (t)=>Object.assign(Object.assign({}, o), {\n                    get: ()=>((t, e)=>{\n                            const n = e.dims.slice(), r = n[1], o = n[2] * n[3], a = [\n                                n[0],\n                                r\n                            ], s = `\\n      vec4 process(int[2] indices) {\\n        vec4 v = vec4(0.0);\\n        int a[4];\\n        a[0] = indices[0];\\n        a[1] = indices[1];\\n        float temp = 0.0;\\n        for(int a2=0; a2<${n[2]}; a2++) {\\n          a[2] = a2;\\n          for(int a3=0; a3<${n[3]}; a3++) {\\n            a[3] = a3;\\n            float x = _X(a);\\n            temp += x;\\n          }\\n        }\\n        float mean = temp / float(${o});\\n        temp = 0.0;\\n        for(int a2=0; a2<${n[2]}; a2++) {\\n          a[2] = a2;\\n          for(int a3=0; a3<${n[3]}; a3++) {\\n            a[3] = a3;\\n            float x = _X(a);\\n            temp += (x - mean) * (x - mean);\\n          }\\n        }\\n        v.r = mean;\\n        v.g = temp / float(${o});\\n\\n        return v;\\n      }`;\n                            return Object.assign(Object.assign({}, t), {\n                                output: {\n                                    dims: a,\n                                    type: e.type,\n                                    textureType: i.TextureType.packedLastDimension\n                                },\n                                shaderSource: s\n                            });\n                        })(o, t)\n                }), s = {\n                name: \"InstanceNormalization_ComputeOutput\",\n                inputNames: [\n                    \"X\",\n                    \"MeanAndVariance\",\n                    \"Scale\",\n                    \"B\"\n                ],\n                inputTypes: [\n                    i.TextureType.unpacked,\n                    i.TextureType.packedLastDimension,\n                    i.TextureType.unpacked,\n                    i.TextureType.unpacked\n                ]\n            }, u = (t, e, n, o)=>{\n                const a = Object.assign(Object.assign({}, s), {\n                    cacheHint: `${n}`\n                });\n                return Object.assign(Object.assign({}, a), {\n                    get: ()=>((t, e, n, o, a)=>{\n                            const s = (0, r.getGlsl)(t.session.backend.glContext.version), [u, c] = t.calculateTextureWidthAndHeight(a, i.TextureType.packedLastDimension), [l, p] = [\n                                u / 4,\n                                c\n                            ], f = `\\n      vec4 get_MeanAndVariance(int[2] mv) {\\n        int offset = indicesToOffset_MeanAndVariance(mv);\\n        vec2 coords = offsetToCoords(offset, ${l}, ${p});\\n        return ${s.texture2D}(MeanAndVariance, coords);\\n      }\\n\\n      float process(int[4] indices) {\\n        int mv[2];\\n        mv[0] = indices[0];\\n        mv[1] = indices[1];\\n        vec4 mean_and_variance = get_MeanAndVariance(mv);\\n        float mean = mean_and_variance.r;\\n        float variance = mean_and_variance.g;\\n\\n        int sb[1];\\n        sb[0] = indices[1];\\n        float scale = _Scale(sb);\\n        float b = _B(sb);\\n\\n        return scale * (_X(indices) - mean) / sqrt(variance + epsilon) + b;\\n      }`;\n                            return Object.assign(Object.assign({}, e), {\n                                output: {\n                                    dims: n.dims,\n                                    type: n.type,\n                                    textureType: i.TextureType.unpacked\n                                },\n                                variables: [\n                                    {\n                                        name: \"epsilon\",\n                                        type: \"float\",\n                                        data: o\n                                    }\n                                ],\n                                shaderSource: f\n                            });\n                        })(t, a, e, n, o)\n                });\n            }, c = (t)=>{\n                if (!t || 3 !== t.length) throw new Error(\"InstanceNormalization requires 3 inputs.\");\n                const e = t[0], n = t[1], r = t[2];\n                if (e.dims.length < 3 || 1 !== n.dims.length || 1 !== r.dims.length) throw new Error(\"Invalid input shape.\");\n                if (n.dims[0] !== e.dims[1] || r.dims[0] !== e.dims[1]) throw new Error(\"Input shapes are mismatched.\");\n                if (\"float32\" !== e.type && \"float64\" !== e.type || \"float32\" !== n.type && \"float64\" !== n.type || \"float32\" !== r.type && \"float64\" !== r.type) throw new Error(\"Invalid input type.\");\n                if (4 !== t[0].dims.length) throw new Error(\"Only support 4-D input shape.\");\n            };\n        },\n        708: (t, e, n)=>{\n            \"use strict\";\n            Object.defineProperty(e, \"__esModule\", {\n                value: !0\n            }), e.createPackedMatmulProgramInfoLoader = void 0;\n            const r = n(2517), i = n(5060), o = n(2039), a = n(9390), s = n(2823), u = n(5623);\n            e.createPackedMatmulProgramInfoLoader = (t, e, n)=>{\n                const c = (l = e.length > 2, p = n.activationCacheKey, {\n                    name: \"MatMul (packed)\",\n                    inputNames: l ? [\n                        \"A\",\n                        \"B\",\n                        \"Bias\"\n                    ] : [\n                        \"A\",\n                        \"B\"\n                    ],\n                    inputTypes: l ? [\n                        o.TextureType.packed,\n                        o.TextureType.packed,\n                        o.TextureType.packed\n                    ] : [\n                        o.TextureType.packed,\n                        o.TextureType.packed\n                    ],\n                    cacheHint: p\n                });\n                var l, p;\n                return Object.assign(Object.assign({}, c), {\n                    get: ()=>((t, e, n, c)=>{\n                            const l = n.length > 2, p = l ? \"value += getBiasForMatmul();\" : \"\", f = n[0].dims, d = n[1].dims, h = r.BroadcastUtil.calcShape(f, d, !0), g = !r.ShapeUtil.areEqual(n[0].dims, n[1].dims);\n                            if (!h) throw new Error(\"Can't use matmul on the given tensors\");\n                            const b = f[f.length - 1], m = Math.ceil(b / 2), y = f.length, _ = d.length, v = (0, i.getGlsl)(t.session.backend.glContext.version), w = (0, a.getCoordsDataType)(h.length), x = h.length, T = (0, a.getGlChannels)(), { activationFunction: S, applyActivation: O } = (0, s.getActivationSnippet)(c), A = l ? `${(0, u.getBiasForMatmul)(w, T, n[2].dims, h, !0)}` : \"\", E = g ? `${function(t, e, n, i) {\n                                let o = [], a = [];\n                                const s = n[0].dims, u = n[1].dims, c = s.length, l = u.length, p = i.length, f = p - c, d = p - l;\n                                o = s.map((t, n)=>`coords.${e[n + f]}`), o[c - 1] = \"i*2\", o.join(\", \"), a = u.map((t, n)=>`coords.${e[n + d]}`), a[l - 2] = \"i*2\", a.join(\", \");\n                                const h = r.BroadcastUtil.getBroadcastDims(s, i), g = r.BroadcastUtil.getBroadcastDims(u, i), b = h.map((t)=>`coords.${e[t + f]} = 0;`).join(\"\\n\"), m = g.map((t)=>`coords.${e[t + d]} = 0;`).join(\"\\n\"), y = `int lastDim = coords.${e[p - 1]};\\n  coords.${e[p - 1]} = coords.${e[p - 2]};\\n  coords.${e[p - 2]} = lastDim;`;\n                                return `\\nvec4 getAAtOutCoordsMatmul(int i) {\\n  ${t} coords = getOutputCoords();\\n  ${y}\\n  ${b}\\n  vec4 outputValue = getA(${o});\\n  return outputValue;\\n}\\n\\nvec4 getBAtOutCoordsMatmul(int i) {\\n  ${t} coords = getOutputCoords();\\n  ${y}\\n  ${m}\\n  vec4 outputValue = getB(${a});\\n  return outputValue;\\n}`;\n                            }(w, T, n, h)}` : \"\", I = g ? \"getAAtOutCoordsMatmul(i)\" : `getA(${function(t, e) {\n                                let n = \"\";\n                                for(let r = 0; r < e - 2; r++)n += `rc.${t[r]}, `;\n                                return n += `rc.${t[e - 2]}, i*2`, n;\n                            }(T, y)})`, P = g ? \"getBAtOutCoordsMatmul(i)\" : `getB(${function(t, e) {\n                                let n = \"\";\n                                for(let r = 0; r < e - 2; r++)n += `rc.${t[r]}, `;\n                                return n += `i*2, rc.${t[e - 1]}`, n;\n                            }(T, _)})`, D = `\\n            ${E}\\n            ${A}\\n            ${S}\\n            void main() {\\n              ${g ? \"\" : `${w} rc =\\n          getOutputCoords(); int lastDim = rc.${T[x - 1]}; rc.${T[x - 1]} =\\n          rc.${T[x - 2]}; rc.${T[x - 2]} = lastDim;\\n      `}\\n\\n              vec4 value = vec4(0);\\n              for (int i = 0; i < ${m}; i++) {\\n                vec4 a = ${I};\\n                vec4 b = ${P};\\n\\n                value += (a.rrbb * b.rgrg);\\n                value += (a.ggaa * b.baba);\\n              }\\n              ${p}\\n              ${O}\\n              ${v.output} = value;\\n            }`;\n                            return Object.assign(Object.assign({}, e), {\n                                output: {\n                                    dims: h,\n                                    type: n[0].type,\n                                    textureType: o.TextureType.packed\n                                },\n                                shaderSource: D,\n                                hasMain: !0\n                            });\n                        })(t, c, e, n)\n                });\n            };\n        },\n        5623: (t, e, n)=>{\n            \"use strict\";\n            Object.defineProperty(e, \"__esModule\", {\n                value: !0\n            }), e.getBiasForMatmul = e.createMatmulProgramInfoLoader = e.parseMatMulAttributes = e.matMul = void 0;\n            const r = n(2517), i = n(2039), o = n(9390), a = n(2823), s = n(708);\n            function u(t, e) {\n                const n = (s = t.length > 2, u = e.activationCacheKey, {\n                    name: \"MatMul\",\n                    inputNames: s ? [\n                        \"A\",\n                        \"B\",\n                        \"Bias\"\n                    ] : [\n                        \"A\",\n                        \"B\"\n                    ],\n                    inputTypes: s ? [\n                        i.TextureType.unpacked,\n                        i.TextureType.unpacked,\n                        i.TextureType.unpacked\n                    ] : [\n                        i.TextureType.unpacked,\n                        i.TextureType.unpacked\n                    ],\n                    cacheHint: u\n                });\n                var s, u;\n                return Object.assign(Object.assign({}, n), {\n                    get: ()=>(function(t, e, n) {\n                            const s = e[0].dims, u = e[1].dims, c = r.BroadcastUtil.calcShape(s, u, !0);\n                            if (!c) throw new Error(\"Can't use matmul on the given tensors\");\n                            const p = (0, o.getCoordsDataType)(c.length), f = (0, o.getGlChannels)(), { activationFunction: d, applyActivation: h } = (0, a.getActivationSnippet)(n), g = e.length > 2, b = g ? \"value += getBiasForMatmul();\" : \"\", m = g ? `${l(p, f, e[2].dims, c, !1)}` : \"\", y = c.length, _ = s.length, v = u.length, w = `\\n    ${d}\\n    ${m}\\n    float process(int indices[${y}]) {\\n        int a[${_}];\\n        int b[${v}];\\n        bcastMatmulIndices_A(indices, a);\\n        bcastMatmulIndices_B(indices, b);\\n\\n        float value;\\n        for (int k=0; k<${s[s.length - 1]}; ++k) {\\n            a[${_ - 1}] = k;\\n            b[${v - 2}] = k;\\n            value += _A(a) * _B(b);\\n        }\\n        ${b}\\n        ${h}\\n        return value;\\n    }`;\n                            return Object.assign(Object.assign({}, t), {\n                                output: {\n                                    dims: c,\n                                    type: e[0].type,\n                                    textureType: i.TextureType.unpacked\n                                },\n                                shaderSource: w\n                            });\n                        })(n, t, e)\n                });\n            }\n            e.matMul = (t, e, n)=>(c(e), t.session.pack ? [\n                    t.run((0, s.createPackedMatmulProgramInfoLoader)(t, e, n), e)\n                ] : [\n                    t.run(u(e, n), e)\n                ]), e.parseMatMulAttributes = (t)=>(0, a.parseInternalActivationAttributes)(t.attributes), e.createMatmulProgramInfoLoader = u;\n            const c = (t)=>{\n                if (!t || 2 !== t.length) throw new Error(\"MatMul requires 2 inputs.\");\n                if (t[0].dims[t[0].dims.length - 1] !== t[1].dims[t[1].dims.length - 2]) throw new Error(\"shared dimension does not match.\");\n                if (\"float32\" !== t[0].type && \"float64\" !== t[0].type || \"float32\" !== t[1].type && \"float64\" !== t[1].type) throw new Error(\"inputs should be float type\");\n                if (t[0].type !== t[1].type) throw new Error(\"inputs types should match\");\n            };\n            function l(t, e, n, i, o) {\n                let a = \"\";\n                const s = n.length, u = i.length, c = u - s;\n                a = u < 2 && s > 0 ? \"coords\" : n.map((t, n)=>`coords.${e[n + c]}`).join(\", \");\n                const l = r.BroadcastUtil.getBroadcastDims(n, i).map((t)=>`coords.${e[t + c]} = 0;`).join(\"\\n\");\n                let p = \"vec4(outputValue.xx, outputValue.yy)\";\n                return 1 === r.ShapeUtil.size(n) && (p = \"vec4(outputValue.x)\"), o ? `\\nvec4 getBiasForMatmul() {\\n  ${t} coords = getOutputCoords();\\n  ${l}\\n  vec4 outputValue = getBias(${a});\\n  return ${p};\\n}` : `\\nfloat getBiasForMatmul() {\\n  ${t} coords = getOutputCoords();\\n  ${l}\\n  return getBias(coords.x);\\n}`;\n            }\n            e.getBiasForMatmul = l;\n        },\n        2403: (t, e, n)=>{\n            \"use strict\";\n            Object.defineProperty(e, \"__esModule\", {\n                value: !0\n            }), e.createPackProgramInfoLoader = void 0;\n            const r = n(5060), i = n(2039), o = n(9390), a = n(2827), s = {\n                name: \"pack\",\n                inputNames: [\n                    \"A\"\n                ],\n                inputTypes: [\n                    i.TextureType.unpackedReversed\n                ]\n            };\n            e.createPackProgramInfoLoader = (t, e)=>Object.assign(Object.assign({}, s), {\n                    get: ()=>((t, e)=>{\n                            const n = (0, r.getGlsl)(t.session.backend.glContext.version), u = e.dims, c = u.length, l = e.dims.length, p = (0, o.getCoordsDataType)(l), f = (0, a.getChannels)(\"rc\", l), d = (h = l, g = f, b = u[u.length - 2], m = u[u.length - 1], 0 === h || 1 === h ? \"\" : `\\n    int r = ${g[h - 2]};\\n    int c = ${g[h - 1]};\\n    int rp1 = ${g[h - 2]} + 1;\\n    int cp1 = ${g[h - 1]} + 1;\\n    bool rEdge = rp1 >= ${m};\\n    bool cEdge = cp1 >= ${b};\\n    `);\n                            var h, g, b, m;\n                            let y;\n                            y = 0 === c ? [\n                                1,\n                                1\n                            ] : 1 === c ? [\n                                u[0],\n                                1\n                            ] : [\n                                u[l - 1],\n                                u[l - 2]\n                            ];\n                            const _ = function(t, e, n) {\n                                if (0 === t) return \"false\";\n                                if (1 === t) return `rc > ${e[0]}`;\n                                let r = \"\";\n                                for(let i = t - 2; i < t; i++)r += `${n[i]} >= ${e[i - t + 2]}`, i < t - 1 && (r += \"||\");\n                                return r;\n                            }(l, y, f), v = function(t, e) {\n                                const n = t.length;\n                                if (0 === n) return \"getA(), 0, 0, 0\";\n                                if (1 === n) return `getA(rc),\\n            rc + 1 >= ${t[0]} ? 0. : getA(rc + 1),\\n            0, 0`;\n                                let r = \"\";\n                                if (n > 2) for(let t = 0; t < n - 2; ++t)r += `${e[t]},`;\n                                return `getA(${r}r, c),\\n          rEdge ? 0. : getA(${r}rp1, c),\\n          cEdge ? 0. : getA(${r}r, cp1),\\n          rEdge || cEdge ? 0. : getA(${r}rp1, cp1)`;\n                            }(u, f), w = `\\n        void main() {\\n          ${p} rc = getOutputCoords();\\n\\n          if(${_}) {\\n            ${n.output} = vec4(0);\\n          } else {\\n            ${d}\\n\\n            ${n.output} = vec4(${v});\\n          }\\n        }\\n      `;\n                            return Object.assign(Object.assign({}, s), {\n                                hasMain: !0,\n                                output: {\n                                    dims: e.dims,\n                                    type: e.type,\n                                    textureType: i.TextureType.packed\n                                },\n                                shaderSource: w\n                            });\n                        })(t, e)\n                });\n        },\n        2827: (t, e, n)=>{\n            \"use strict\";\n            Object.defineProperty(e, \"__esModule\", {\n                value: !0\n            }), e.unpackFromChannel = e.getChannels = e.getVecChannels = void 0;\n            const r = n(9390);\n            function i(t, e) {\n                return (0, r.getGlChannels)(e).map((e)=>`${t}.${e}`);\n            }\n            e.getVecChannels = i, e.getChannels = function(t, e) {\n                return 1 === e ? [\n                    t\n                ] : i(t, e);\n            }, e.unpackFromChannel = function() {\n                return \"\\n    float getChannel(vec4 frag, int dim) {\\n      int modCoord = imod(dim, 2);\\n      return modCoord == 0 ? frag.r : frag.g;\\n    }\\n\\n    float getChannel(vec4 frag, vec2 innerDims) {\\n      vec2 modCoord = mod(innerDims, 2.);\\n      return modCoord.x == 0. ?\\n        (modCoord.y == 0. ? frag.r : frag.g) :\\n        (modCoord.y == 0. ? frag.b : frag.a);\\n    }\\n  \";\n            };\n        },\n        2870: (t, e, n)=>{\n            \"use strict\";\n            Object.defineProperty(e, \"__esModule\", {\n                value: !0\n            }), e.parsePadAttributesV11 = e.padV11 = e.parsePadAttributesV2 = e.padV2 = void 0;\n            const r = n(246), i = n(2517), o = n(5060), a = n(2039), s = {\n                name: \"Pad\",\n                inputNames: [\n                    \"A\"\n                ],\n                inputTypes: [\n                    a.TextureType.unpacked\n                ]\n            };\n            e.padV2 = (t, e, n)=>(l(e), [\n                    t.run(Object.assign(Object.assign({}, s), {\n                        cacheHint: n.cacheKey,\n                        get: ()=>c(t, e[0], n)\n                    }), e)\n                ]), e.parsePadAttributesV2 = (t)=>{\n                const e = t.attributes.getString(\"mode\", \"constant\"), n = t.attributes.getFloat(\"value\", 0), i = t.attributes.getInts(\"pads\");\n                return (0, r.createAttributeWithCacheKey)({\n                    mode: e,\n                    value: n,\n                    pads: i\n                });\n            }, e.padV11 = (t, n, r)=>{\n                p(n);\n                const i = u(t, n, r);\n                return (0, e.padV2)(t, [\n                    n[0]\n                ], i);\n            }, e.parsePadAttributesV11 = (t)=>t.attributes.getString(\"mode\", \"constant\");\n            const u = (t, e, n)=>{\n                if (!t.session.isInitializer(e[1].dataId) || e.length >= 3 && !t.session.isInitializer(e[2].dataId)) throw new Error(\"dynamic pad attributes are not allowed\");\n                const i = Array.from(e[1].integerData), o = e.length >= 3 ? e[2].floatData[0] : 0;\n                return (0, r.createAttributeWithCacheKey)({\n                    mode: n,\n                    pads: i,\n                    value: o\n                });\n            }, c = (t, e, n)=>{\n                const r = i.ShapeUtil.padShape(e.dims.slice(), n.pads), o = r.length, s = `\\n      ${f(t, e, n)}\\n      float process(int[${o}] indices) {\\n          return padA(indices);\\n      }`;\n                return {\n                    name: \"Pad\",\n                    inputNames: [\n                        \"A\"\n                    ],\n                    inputTypes: [\n                        a.TextureType.unpacked\n                    ],\n                    output: {\n                        dims: r,\n                        type: e.type,\n                        textureType: a.TextureType.unpacked\n                    },\n                    shaderSource: s\n                };\n            }, l = (t)=>{\n                if (!t || 1 !== t.length) throw new Error(\"Pad requires 1 input\");\n                if (\"float32\" !== t[0].type && \"float64\" !== t[0].type) throw new Error(\"Invalid input type.\");\n            }, p = (t)=>{\n                if (!t || 2 !== t.length && 3 !== t.length) throw new Error(\"Pad requires 2 or 3 inputs\");\n                if (\"int32\" !== t[1].type) throw new Error(\"Invalid input type.\");\n                if (t.length >= 3 && \"string\" === t[2].type) throw new Error(\"Invalid input type.\");\n            }, f = (t, e, n)=>{\n                const r = (0, o.getGlsl)(t.session.backend.glContext.version), [s, u] = t.calculateTextureWidthAndHeight(e.dims, a.TextureType.unpacked), c = i.ShapeUtil.computeStrides(e.dims);\n                switch(n.mode){\n                    case \"constant\":\n                        return d(r, e.dims, c, s, u, n.pads, n.value);\n                    case \"reflect\":\n                        return h(r, e.dims, c, s, u, n.pads);\n                    case \"edge\":\n                        return g(r, e.dims, c, s, u, n.pads);\n                    default:\n                        throw new Error(\"Invalid mode\");\n                }\n            }, d = (t, e, n, r, i, o, a)=>{\n                const s = e.length;\n                let u = \"\";\n                for(let t = s - 1; t >= 0; --t)u += `\\n        k = m[${t}] - ${o[t]};\\n        if (k < 0)  return constant;\\n        if (k >= ${e[t]}) return constant;\\n        offset += k * ${n[t]};\\n        `;\n                return `\\n      float padA(int m[${s}]) {\\n        const float constant = float(${a});\\n        int offset = 0;\\n        int k = 0;\\n        ${u}\\n        vec2 coords = offsetToCoords(offset, ${r}, ${i});\\n        float value = getColorAsFloat(${t.texture2D}(A, coords));\\n        return value;\\n      }\\n      `;\n            }, h = (t, e, n, r, i, o)=>{\n                const a = e.length;\n                let s = \"\";\n                for(let t = a - 1; t >= 0; --t)s += `\\n        k = m[${t}] - ${o[t]};\\n        if (k < 0) { k = -k; }\\n        {\\n          const int _2n_1 = ${2 * (e[t] - 1)};\\n          k = int( mod( float(k), float(_2n_1) ) ) ;\\n          if(k >= ${e[t]}) { k = _2n_1 - k; }\\n        }\\n        offset += k * ${n[t]};\\n        `;\n                return `\\n      float padA(int m[${a}]) {\\n        int offset = 0;\\n        int k = 0;\\n        ${s}\\n        vec2 coords = offsetToCoords(offset, ${r}, ${i});\\n        float value = getColorAsFloat(${t.texture2D}(A, coords));\\n        return value;\\n      }\\n      `;\n            }, g = (t, e, n, r, i, o)=>{\n                const a = e.length;\n                let s = \"\";\n                for(let t = a - 1; t >= 0; --t)s += `\\n        k = m[${t}] - ${o[t]};\\n        if (k < 0)  k = 0;\\n        if (k >= ${e[t]}) k = ${e[t] - 1};\\n        offset += k * ${n[t]};\\n      `;\n                return `\\n      float padA(int m[${a}]) {\\n        int offset = 0;\\n        int k = 0;\\n        ${s}\\n        vec2 coords = offsetToCoords(offset, ${r}, ${i});\\n        float value = getColorAsFloat(${t.texture2D}(A, coords));\\n        return value;\\n      }\\n      `;\n            };\n        },\n        2143: (t, e, n)=>{\n            \"use strict\";\n            Object.defineProperty(e, \"__esModule\", {\n                value: !0\n            }), e.globalMaxPool = e.parseMaxPoolAttributes = e.maxPool = e.parseGlobalAveragePoolAttributes = e.globalAveragePool = e.parseAveragePoolAttributes = e.averagePool = void 0;\n            const r = n(246), i = n(2517), o = n(2039);\n            e.averagePool = (t, e, n)=>{\n                p(e);\n                const r = {\n                    name: \"AveragePool\",\n                    inputNames: [\n                        \"X\"\n                    ],\n                    inputTypes: [\n                        o.TextureType.unpacked\n                    ],\n                    cacheHint: n.cacheKey\n                };\n                return [\n                    t.run(Object.assign(Object.assign({}, r), {\n                        get: ()=>a(e, r, !1, n)\n                    }), e)\n                ];\n            }, e.parseAveragePoolAttributes = (t)=>{\n                const e = t.attributes.getString(\"auto_pad\", \"NOTSET\"), n = t.attributes.getInt(\"ceil_mode\", 0), i = 0 !== t.attributes.getInt(\"count_include_pad\", 0), o = t.attributes.getInts(\"kernel_shape\"), a = t.attributes.getInts(\"strides\", []), s = t.attributes.getInts(\"pads\", []);\n                if (0 !== n) throw new Error(\"using ceil() in shape computation is not yet supported for AveragePool\");\n                return (0, r.createAttributeWithCacheKey)({\n                    autoPad: e,\n                    ceilMode: n,\n                    countIncludePad: i,\n                    kernelShape: o,\n                    strides: a,\n                    pads: s\n                });\n            };\n            const a = (t, e, n, r)=>{\n                const [a, s] = u(t, r, n), c = i.ShapeUtil.size(a.kernelShape);\n                let l = \"\";\n                a.countIncludePad ? l += `value /= float(${c});` : l += `value /= float(${c} - pad);`;\n                const p = `\\n        ${f(t[0].dims, a, \"value += _X(x);\", l, \"0.0\")}\\n      `;\n                return Object.assign(Object.assign({}, e), {\n                    output: {\n                        dims: s,\n                        type: t[0].type,\n                        textureType: o.TextureType.unpacked\n                    },\n                    shaderSource: p\n                });\n            };\n            e.globalAveragePool = (t, e, n)=>{\n                p(e);\n                const r = {\n                    name: \"GlobalAveragePool\",\n                    inputNames: [\n                        \"X\"\n                    ],\n                    inputTypes: [\n                        o.TextureType.unpacked\n                    ],\n                    cacheHint: `${n.countIncludePad}`\n                };\n                return [\n                    t.run(Object.assign(Object.assign({}, r), {\n                        get: ()=>a(e, r, !0, n)\n                    }), e)\n                ];\n            }, e.parseGlobalAveragePoolAttributes = (t)=>{\n                const e = 0 !== t.attributes.getInt(\"count_include_pad\", 0);\n                return (0, r.createAttributeWithCacheKey)({\n                    autoPad: \"\",\n                    ceilMode: 0,\n                    countIncludePad: e,\n                    kernelShape: [],\n                    strides: [],\n                    pads: []\n                });\n            }, e.maxPool = (t, e, n)=>{\n                p(e);\n                const r = {\n                    name: \"MaxPool\",\n                    inputNames: [\n                        \"X\"\n                    ],\n                    inputTypes: [\n                        o.TextureType.unpacked\n                    ],\n                    cacheHint: n.cacheKey\n                };\n                return [\n                    t.run(Object.assign(Object.assign({}, r), {\n                        get: ()=>s(e, r, !1, n)\n                    }), e)\n                ];\n            }, e.parseMaxPoolAttributes = (t)=>{\n                const e = t.attributes.getString(\"auto_pad\", \"NOTSET\"), n = t.attributes.getInt(\"ceil_mode\", 0), i = t.attributes.getInts(\"kernel_shape\"), o = t.attributes.getInts(\"strides\", []), a = t.attributes.getInts(\"pads\", []), s = t.attributes.getInt(\"storage_order\", 0), u = t.attributes.getInts(\"dilations\", []);\n                if (0 !== s) throw new Error(\"column major storage order is not yet supported for MaxPool\");\n                if (0 !== n) throw new Error(\"using ceil() in shape computation is not yet supported for MaxPool\");\n                return (0, r.createAttributeWithCacheKey)({\n                    autoPad: e,\n                    ceilMode: n,\n                    countIncludePad: !1,\n                    kernelShape: i,\n                    strides: o,\n                    pads: a,\n                    storageOrder: s,\n                    dilations: u\n                });\n            };\n            const s = (t, e, n, r)=>{\n                const [i, a] = u(t, r, n), s = `\\n      ${f(t[0].dims, i, \"\\n      value = max(_X(x), value);\\n    \", \"\", \"-1e5\")}\\n    `;\n                return Object.assign(Object.assign({}, e), {\n                    output: {\n                        dims: a,\n                        type: t[0].type,\n                        textureType: o.TextureType.unpacked\n                    },\n                    shaderSource: s\n                });\n            }, u = (t, e, n)=>{\n                const r = t[0].dims.slice(), o = Object.hasOwnProperty.call(e, \"dilations\"), a = e.kernelShape.slice(), s = e.strides.slice(), u = o ? e.dilations.slice() : [], c = e.pads.slice();\n                i.PoolConvUtil.adjustPoolAttributes(n, r, a, s, u, c);\n                const l = i.PoolConvUtil.computePoolOutputShape(n, r, s, u, a, c, e.autoPad), p = Object.assign({}, e);\n                return o ? Object.assign(p, {\n                    kernelShape: a,\n                    strides: s,\n                    pads: c,\n                    dilations: u,\n                    cacheKey: e.cacheKey\n                }) : Object.assign(p, {\n                    kernelShape: a,\n                    strides: s,\n                    pads: c,\n                    cacheKey: e.cacheKey\n                }), [\n                    p,\n                    l\n                ];\n            }, c = {\n                autoPad: \"\",\n                ceilMode: 0,\n                countIncludePad: !1,\n                kernelShape: [],\n                strides: [],\n                pads: [],\n                storageOrder: 0,\n                dilations: [],\n                cacheKey: \"\"\n            }, l = {\n                name: \"GlobalMaxPool\",\n                inputNames: [\n                    \"X\"\n                ],\n                inputTypes: [\n                    o.TextureType.unpacked\n                ]\n            };\n            e.globalMaxPool = (t, e)=>(p(e), [\n                    t.run(Object.assign(Object.assign({}, l), {\n                        get: ()=>s(e, l, !0, c)\n                    }), e)\n                ]);\n            const p = (t)=>{\n                if (!t || 1 !== t.length) throw new Error(\"Pool ops requires 1 input.\");\n                if (\"float32\" !== t[0].type && \"float64\" !== t[0].type) throw new Error(\"Invalid input type.\");\n            }, f = (t, e, n, r, o)=>{\n                const a = t.length;\n                if (e.kernelShape.length <= 2) {\n                    const i = e.kernelShape[e.kernelShape.length - 1], s = e.strides[e.strides.length - 1], u = e.pads[e.pads.length / 2 - 1], c = e.pads[e.pads.length - 1], l = t[a - 1];\n                    let p = \"\", f = \"\", d = \"\";\n                    if (p = u + c !== 0 ? `\\n          for (int i = 0; i < ${i}; i++) {\\n            x[${a} - 1] = indices[${a} - 1] * ${s} - ${u} + i;\\n            if (x[${a} - 1] < 0 || x[${a} - 1] >= ${l}) {\\n              pad++;\\n              continue;\\n            }\\n            ${n}\\n          }` : `\\n          for (int i = 0; i < ${i}; i++) {\\n            x[${a} - 1] = indices[${a} - 1] * ${s} - ${u} + i;\\n            ${n}\\n          }`, 2 === e.kernelShape.length) {\n                        const n = e.kernelShape[e.kernelShape.length - 2], r = e.strides[e.strides.length - 2], o = e.pads[e.pads.length / 2 - 2], s = e.pads[e.pads.length - 2], u = t[a - 2];\n                        f = o + s !== 0 ? `\\n            for (int j = 0; j < ${n}; j++) {\\n              x[${a} - 2] = indices[${a} - 2] * ${r} - ${o} + j;\\n              if (x[${a} - 2] < 0 || x[${a} - 2] >= ${u}) {\\n                pad+= ${i};\\n                continue;\\n              }\\n          ` : `\\n            for (int j = 0; j < ${n}; j++) {\\n              x[${a} - 2] = indices[${a} - 2] * ${r} - ${o} + j;\\n            `, d = \"\\n          }\\n        \";\n                    }\n                    return `\\n        float process(int indices[${a}]) {\\n          int x[${a}];\\n          copyVec(indices, x);\\n\\n          float value = ${o};\\n          int pad = 0;\\n          ${f}\\n          ${p}\\n          ${d}\\n          ${r}\\n          return value;\\n        }\\n      `;\n                }\n                {\n                    const s = i.ShapeUtil.size(e.kernelShape), u = i.ShapeUtil.computeStrides(e.kernelShape), c = u.length, l = e.pads.length, p = h(c), f = d(t, \"inputDims\"), g = d(e.pads, \"pads\"), b = d(u, \"kernelStrides\"), m = d(e.strides, \"strides\");\n                    let y = \"\";\n                    return y = e.pads.reduce((t, e)=>t + e) ? `\\n            if (x[j] >= inputDims[j] || x[j] < 0) {\\n              pad++;\\n              isPad = true;\\n              break;\\n            }\\n          }\\n          if (!isPad) {\\n            ${n}\\n          }` : `\\n          }\\n          ${n}\\n        `, `\\n        ${p}\\n        float process(int indices[${a}]) {\\n          int x[${a}];\\n          copyVec(indices, x);\\n          int offset[${c}];\\n          int pads[${l}];\\n          int inputDims[${a}];\\n          int kernelStrides[${c}];\\n          int strides[${c}];\\n          ${g}\\n          ${f}\\n          ${m}\\n          ${b}\\n\\n          float value = ${o};\\n          int pad = 0;\\n          bool isPad = false;\\n          for (int i = 0; i < ${s}; i++) {\\n            offsetToIndices(i, kernelStrides, offset);\\n            isPad = false;\\n            for (int j = ${a} - ${c}; j < ${a}; j++) {\\n              x[j] = indices[j] * strides[j - ${a} + ${c}]\\n                + offset[j - ${a} + ${c}] - pads[j - 2];\\n              ${y}\\n          }\\n          ${r}\\n\\n          return value;\\n        }\\n      `;\n                }\n            }, d = (t, e)=>{\n                let n = \"\";\n                for(let r = 0; r < t.length; r++)n += `\\n      ${e}[${r}] = ${t[r]};\\n    `;\n                return n;\n            }, h = (t)=>`\\n  void offsetToIndices(int offset, int[${t}] strides, out int[${t}] indices) {\\n    if (${t} == 0) {\\n      return;\\n    }\\n    for (int i = 0; i < ${t} - 1; ++i) {\\n      indices[i] = offset / strides[i];\\n      offset -= indices[i] * strides[i];\\n    }\\n    indices[${t} - 1] = offset;\\n  }`;\n        },\n        4939: (t, e, n)=>{\n            \"use strict\";\n            Object.defineProperty(e, \"__esModule\", {\n                value: !0\n            }), e.reduceLogSumSquare = e.reduceLogSum = e.reduceProd = e.reduceMin = e.reduceMax = e.reduceMean = e.reduceSum = e.parseReduceAttributes = void 0;\n            const r = n(246), i = n(782), o = n(2517), a = n(2039), s = (t, e, n, r, i)=>{\n                c(e);\n                const o = {\n                    name: r,\n                    inputNames: [\n                        \"A\"\n                    ],\n                    inputTypes: [\n                        a.TextureType.unpacked\n                    ]\n                };\n                return [\n                    t.run(Object.assign(Object.assign({}, o), {\n                        cacheHint: n.cacheKey,\n                        get: ()=>u(t, e, n, r, i, o)\n                    }), e)\n                ];\n            };\n            e.parseReduceAttributes = (t)=>{\n                const e = t.attributes.getInts(\"axes\", []), n = 1 === t.attributes.getInt(\"keepdims\", 1);\n                return (0, r.createAttributeWithCacheKey)({\n                    axes: e,\n                    keepDims: n\n                });\n            };\n            const u = (t, e, n, r, i, s)=>{\n                const u = [], c = e[0].dims.length || 1, l = [], p = o.ShapeUtil.normalizeAxes(n.axes, e[0].dims.length), f = i(e, p);\n                let d = f[1];\n                for(let t = 0; t < e[0].dims.length; t++)p.indexOf(t) >= 0 || 0 === p.length ? (n.keepDims && u.push(1), d = `\\n          for(int j${t} = 0; j${t} < ${e[0].dims[t]}; j${t}++) {\\n            inputIdx[${t}] = j${t};\\n            ${d}\\n          }`) : (l.push(`inputIdx[${t}] = outputIdx[${u.length}];`), u.push(e[0].dims[t]));\n                const h = `\\n      float process(int outputIdx[${u.length || 1}]) {\\n        float value;                 // final result\\n        int inputIdx[${c}];      // addressing input data\\n        ${l.join(\"\\n\")}\\n        ${f[0]}       // init ops for reduce max/min\\n        ${d}\\n        ${f[2]}       // final computation for reduce mean\\n        return value;\\n      }`;\n                return Object.assign(Object.assign({}, s), {\n                    output: {\n                        dims: u,\n                        type: e[0].type,\n                        textureType: a.TextureType.unpacked\n                    },\n                    shaderSource: h\n                });\n            }, c = (t)=>{\n                if (!t || 1 !== t.length) throw new Error(\"Reduce op requires 1 input.\");\n                if (-1 === i.NUMBER_TYPES.indexOf(t[0].type)) throw new Error(\"Invalid input type.\");\n            };\n            e.reduceSum = (t, e, n)=>s(t, e, n, \"ReduceSum\", ()=>[\n                        \"value = 0.0;\",\n                        \"value += _A(inputIdx);\",\n                        \"\"\n                    ]), e.reduceMean = (t, e, n)=>s(t, e, n, \"ReduceMean\", (t, e)=>{\n                    let n = 1;\n                    for(let r = 0; r < t[0].dims.length; r++)(e.indexOf(r) >= 0 || 0 === e.length) && (n *= t[0].dims[r]);\n                    return [\n                        \"value = 0.0;\",\n                        \"value += _A(inputIdx);\",\n                        `value /= ${n}.;`\n                    ];\n                }), e.reduceMax = (t, e, n)=>s(t, e, n, \"ReduceMax\", (t, e)=>{\n                    const n = [];\n                    for(let r = 0; r < t[0].dims.length; r++)(e.indexOf(r) >= 0 || 0 === e.length) && n.push(`inputIdx[${r}] = 0;`);\n                    return [\n                        `${n.join(\"\\n\")}\\nvalue = _A(inputIdx);`,\n                        \"value = max(value, _A(inputIdx));\",\n                        \"\"\n                    ];\n                }), e.reduceMin = (t, e, n)=>s(t, e, n, \"ReduceMin\", (t, e)=>{\n                    const n = [];\n                    for(let r = 0; r < t[0].dims.length; r++)(e.indexOf(r) >= 0 || 0 === e.length) && n.push(`inputIdx[${r}] = 0;`);\n                    return [\n                        `${n.join(\"\\n\")}\\nvalue = _A(inputIdx);`,\n                        \"value = min(value, _A(inputIdx));\",\n                        \"\"\n                    ];\n                }), e.reduceProd = (t, e, n)=>s(t, e, n, \"ReduceProd\", ()=>[\n                        \"value = 1.0;\",\n                        \"value *= _A(inputIdx);\",\n                        \"\"\n                    ]), e.reduceLogSum = (t, e, n)=>s(t, e, n, \"ReduceLogSum\", ()=>[\n                        \"value = 0.0;\",\n                        \"value += _A(inputIdx);\",\n                        \"value = log(value);\"\n                    ]), e.reduceLogSumSquare = (t, e, n)=>s(t, e, n, \"ReduceLogSumSquare\", ()=>[\n                        \"float t; value = 0.0;\",\n                        \"t = _A(inputIdx); value += t * t;\",\n                        \"\"\n                    ]);\n        },\n        7019: (t, e, n)=>{\n            \"use strict\";\n            Object.defineProperty(e, \"__esModule\", {\n                value: !0\n            }), e.isReshapeCheap = e.processDims3D = e.createPackedReshape3DProgramInfoLoader = void 0;\n            const r = n(2517), i = n(5060), o = n(2039), a = n(2827);\n            e.createPackedReshape3DProgramInfoLoader = (t, e, n)=>{\n                const s = ((t)=>({\n                        name: \"Reshape (packed)\",\n                        inputTypes: [\n                            o.TextureType.packed\n                        ],\n                        inputNames: [\n                            \"A\"\n                        ],\n                        cacheHint: `${t}`\n                    }))(n);\n                return Object.assign(Object.assign({}, s), {\n                    get: ()=>((t, e, n, s)=>{\n                            const u = e.dims, c = s;\n                            let l = \"\";\n                            for(let t = 0; t < 4; t++){\n                                let e = \"\";\n                                switch(t){\n                                    case 0:\n                                        e = \"outputCoords = rc;\";\n                                        break;\n                                    case 1:\n                                        e = \"outputCoords = ivec3(rc.x, rc.y+1, rc.z);\";\n                                        break;\n                                    case 2:\n                                        e = \"outputCoords = ivec3(rc.x, rc.y, rc.z+1);\";\n                                        break;\n                                    case 3:\n                                        e = \"outputCoords = ivec3(rc.x, rc.y+1, rc.z+1);\";\n                                        break;\n                                    default:\n                                        throw new Error;\n                                }\n                                l += `\\n        ${e}\\n        ${t > 0 ? \"if(outputCoords.y < rows && outputCoords.z < cols){\" : \"\"}\\n          int flattenedIndex = getFlattenedIndex(outputCoords);\\n\\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flattenedIndex);\\n          vec2 innerDims = vec2(float(inputRC.y),float(inputRC.z));\\n\\n          result[${t}] = getChannel(getA(inputRC.x, inputRC.y, inputRC.z), innerDims);\\n\\n        ${t > 0 ? \"}\" : \"\"}\\n      `;\n                            }\n                            const p = (0, i.getGlsl)(t.session.backend.glContext.version), f = `\\n      ${function(t) {\n                                const e = r.ShapeUtil.computeStrides(t), n = [\n                                    \"b\",\n                                    \"r\",\n                                    \"c\"\n                                ], i = \"index\", o = e.map((t, r)=>`int ${n[r]} = ${i} / ${t}; ${r === e.length - 1 ? `int ${n[r + 1]} = ${i} - ${n[r]} * ${t}` : `index -= ${n[r]} * ${t}`};`).join(\"\");\n                                return `\\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\\n      ${o}\\n      return ivec3(b, r, c);\\n    }\\n  `;\n                            }(u)}\\n      ${function(t) {\n                                const e = r.ShapeUtil.computeStrides(t);\n                                return `\\n  int getFlattenedIndex(ivec3 coords) {\\n    // reverse y, z order\\n    return coords.x * ${e[0]} + coords.z * ${e[1]} + coords.y;\\n  }\\n`;\n                            }(c)}\\n      ${(0, a.unpackFromChannel)()}\\n\\n      void main() {\\n        ivec3 rc = getOutputCoords();\\n\\n        vec4 result = vec4(0.0);\\n\\n        ivec3 outputCoords;\\n        int rows = ${c[2]};\\n        int cols = ${c[1]};\\n\\n        ${l}\\n        ${p.output} = result;\\n      }\\n    `;\n                            return Object.assign(Object.assign({}, n), {\n                                output: {\n                                    dims: c,\n                                    type: e.type,\n                                    textureType: o.TextureType.packed\n                                },\n                                shaderSource: f,\n                                hasMain: !0\n                            });\n                        })(t, e, s, n)\n                });\n            }, e.processDims3D = function(t) {\n                if (0 === t.length) return [\n                    1,\n                    1,\n                    1\n                ];\n                let e = 1;\n                for(let n = 0; n < t.length - 2; ++n)e *= t[n];\n                return [\n                    e,\n                    t.length > 1 ? t[t.length - 2] : 1,\n                    t[t.length - 1]\n                ];\n            }, e.isReshapeCheap = function(t, e) {\n                let n = !1;\n                return n = 0 === t.length || 0 === e.length || (t.length < 2 || e.length < 2 ? t[t.length - 1] === e[e.length - 1] : t[t.length - 1] === e[e.length - 1] && t[t.length - 2] === e[e.length - 2]), n;\n            };\n        },\n        718: (t, e, n)=>{\n            \"use strict\";\n            Object.defineProperty(e, \"__esModule\", {\n                value: !0\n            }), e.reshape = void 0;\n            const r = n(2517);\n            e.reshape = (t, e)=>{\n                const n = r.ShapeUtil.calculateReshapedDims(e[0].dims, e[1].integerData);\n                return t.session.pack ? [\n                    t.reshapePacked(e[0], n)\n                ] : [\n                    t.reshapeUnpacked(e[0], n)\n                ];\n            };\n        },\n        2268: (t, e, n)=>{\n            \"use strict\";\n            Object.defineProperty(e, \"__esModule\", {\n                value: !0\n            }), e.parseResizeAttributesV11 = e.parseResizeAttributesV10 = e.resize = void 0;\n            const r = n(5060), i = n(2039), o = n(9390), a = n(2827), s = n(9793), u = {\n                name: \"Resize\",\n                inputNames: [\n                    \"A\"\n                ],\n                inputTypes: [\n                    i.TextureType.packed\n                ]\n            };\n            e.resize = (t, e, n)=>((0, s.validateInputs)(e, n), [\n                    t.run(Object.assign(Object.assign({}, u), {\n                        cacheHint: n.cacheKey,\n                        get: ()=>c(t, e, n)\n                    }), e)\n                ]), e.parseResizeAttributesV10 = (t)=>(0, s.parseUpsampleAttributes)(t, 10), e.parseResizeAttributesV11 = (t)=>(0, s.parseUpsampleAttributes)(t, 11);\n            const c = (t, e, n)=>{\n                const s = (0, r.getGlsl)(t.session.backend.glContext.version), [c, p] = l(e, n);\n                if (c.every((t)=>1 === t) && \"tf_crop_and_resize\" !== n.coordinateTransformMode) return Object.assign(Object.assign({}, u), {\n                    output: {\n                        dims: p,\n                        type: e[0].type,\n                        textureType: i.TextureType.packed\n                    },\n                    hasMain: !0,\n                    shaderSource: `void main() {\\n                    vec4 v = ${s.texture2D}(X, TexCoords);\\n                    ${s.output} = v;\\n                }`\n                });\n                const f = p.length;\n                if (f < 2) throw new Error(`output dimension should be at least 2, but got ${f}`);\n                const d = p[f - 2], h = p[f - 1], g = e[0].dims;\n                if (f !== g.length) throw new Error(`output dimension should match input ${g.length}, but got ${f}`);\n                const b = g[f - 2], m = g[f - 1], y = c[f - 2], _ = c[f - 1];\n                let v = \"\";\n                if (\"linear\" !== n.mode) throw new Error(`resize (packed) does not support mode: '${n.mode}'`);\n                switch(n.coordinateTransformMode){\n                    case \"asymmetric\":\n                        v = \"\\n                    vec4 getSourceFracIndex(ivec4 coords) {\\n                        return vec4(coords) / scaleWHWH;\\n                    }\\n                \";\n                        break;\n                    case \"half_pixel\":\n                        v = \"\\n                    vec4 getSourceFracIndex(ivec4 coords) {\\n                        return (vec4(coords) + 0.5) / scaleWHWH - 0.5;\\n                    }\\n                \";\n                        break;\n                    case \"pytorch_half_pixel\":\n                        v = `\\n                    vec4 getSourceFracIndex(ivec4 coords) {\\n                        vec4 fcoords = vec4(coords);\\n                        return vec4(\\n                            ${h}.0 > 1.0 ? (fcoords.x + 0.5) / scaleWHWH.x - 0.5 : 0.0,\\n                            ${d}.0 > 1.0 ? (fcoords.y + 0.5) / scaleWHWH.y - 0.5 : 0.0,\\n                            ${h}.0 > 1.0 ? (fcoords.z + 0.5) / scaleWHWH.z - 0.5 : 0.0,\\n                            ${d}.0 > 1.0 ? (fcoords.w + 0.5) / scaleWHWH.w - 0.5 : 0.0\\n                          );\\n                    }\\n                `;\n                        break;\n                    case \"align_corners\":\n                        v = `\\n                    vec4 getSourceFracIndex(ivec4 coords) {\\n                        vec4 resized = vec4(${h}.0 - 1.0, ${d}.0 - 1.0, ${h}.0 - 1.0,\\n                            ${d}.0 - 1.0);\\n                        vec4 original = vec4(${m}.0 - 1.0, ${b}.0 - 1.0, ${m}.0 - 1.0,\\n                            ${b}.0 - 1.0);\\n                        vec4 new_scale = original / resized;\\n                        return vec4(coords) * new_scale;\\n                    }\\n                `;\n                        break;\n                    default:\n                        throw new Error(`resize (packed) does not support coordinateTransformMode:                                 '${n.coordinateTransformMode}'`);\n                }\n                const w = (0, o.getCoordsDataType)(f), x = `\\n            const vec2 inputWH = vec2(${b}.0, ${m}.0);\\n            const vec4 scaleWHWH = vec4(float(${y}), float(${_}), float(${y}), float(${_}));\\n            ${(0, a.unpackFromChannel)()}\\n            ${v}\\n            float getAValue(int x10, int r, int c, int d) {\\n                return getChannel(getA(x10, r, c, d), vec2(c, d));\\n            }\\n            void main() {\\n                ${w} rc = getOutputCoords();\\n\\n                int batch = rc[0];\\n                int depth = rc[1];\\n\\n                // retrieve the 4 coordinates that is used in the 4 packed output values.\\n                ivec4 coords = ivec4(rc.wz, rc.w + 1, rc.z + 1);\\n\\n                // calculate the source index in fraction\\n                vec4 sourceFrac = getSourceFracIndex(coords);\\n\\n                // get the lower and upper bound of the 4 values that will be packed into one texel.\\n                ivec4 x00 = ivec4(max(sourceFrac.xy, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.xy)));\\n                ivec4 x01 = ivec4(max(sourceFrac.xw, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.xw)));\\n                ivec4 x10 = ivec4(max(sourceFrac.zy, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.zy)));\\n                ivec4 x11 = ivec4(max(sourceFrac.zw, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.zw)));\\n\\n                bool hasNextRow = rc.w < ${d - 1};\\n                bool hasNextCol = rc.z < ${h - 1};\\n\\n                // pack x00, x01, x10, x11's top-left corner into one vec4 structure\\n                vec4 topLeft = vec4(\\n                    getAValue(batch, depth, x00.x, x00.y),\\n                    hasNextCol ? getAValue(batch, depth, x01.x, x01.y) : 0.0,\\n                    hasNextRow ? getAValue(batch, depth, x10.x, x10.y) : 0.0,\\n                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.x, x11.y) : 0.0);\\n\\n                // pack x00, x01, x10, x11's top-right corner into one vec4 structure\\n                vec4 topRight = vec4(\\n                    getAValue(batch, depth, x00.x, x00.w),\\n                    hasNextCol ? getAValue(batch, depth, x01.x, x01.w) : 0.0,\\n                    hasNextRow ? getAValue(batch, depth, x10.x, x10.w) : 0.0,\\n                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.x, x11.w) : 0.0);\\n\\n                // pack x00, x01, x10, x11's bottom-left corner into one vec4 structure\\n                vec4 bottomLeft = vec4(\\n                    getAValue(batch, depth, x00.z, x00.y),\\n                    hasNextCol ? getAValue(batch, depth, x01.z, x01.y) : 0.0,\\n                    hasNextRow ? getAValue(batch, depth, x10.z, x10.y) : 0.0,\\n                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.z, x11.y) : 0.0);\\n\\n                // pack x00, x01, x10, x11's bottom-right corner into one vec4 structure\\n                vec4 bottomRight = vec4(\\n                    getAValue(batch, depth, x00.z, x00.w),\\n                    hasNextCol ? getAValue(batch, depth, x01.z, x01.w) : 0.0,\\n                    hasNextRow ? getAValue(batch, depth, x10.z, x10.w) : 0.0,\\n                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.z, x11.w) : 0.0);\\n\\n                // calculate the interpolation fraction on u and v direction\\n                vec4 frac = vec4(sourceFrac) - floor(sourceFrac);\\n                vec4 clampFrac = clamp(frac, vec4(0.0), vec4(1.0));\\n\\n                vec4 top = mix(topLeft, topRight, clampFrac.ywyw);\\n                vec4 bottom = mix(bottomLeft, bottomRight, clampFrac.ywyw);\\n                vec4 newValue = mix(top, bottom, clampFrac.xxzz);\\n\\n                ${s.output} = vec4(newValue);\\n            }\\n        `;\n                return Object.assign(Object.assign({}, u), {\n                    output: {\n                        dims: p,\n                        type: e[0].type,\n                        textureType: i.TextureType.packed\n                    },\n                    hasMain: !0,\n                    shaderSource: x\n                });\n            }, l = (t, e)=>{\n                const n = t[0].dims;\n                let r, i = e.scales;\n                if (0 === i.length) {\n                    const o = t[e.scalesInputIdx];\n                    if (o && 0 !== o.size) {\n                        if (t[e.sizesInputIdx]) throw new Error(\"Only one of scales or sizes must be provided as input.\");\n                        i = p(o, e.mode, e.isResize);\n                    } else {\n                        const o = t[e.sizesInputIdx];\n                        if (!o || 0 === o.size) throw new Error(\"Either scales or sizes MUST be provided as input.\");\n                        r = Array.from(o.integerData), i = f(r, n, e.mode, e.isResize);\n                    }\n                } else if (t[e.sizesInputIdx]) throw new Error(\"Only one of scales or sizes must be provided as input.\");\n                const o = r || n.map((t, e)=>Math.floor(t * i[e]));\n                return [\n                    i,\n                    o\n                ];\n            }, p = (t, e, n)=>{\n                const r = Array.from(t.floatData);\n                return (0, s.scalesValidation)(r, e, n), r;\n            }, f = (t, e, n, r)=>{\n                const i = e.length, o = new Array(i);\n                for(let n = 0, r = i; n < r; n++)if (0 === e[n]) {\n                    if (0 !== t[n]) throw new Error(\"Input dim is zero but required output dim is non-zero.\");\n                    o[n] = 1;\n                } else o[n] = t[n] / e[n];\n                return (0, s.scalesValidation)(o, n, r), o;\n            };\n        },\n        8117: (t, e, n)=>{\n            \"use strict\";\n            Object.defineProperty(e, \"__esModule\", {\n                value: !0\n            }), e.shape = void 0;\n            const r = n(9162);\n            e.shape = (t, e)=>(i(e), [\n                    new r.Tensor([\n                        e[0].dims.length\n                    ], \"int32\", void 0, void 0, new Int32Array(e[0].dims))\n                ]);\n            const i = (t)=>{\n                if (!t || 1 !== t.length) throw new Error(\"Shape requires 1 input.\");\n            };\n        },\n        2278: (t, e, n)=>{\n            \"use strict\";\n            Object.defineProperty(e, \"__esModule\", {\n                value: !0\n            }), e.sliceV10 = e.parseSliceAttributes = e.slice = void 0;\n            const r = n(246), i = n(782), o = n(2517), a = n(2039), s = {\n                name: \"Slice\",\n                inputNames: [\n                    \"A\"\n                ],\n                inputTypes: [\n                    a.TextureType.unpacked\n                ]\n            };\n            e.slice = (t, e, n)=>(c(e), [\n                    t.run(Object.assign(Object.assign({}, s), {\n                        cacheHint: n.cacheKey,\n                        get: ()=>u(t, e[0], n)\n                    }), e)\n                ]), e.parseSliceAttributes = (t)=>{\n                const e = t.attributes.getInts(\"starts\"), n = t.attributes.getInts(\"ends\"), i = t.attributes.getInts(\"axes\", []);\n                return (0, r.createAttributeWithCacheKey)({\n                    starts: e,\n                    ends: n,\n                    axes: i\n                });\n            };\n            const u = (t, e, n)=>{\n                const r = 0 === n.axes.length ? e.dims.slice(0).map((t, e)=>e) : n.axes, i = o.ShapeUtil.normalizeAxes(r, e.dims.length), u = n.starts.map((t, n)=>t > e.dims[i[n]] - 1 ? e.dims[i[n]] : o.ShapeUtil.normalizeAxis(t, e.dims[i[n]])), c = n.ends.map((t, n)=>t > e.dims[i[n]] - 1 ? e.dims[i[n]] : o.ShapeUtil.normalizeAxis(t, e.dims[i[n]])), l = e.dims.slice(), p = [];\n                for(let t = 0; t < i.length; t++)l[i[t]] = c[t] - u[t], u[t] > 0 && p.push(`outputIdx[${i[t]}] += ${u[t]};`);\n                const f = `\\n      float process(int outputIdx[${l.length}]) {\\n        ${p.join(\"\\n      \")}\\n        return _A(outputIdx);\\n      }`;\n                return Object.assign(Object.assign({}, s), {\n                    output: {\n                        dims: l,\n                        type: e.type,\n                        textureType: a.TextureType.unpacked\n                    },\n                    shaderSource: f\n                });\n            }, c = (t)=>{\n                if (!t || 1 !== t.length) throw new Error(\"Slice requires 1 input.\");\n                if (-1 === i.NUMBER_TYPES.indexOf(t[0].type)) throw new Error(\"Invalid input type.\");\n            };\n            e.sliceV10 = (t, e)=>{\n                p(e);\n                const n = l(t, e);\n                return [\n                    t.run(Object.assign(Object.assign({}, s), {\n                        cacheHint: n.cacheKey,\n                        get: ()=>u(t, e[0], n)\n                    }), [\n                        e[0]\n                    ])\n                ];\n            };\n            const l = (t, e)=>{\n                if (!t.session.isInitializer(e[1].dataId) || !t.session.isInitializer(e[2].dataId) || e.length >= 4 && !t.session.isInitializer(e[3].dataId) || e.length >= 5 && !t.session.isInitializer(e[4].dataId)) throw new Error(\"dynamic slice attributes are not allowed\");\n                if (e.length >= 5 && e[4].integerData.some((t)=>1 !== t)) throw new Error(\"currently non-1 steps is not supported for Slice\");\n                const n = Array.from(e[1].integerData), r = Array.from(e[2].integerData), i = e.length >= 4 ? Array.from(e[3].integerData) : [];\n                return {\n                    starts: n,\n                    ends: r,\n                    axes: i,\n                    cacheKey: `${i};${n};${r}`\n                };\n            }, p = (t)=>{\n                if (!t || t.length < 3 || t.length > 5) throw new Error(\"Invalid input number.\");\n                if (\"int32\" !== t[1].type || 1 !== t[1].dims.length) throw new Error(\"Invalid input type.\");\n                if (\"int32\" !== t[2].type || 1 !== t[2].dims.length) throw new Error(\"Invalid input type.\");\n                if (t.length >= 4 && (\"int32\" !== t[3].type || 1 !== t[3].dims.length)) throw new Error(\"Invalid input type.\");\n                if (t.length >= 5 && (\"int32\" !== t[4].type || 1 !== t[4].dims.length)) throw new Error(\"Invalid input type.\");\n            };\n        },\n        5524: (t, e, n)=>{\n            \"use strict\";\n            Object.defineProperty(e, \"__esModule\", {\n                value: !0\n            }), e.softmaxV13 = e.parseSoftmaxAttributesV13 = e.parseSoftmaxAttributes = e.softmax = void 0;\n            const r = n(246), i = n(2517), o = n(5060), a = n(2039), s = n(3738), u = {\n                name: \"SoftmaxComputeMax\",\n                inputNames: [\n                    \"A\"\n                ],\n                inputTypes: [\n                    a.TextureType.unpacked\n                ]\n            }, c = {\n                name: \"SoftmaxComputeScale\",\n                inputNames: [\n                    \"A\",\n                    \"Max\"\n                ],\n                inputTypes: [\n                    a.TextureType.unpacked,\n                    a.TextureType.unpacked\n                ]\n            }, l = {\n                name: \"SoftMax\",\n                inputNames: [\n                    \"A\",\n                    \"Max\",\n                    \"Norm\"\n                ],\n                inputTypes: [\n                    a.TextureType.unpacked,\n                    a.TextureType.unpacked,\n                    a.TextureType.unpacked\n                ]\n            };\n            e.softmax = (t, e, n)=>{\n                g(e);\n                const r = e[0].dims.slice(), o = i.ShapeUtil.normalizeAxis(n.axis, r.length), a = i.ShapeUtil.sizeToDimension(r, o), s = i.ShapeUtil.sizeFromDimension(r, o);\n                return p(t, e, n, a, s);\n            }, e.parseSoftmaxAttributes = (t)=>(0, r.createAttributeWithCacheKey)({\n                    axis: t.attributes.getInt(\"axis\", 1)\n                }), e.parseSoftmaxAttributesV13 = (t)=>(0, r.createAttributeWithCacheKey)({\n                    axis: t.attributes.getInt(\"axis\", -1)\n                }), e.softmaxV13 = (t, e, n)=>{\n                g(e);\n                const o = e[0].dims.slice(), a = i.ShapeUtil.normalizeAxis(n.axis, o.length), u = o.length, c = a !== u - 1, l = [];\n                let f, d = [], h = [];\n                c && (d = Array.from({\n                    length: u\n                }).map((t, e)=>e), d[a] = u - 1, d[u - 1] = a, d.map((t)=>l.push(o[t])), f = (0, r.createAttributeWithCacheKey)({\n                    perm: d\n                }), h = (0, s.transpose)(t, e, f));\n                const b = c ? i.ShapeUtil.sizeToDimension(l, u - 1) : i.ShapeUtil.sizeToDimension(o, u - 1), m = c ? i.ShapeUtil.sizeFromDimension(l, u - 1) : i.ShapeUtil.sizeFromDimension(o, u - 1), y = p(t, c ? h : e, n, b, m);\n                return c ? (0, s.transpose)(t, y, f) : y;\n            };\n            const p = (t, e, n, r, i)=>{\n                const o = f(t, e[0], r, i, [\n                    r\n                ]), a = t.run(Object.assign(Object.assign({}, u), {\n                    cacheHint: n.cacheKey,\n                    get: ()=>o\n                }), e), s = d(t, e[0], r, i, o.output.dims, [\n                    r\n                ]), p = t.run(Object.assign(Object.assign({}, c), {\n                    cacheHint: n.cacheKey,\n                    get: ()=>s\n                }), [\n                    e[0],\n                    a\n                ]), g = h(t, e[0], r, i, o.output.dims, s.output.dims);\n                return [\n                    t.run(Object.assign(Object.assign({}, l), {\n                        cacheHint: n.cacheKey,\n                        get: ()=>g\n                    }), [\n                        e[0],\n                        a,\n                        p\n                    ])\n                ];\n            }, f = (t, e, n, r, i)=>{\n                const [s, c] = t.calculateTextureWidthAndHeight(e.dims, a.TextureType.unpacked), l = i.length;\n                if (n < 1 || r < 1) throw new Error(\"Logical row count N and feature count D must be greater than or equal to 1\");\n                if (1 !== i.length) throw new Error(\"Dimensionality of the output should be 1\");\n                if (i[0] !== n) throw new Error(\"Shape of the output should be equal to logical row count\");\n                const p = (0, o.getGlsl)(t.session.backend.glContext.version), f = `\\n      float process(int[${l}] indices) {\\n        int logical_row_start_offset = indices[0] * ${r};\\n\\n        float max = getColorAsFloat(${p.texture2D}(A, offsetToCoords(logical_row_start_offset, ${s},\\n        ${c} )));\\n        for(int i=1; i<${r}; ++i)\\n        {\\n          float current = getColorAsFloat(${p.texture2D}(A, offsetToCoords(logical_row_start_offset + i,\\n            ${s}, ${c})));\\n          if(current > max)\\n          max = current;\\n        }\\n\\n        return max;\\n      }`;\n                return Object.assign(Object.assign({}, u), {\n                    output: {\n                        dims: i,\n                        type: e.type,\n                        textureType: a.TextureType.unpacked\n                    },\n                    shaderSource: f\n                });\n            }, d = (t, e, n, r, i, s)=>{\n                const [u, l] = t.calculateTextureWidthAndHeight(e.dims, a.TextureType.unpacked), p = s.length;\n                if (n < 1 || r < 1) throw new Error(\"Logical row count N and feature count D must be greater than or equal to 1\");\n                if (1 !== s.length) throw new Error(\"Dimensionality of the output should be 1\");\n                if (s[0] !== n) throw new Error(\"Shape of the output should be equal to logical row count\");\n                if (1 !== i.length) throw new Error(\"Dimensionality of the intermediate results should be 1\");\n                if (i[0] !== n) throw new Error(\"Shape of the intermediate results should be equal to logical row count\");\n                const f = `\\n      float process(int[${p}] indices) {\\n        int logical_row_start_offset = indices[0] * ${r};\\n\\n        float norm_factor = 0.0;\\n        float max = _Max(indices);\\n        for(int i=0; i<${r}; ++i)\\n        {\\n          norm_factor += exp(getColorAsFloat(${(0, o.getGlsl)(t.session.backend.glContext.version).texture2D}(A, offsetToCoords(logical_row_start_offset + i,\\n            ${u}, ${l}))) - max);\\n        }\\n\\n        return norm_factor;\\n      }`;\n                return Object.assign(Object.assign({}, c), {\n                    output: {\n                        dims: s,\n                        type: e.type,\n                        textureType: a.TextureType.unpacked\n                    },\n                    shaderSource: f\n                });\n            }, h = (t, e, n, r, i, o)=>{\n                const [s, u] = t.calculateTextureWidthAndHeight(e.dims, a.TextureType.unpacked), c = e.dims.length;\n                if (n < 1 || r < 1) throw new Error(\"Logical row count N and feature count D must be greater than or equal to 1\");\n                if (1 !== i.length || 1 !== o.length) throw new Error(\"Dimensionality of the intermediate results should be 1\");\n                if (i[0] !== n || o[0] !== n) throw new Error(\"Shape of the intermediate results should be equal to logical row count\");\n                const p = `\\n      float process(int[${c}] indices) {\\n\\n      // get offset of current logical tensor index from the 2-D texture coordinates (TexCoords)\\n      int offset = coordsToOffset(TexCoords, ${s}, ${u});\\n\\n      //determine the logical row for this index\\n      int logical_row_index[1];\\n      logical_row_index[0] = offset / ${r};\\n\\n      float norm_factor = _Norm(logical_row_index);\\n\\n      // avoid possible division by 0\\n      // if norm_facor is 0, all elements are zero\\n      // if so, return 0\\n      if(norm_factor == 0.0)\\n        return 0.0;\\n\\n      return exp(_A(indices) - _Max(logical_row_index)) / norm_factor;\\n    }`;\n                return Object.assign(Object.assign({}, l), {\n                    output: {\n                        dims: e.dims,\n                        type: e.type,\n                        textureType: a.TextureType.unpacked\n                    },\n                    shaderSource: p\n                });\n            }, g = (t)=>{\n                if (!t || 1 !== t.length) throw new Error(\"Softmax requires 1 input.\");\n                if (\"float32\" !== t[0].type && \"float64\" !== t[0].type) throw new Error(\"Invalid input type\");\n            };\n        },\n        5975: (t, e, n)=>{\n            \"use strict\";\n            Object.defineProperty(e, \"__esModule\", {\n                value: !0\n            }), e.parseSplitAttributes = e.split = void 0;\n            const r = n(246), i = n(2517), o = n(2039), a = {\n                name: \"Split\",\n                inputNames: [\n                    \"A\"\n                ],\n                inputTypes: [\n                    o.TextureType.unpacked\n                ]\n            };\n            e.split = (t, e, n)=>{\n                c(e);\n                const r = i.ShapeUtil.normalizeAxis(n.axis, e[0].dims.length), o = s(t, e, r, n), l = [];\n                for(let i = 0; i < o; ++i)l.push(t.run(Object.assign(Object.assign({}, a), {\n                    cacheHint: `${n.cacheKey};${i}`,\n                    get: ()=>u(t, e[0], n, r, i)\n                }), e));\n                return l;\n            }, e.parseSplitAttributes = (t)=>{\n                const e = t.attributes.getInt(\"axis\", 0), n = t.attributes.getInts(\"split\", []), i = t.outputs.length;\n                return (0, r.createAttributeWithCacheKey)({\n                    axis: e,\n                    split: n,\n                    numOutputs: i\n                });\n            };\n            const s = (t, e, n, r)=>{\n                const [, o] = i.SplitUtil.splitShape(e[0].dims, n, r.split, r.numOutputs);\n                return o.length;\n            }, u = (t, e, n, r, s)=>{\n                const [u, c] = i.SplitUtil.splitShape(e.dims, r, n.split, n.numOutputs), l = c[s], p = u[s], f = `\\n      float process(int indices[${p.length}]) {\\n        indices[${r}] += ${l};\\n        return _A(indices);\\n      }\\n    `;\n                return Object.assign(Object.assign({}, a), {\n                    cacheHint: `${n.cacheKey}:${s}`,\n                    output: {\n                        dims: p,\n                        type: e.type,\n                        textureType: o.TextureType.unpacked\n                    },\n                    shaderSource: f\n                });\n            }, c = (t)=>{\n                if (!t || 1 !== t.length) throw new Error(\"Split requires one input.\");\n                if (\"int8\" !== t[0].type && \"uint8\" !== t[0].type && \"int16\" !== t[0].type && \"uint16\" !== t[0].type && \"int32\" !== t[0].type && \"uint32\" !== t[0].type && \"float32\" !== t[0].type && \"float64\" !== t[0].type && \"bool\" !== t[0].type) throw new Error(\"Invalid input type.\");\n            };\n        },\n        3933: (t, e, n)=>{\n            \"use strict\";\n            Object.defineProperty(e, \"__esModule\", {\n                value: !0\n            }), e.parseSqueezeAttributes = e.squeezeV13 = e.squeeze = void 0;\n            const r = n(2517);\n            e.squeeze = (t, e, n)=>{\n                i(e);\n                const o = r.ShapeUtil.squeezeShape(e[0].dims, n);\n                return [\n                    t.reshapeUnpacked(e[0], o)\n                ];\n            }, e.squeezeV13 = (t, n)=>(o(n), (0, e.squeeze)(t, [\n                    n[0]\n                ], Array.from(n[1].integerData))), e.parseSqueezeAttributes = (t)=>t.attributes.getInts(\"axes\");\n            const i = (t)=>{\n                if (!t || 1 !== t.length) throw new Error(\"Squeeze requires 1 input.\");\n                if (\"string\" === t[0].type) throw new Error(\"invalid input tensor types.\");\n            }, o = (t)=>{\n                if (!t || 2 !== t.length) throw new Error(\"Squeeze requires 2 inputs.\");\n                if (\"int32\" !== t[1].type) throw new Error(\"Invalid input type.\");\n            };\n        },\n        6558: (t, e, n)=>{\n            \"use strict\";\n            Object.defineProperty(e, \"__esModule\", {\n                value: !0\n            }), e.sum = void 0;\n            const r = n(5060), i = n(2039);\n            e.sum = (t, e)=>{\n                a(e);\n                const n = {\n                    name: \"Sum\",\n                    inputNames: e.map((t, e)=>`X${e}`),\n                    inputTypes: new Array(e.length).fill(i.TextureType.unpacked)\n                };\n                return [\n                    t.run(Object.assign(Object.assign({}, n), {\n                        get: ()=>o(t, e, n)\n                    }), e)\n                ];\n            };\n            const o = (t, e, n)=>{\n                const o = (0, r.getGlsl)(t.session.backend.glContext.version), a = e[0].dims.slice(), s = e.map((t, e)=>`${o.texture2D}(X${e},TexCoords)`).join(\" + \"), u = `\\n      void main() {\\n        vec4 result = ${s};\\n        ${o.output} = result;\\n      }\\n    `;\n                return Object.assign(Object.assign({}, n), {\n                    output: {\n                        dims: a,\n                        type: e[0].type,\n                        textureType: i.TextureType.unpacked\n                    },\n                    hasMain: !0,\n                    shaderSource: u\n                });\n            }, a = (t)=>{\n                if (!t || 0 === t.length) throw new Error(\"Sum requires inputs.\");\n                const e = t[0].dims.length;\n                for(let n = 1; n < t.length; n++){\n                    if (e !== t[n].dims.length) throw new Error(\"Input shapes are mismatched.\");\n                    for(let r = 0; r < e; r++)if (t[0].dims[r] !== t[n].dims[r]) throw new Error(\"Input shapes are not matched.\");\n                }\n                if (\"float32\" !== t[0].type && \"float64\" !== t[0].type) throw new Error(\"Invalid input type.\");\n                for(let e = 1; e < t.length; e++)if (t[0].type !== t[e].type) throw new Error(\"Input types are not matched.\");\n            };\n        },\n        5723: (t, e, n)=>{\n            \"use strict\";\n            Object.defineProperty(e, \"__esModule\", {\n                value: !0\n            }), e.tile = void 0;\n            const r = n(782), i = n(2039);\n            e.tile = (t, e)=>{\n                a(e);\n                const n = {\n                    name: \"Tile\",\n                    inputNames: [\n                        \"A\"\n                    ],\n                    inputTypes: [\n                        i.TextureType.unpacked\n                    ]\n                };\n                return [\n                    t.run(Object.assign(Object.assign({}, n), {\n                        get: ()=>o(t, e, n)\n                    }), e)\n                ];\n            };\n            const o = (t, e, n)=>{\n                const r = e[0].dims.slice(), o = new Array(r.length), a = [];\n                for(let t = 0; t < r.length; t++)o[t] = r[t] * e[1].numberData[t], a.push(`inputIdx[${t}] = int(mod(float(outputIdx[${t}]), ${r[t]}.));`);\n                const s = o.length, u = `\\n      float process(int outputIdx[${s}]) {\\n        int inputIdx[${s}];\\n        ${a.join(\"\\n\")}\\n        return _A(inputIdx);\\n      }\\n    `;\n                return Object.assign(Object.assign({}, n), {\n                    output: {\n                        dims: o,\n                        type: e[0].type,\n                        textureType: i.TextureType.unpacked\n                    },\n                    shaderSource: u\n                });\n            }, a = (t)=>{\n                if (!t || 2 !== t.length) throw new Error(\"Tile requires 2 input.\");\n                if (1 !== t[1].dims.length) throw new Error(\"The second input shape must 1 dimension.\");\n                if (t[1].dims[0] !== t[0].dims.length) throw new Error(\"Invalid input shape.\");\n                if (-1 === r.NUMBER_TYPES.indexOf(t[0].type)) throw new Error(\"Invalid input type.\");\n                if (\"int32\" !== t[1].type && \"int16\" !== t[1].type) throw new Error(\"Invalid repeat type.\");\n            };\n        },\n        3738: (t, e, n)=>{\n            \"use strict\";\n            Object.defineProperty(e, \"__esModule\", {\n                value: !0\n            }), e.parseTransposeAttributes = e.transpose = void 0;\n            const r = n(246), i = n(2517), o = n(2039), a = {\n                name: \"Transpose\",\n                inputNames: [\n                    \"A\"\n                ],\n                inputTypes: [\n                    o.TextureType.unpacked\n                ]\n            };\n            e.transpose = (t, e, n)=>(p(e), [\n                    t.run(Object.assign(Object.assign({}, a), {\n                        cacheHint: n.cacheKey,\n                        get: ()=>s(t, e[0], n.perm)\n                    }), e)\n                ]), e.parseTransposeAttributes = (t)=>(0, r.createAttributeWithCacheKey)({\n                    perm: t.attributes.getInts(\"perm\", [])\n                });\n            const s = (t, e, n)=>{\n                const r = e.dims;\n                n = u(r, n);\n                const i = c(r, n), s = r.length, p = `\\n      ${l(\"perm\", n, s)}\\n      float process(int indices[${s}]) {\\n        int a[${s}];\\n        perm(a, indices);\\n        return _A(a);\\n      }`;\n                return Object.assign(Object.assign({}, a), {\n                    output: {\n                        dims: i,\n                        type: e.type,\n                        textureType: o.TextureType.unpacked\n                    },\n                    shaderSource: p\n                });\n            }, u = (t, e)=>(e && e.length !== t.length && (e = [\n                    ...t.keys()\n                ].reverse()), e), c = (t, e)=>(e = u(t, e), i.ShapeUtil.sortBasedOnPerm(t, e)), l = (t, e, n)=>{\n                const r = [];\n                r.push(`void ${t}(out int a[${n}], int src[${n}]) {`);\n                for(let t = 0; t < n; ++t)r.push(`\\ta[${e[t]}]=src[${t}];`);\n                return r.push(\"\t}\"), r.join(\"\\n\");\n            }, p = (t)=>{\n                if (!t || 1 !== t.length) throw new Error(\"Transpose requires 1 input.\");\n                if (\"float32\" !== t[0].type && \"float64\" !== t[0].type) throw new Error(\"input should be float tensor\");\n            };\n        },\n        8710: (t, e, n)=>{\n            \"use strict\";\n            Object.defineProperty(e, \"__esModule\", {\n                value: !0\n            }), e.encodeAsUint8 = void 0;\n            const r = n(5060), i = n(2039);\n            e.encodeAsUint8 = (t, e)=>{\n                const n = e.shape, o = (0, r.getGlsl)(t.session.backend.glContext.version), a = `\\n    const float FLOAT_MAX = 1.70141184e38;\\n    const float FLOAT_MIN = 1.17549435e-38;\\n\\n    bool isNaN(float val) {\\n      return (val < 1.0 || 0.0 < val || val == 0.0) ? false : true;\\n    }\\n\\n    highp vec4 encodeAsUint8(highp float v) {\\n      if (isNaN(v)) {\\n        return vec4(255, 255, 255, 255);\\n      }\\n\\n      highp float av = abs(v);\\n\\n      if(av < FLOAT_MIN) {\\n        return vec4(0.0, 0.0, 0.0, 0.0);\\n      } else if(v > FLOAT_MAX) {\\n        return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\\n      } else if(v < -FLOAT_MAX) {\\n        return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\\n      }\\n\\n      highp vec4 c = vec4(0,0,0,0);\\n\\n      highp float e = floor(log2(av));\\n      highp float m = exp2(fract(log2(av))) - 1.0;\\n\\n      c[2] = floor(128.0 * m);\\n      m -= c[2] / 128.0;\\n      c[1] = floor(32768.0 * m);\\n      m -= c[1] / 32768.0;\\n      c[0] = floor(8388608.0 * m);\\n\\n      highp float ebias = e + 127.0;\\n      c[3] = floor(ebias / 2.0);\\n      ebias -= c[3] * 2.0;\\n      c[2] += floor(ebias) * 128.0;\\n\\n      c[3] += 128.0 * step(0.0, -v);\\n\\n      return c / 255.0;\\n    }\\n\\n    void main() {\\n      float value = ${o.texture2D}(X,TexCoords).r;\\n      ${o.output} = encodeAsUint8(value);\\n    }`, s = {\n                    name: \"Uint8Encode\",\n                    inputTypes: [\n                        i.TextureType.unpacked\n                    ],\n                    inputNames: [\n                        \"X\"\n                    ],\n                    output: {\n                        dims: n,\n                        type: e.tensor.type,\n                        textureType: i.TextureType.downloadUint8AsFloat\n                    },\n                    shaderSource: a,\n                    hasMain: !0\n                };\n                return t.executeProgram(s, [\n                    e.tensor\n                ]);\n            };\n        },\n        4909: (t, e, n)=>{\n            \"use strict\";\n            Object.defineProperty(e, \"__esModule\", {\n                value: !0\n            }), e.tanh = e.tan = e.sqrt = e.sin = e.sigmoid = e.relu = e.not = e.neg = e.log = e.parseLeakyReluAttributes = e.leakyRelu = e.identity = e.floor = e.exp = e.parseEluAttributes = e.elu = e.cos = e.ceil = e.clipV11 = e.parseClipAttributes = e.clip = e.atan = e.asin = e.acos = e.abs = e.glslTanh = e.glslTan = e.glslSqrt = e.glslSigmoid = e.glslRelu = e.glslSin = e.glslNot = e.glslNeg = e.glslLog = e.glslLeakyRelu = e.glslIdentity = e.glslClip = e.glslFloor = e.glslExp = e.glslElu = e.glslCos = e.glslCeil = e.glslAtan = e.glslAsin = e.glslAcos = e.glslAbs = void 0;\n            const r = n(246), i = n(2517), o = n(8520), a = n(5060), s = n(2039);\n            function u() {\n                return P(\"abs\");\n            }\n            function c() {\n                return P(\"acos\");\n            }\n            function l() {\n                return P(\"asin\");\n            }\n            function p() {\n                return P(\"atan\");\n            }\n            function f() {\n                return P(\"ceil\");\n            }\n            function d() {\n                return P(\"cos\");\n            }\n            function h(t) {\n                const e = \"elu\";\n                return {\n                    body: `\\n  const float alpha = float(${t});\\n\\n  float ${e}_(float a) {\\n    return a >= 0.0 ? a: (exp(a) - 1.0) * alpha;\\n  }\\n  vec4 ${e}_(vec4 v) {\\n    return vec4(${e}_(v.x), ${e}_(v.y), ${e}_(v.z), ${e}_(v.w));\\n  }\\n  `,\n                    name: e,\n                    type: o.FunctionType.ValueBased\n                };\n            }\n            function g() {\n                return P(\"exp\");\n            }\n            function b() {\n                return P(\"floor\");\n            }\n            function m(t, e) {\n                const n = \"clip\";\n                return {\n                    body: `\\n  const float min = float(${t});\\n  const float max = float(${e});\\n\\n  float ${n}_(float a) {\\n    return clamp(a, min, max);\\n  }\\n  vec4 ${n}_(vec4 v) {\\n    return clamp(v, min, max);\\n  }\\n  `,\n                    name: n,\n                    type: o.FunctionType.ValueBased\n                };\n            }\n            function y() {\n                const t = \"indentity\";\n                return {\n                    body: `\\n  float ${t}_(float a) {\\n    return a;\\n  }\\n  vec4 ${t}_(vec4 v) {\\n    return v;\\n  }\\n  `,\n                    name: t,\n                    type: o.FunctionType.ValueBased\n                };\n            }\n            function _(t) {\n                const e = \"leakyRelu\";\n                return {\n                    body: `\\n  const float alpha = float(${t});\\n\\n  float ${e}_(float a) {\\n    return a < 0.0 ? a * alpha : a;\\n  }\\n  vec4 ${e}_(vec4 v) {\\n    return vec4(${e}_(v.x), ${e}_(v.y), ${e}_(v.z), ${e}_(v.w));\\n  }\\n  `,\n                    name: e,\n                    type: o.FunctionType.ValueBased\n                };\n            }\n            function v() {\n                return P(\"log\");\n            }\n            function w() {\n                const t = \"neg\";\n                return {\n                    body: `\\n  float ${t}_(float a) {\\n    return -a;\\n  }\\n  vec4 ${t}_(vec4 v) {\\n    return -v;\\n  }\\n  `,\n                    name: t,\n                    type: o.FunctionType.ValueBased\n                };\n            }\n            function x() {\n                const t = \"not\";\n                return {\n                    body: `\\n  float ${t}_(float a) {\\n    return float( ! bool(a) );\\n  }\\n  bool ${t}_(bool a) {\\n    return !a;\\n  }\\n  vec4 ${t}_(vec4 v) {\\n    return vec4(!bool(v.x), !bool(v.y), !bool(v.z), !bool(v.w));\\n  }\\n  bvec4 ${t}_(bvec4 v) {\\n    return bvec4(!v.x, !v.y, !v.z, !v.w);\\n  }\\n  `,\n                    name: t,\n                    type: o.FunctionType.ValueBased\n                };\n            }\n            function T() {\n                return P(\"sin\");\n            }\n            function S() {\n                const t = \"relu\";\n                return {\n                    body: `\\n  float ${t}_(float a) {\\n    return max( a, 0.0 );\\n  }\\n  vec4 ${t}_(vec4 v) {\\n    return max( v, 0.0 );\\n  }\\n  `,\n                    name: t,\n                    type: o.FunctionType.ValueBased\n                };\n            }\n            function O() {\n                const t = \"sigmoid\";\n                return {\n                    body: `\\n  float ${t}_(float a) {\\n    return 1.0 / (1.0 + exp(-a));\\n  }\\n  vec4 ${t}_(vec4 v) {\\n    return 1.0 / (1.0 + exp(-v));\\n  }\\n  `,\n                    name: t,\n                    type: o.FunctionType.ValueBased\n                };\n            }\n            function A() {\n                return P(\"sqrt\");\n            }\n            function E() {\n                return P(\"tan\");\n            }\n            function I() {\n                const t = \"tanh\";\n                return {\n                    body: `\\n  float ${t}_(float a) {\\n    a = clamp(a, -10., 10.);\\n    a = exp(2.*a);\\n    return (a - 1.) / (a + 1.);\\n  }\\n  vec4 ${t}_(vec4 v) {\\n    v = clamp(v, -10., 10.);\\n    v = exp(2.*v);\\n    return (v - 1.) / (v + 1.);\\n  }\\n  `,\n                    name: t,\n                    type: o.FunctionType.ValueBased\n                };\n            }\n            function P(t) {\n                return {\n                    body: `\\n  float ${t}_(float a) {\\n    return ${t}(a);\\n  }\\n  vec4 ${t}_(vec4 v) {\\n    return ${t}(v);\\n  }\\n  `,\n                    name: t,\n                    type: o.FunctionType.ValueBased\n                };\n            }\n            e.glslAbs = u, e.glslAcos = c, e.glslAsin = l, e.glslAtan = p, e.glslCeil = f, e.glslCos = d, e.glslElu = h, e.glslExp = g, e.glslFloor = b, e.glslClip = m, e.glslIdentity = y, e.glslLeakyRelu = _, e.glslLog = v, e.glslNeg = w, e.glslNot = x, e.glslSin = T, e.glslRelu = S, e.glslSigmoid = O, e.glslSqrt = A, e.glslTan = E, e.glslTanh = I;\n            const D = (t, e, n, r)=>{\n                const i = t.session.pack ? s.TextureType.packed : s.TextureType.unpacked, o = {\n                    name: n.name,\n                    inputTypes: [\n                        i\n                    ],\n                    inputNames: [\n                        \"A\"\n                    ],\n                    cacheHint: r\n                };\n                return Object.assign(Object.assign({}, o), {\n                    get: ()=>((t, e, n, r)=>{\n                            const i = t.session.pack ? s.TextureType.packed : s.TextureType.unpacked, o = (0, a.getGlsl)(t.session.backend.glContext.version);\n                            return Object.assign(Object.assign({}, e), {\n                                output: {\n                                    dims: n.dims,\n                                    type: n.type,\n                                    textureType: i\n                                },\n                                shaderSource: `\\n     ${r.body}\\n     void main() {\\n       vec4 v = ${o.texture2D}(A, TexCoords);\\n       v = ${r.name}_(v);\\n       ${o.output} = v;\\n     }\\n     `,\n                                hasMain: !0\n                            });\n                        })(t, o, e, n)\n                });\n            };\n            e.abs = (t, e)=>[\n                    t.run(D(t, e[0], u()), e)\n                ], e.acos = (t, e)=>[\n                    t.run(D(t, e[0], c()), e)\n                ], e.asin = (t, e)=>[\n                    t.run(D(t, e[0], l()), e)\n                ], e.atan = (t, e)=>[\n                    t.run(D(t, e[0], p()), e)\n                ], e.clip = (t, e, n)=>[\n                    t.run(D(t, e[0], m(n.min, n.max), n.cacheKey), e)\n                ], e.parseClipAttributes = (t)=>(0, r.createAttributeWithCacheKey)({\n                    min: t.attributes.getFloat(\"min\", i.MIN_CLIP),\n                    max: t.attributes.getFloat(\"max\", i.MAX_CLIP)\n                }), e.clipV11 = (t, n)=>{\n                const r = $(t, n);\n                return (0, e.clip)(t, [\n                    n[0]\n                ], r);\n            };\n            const $ = (t, e)=>{\n                if (e.length >= 3 && (!t.session.isInitializer(e[1].dataId) || !t.session.isInitializer(e[2].dataId))) throw new Error(\"dynamic clip attributes are not allowed\");\n                const n = e.length >= 3 ? e[1].numberData[0] : i.MIN_CLIP, o = e.length >= 3 ? e[2].numberData[0] : i.MAX_CLIP;\n                return (0, r.createAttributeWithCacheKey)({\n                    min: n,\n                    max: o\n                });\n            };\n            e.ceil = (t, e)=>[\n                    t.run(D(t, e[0], f()), e)\n                ], e.cos = (t, e)=>[\n                    t.run(D(t, e[0], d()), e)\n                ], e.elu = (t, e, n)=>[\n                    t.run(D(t, e[0], h(n.alpha), n.cacheKey), e)\n                ], e.parseEluAttributes = (t)=>(0, r.createAttributeWithCacheKey)({\n                    alpha: t.attributes.getFloat(\"alpha\", 1)\n                }), e.exp = (t, e)=>[\n                    t.run(D(t, e[0], g()), e)\n                ], e.floor = (t, e)=>[\n                    t.run(D(t, e[0], b()), e)\n                ], e.identity = (t, e)=>[\n                    t.run(D(t, e[0], y()), e)\n                ], e.leakyRelu = (t, e, n)=>[\n                    t.run(D(t, e[0], _(n.alpha), n.cacheKey), e)\n                ], e.parseLeakyReluAttributes = (t)=>(0, r.createAttributeWithCacheKey)({\n                    alpha: t.attributes.getFloat(\"alpha\", .01)\n                }), e.log = (t, e)=>[\n                    t.run(D(t, e[0], v()), e)\n                ], e.neg = (t, e)=>[\n                    t.run(D(t, e[0], w()), e)\n                ], e.not = (t, e)=>[\n                    t.run(D(t, e[0], x()), e)\n                ], e.relu = (t, e)=>[\n                    t.run(D(t, e[0], S()), e)\n                ], e.sigmoid = (t, e)=>[\n                    t.run(D(t, e[0], O()), e)\n                ], e.sin = (t, e)=>[\n                    t.run(D(t, e[0], T()), e)\n                ], e.sqrt = (t, e)=>[\n                    t.run(D(t, e[0], A()), e)\n                ], e.tan = (t, e)=>[\n                    t.run(D(t, e[0], E()), e)\n                ], e.tanh = (t, e)=>[\n                    t.run(D(t, e[0], I()), e)\n                ];\n        },\n        5611: (t, e, n)=>{\n            \"use strict\";\n            Object.defineProperty(e, \"__esModule\", {\n                value: !0\n            }), e.createUnpackProgramInfoLoader = e.createUnpackProgramInfo = void 0;\n            const r = n(5060), i = n(2039), o = n(9390), a = n(2827), s = {\n                name: \"unpack\",\n                inputNames: [\n                    \"A\"\n                ],\n                inputTypes: [\n                    i.TextureType.packed\n                ]\n            };\n            e.createUnpackProgramInfo = (t, e)=>{\n                const n = e.dims.length, u = (0, a.getChannels)(\"rc\", n), c = u.slice(-2), l = (0, o.getCoordsDataType)(n), p = (0, a.unpackFromChannel)(), f = 0 === e.dims.length ? \"\" : function(t, e) {\n                    if (1 === t) return \"rc\";\n                    let n = \"\";\n                    for(let r = 0; r < t; r++)n += e[r], r < t - 1 && (n += \",\");\n                    return n;\n                }(n, u), d = n <= 1 ? \"rc\" : `vec2(${c.join(\",\")})`, h = `\\n    ${p}\\n    void main() {\\n      ${l} rc = getOutputCoords();\\n\\n       // Sample the texture with the coords to get the rgba channel value.\\n       vec4 packedInput = getA(${f});\\n\\n       ${(0, r.getGlsl)(t.session.backend.glContext.version).output} = vec4(getChannel(packedInput, ${d}), 0, 0, 0);\\n     }\\n   `;\n                return Object.assign(Object.assign({}, s), {\n                    hasMain: !0,\n                    output: {\n                        dims: e.dims,\n                        type: e.type,\n                        textureType: i.TextureType.unpacked\n                    },\n                    shaderSource: h\n                });\n            }, e.createUnpackProgramInfoLoader = (t, n)=>Object.assign(Object.assign({}, s), {\n                    get: ()=>(0, e.createUnpackProgramInfo)(t, n)\n                });\n        },\n        8428: (t, e, n)=>{\n            \"use strict\";\n            Object.defineProperty(e, \"__esModule\", {\n                value: !0\n            }), e.parseUnsqueezeAttributes = e.unsqueezeV13 = e.unsqueeze = void 0;\n            const r = n(2517);\n            e.unsqueeze = (t, e, n)=>{\n                i(e);\n                const o = r.ShapeUtil.unsqueezeShape(e[0].dims, n);\n                return [\n                    t.reshapeUnpacked(e[0], o)\n                ];\n            }, e.unsqueezeV13 = (t, n)=>(o(n), (0, e.unsqueeze)(t, [\n                    n[0]\n                ], Array.from(n[1].integerData))), e.parseUnsqueezeAttributes = (t)=>t.attributes.getInts(\"axes\");\n            const i = (t)=>{\n                if (!t || 1 !== t.length) throw new Error(\"Unsqueeze requires 1 input.\");\n                if (\"string\" === t[0].type) throw new Error(\"invalid input tensor types.\");\n            }, o = (t)=>{\n                if (!t || 2 !== t.length) throw new Error(\"Unsqueeze requires 2 inputs.\");\n                if (\"int32\" !== t[1].type) throw new Error(\"Invalid input type.\");\n            };\n        },\n        9793: (t, e, n)=>{\n            \"use strict\";\n            Object.defineProperty(e, \"__esModule\", {\n                value: !0\n            }), e.scalesValidation = e.validateInputs = e.parseUpsampleAttributes = e.parseUpsampleAttributesV9 = e.parseUpsampleAttributesV7 = e.upsample = void 0;\n            const r = n(246), i = n(5060), o = n(2039), a = {\n                name: \"Upsample\",\n                inputNames: [\n                    \"X\"\n                ],\n                inputTypes: [\n                    o.TextureType.unpacked\n                ]\n            };\n            e.upsample = (t, n, r)=>((0, e.validateInputs)(n, r), [\n                    t.run(Object.assign(Object.assign({}, a), {\n                        cacheHint: r.cacheKey,\n                        get: ()=>s(t, n, r)\n                    }), n)\n                ]), e.parseUpsampleAttributesV7 = (t)=>(0, e.parseUpsampleAttributes)(t, 7), e.parseUpsampleAttributesV9 = (t)=>(0, e.parseUpsampleAttributes)(t, 9), e.parseUpsampleAttributes = (t, n)=>{\n                const i = n >= 10, o = t.attributes.getString(\"mode\", \"nearest\");\n                if (\"nearest\" !== o && \"linear\" !== o && (n < 11 || \"cubic\" !== o)) throw new Error(`unrecognized mode: ${o}`);\n                let a = [];\n                n < 9 && (a = t.attributes.getFloats(\"scales\"), (0, e.scalesValidation)(a, o, i));\n                const s = t.attributes.getFloat(\"extrapolation_value\", 0), u = n > 10 ? t.attributes.getString(\"coordinate_transformation_mode\", \"half_pixel\") : \"asymmetric\";\n                if (-1 === [\n                    \"asymmetric\",\n                    \"pytorch_half_pixel\",\n                    \"tf_half_pixel_for_nn\",\n                    \"align_corners\",\n                    \"tf_crop_and_resize\",\n                    \"half_pixel\"\n                ].indexOf(u)) throw new Error(`coordinate_transform_mode '${u}' is not supported`);\n                const c = \"tf_crop_and_resize\" === u, l = c, p = \"nearest\" === o && n >= 11 ? t.attributes.getString(\"nearest_mode\", \"round_prefer_floor\") : \"\";\n                if (-1 === [\n                    \"round_prefer_floor\",\n                    \"round_prefer_ceil\",\n                    \"floor\",\n                    \"ceil\",\n                    \"\"\n                ].indexOf(p)) throw new Error(`nearest_mode '${p}' is not supported`);\n                const f = t.attributes.getFloat(\"cubic_coeff_a\", -.75), d = 0 !== t.attributes.getInt(\"exclude_outside\", 0);\n                if (d && \"cubic\" !== o) throw new Error(\"exclude_outside can be set to 1 only when mode is CUBIC.\");\n                const h = n < 11 || \"nearest\" === o && \"asymmetric\" === u && \"floor\" === p;\n                let g = 0, b = 0, m = 0;\n                return n > 10 ? t.inputs.length > 2 ? (g = 1, b = 2, m = 3) : (b = 1, m = 2) : 9 === n && (b = 1), (0, r.createAttributeWithCacheKey)({\n                    opset: n,\n                    isResize: i,\n                    mode: o,\n                    scales: a,\n                    extrapolationValue: s,\n                    coordinateTransformMode: u,\n                    useExtrapolation: l,\n                    needRoiInput: c,\n                    nearestMode: p,\n                    cubicCoefficientA: f,\n                    excludeOutside: d,\n                    useNearest2xOptimization: h,\n                    roiInputIdx: g,\n                    scalesInputIdx: b,\n                    sizesInputIdx: m\n                });\n            };\n            const s = (t, e, n)=>{\n                const r = (0, i.getGlsl)(t.session.backend.glContext.version), [s, u] = t.calculateTextureWidthAndHeight(e[0].dims, o.TextureType.unpacked), c = e[0].dims.map((t, e)=>Math.floor(t * n.scales[e])), [l, p] = t.calculateTextureWidthAndHeight(c, o.TextureType.unpacked), f = c.length, d = new Array(f), h = new Array(f);\n                let g = `\\n      int output_pitches[${f}];\\n      int input_pitches[${f}];\\n      `;\n                for(let t = f - 1; t >= 0; t--)d[t] = t === f - 1 ? 1 : d[t + 1] * c[t + 1], h[t] = t === f - 1 ? 1 : h[t + 1] * e[0].dims[t + 1], g += `\\n        output_pitches[${t}] = ${d[t]};\\n        input_pitches[${t}] = ${h[t]};\\n        `;\n                const b = `\\n      float getInputFloat(int index) {\\n        vec2 coords = offsetToCoords(index, ${s}, ${u});\\n        float value = getColorAsFloat(${r.texture2D}(X, coords));\\n        return value;\\n      }\\n      `, m = \"nearest\" === n.mode ? `\\n    ${b}\\n    float process(int indices[${f}]) {\\n      int input_index = 0;\\n      int output_index = coordsToOffset(TexCoords, ${l}, ${p});\\n\\n      ${g}\\n\\n      int d, m;\\n      for (int dim = 0; dim < ${f}; ++dim) {\\n        d = output_index / output_pitches[dim];\\n        m = output_index - d * output_pitches[dim];\\n        output_index = m;\\n\\n        if (scales[dim] != 1 && d > 0) {\\n          int d2 = d / scales[dim];\\n          m = d - d2 * scales[dim];\\n          d = d2;\\n        }\\n        input_index += input_pitches[dim] * d;\\n      }\\n\\n      return getInputFloat(input_index);\\n    }` : 4 === f ? `\\n    ${b}\\n    float process(int indices[4]) {\\n      int input_index = 0;\\n      int output_index = coordsToOffset(TexCoords, ${l}, ${p});\\n\\n      ${g}\\n\\n      int m;\\n      int index_of_dim0, index_of_dim1, index_of_dim2, index_of_dim3;\\n      index_of_dim0 = output_index / output_pitches[0];\\n      m = output_index - index_of_dim0 * output_pitches[0];\\n      index_of_dim1 = m / output_pitches[1];\\n      m = m - index_of_dim1 * output_pitches[1];\\n      index_of_dim2 = m / output_pitches[2];\\n      m = m - index_of_dim2 * output_pitches[2];\\n      index_of_dim3 = m;\\n\\n      int index_of_input_dim2, index_of_input_dim3, x_offset, y_offset;\\n      index_of_input_dim2 = index_of_dim2 / scales[2];\\n      y_offset = index_of_dim2 - index_of_input_dim2 * scales[2];\\n      index_of_input_dim3 = index_of_dim3 / scales[3];\\n      x_offset = index_of_dim3 - index_of_input_dim3 * scales[3];\\n\\n      input_index = index_of_dim0 * input_pitches[0] +\\n            index_of_dim1 * input_pitches[1] +\\n            index_of_input_dim2 * input_pitches[2] +\\n            index_of_input_dim3;\\n\\n      float x00 = getInputFloat(input_index);\\n      float x10, x01, x11;\\n\\n      bool end_of_dim2 = false;\\n      if (index_of_input_dim2 == (${e[0].dims[2]} - 1)) {\\n        // It's the end in dimension 2\\n        x01 = x00;\\n        end_of_dim2 = true;\\n      } else {\\n        x01 = getInputFloat(input_index + input_pitches[2]);\\n      }\\n\\n      if (index_of_input_dim3 == (input_pitches[2] - 1)) {\\n        // It's the end in dimension 3\\n        x10 = x00;\\n        x11 = x01;\\n      }\\n      else {\\n        x10 = getInputFloat(input_index + 1);\\n        x11 = end_of_dim2 ? x10 : getInputFloat(input_index + input_pitches[2] + 1);\\n      }\\n\\n      float y0 = x00 + float(y_offset) * (x01 - x00) / float(scales[2]);\\n      float y1 = x10 + float(y_offset) * (x11 - x10) / float(scales[2]);\\n      return y0 + float(x_offset) * (y1 - y0) / float(scales[3]);\\n    }` : `\\n    ${b}\\n    float process(int indices[2]) {\\n      int input_index = 0;\\n      int output_index = coordsToOffset(TexCoords, ${l}, ${p});\\n\\n      ${g}\\n\\n      int m;\\n      int index_of_dim0, index_of_dim1;\\n      index_of_dim0 = output_index / output_pitches[0];\\n      m = output_index - index_of_dim0 * output_pitches[0];\\n      index_of_dim1 = m;\\n\\n      int index_of_input_dim0, index_of_input_dim1, x_offset, y_offset;\\n      index_of_input_dim0 = index_of_dim0 / scales[0];\\n      y_offset = index_of_dim0 - index_of_input_dim0 * scales[0];\\n      index_of_input_dim1 = index_of_dim1 / scales[1];\\n      x_offset = index_of_dim1 - index_of_input_dim1 * scales[1];\\n\\n      input_index = index_of_input_dim0 * input_pitches[0] + index_of_input_dim1;\\n\\n      float x00 = getInputFloat(input_index);\\n      float x10, x01, x11;\\n\\n      bool end_of_dim0 = false;\\n      if (index_of_input_dim0 == (${e[0].dims[0]} - 1)) {\\n        // It's the end in dimension 0\\n        x01 = x00;\\n        end_of_dim0 = true;\\n      } else {\\n        x01 = getInputFloat(input_index + input_pitches[0]);\\n      }\\n\\n      if (index_of_input_dim1 == (input_pitches[0] - 1)) {\\n        // It's the end in dimension 1\\n        x10 = x00;\\n        x11 = x01;\\n      }\\n      else {\\n        x10 = getInputFloat(input_index + 1);\\n        x11 = end_of_dim0 ? x10 : getInputFloat(input_index + input_pitches[0] + 1);\\n      }\\n\\n      float y0 = x00 + float(y_offset) * (x01 - x00) / float(scales[0]);\\n      float y1 = x10 + float(y_offset) * (x11 - x10) / float(scales[0]);\\n      return y0 + float(x_offset) * (y1 - y0) / float(scales[1]);\\n    }`;\n                return Object.assign(Object.assign({}, a), {\n                    output: {\n                        dims: c,\n                        type: e[0].type,\n                        textureType: o.TextureType.unpacked\n                    },\n                    shaderSource: m,\n                    variables: [\n                        {\n                            name: \"scales\",\n                            type: \"int\",\n                            arrayLength: n.scales.length,\n                            data: n.scales.map((t)=>Math.ceil(t))\n                        }\n                    ]\n                });\n            };\n            e.validateInputs = (t, e)=>{\n                if (!t || e.opset < 9 && 1 !== t.length || e.opset >= 9 && e.opset < 11 && 2 !== t.length || e.opset >= 11 && t.length < 2) throw new Error(\"invalid inputs.\");\n                if (e.scales.length > 0 && t[0].dims.length !== e.scales.length) throw new Error(\"Invalid input shape.\");\n                if (\"string\" === t[0].type) throw new Error(\"Invalid input tensor types.\");\n            }, e.scalesValidation = (t, e, n)=>{\n                if (n) {\n                    for (const e of t)if (e <= 0) throw new Error(\"Scale value should be greater than 0.\");\n                } else for (const e of t)if (e < 1) throw new Error(\"Scale value should be greater than or equal to 1.\");\n                if (!(\"linear\" !== e && \"cubic\" !== e || 2 === t.length || 4 === t.length && 1 === t[0] && 1 === t[1])) throw new Error(`'Linear' mode and 'Cubic' mode only support 2-D inputs ('Bilinear', 'Bicubic')         or 4-D inputs with the corresponding outermost 2 scale values being 1         in the ${n ? \"Resize\" : \"Upsample\"} opeartor.`);\n            };\n        },\n        1958: (t, e, n)=>{\n            \"use strict\";\n            Object.defineProperty(e, \"__esModule\", {\n                value: !0\n            }), e.ProgramManager = void 0;\n            const r = n(6207), i = n(3694), o = n(8879), a = n(5060);\n            e.ProgramManager = class {\n                constructor(t, e, n){\n                    this.profiler = t, this.glContext = e, this.textureLayoutStrategy = n, this.repo = new Map, this.attributesBound = !1;\n                }\n                getArtifact(t) {\n                    return this.repo.get(t);\n                }\n                setArtifact(t, e) {\n                    this.repo.set(t, e);\n                }\n                run(t, e, n) {\n                    var r;\n                    this.profiler.event(\"op\", `ProgramManager.run ${null !== (r = t.programInfo.name) && void 0 !== r ? r : \"unknown kernel\"}`, ()=>{\n                        var r;\n                        const o = this.glContext.gl, a = t.program;\n                        o.useProgram(a);\n                        try {\n                            this.bindOutput(n), this.attributesBound || this.bindAttributes(t.attribLocations), this.bindUniforms(t.uniformLocations, null !== (r = t.programInfo.variables) && void 0 !== r ? r : [], e);\n                        } catch (e) {\n                            throw i.Logger.error(\"ProgramManager\", t.programInfo.shaderSource), e;\n                        }\n                        this.profiler.event(\"backend\", \"GlContext.draw()\", ()=>{\n                            this.glContext.draw();\n                        });\n                    }, this.glContext);\n                }\n                dispose() {\n                    this.vertexShader && this.glContext.deleteShader(this.vertexShader), this.repo.forEach((t)=>this.glContext.deleteProgram(t.program));\n                }\n                build(t, e, n) {\n                    return this.profiler.event(\"backend\", \"ProgramManager.build\", ()=>{\n                        const r = new o.GlslPreprocessor(this.glContext, t, e, n), i = r.preprocess(), a = this.compile(i);\n                        return {\n                            programInfo: t,\n                            program: a,\n                            uniformLocations: this.getUniformLocations(a, r.context.programInfo.inputNames, r.context.programInfo.variables),\n                            attribLocations: this.getAttribLocations(a)\n                        };\n                    });\n                }\n                compile(t) {\n                    if (!this.vertexShader) {\n                        i.Logger.verbose(\"ProrgramManager\", \"Compiling and caching Vertex shader for the first time\");\n                        const t = (0, a.getVertexShaderSource)(this.glContext.version);\n                        this.vertexShader = this.glContext.compileShader(t, this.glContext.gl.VERTEX_SHADER);\n                    }\n                    r.env.debug && i.Logger.verbose(\"ProrgramManager\", `FragShader:\\n${t}\\n`);\n                    const e = this.glContext.compileShader(t, this.glContext.gl.FRAGMENT_SHADER), n = this.glContext.createProgram(this.vertexShader, e);\n                    return this.glContext.deleteShader(e), n;\n                }\n                bindOutput(t) {\n                    const e = t.width, n = t.height;\n                    i.Logger.verbose(\"ProrgramManager\", `Binding output texture to Framebuffer: w/h=${e}/${n}, shape=${t.shape}, type=${t.tensor.type}`), this.glContext.attachFramebuffer(t.texture, e, n);\n                }\n                bindAttributes(t) {\n                    const e = t.position, n = t.textureCoord;\n                    this.glContext.setVertexAttributes(e, n), this.attributesBound = !0;\n                }\n                bindUniforms(t, e, n) {\n                    var r;\n                    const i = this.glContext.gl;\n                    let o = 0;\n                    for (const { name: a, type: s, location: u, arrayLength: c } of t){\n                        const t = null === (r = e.find((t)=>t.name === a)) || void 0 === r ? void 0 : r.data;\n                        if (\"sampler2D\" !== s && !t) throw new Error(`variable '${a}' does not have data defined in program info`);\n                        switch(s){\n                            case \"sampler2D\":\n                                this.bindTexture(n[o], u, o), o++;\n                                break;\n                            case \"float\":\n                                c ? i.uniform1fv(u, t) : i.uniform1f(u, t);\n                                break;\n                            case \"int\":\n                                c ? i.uniform1iv(u, t) : i.uniform1i(u, t);\n                                break;\n                            default:\n                                throw new Error(`Uniform not implemented: ${s}`);\n                        }\n                    }\n                }\n                bindTexture(t, e, n) {\n                    this.glContext.bindTextureToUniform(t.texture, n, e);\n                }\n                getAttribLocations(t) {\n                    return {\n                        position: this.getAttribLocation(t, \"position\"),\n                        textureCoord: this.getAttribLocation(t, \"textureCoord\")\n                    };\n                }\n                getUniformLocations(t, e, n) {\n                    const r = [];\n                    if (e) for (const n of e)r.push({\n                        name: n,\n                        type: \"sampler2D\",\n                        location: this.getUniformLocation(t, n)\n                    });\n                    if (n) for (const e of n)r.push(Object.assign(Object.assign({}, e), {\n                        location: this.getUniformLocation(t, e.name)\n                    }));\n                    return r;\n                }\n                getUniformLocation(t, e) {\n                    const n = this.glContext.gl.getUniformLocation(t, e);\n                    if (null === n) throw new Error(`Uniform ${e} not found.`);\n                    return n;\n                }\n                getAttribLocation(t, e) {\n                    return this.glContext.gl.getAttribLocation(t, e);\n                }\n            };\n        },\n        6416: (t, e, n)=>{\n            \"use strict\";\n            Object.defineProperty(e, \"__esModule\", {\n                value: !0\n            }), e.WebGLSessionHandler = void 0;\n            const r = n(3694), i = n(1047), o = n(8316), a = n(1640), s = n(1958), u = n(7859), c = n(5702);\n            e.WebGLSessionHandler = class {\n                constructor(t, e){\n                    this.backend = t, this.context = e, this.layoutStrategy = new u.PreferLogicalStrategy(t.glContext.maxTextureSize), this.programManager = new s.ProgramManager(this.context.profiler, t.glContext, this.layoutStrategy), this.textureManager = new c.TextureManager(t.glContext, this.layoutStrategy, this.context.profiler, {\n                        reuseTextures: \"full\" === t.textureCacheMode\n                    }), this.packedTextureDataCache = new Map, this.unpackedTextureDataCache = new Map, this.pack = t.pack, this.pack2unpackMap = new Map, this.unpack2packMap = new Map;\n                }\n                createInferenceHandler() {\n                    return new o.WebGLInferenceHandler(this);\n                }\n                onGraphInitialized(t) {\n                    const e = t.getValues().filter((t)=>-1 === t.from && t.tensor).map((t)=>t.tensor.dataId);\n                    this.initializers = new Set(e);\n                }\n                isInitializer(t) {\n                    return !!this.initializers && this.initializers.has(t);\n                }\n                addInitializer(t) {\n                    this.initializers.add(t);\n                }\n                getTextureData(t, e) {\n                    return e ? this.packedTextureDataCache.get(t) : this.unpackedTextureDataCache.get(t);\n                }\n                setTextureData(t, e, n = !1) {\n                    r.Logger.verbose(\"WebGLSessionHandler\", \"Storing Texture data in cache\"), n ? this.packedTextureDataCache.set(t, e) : this.unpackedTextureDataCache.set(t, e);\n                }\n                dispose() {\n                    this.programManager.dispose(), this.textureManager.clearActiveTextures(), this.packedTextureDataCache.forEach((t)=>this.textureManager.releaseTexture(t, !0)), this.packedTextureDataCache = new Map, this.unpackedTextureDataCache.forEach((t)=>this.textureManager.releaseTexture(t, !0)), this.unpackedTextureDataCache = new Map;\n                }\n                resolve(t, e, n) {\n                    const r = (0, i.resolveOperator)(t, e, a.WEBGL_OP_RESOLVE_RULES);\n                    return {\n                        impl: r.opImpl,\n                        context: r.opInit ? r.opInit(t, n) : t\n                    };\n                }\n            };\n        },\n        7769: (t, e, n)=>{\n            \"use strict\";\n            Object.defineProperty(e, \"__esModule\", {\n                value: !0\n            }), e.Uint8DataEncoder = e.RGBAFloatDataEncoder = e.RedFloat32DataEncoder = void 0;\n            const r = n(3694);\n            e.RedFloat32DataEncoder = class {\n                constructor(t, e = 1){\n                    if (1 === e) this.internalFormat = t.R32F, this.format = t.RED, this.textureType = t.FLOAT, this.channelSize = e;\n                    else {\n                        if (4 !== e) throw new Error(`Invalid number of channels: ${e}`);\n                        this.internalFormat = t.RGBA32F, this.format = t.RGBA, this.textureType = t.FLOAT, this.channelSize = e;\n                    }\n                }\n                encode(t, e) {\n                    let n, i;\n                    return t.constructor !== Float32Array && (r.Logger.warning(\"Encoder\", \"data was not of type Float32; creating new Float32Array\"), i = new Float32Array(t)), e * this.channelSize > t.length ? (r.Logger.warning(\"Encoder\", \"Source data too small. Allocating larger array\"), i = t, n = this.allocate(e * this.channelSize), i.forEach((t, e)=>n[e] = t)) : (i = t, n = i), n;\n                }\n                allocate(t) {\n                    return new Float32Array(4 * t);\n                }\n                decode(t, e) {\n                    return 1 === this.channelSize ? t.filter((t, e)=>e % 4 == 0).subarray(0, e) : t.subarray(0, e);\n                }\n            }, e.RGBAFloatDataEncoder = class {\n                constructor(t, e = 1, n){\n                    if (1 !== e && 4 !== e) throw new Error(`Invalid number of channels: ${e}`);\n                    this.internalFormat = t.RGBA, this.format = t.RGBA, this.channelSize = e, this.textureType = n || t.FLOAT;\n                }\n                encode(t, e) {\n                    let n = t;\n                    return 1 === this.channelSize && (r.Logger.verbose(\"Encoder\", \"Exploding into a larger array\"), n = this.allocate(e), t.forEach((t, e)=>n[4 * e] = t)), n;\n                }\n                allocate(t) {\n                    return new Float32Array(4 * t);\n                }\n                decode(t, e) {\n                    return 1 === this.channelSize ? t.filter((t, e)=>e % 4 == 0).subarray(0, e) : t.subarray(0, e);\n                }\n            }, e.Uint8DataEncoder = class {\n                constructor(t, e = 1){\n                    if (this.channelSize = 4, 1 === e) this.internalFormat = t.ALPHA, this.format = t.ALPHA, this.textureType = t.UNSIGNED_BYTE, this.channelSize = e;\n                    else {\n                        if (4 !== e) throw new Error(`Invalid number of channels: ${e}`);\n                        this.internalFormat = t.RGBA, this.format = t.RGBA, this.textureType = t.UNSIGNED_BYTE, this.channelSize = e;\n                    }\n                }\n                encode(t, e) {\n                    return new Uint8Array(t.buffer, t.byteOffset, t.byteLength);\n                }\n                allocate(t) {\n                    return new Uint8Array(t * this.channelSize);\n                }\n                decode(t, e) {\n                    if (t instanceof Uint8Array) return t.subarray(0, e);\n                    throw new Error(`Invalid array type: ${t.constructor}`);\n                }\n            };\n        },\n        7859: (t, e, n)=>{\n            \"use strict\";\n            Object.defineProperty(e, \"__esModule\", {\n                value: !0\n            }), e.getBatchDim = e.sizeToSquarishShape = e.getRowsCols = e.sizeFromShape = e.isInt = e.parseAxisParam = e.squeezeShape = e.PreferLogicalStrategy = e.AlwaysKeepOriginalSizeStrategy = void 0;\n            const r = n(3694), i = n(2517);\n            function o(t, e) {\n                const n = [], r = [], i = null != e && Array.isArray(e) && 0 === e.length, o = null == e || i ? null : a(e, t).sort();\n                let s = 0;\n                for(let e = 0; e < t.length; ++e){\n                    if (null != o) {\n                        if (o[s] === e && 1 !== t[e]) throw new Error(`Can't squeeze axis ${e} since its dim '${t[e]}' is not 1`);\n                        (null == o[s] || o[s] > e) && 1 === t[e] && (n.push(t[e]), r.push(e)), o[s] <= e && s++;\n                    }\n                    1 !== t[e] && (n.push(t[e]), r.push(e));\n                }\n                return {\n                    newShape: n,\n                    keptDims: r\n                };\n            }\n            function a(t, e) {\n                const n = e.length;\n                return t = null == t ? e.map((t, e)=>e) : [].concat(t), (0, i.assert)(t.every((t)=>t >= -n && t < n), ()=>`All values in axis param must be in range [-${n}, ${n}) but got axis ${t}`), (0, i.assert)(t.every(s), ()=>`All values in axis param must be integers but got axis ${t}`), t.map((t)=>t < 0 ? n + t : t);\n            }\n            function s(t) {\n                return t % 1 == 0;\n            }\n            function u(t) {\n                if (0 === t.length) return 1;\n                let e = t[0];\n                for(let n = 1; n < t.length; n++)e *= t[n];\n                return e;\n            }\n            function c(t) {\n                const e = Math.ceil(Math.sqrt(t));\n                return [\n                    e,\n                    Math.ceil(t / e)\n                ];\n            }\n            e.AlwaysKeepOriginalSizeStrategy = class {\n                constructor(t){\n                    this.maxTextureSize = t;\n                }\n                computeTextureWH(t, e) {\n                    if (0 === t.length) return [\n                        1,\n                        1\n                    ];\n                    const n = this.maxTextureSize;\n                    if (e && void 0 !== e.breakAxis) {\n                        const i = e.breakAxis >= t.length ? 1 : t.slice(e.breakAxis).reduce((t, e)=>t * e), o = e.breakAxis <= 0 ? 1 : t.slice(0, e.breakAxis).reduce((t, e)=>t * e);\n                        if (!(i > n || o > n)) return [\n                            i,\n                            o\n                        ];\n                        r.Logger.verbose(\"TextureLayout\", `Given width/height preferences were unattainable: shape:${t}, breakAxis:${e.breakAxis}`);\n                    }\n                    const i = t.reduce((t, e)=>t * e);\n                    let o = Math.floor(Math.sqrt(i));\n                    for(; o < n && o < i && i % o != 0; o++);\n                    if (o >= n || i % o != 0) throw new Error(`The given dimensions are outside this GPU's boundaries: ${t}`);\n                    return [\n                        o,\n                        i / o\n                    ];\n                }\n            }, e.PreferLogicalStrategy = class {\n                constructor(t){\n                    this.maxTextureSize = t;\n                }\n                computeTextureWH(t, e) {\n                    const n = this.computeTexture(t, e);\n                    return e && e.isPacked && (n[0] /= 2, n[1] /= 2), e && e.reverseWH ? [\n                        n[1],\n                        n[0]\n                    ] : n;\n                }\n                computeTexture(t, e) {\n                    const n = e && e.isPacked;\n                    if (0 === t.length) return n ? [\n                        2,\n                        2\n                    ] : [\n                        1,\n                        1\n                    ];\n                    let i = this.maxTextureSize;\n                    if (e && void 0 !== e.breakAxis) {\n                        const n = e.breakAxis >= t.length ? 1 : t.slice(e.breakAxis).reduce((t, e)=>t * e), o = e.breakAxis <= 0 ? 1 : t.slice(0, e.breakAxis).reduce((t, e)=>t * e);\n                        if (!(n > i || o > i)) return [\n                            n,\n                            o\n                        ];\n                        r.Logger.verbose(\"TextureLayout\", `Given width/height preferences were unattainable: shape:${t}, breakAxis:${e.breakAxis}`);\n                    }\n                    let a = t.slice(0);\n                    if (n && (i *= 2, a = a.map((t, e)=>e >= a.length - 2 ? a[e] % 2 == 0 ? a[e] : a[e] + 1 : a[e]), 1 === a.length && (a = [\n                        2,\n                        a[0]\n                    ])), 2 !== a.length) {\n                        const t = o(a);\n                        a = t.newShape;\n                    }\n                    const s = u(a);\n                    return a.length <= 1 && s <= i ? [\n                        1,\n                        s\n                    ] : 2 === a.length && a[0] <= i && a[1] <= i ? a : 3 === a.length && a[0] * a[1] <= i && a[2] <= i ? [\n                        a[0] * a[1],\n                        a[2]\n                    ] : 3 === a.length && a[0] <= i && a[1] * a[2] <= i ? [\n                        a[0],\n                        a[1] * a[2]\n                    ] : 4 === a.length && a[0] * a[1] * a[2] <= i && a[3] <= i ? [\n                        a[0] * a[1] * a[2],\n                        a[3]\n                    ] : 4 === a.length && a[0] <= i && a[1] * a[2] * a[3] <= i ? [\n                        a[0],\n                        a[1] * a[2] * a[3]\n                    ] : n ? c(s / 4).map((t)=>2 * t) : c(s);\n                }\n            }, e.squeezeShape = o, e.parseAxisParam = a, e.isInt = s, e.sizeFromShape = u, e.getRowsCols = function(t) {\n                if (0 === t.length) throw Error(\"Cannot get rows and columns of an empty shape array.\");\n                return [\n                    t.length > 1 ? t[t.length - 2] : 1,\n                    t[t.length - 1]\n                ];\n            }, e.sizeToSquarishShape = c, e.getBatchDim = function(t, e = 2) {\n                return u(t.slice(0, t.length - e));\n            };\n        },\n        4057: (t, e, n)=>{\n            \"use strict\";\n            Object.defineProperty(e, \"__esModule\", {\n                value: !0\n            }), e.createTextureLayoutFromShape = e.calculateTextureWidthAndHeight = e.createTextureLayoutFromTextureType = void 0;\n            const r = n(2517), i = n(2039);\n            e.createTextureLayoutFromTextureType = (t, n, r)=>{\n                const o = r === i.TextureType.unpacked || r === i.TextureType.unpackedReversed ? 1 : 4, a = r === i.TextureType.packed, s = r === i.TextureType.unpackedReversed || r === i.TextureType.packed, u = r === i.TextureType.packedLastDimension ? n.length - 1 : void 0, c = r === i.TextureType.packedLastDimension ? n.map((t, e)=>e === n.length - 1 ? 4 * t : t) : void 0;\n                return (0, e.createTextureLayoutFromShape)(t, n, o, c, {\n                    isPacked: a,\n                    reverseWH: s,\n                    breakAxis: u\n                });\n            }, e.calculateTextureWidthAndHeight = (t, n, r)=>{\n                const i = (0, e.createTextureLayoutFromTextureType)(t, n, r);\n                return [\n                    i.width,\n                    i.height\n                ];\n            }, e.createTextureLayoutFromShape = (t, e, n = 1, i, o)=>{\n                const a = !(!o || !o.isPacked), [s, u] = t.computeTextureWH(a && i || e, o), c = e.length;\n                let l = e.slice(0);\n                if (0 === c && (l = [\n                    1\n                ]), 1 === n) i = e;\n                else if (a) {\n                    if (4 !== n) throw new Error(\"a packed texture must be 4-channel\");\n                    i = e, c > 0 && (l[c - 1] = Math.ceil(l[c - 1] / 2)), c > 1 && (l[c - 2] = Math.ceil(l[c - 2] / 2));\n                } else if (!i) throw new Error(\"Unpacked shape is needed when using channels > 1\");\n                return {\n                    width: s,\n                    height: u,\n                    channels: n,\n                    isPacked: a,\n                    shape: l,\n                    strides: r.ShapeUtil.computeStrides(l),\n                    unpackedShape: i,\n                    reversedWH: o && o.reverseWH\n                };\n            };\n        },\n        5702: (t, e, n)=>{\n            \"use strict\";\n            Object.defineProperty(e, \"__esModule\", {\n                value: !0\n            }), e.TextureManager = void 0;\n            const r = n(3694);\n            e.TextureManager = class {\n                constructor(t, e, n, r){\n                    this.glContext = t, this.layoutStrategy = e, this.profiler = n, this.config = r, this.pendingRead = new Map, r.reuseTextures && (this.inUseTextures = new Map, this.idleTextures = new Map, this.textureLookup = new Map);\n                }\n                createTextureFromLayout(t, e, n, i) {\n                    const o = this.toEncoderType(t), a = this.glContext.getEncoder(o, e.channels || 1, i);\n                    if (e.isPacked && 1 === i) throw new Error(\"not implemented\");\n                    const s = e.width, u = e.height;\n                    let c, l;\n                    if (this.config.reuseTextures) {\n                        c = `${s}x${u}_${a.format}_${a.internalFormat}_${a.textureType}`, l = this.inUseTextures.get(c), l || (l = [], this.inUseTextures.set(c, l));\n                        const e = this.idleTextures.get(c);\n                        if (e && e.length > 0) {\n                            const r = e.pop();\n                            return l.push(r), 1 === i && this.glContext.updateTexture(r, s, u, a, this.toTextureData(t, n)), r;\n                        }\n                    }\n                    r.Logger.verbose(\"TextureManager\", `Creating new texture of size ${e.width}x${e.height}`);\n                    const p = this.glContext.allocateTexture(s, u, a, this.toTextureData(t, n));\n                    return this.config.reuseTextures && (l.push(p), this.textureLookup.set(p, c)), p;\n                }\n                readTexture(t, e, n) {\n                    return n || (n = 1), this.profiler.event(\"backend\", \"TextureManager.readTexture\", ()=>{\n                        const r = t.shape.reduce((t, e)=>t * e) * n, i = this.glContext.readTexture(t.texture, t.width, t.height, r, this.toEncoderType(e), n);\n                        return this.toTensorData(e, i);\n                    });\n                }\n                async readTextureAsync(t, e, n) {\n                    const r = t.tensor.dataId;\n                    if (n || (n = 1), this.pendingRead.has(r)) {\n                        const t = this.pendingRead.get(r);\n                        return new Promise((e)=>null == t ? void 0 : t.push(e));\n                    }\n                    return this.profiler.event(\"backend\", \"TextureManager.readTextureAsync\", async ()=>{\n                        this.pendingRead.set(r, []);\n                        const i = t.shape.reduce((t, e)=>t * e) * n;\n                        await this.glContext.createAndWaitForFence();\n                        const o = this.glContext.readTexture(t.texture, t.width, t.height, i, this.toEncoderType(e), n), a = this.toTensorData(e, o), s = this.pendingRead.get(r);\n                        return this.pendingRead.delete(r), null == s || s.forEach((t)=>t(a)), a;\n                    });\n                }\n                readUint8TextureAsFloat(t) {\n                    return this.profiler.event(\"backend\", \"TextureManager.readUint8TextureAsFloat\", ()=>{\n                        const e = t.shape.reduce((t, e)=>t * e), n = this.glContext.readTexture(t.texture, t.width, t.height, 4 * e, \"byte\", 4);\n                        return new Float32Array(n.buffer, n.byteOffset, e);\n                    });\n                }\n                releaseTexture(t, e) {\n                    let n;\n                    if (this.config.reuseTextures && (n = this.textureLookup.get(t.texture), n)) {\n                        e && this.textureLookup.delete(n);\n                        const r = this.inUseTextures.get(n);\n                        if (r) {\n                            const e = r.indexOf(t.texture);\n                            if (-1 !== e) {\n                                r.splice(e, 1);\n                                let i = this.idleTextures.get(n);\n                                i || (i = [], this.idleTextures.set(n, i)), i.push(t.texture);\n                            }\n                        }\n                    }\n                    n && !e || (r.Logger.verbose(\"TextureManager\", `Deleting texture of size ${t.width}x${t.height}`), this.glContext.deleteTexture(t.texture));\n                }\n                toTensorData(t, e) {\n                    switch(t){\n                        case \"int16\":\n                            return e instanceof Int16Array ? e : Int16Array.from(e);\n                        case \"int32\":\n                            return e instanceof Int32Array ? e : Int32Array.from(e);\n                        case \"int8\":\n                            return e instanceof Int8Array ? e : Int8Array.from(e);\n                        case \"uint16\":\n                            return e instanceof Uint16Array ? e : Uint16Array.from(e);\n                        case \"uint32\":\n                            return e instanceof Uint32Array ? e : Uint32Array.from(e);\n                        case \"uint8\":\n                        case \"bool\":\n                            return e instanceof Uint8Array ? e : Uint8Array.from(e);\n                        case \"float32\":\n                            return e instanceof Float32Array ? e : Float32Array.from(e);\n                        case \"float64\":\n                            return e instanceof Float64Array ? e : Float64Array.from(e);\n                        default:\n                            throw new Error(`TensorData type ${t} is not supported`);\n                    }\n                }\n                toTextureData(t, e) {\n                    if (e) return e instanceof Float32Array ? e : new Float32Array(e);\n                }\n                toEncoderType(t) {\n                    return \"float\";\n                }\n                clearActiveTextures() {\n                    this.glContext.clearActiveTextures();\n                }\n            };\n        },\n        2039: (t, e)=>{\n            \"use strict\";\n            var n;\n            Object.defineProperty(e, \"__esModule\", {\n                value: !0\n            }), e.TextureType = void 0, (n = e.TextureType || (e.TextureType = {}))[n.unpacked = 0] = \"unpacked\", n[n.unpackedReversed = 1] = \"unpackedReversed\", n[n.packed = 2] = \"packed\", n[n.downloadUint8AsFloat = 3] = \"downloadUint8AsFloat\", n[n.packedLastDimension = 4] = \"packedLastDimension\";\n        },\n        9390: (t, e, n)=>{\n            \"use strict\";\n            Object.defineProperty(e, \"__esModule\", {\n                value: !0\n            }), e.getGlChannels = e.getCoordsDataType = e.getSqueezedParams = e.squeezeInputShape = e.generateShaderFuncNameFromInputSamplerNameAtOutCoords = e.generateShaderFuncNameFromInputSamplerName = e.repeatedTry = e.getPackedShape = void 0;\n            const r = n(2517);\n            e.getPackedShape = function(t) {\n                const e = t.length;\n                return t.slice(0, e - 1).concat(t[e - 1] / 4);\n            }, e.repeatedTry = async function(t, e = (t)=>0, n) {\n                return new Promise((r, i)=>{\n                    let o = 0;\n                    const a = ()=>{\n                        if (t()) return void r();\n                        o++;\n                        const s = e(o);\n                        null != n && o >= n ? i() : setTimeout(a, s);\n                    };\n                    a();\n                });\n            }, e.generateShaderFuncNameFromInputSamplerName = function(t) {\n                return (0, r.assert)(void 0 !== t && 0 !== t.length, ()=>\"empty string found for sampler name\"), \"get\" + t.charAt(0).toUpperCase() + t.slice(1);\n            }, e.generateShaderFuncNameFromInputSamplerNameAtOutCoords = function(t) {\n                return (0, r.assert)(void 0 !== t && 0 !== t.length, ()=>\"empty string found for sampler name\"), \"get\" + t.charAt(0).toUpperCase() + t.slice(1) + \"AtOutCoords\";\n            }, e.squeezeInputShape = function(t, e) {\n                let n = JSON.parse(JSON.stringify(t));\n                return n = e, n;\n            }, e.getSqueezedParams = function(t, e) {\n                return e.map((e)=>t[e]).join(\", \");\n            }, e.getCoordsDataType = function(t) {\n                if (t <= 1) return \"int\";\n                if (2 === t) return \"ivec2\";\n                if (3 === t) return \"ivec3\";\n                if (4 === t) return \"ivec4\";\n                if (5 === t) return \"ivec5\";\n                if (6 === t) return \"ivec6\";\n                throw Error(`GPU for rank ${t} is not yet supported`);\n            }, e.getGlChannels = function(t = 6) {\n                return [\n                    \"x\",\n                    \"y\",\n                    \"z\",\n                    \"w\",\n                    \"u\",\n                    \"v\"\n                ].slice(0, t);\n            };\n        },\n        7305: (t, e, n)=>{\n            \"use strict\";\n            Object.defineProperty(e, \"__esModule\", {\n                value: !0\n            }), e.createNewWebGLContext = e.createWebGLContext = void 0;\n            const r = n(3694), i = n(1713), o = {};\n            function a(t) {\n                const e = function() {\n                    if (\"undefined\" == typeof document) {\n                        if (\"undefined\" == typeof OffscreenCanvas) throw new TypeError(\"failed to create canvas: OffscreenCanvas is not supported\");\n                        return new OffscreenCanvas(1, 1);\n                    }\n                    const t = document.createElement(\"canvas\");\n                    return t.width = 1, t.height = 1, t;\n                }();\n                let n;\n                const o = {\n                    alpha: !1,\n                    depth: !1,\n                    antialias: !1,\n                    stencil: !1,\n                    preserveDrawingBuffer: !1,\n                    premultipliedAlpha: !1,\n                    failIfMajorPerformanceCaveat: !1\n                };\n                if ((!t || \"webgl2\" === t) && (n = e.getContext(\"webgl2\", o), n)) try {\n                    return new i.WebGLContext(n, 2);\n                } catch (t) {\n                    r.Logger.warning(\"GlContextFactory\", `failed to create WebGLContext using contextId 'webgl2'. Error: ${t}`);\n                }\n                if ((!t || \"webgl\" === t) && (n = e.getContext(\"webgl\", o) || e.getContext(\"experimental-webgl\", o), n)) try {\n                    return new i.WebGLContext(n, 1);\n                } catch (t) {\n                    r.Logger.warning(\"GlContextFactory\", `failed to create WebGLContext using contextId 'webgl' or 'experimental-webgl'. Error: ${t}`);\n                }\n                throw new Error(\"WebGL is not supported\");\n            }\n            e.createWebGLContext = function t(e) {\n                let n;\n                e && \"webgl2\" !== e || !(\"webgl2\" in o) ? e && \"webgl\" !== e || !(\"webgl\" in o) || (n = o.webgl) : n = o.webgl2, n = n || a(e), e = e || 1 === n.version ? \"webgl\" : \"webgl2\";\n                const r = n.gl;\n                return o[e] = n, r.isContextLost() ? (delete o[e], t(e)) : (r.disable(r.DEPTH_TEST), r.disable(r.STENCIL_TEST), r.disable(r.BLEND), r.disable(r.DITHER), r.disable(r.POLYGON_OFFSET_FILL), r.disable(r.SAMPLE_COVERAGE), r.enable(r.SCISSOR_TEST), r.enable(r.CULL_FACE), r.cullFace(r.BACK), n);\n            }, e.createNewWebGLContext = a;\n        },\n        1713: function(t, e, n) {\n            \"use strict\";\n            var r = this && this.__createBinding || (Object.create ? function(t, e, n, r) {\n                void 0 === r && (r = n);\n                var i = Object.getOwnPropertyDescriptor(e, n);\n                i && !(\"get\" in i ? !e.__esModule : i.writable || i.configurable) || (i = {\n                    enumerable: !0,\n                    get: function() {\n                        return e[n];\n                    }\n                }), Object.defineProperty(t, r, i);\n            } : function(t, e, n, r) {\n                void 0 === r && (r = n), t[r] = e[n];\n            }), i = this && this.__setModuleDefault || (Object.create ? function(t, e) {\n                Object.defineProperty(t, \"default\", {\n                    enumerable: !0,\n                    value: e\n                });\n            } : function(t, e) {\n                t.default = e;\n            }), o = this && this.__importStar || function(t) {\n                if (t && t.__esModule) return t;\n                var e = {};\n                if (null != t) for(var n in t)\"default\" !== n && Object.prototype.hasOwnProperty.call(t, n) && r(e, t, n);\n                return i(e, t), e;\n            };\n            Object.defineProperty(e, \"__esModule\", {\n                value: !0\n            }), e.WebGLContext = e.linearSearchLastTrue = void 0;\n            const a = n(6207), s = o(n(7769)), u = n(9390);\n            function c(t) {\n                let e = 0;\n                for(; e < t.length && t[e](); ++e);\n                return e - 1;\n            }\n            e.linearSearchLastTrue = c, e.WebGLContext = class {\n                constructor(t, e){\n                    this.frameBufferBound = !1, this.itemsToPoll = [], this.gl = t, this.version = e, this.getExtensions(), this.vertexbuffer = this.createVertexbuffer(), this.framebuffer = this.createFramebuffer(), this.queryVitalParameters();\n                }\n                allocateTexture(t, e, n, r) {\n                    const i = this.gl, o = i.createTexture();\n                    i.bindTexture(i.TEXTURE_2D, o), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_MIN_FILTER, i.NEAREST), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_MAG_FILTER, i.NEAREST), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_WRAP_S, i.CLAMP_TO_EDGE), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_WRAP_T, i.CLAMP_TO_EDGE);\n                    const a = r ? n.encode(r, t * e) : null;\n                    return i.texImage2D(i.TEXTURE_2D, 0, n.internalFormat, t, e, 0, n.format, n.textureType, a), this.checkError(), o;\n                }\n                updateTexture(t, e, n, r, i) {\n                    const o = this.gl;\n                    o.bindTexture(o.TEXTURE_2D, t);\n                    const a = r.encode(i, e * n);\n                    o.texSubImage2D(o.TEXTURE_2D, 0, 0, 0, e, n, r.format, r.textureType, a), this.checkError();\n                }\n                attachFramebuffer(t, e, n) {\n                    const r = this.gl;\n                    r.bindTexture(r.TEXTURE_2D, t), r.bindFramebuffer(r.FRAMEBUFFER, this.framebuffer), r.framebufferTexture2D(r.FRAMEBUFFER, r.COLOR_ATTACHMENT0, r.TEXTURE_2D, t, 0), this.checkError(), r.viewport(0, 0, e, n), r.scissor(0, 0, e, n);\n                }\n                readTexture(t, e, n, r, i, o) {\n                    const a = this.gl;\n                    o || (o = 1), this.frameBufferBound || this.attachFramebuffer(t, e, n);\n                    const s = this.getEncoder(i, o), u = s.allocate(e * n);\n                    return a.bindTexture(a.TEXTURE_2D, t), a.framebufferTexture2D(a.FRAMEBUFFER, a.COLOR_ATTACHMENT0, a.TEXTURE_2D, t, 0), a.readPixels(0, 0, e, n, a.RGBA, s.textureType, u), this.checkError(), s.decode(u, r);\n                }\n                isFramebufferReady() {\n                    return !0;\n                }\n                getActiveTexture() {\n                    const t = this.gl;\n                    return \"TEXTURE\" + (t.getParameter(this.gl.ACTIVE_TEXTURE) - t.TEXTURE0);\n                }\n                getTextureBinding() {\n                    return this.gl.getParameter(this.gl.TEXTURE_BINDING_2D);\n                }\n                getFramebufferBinding() {\n                    return this.gl.getParameter(this.gl.FRAMEBUFFER_BINDING);\n                }\n                setVertexAttributes(t, e) {\n                    const n = this.gl;\n                    n.vertexAttribPointer(t, 3, n.FLOAT, !1, 20, 0), n.enableVertexAttribArray(t), -1 !== e && (n.vertexAttribPointer(e, 2, n.FLOAT, !1, 20, 12), n.enableVertexAttribArray(e)), this.checkError();\n                }\n                createProgram(t, e) {\n                    const n = this.gl, r = n.createProgram();\n                    return n.attachShader(r, t), n.attachShader(r, e), n.linkProgram(r), r;\n                }\n                compileShader(t, e) {\n                    const n = this.gl, r = n.createShader(e);\n                    if (!r) throw new Error(`createShader() returned null with type ${e}`);\n                    if (n.shaderSource(r, t), n.compileShader(r), !1 === n.getShaderParameter(r, n.COMPILE_STATUS)) throw new Error(`Failed to compile shader: ${n.getShaderInfoLog(r)}\\nShader source:\\n${t}`);\n                    return r;\n                }\n                deleteShader(t) {\n                    this.gl.deleteShader(t);\n                }\n                bindTextureToUniform(t, e, n) {\n                    const r = this.gl;\n                    r.activeTexture(r.TEXTURE0 + e), this.checkError(), r.bindTexture(r.TEXTURE_2D, t), this.checkError(), r.uniform1i(n, e), this.checkError();\n                }\n                draw() {\n                    this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4), this.checkError();\n                }\n                checkError() {\n                    if (a.env.debug) {\n                        const t = this.gl, e = t.getError();\n                        let n = \"\";\n                        switch(e){\n                            case t.NO_ERROR:\n                                return;\n                            case t.INVALID_ENUM:\n                                n = \"INVALID_ENUM\";\n                                break;\n                            case t.INVALID_VALUE:\n                                n = \"INVALID_VALUE\";\n                                break;\n                            case t.INVALID_OPERATION:\n                                n = \"INVALID_OPERATION\";\n                                break;\n                            case t.INVALID_FRAMEBUFFER_OPERATION:\n                                n = \"INVALID_FRAMEBUFFER_OPERATION\";\n                                break;\n                            case t.OUT_OF_MEMORY:\n                                n = \"OUT_OF_MEMORY\";\n                                break;\n                            case t.CONTEXT_LOST_WEBGL:\n                                n = \"CONTEXT_LOST_WEBGL\";\n                                break;\n                            default:\n                                n = `Unknown WebGL Error: ${e.toString(16)}`;\n                        }\n                        throw new Error(n);\n                    }\n                }\n                deleteTexture(t) {\n                    this.gl.deleteTexture(t);\n                }\n                deleteProgram(t) {\n                    this.gl.deleteProgram(t);\n                }\n                getEncoder(t, e, n = 0) {\n                    if (2 === this.version) return new s.RedFloat32DataEncoder(this.gl, e);\n                    switch(t){\n                        case \"float\":\n                            return 1 === n || this.isRenderFloat32Supported ? new s.RGBAFloatDataEncoder(this.gl, e) : new s.RGBAFloatDataEncoder(this.gl, e, this.textureHalfFloatExtension.HALF_FLOAT_OES);\n                        case \"int\":\n                            throw new Error(\"not implemented\");\n                        case \"byte\":\n                            return new s.Uint8DataEncoder(this.gl, e);\n                        default:\n                            throw new Error(`Invalid dataType: ${t}`);\n                    }\n                }\n                clearActiveTextures() {\n                    const t = this.gl;\n                    for(let e = 0; e < this.maxTextureImageUnits; ++e)t.activeTexture(t.TEXTURE0 + e), t.bindTexture(t.TEXTURE_2D, null);\n                }\n                dispose() {\n                    if (this.disposed) return;\n                    const t = this.gl;\n                    t.bindFramebuffer(t.FRAMEBUFFER, null), t.deleteFramebuffer(this.framebuffer), t.bindBuffer(t.ARRAY_BUFFER, null), t.deleteBuffer(this.vertexbuffer), t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, null), t.finish(), this.disposed = !0;\n                }\n                createDefaultGeometry() {\n                    return new Float32Array([\n                        -1,\n                        1,\n                        0,\n                        0,\n                        1,\n                        -1,\n                        -1,\n                        0,\n                        0,\n                        0,\n                        1,\n                        1,\n                        0,\n                        1,\n                        1,\n                        1,\n                        -1,\n                        0,\n                        1,\n                        0\n                    ]);\n                }\n                createVertexbuffer() {\n                    const t = this.gl, e = t.createBuffer();\n                    if (!e) throw new Error(\"createBuffer() returned null\");\n                    const n = this.createDefaultGeometry();\n                    return t.bindBuffer(t.ARRAY_BUFFER, e), t.bufferData(t.ARRAY_BUFFER, n, t.STATIC_DRAW), this.checkError(), e;\n                }\n                createFramebuffer() {\n                    const t = this.gl.createFramebuffer();\n                    if (!t) throw new Error(\"createFramebuffer returned null\");\n                    return t;\n                }\n                queryVitalParameters() {\n                    const t = this.gl;\n                    if (this.isFloatTextureAttachableToFrameBuffer = this.checkFloatTextureAttachableToFrameBuffer(), this.isRenderFloat32Supported = this.checkRenderFloat32(), this.isFloat32DownloadSupported = this.checkFloat32Download(), 1 === this.version && !this.textureHalfFloatExtension && !this.isRenderFloat32Supported) throw new Error(\"both float32 and float16 TextureType are not supported\");\n                    this.isBlendSupported = !this.isRenderFloat32Supported || this.checkFloat32Blend(), this.maxTextureSize = t.getParameter(t.MAX_TEXTURE_SIZE), this.maxTextureImageUnits = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS), this.version;\n                }\n                getExtensions() {\n                    2 === this.version ? (this.colorBufferFloatExtension = this.gl.getExtension(\"EXT_color_buffer_float\"), this.disjointTimerQueryWebgl2Extension = this.gl.getExtension(\"EXT_disjoint_timer_query_webgl2\")) : (this.textureFloatExtension = this.gl.getExtension(\"OES_texture_float\"), this.textureHalfFloatExtension = this.gl.getExtension(\"OES_texture_half_float\"));\n                }\n                checkFloatTextureAttachableToFrameBuffer() {\n                    const t = this.gl, e = t.createTexture();\n                    t.bindTexture(t.TEXTURE_2D, e);\n                    const n = 2 === this.version ? t.RGBA32F : t.RGBA;\n                    t.texImage2D(t.TEXTURE_2D, 0, n, 1, 1, 0, t.RGBA, t.FLOAT, null);\n                    const r = t.createFramebuffer();\n                    t.bindFramebuffer(t.FRAMEBUFFER, r), t.framebufferTexture2D(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, e, 0);\n                    const i = t.checkFramebufferStatus(t.FRAMEBUFFER) === t.FRAMEBUFFER_COMPLETE;\n                    return t.bindTexture(t.TEXTURE_2D, null), t.bindFramebuffer(t.FRAMEBUFFER, null), t.deleteTexture(e), t.deleteFramebuffer(r), i;\n                }\n                checkRenderFloat32() {\n                    if (2 === this.version) {\n                        if (!this.colorBufferFloatExtension) return !1;\n                    } else if (!this.textureFloatExtension) return !1;\n                    return this.isFloatTextureAttachableToFrameBuffer;\n                }\n                checkFloat32Download() {\n                    if (2 === this.version) {\n                        if (!this.colorBufferFloatExtension) return !1;\n                    } else {\n                        if (!this.textureFloatExtension) return !1;\n                        if (!this.gl.getExtension(\"WEBGL_color_buffer_float\")) return !1;\n                    }\n                    return this.isFloatTextureAttachableToFrameBuffer;\n                }\n                checkFloat32Blend() {\n                    const t = this.gl;\n                    let e, n, r, i, o;\n                    try {\n                        e = t.createTexture(), n = t.createFramebuffer(), t.bindTexture(t.TEXTURE_2D, e);\n                        const a = 2 === this.version ? t.RGBA32F : t.RGBA;\n                        return t.texImage2D(t.TEXTURE_2D, 0, a, 1, 1, 0, t.RGBA, t.FLOAT, null), t.bindFramebuffer(t.FRAMEBUFFER, n), t.framebufferTexture2D(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, e, 0), t.enable(t.BLEND), r = t.createShader(t.VERTEX_SHADER), !!r && (t.shaderSource(r, \"void main(){}\"), t.compileShader(r), i = t.createShader(t.FRAGMENT_SHADER), !!i && (t.shaderSource(i, \"precision highp float;void main(){gl_FragColor=vec4(0.5);}\"), t.compileShader(i), o = t.createProgram(), !!o && (t.attachShader(o, r), t.attachShader(o, i), t.linkProgram(o), t.useProgram(o), t.drawArrays(t.POINTS, 0, 1), t.getError() === t.NO_ERROR)));\n                    } finally{\n                        t.disable(t.BLEND), o && t.deleteProgram(o), r && t.deleteShader(r), i && t.deleteShader(i), n && (t.bindFramebuffer(t.FRAMEBUFFER, null), t.deleteFramebuffer(n)), e && (t.bindTexture(t.TEXTURE_2D, null), t.deleteTexture(e));\n                    }\n                }\n                beginTimer() {\n                    if (2 === this.version && this.disjointTimerQueryWebgl2Extension) {\n                        const t = this.gl, e = this.disjointTimerQueryWebgl2Extension, n = t.createQuery();\n                        return t.beginQuery(e.TIME_ELAPSED_EXT, n), n;\n                    }\n                    throw new Error(\"WebGL1 profiling currently not supported.\");\n                }\n                endTimer() {\n                    if (2 !== this.version || !this.disjointTimerQueryWebgl2Extension) throw new Error(\"WebGL1 profiling currently not supported\");\n                    {\n                        const t = this.gl, e = this.disjointTimerQueryWebgl2Extension;\n                        t.endQuery(e.TIME_ELAPSED_EXT);\n                    }\n                }\n                isTimerResultAvailable(t) {\n                    let e = !1, n = !1;\n                    if (2 !== this.version || !this.disjointTimerQueryWebgl2Extension) throw new Error(\"WebGL1 profiling currently not supported\");\n                    {\n                        const r = this.gl, i = this.disjointTimerQueryWebgl2Extension;\n                        e = r.getQueryParameter(t, r.QUERY_RESULT_AVAILABLE), n = r.getParameter(i.GPU_DISJOINT_EXT);\n                    }\n                    return e && !n;\n                }\n                getTimerResult(t) {\n                    let e = 0;\n                    if (2 !== this.version) throw new Error(\"WebGL1 profiling currently not supported\");\n                    {\n                        const n = this.gl;\n                        e = n.getQueryParameter(t, n.QUERY_RESULT), n.deleteQuery(t);\n                    }\n                    return e / 1e6;\n                }\n                async waitForQueryAndGetTime(t) {\n                    return await (0, u.repeatedTry)(()=>this.isTimerResultAvailable(t)), this.getTimerResult(t);\n                }\n                async createAndWaitForFence() {\n                    const t = this.createFence(this.gl);\n                    return this.pollFence(t);\n                }\n                createFence(t) {\n                    let e;\n                    const n = t, r = n.fenceSync(n.SYNC_GPU_COMMANDS_COMPLETE, 0);\n                    return t.flush(), e = null === r ? ()=>!0 : ()=>{\n                        const t = n.clientWaitSync(r, 0, 0);\n                        return t === n.ALREADY_SIGNALED || t === n.CONDITION_SATISFIED;\n                    }, {\n                        query: r,\n                        isFencePassed: e\n                    };\n                }\n                async pollFence(t) {\n                    return new Promise((e)=>{\n                        this.addItemToPoll(()=>t.isFencePassed(), ()=>e());\n                    });\n                }\n                pollItems() {\n                    const t = c(this.itemsToPoll.map((t)=>t.isDoneFn));\n                    for(let e = 0; e <= t; ++e){\n                        const { resolveFn: t } = this.itemsToPoll[e];\n                        t();\n                    }\n                    this.itemsToPoll = this.itemsToPoll.slice(t + 1);\n                }\n                async addItemToPoll(t, e) {\n                    this.itemsToPoll.push({\n                        isDoneFn: t,\n                        resolveFn: e\n                    }), this.itemsToPoll.length > 1 || await (0, u.repeatedTry)(()=>(this.pollItems(), 0 === this.itemsToPoll.length));\n                }\n            };\n        },\n        1036: (t, e, n)=>{\n            \"use strict\";\n            Object.defineProperty(e, \"__esModule\", {\n                value: !0\n            }), e.ExecutionPlan = void 0;\n            const r = n(3694);\n            class i {\n                constructor(t, e){\n                    this.op = t, this.node = e;\n                }\n            }\n            e.ExecutionPlan = class {\n                constructor(t, e, n){\n                    this.graph = t, this.profiler = n, this.initialize(e);\n                }\n                initialize(t) {\n                    this.profiler.event(\"session\", \"ExecutionPlan.initialize\", ()=>{\n                        const e = this.graph.getNodes();\n                        if (e.length !== t.length) throw new Error(\"The size of nodes and OPs do not match.\");\n                        this._ops = t.map((t, n)=>new i(t, e[n])), this.reset(), this._starter = [], this._ops.forEach((t, e)=>{\n                            let n = !0;\n                            for (const e of t.node.inputs)if (!this._values[e] && -1 === this.graph.getInputIndices().indexOf(e)) {\n                                n = !1;\n                                break;\n                            }\n                            n && this._starter.push(e);\n                        });\n                    });\n                }\n                reset() {\n                    this._values = this.graph.getValues().map((t)=>t.tensor);\n                }\n                async execute(t, e) {\n                    return this.profiler.event(\"session\", \"ExecutionPlan.execute\", async ()=>{\n                        this.reset();\n                        const n = t.createInferenceHandler(), i = this.graph.getInputIndices();\n                        if (e.length !== i.length) throw new Error(`number of input tensors don't match the number of inputs to the model: actual: ${e.length} expected: ${i.length}`);\n                        e.forEach((t, e)=>{\n                            const n = i[e];\n                            this._values[n] = t;\n                        });\n                        const o = this._starter.slice(0), a = this.graph.getValues(), s = this.graph.getNodes();\n                        let u = 0;\n                        for(; u < o.length;){\n                            const t = o[u++], e = this._ops[t], i = e.node.inputs.map((t)=>this._values[t]);\n                            if (-1 !== i.indexOf(void 0)) throw new Error(`unresolved input detected: op: ${e.node}`);\n                            const c = i;\n                            r.Logger.verbose(\"ExecPlan\", `Runing op:${e.node.name} (${c.map((t, n)=>`'${e.node.inputs[n]}': ${t.type}[${t.dims.join(\",\")}]`).join(\", \")})`);\n                            const l = await this.profiler.event(\"node\", e.node.name, async ()=>e.op.impl(n, c, e.op.context));\n                            if (l.length !== e.node.outputs.length) throw new Error(\"the size of output does not match model definition.\");\n                            l.forEach((t, n)=>{\n                                const r = e.node.outputs[n];\n                                if (this._values[r]) throw new Error(`output [${r}] already has value: op:${e.node.name}`);\n                                this._values[r] = t;\n                            });\n                            const p = new Set;\n                            l.forEach((t, n)=>{\n                                const r = e.node.outputs[n];\n                                for (const t of a[r].to){\n                                    const e = s[t];\n                                    let n = !0;\n                                    for (const t of e.inputs)if (!this._values[t]) {\n                                        n = !1;\n                                        break;\n                                    }\n                                    n && p.add(t);\n                                }\n                            }), o.push(...p);\n                        }\n                        const c = [];\n                        for(let t = 0; t < this.graph.getOutputIndices().length; t++){\n                            const e = this.graph.getOutputIndices()[t], n = this._values[e];\n                            if (void 0 === n) throw new Error(`required output [${e}] does not have value`);\n                            0 === e ? await n.getData() : n.data, c.push(n);\n                        }\n                        return r.Logger.verbose(\"ExecPlan\", \"disposing of inferenceHandler\"), n.dispose(), c;\n                    });\n                }\n            };\n        },\n        7070: (t, e, n)=>{\n            \"use strict\";\n            Object.defineProperty(e, \"__esModule\", {\n                value: !0\n            }), e.Graph = void 0;\n            const r = n(1446), i = n(7778), o = n(9395), a = n(9162), s = n(2517);\n            var u = o.onnxruntime.experimental.fbs;\n            e.Graph = {\n                from: (t, e)=>new p(t, e)\n            };\n            class c {\n                constructor(t){\n                    this._from = void 0, this._to = [], this.tensor = void 0, this.type = void 0, t && (this.type = s.ProtoUtil.tensorValueTypeFromProto(t.type.tensorType));\n                }\n                get from() {\n                    return this._from;\n                }\n                get to() {\n                    return this._to;\n                }\n            }\n            class l {\n                constructor(t, e){\n                    t instanceof r.onnx.NodeProto ? (this.name = t.name, this.opType = t.opType, this.attributes = new i.Attribute(t.attribute)) : t instanceof u.Node && (this.name = null != e ? e : t.name(), this.opType = t.opType(), this.attributes = new i.Attribute(s.ProtoUtil.tensorAttributesFromORTFormat(t))), this.inputs = [], this.outputs = [], this.executeNode = !0;\n                }\n            }\n            class p {\n                constructor(t, e){\n                    if (!t) throw new TypeError(\"graph is empty\");\n                    this.buildGraph(t), this.transformGraph(e), this.checkIsAcyclic();\n                }\n                getInputIndices() {\n                    return this._allInputIndices;\n                }\n                getInputNames() {\n                    return this._allInputNames;\n                }\n                getOutputIndices() {\n                    return this._allOutputIndices;\n                }\n                getOutputNames() {\n                    return this._allOutputNames;\n                }\n                getValues() {\n                    return this._allData;\n                }\n                getNodes() {\n                    return this._nodes;\n                }\n                buildGraph(t) {\n                    if (t instanceof r.onnx.GraphProto) this.buildGraphFromOnnxFormat(t);\n                    else {\n                        if (!(t instanceof u.Graph)) throw new TypeError(\"Graph type is not supported.\");\n                        this.buildGraphFromOrtFormat(t);\n                    }\n                }\n                buildGraphFromOnnxFormat(t) {\n                    const e = new Map;\n                    this._allData = [], this._allInputIndices = [], this._allInputNames = [], this._allOutputIndices = [], this._allOutputNames = [], this._nodes = [];\n                    const n = new Map;\n                    if (!t.input) throw new Error(\"missing information in graph: input\");\n                    const r = [];\n                    for (const n of t.input){\n                        if (e.has(n.name)) throw new Error(`duplicated input name: ${n.name}`);\n                        const t = this._allData.push(new c(n)) - 1;\n                        e.set(n.name, t), r.push(n.name);\n                    }\n                    if (!t.initializer) throw new Error(\"missing information in graph: initializer\");\n                    for (const n of t.initializer){\n                        let t = e.get(n.name);\n                        if (void 0 === t) {\n                            const r = new c;\n                            r.type = {\n                                shape: {\n                                    dims: s.ProtoUtil.tensorDimsFromProto(n.dims)\n                                },\n                                tensorType: s.ProtoUtil.tensorDataTypeFromProto(n.dataType)\n                            }, t = this._allData.push(r) - 1, e.set(n.name, t);\n                        }\n                        this._allData[t]._from = -1, this._allData[t].tensor = a.Tensor.fromProto(n);\n                    }\n                    for(let t = 0; t < this._allData.length; t++)this._allData[t].tensor || (this._allInputIndices.push(t), this._allInputNames.push(r[t]));\n                    if (!t.output) throw new Error(\"missing information in graph: output\");\n                    for (const n of t.output){\n                        if (e.has(n.name)) throw new Error(`duplicated output name: ${n.name}`);\n                        const t = this._allData.push(new c(n)) - 1;\n                        e.set(n.name, t), this._allOutputIndices.push(t), this._allOutputNames.push(n.name);\n                    }\n                    if (!t.node) throw new Error(\"missing information in graph: node\");\n                    for (const e of t.node){\n                        if (!e.name) for(let t = 0;; t++){\n                            const r = `unnamed_${e.opType}_${t}`;\n                            if (!n.has(r)) {\n                                e.name = r;\n                                break;\n                            }\n                        }\n                        if (n.has(e.name)) throw new Error(`duplicated node name: ${e.name}`);\n                        const t = this._nodes.push(new l(e)) - 1;\n                        n.set(e.name, t);\n                    }\n                    for(let n = 0; n < this._nodes.length; n++){\n                        const r = this._nodes[n], i = t.node[n];\n                        if (!i.output) throw new Error(`missing output for node: ${i.name}`);\n                        for (const t of i.output){\n                            let o = e.get(t);\n                            if (void 0 === o && (o = this._allData.push(new c) - 1, e.set(t, o)), r.outputs.push(o), void 0 !== this._allData[o]._from) throw new Error(`multiple nodes output to one data value: ${o}`);\n                            if (this._allData[o]._from = n, \"Constant\" === i.opType) {\n                                if (!i.attribute || 1 !== i.attribute.length || !i.attribute[0].t) throw new Error(\"missing attributes or missing tensor value in attributes for this Constant operator\");\n                                if (!i.output || 1 !== i.output.length) throw new Error(\"missing output or incorrect number of outputs for this Constant operator\");\n                                r.outputs.pop(), r.executeNode = !1, this._allData[o]._from = -1, this._allData[o].tensor = a.Tensor.fromProto(i.attribute[0].t);\n                            }\n                        }\n                    }\n                    for(let n = 0; n < this._nodes.length; n++){\n                        const r = this._nodes[n], i = t.node[n];\n                        if (!i.input) throw new Error(`missing input for node: ${i.name}`);\n                        for (const t of i.input){\n                            const o = e.get(t);\n                            if (void 0 === o) {\n                                if (\"\" === t && 3 === i.input.length && \"Resize\" === i.opType) continue;\n                                throw new Error(`unrecognized input '${t}' for node: ${i.name}`);\n                            }\n                            r.inputs.push(o), this._allData[o]._to.push(n);\n                        }\n                    }\n                    return !0;\n                }\n                buildGraphFromOrtFormat(t) {\n                    var e, n, r;\n                    const i = new Map;\n                    this._allData = [], this._allInputIndices = [], this._allInputNames = [], this._allOutputIndices = [], this._allOutputNames = [], this._nodes = [];\n                    const o = new Map, p = [];\n                    for(let o = 0; o < t.inputsLength(); o++){\n                        const a = t.inputs(o);\n                        if (i.has(a)) throw new Error(`duplicated input name: ${a}`);\n                        for(let o = 0; o < t.nodeArgsLength(); o++)if ((null === (e = t.nodeArgs(o)) || void 0 === e ? void 0 : e.name()) === a) {\n                            const e = new c;\n                            if ((null === (r = null === (n = t.nodeArgs(o)) || void 0 === n ? void 0 : n.type()) || void 0 === r ? void 0 : r.valueType()) !== u.TypeInfoValue.tensor_type) throw new Error(\"Unexpected value type for the nodeArg.\");\n                            const l = t.nodeArgs(o).type().value(new u.TensorTypeAndShape), f = s.ProtoUtil.tensorDataTypeFromProto(l.elemType()), d = l.shape(), h = [];\n                            for(let t = 0; t < d.dimLength(); t++)h.push(s.LongUtil.longToNumber(d.dim(t).value().dimValue()));\n                            e.type = {\n                                shape: {\n                                    dims: h\n                                },\n                                tensorType: f\n                            };\n                            const g = this._allData.push(e) - 1;\n                            i.set(a, g), p.push(a);\n                        }\n                    }\n                    for(let e = 0; e < t.initializersLength(); e++){\n                        const n = t.initializers(e);\n                        let r = i.get(n.name());\n                        if (void 0 === r) {\n                            const t = new c, e = s.ProtoUtil.tensorDimsFromORTFormat(n), o = s.ProtoUtil.tensorDataTypeFromProto(n.dataType());\n                            t.type = {\n                                shape: {\n                                    dims: e\n                                },\n                                tensorType: o\n                            }, r = this._allData.push(t) - 1, i.set(n.name(), r);\n                        }\n                        this._allData[r]._from = -1, this._allData[r].tensor = a.Tensor.fromOrtTensor(n);\n                    }\n                    for(let t = 0; t < this._allData.length; t++)this._allData[t].tensor || (this._allInputIndices.push(t), this._allInputNames.push(p[t]));\n                    for(let e = 0; e < t.outputsLength(); e++){\n                        const n = t.outputs(e);\n                        if (i.has(n)) throw new Error(`duplicated output name: ${n}`);\n                        const r = this._allData.push(new c) - 1;\n                        i.set(n, r), this._allOutputIndices.push(r), this._allOutputNames.push(n);\n                    }\n                    if (!t.nodes) throw new Error(\"missing information in graph: node\");\n                    for(let e = 0; e < t.nodesLength(); e++){\n                        const n = t.nodes(e);\n                        let r = n.name();\n                        if (!r) for(let t = 0; r = `unnamed_${n.opType()}_${t}`, o.has(r); t++);\n                        if (o.has(r)) throw new Error(`duplicated node name: ${r}`);\n                        const i = this._nodes.push(new l(n, r)) - 1;\n                        o.set(r, i);\n                    }\n                    for(let e = 0; e < this._nodes.length; e++){\n                        const n = this._nodes[e], r = t.nodes(e);\n                        if (null == r) throw new Error(`No node exists at index ${e}`);\n                        if (0 === (null == r ? void 0 : r.outputsLength())) throw new Error(`missing output for node: ${r.name}`);\n                        for(let t = 0; t < (null == r ? void 0 : r.outputsLength()); t++){\n                            const o = null == r ? void 0 : r.outputs(t);\n                            let s = i.get(o);\n                            if (void 0 === s && (s = this._allData.push(new c) - 1, i.set(o, s)), n.outputs.push(s), void 0 !== this._allData[s]._from) throw new Error(`multiple nodes output to one data value: ${s}`);\n                            if (this._allData[s]._from = e, \"Constant\" === r.opType()) {\n                                if (1 !== r.attributesLength() || !r.attributes(0).t()) throw new Error(\"missing attributes or missing tensor value in attributes for this Constant operator\");\n                                if (1 !== r.outputsLength()) throw new Error(\"missing output or incorrect number of outputs for this Constant operator\");\n                                n.outputs.pop(), n.executeNode = !1, this._allData[s]._from = -1, this._allData[s].tensor = a.Tensor.fromOrtTensor(r.attributes(0).t());\n                            }\n                        }\n                    }\n                    for(let e = 0; e < this._nodes.length; e++){\n                        const n = this._nodes[e], r = t.nodes(e);\n                        if (0 === r.inputsLength()) throw new Error(`missing input for node: ${r.name}`);\n                        for(let t = 0; t < r.inputsLength(); t++){\n                            const o = r.inputs(t), a = i.get(o);\n                            if (void 0 === a) throw new Error(`unrecognized input '${o}' for node: ${r.name()}`);\n                            n.inputs.push(a), this._allData[a]._to.push(e);\n                        }\n                    }\n                }\n                checkIsAcyclic() {\n                    const t = new Set;\n                    this._allInputIndices.forEach((e)=>{\n                        this._allData[e]._to.forEach((e)=>{\n                            t.add(e);\n                        });\n                    });\n                    const e = Array.from(t), n = new Array(this._nodes.length).fill(\"white\");\n                    for(; e.length > 0;){\n                        const t = e.pop();\n                        \"gray\" === n[t] ? n[t] = \"black\" : (e.push(t), n[t] = \"gray\", this._nodes[t].outputs.forEach((r)=>{\n                            const i = this._allData[r];\n                            if (void 0 !== i.tensor) throw new Error(\"node outputs should not be initialized\");\n                            if (i._from !== t) throw new Error(\"from property of the Value object doesn't match index of Node being processed\");\n                            i._to.forEach((t)=>{\n                                if (\"gray\" === n[t]) throw new Error(\"model graph is cyclic\");\n                                \"white\" === n[t] && e.push(t);\n                            });\n                        }));\n                    }\n                }\n                transformGraph(t) {\n                    this.removeAllIdentityNodes(), this.removeAllDropoutNodes(), this.fuseConvActivationNodes(), t && t.transformGraph(this), this.finalizeGraph();\n                }\n                finalizeGraph() {\n                    let t = 0;\n                    for(let e = 0; e < this._nodes.length; e++)this._nodes[e].executeNode ? t > 0 && (this._nodes[e].inputs.forEach((n)=>{\n                        const r = this._allData[n]._to.indexOf(e + t);\n                        -1 !== r && (this._allData[n]._to[r] = e);\n                    }), this._nodes[e].outputs.forEach((n)=>{\n                        this._allData[n]._from && this._allData[n]._from === e + t && (this._allData[n]._from = e);\n                    })) : (t++, this._nodes[e].outputs.forEach((t)=>{\n                        this._allData[t]._from = -2;\n                    }), this._nodes.splice(e, 1), e--);\n                    t = 0;\n                    for(let e = 0; e < this._allData.length; e++)if (-2 !== this._allData[e].from || -1 !== this._allOutputIndices.indexOf(e + t)) {\n                        if (t > 0) {\n                            let n = -1;\n                            void 0 !== this._allData[e].from && -1 !== this._allData[e].from ? (n = this._nodes[this._allData[e].from].outputs.indexOf(e + t), -1 !== n && (this._nodes[this._allData[e].from].outputs[n] = e)) : (n = this._allInputIndices.indexOf(e + t), -1 !== n && (this._allInputIndices[n] = e)), this._allData[e].to.forEach((r)=>{\n                                n = this._nodes[r].inputs.indexOf(e + t), -1 !== n && (this._nodes[r].inputs[n] = e);\n                            }), 0 === this._allData[e].to.length && (n = this._allOutputIndices.indexOf(e + t), -1 !== n && (this._allOutputIndices[n] = e));\n                        }\n                    } else t++, this._allData.splice(e, 1), e--;\n                }\n                deleteNode(t) {\n                    const e = this._nodes[t];\n                    if (e.outputs.length > 1) {\n                        for(let t = 1; t < e.outputs.length; t++)if (this._allData[e.outputs[t]].to.length > 0) throw new Error(\"Node deletion with more than one output connected to other nodes is not supported. \");\n                    }\n                    e.executeNode = !1;\n                    const n = e.inputs[0], r = e.outputs[0], i = this._allData[r].to, o = this._allData[n].to.indexOf(t);\n                    if (-1 === o) throw new Error(\"The Value object doesn't have the current Node in it's 'to' property \");\n                    this._allData[n].to.splice(o, 1), this._allData[r]._to = [];\n                    const a = this._allOutputIndices.indexOf(r);\n                    if (-1 !== a && (this._allOutputIndices[a] = n), i && i.length > 0) for (const t of i){\n                        const e = this._nodes[t].inputs.indexOf(r);\n                        if (-1 === e) throw new Error(\"The Node object doesn't have the output Value in it's 'inputs' property \");\n                        this._nodes[t].inputs[e] = n, this._allData[n].to.push(t);\n                    }\n                }\n                removeAllDropoutNodes() {\n                    let t = 0;\n                    for (const e of this._nodes){\n                        if (\"Dropout\" === e.opType) {\n                            if (1 !== e.inputs.length) throw new Error(\"Dropout nodes should only contain one input. \");\n                            if (1 !== e.outputs.length && 2 !== e.outputs.length) throw new Error(\"Dropout nodes should contain either 1 or 2 output(s)\");\n                            if (2 === e.outputs.length && 0 !== this._allData[e.outputs[1]]._to.length) throw new Error(\"Dropout nodes's second output should not be referenced by other nodes\");\n                            this.deleteNode(t);\n                        }\n                        t++;\n                    }\n                }\n                removeAllIdentityNodes() {\n                    let t = 0;\n                    for (const e of this._nodes)\"Identity\" === e.opType && this.deleteNode(t), t++;\n                }\n                isActivation(t) {\n                    switch(t.opType){\n                        case \"Relu\":\n                        case \"Sigmoid\":\n                        case \"Clip\":\n                            return !0;\n                        default:\n                            return !1;\n                    }\n                }\n                fuseConvActivationNodes() {\n                    for (const t of this._nodes)if (\"Conv\" === t.opType) {\n                        const e = this._allData[t.outputs[0]]._to;\n                        if (1 === e.length && this.isActivation(this._nodes[e[0]])) {\n                            const n = this._nodes[e[0]];\n                            if (\"Clip\" === n.opType) if (1 === n.inputs.length) try {\n                                t.attributes.set(\"activation_params\", \"floats\", [\n                                    n.attributes.getFloat(\"min\"),\n                                    n.attributes.getFloat(\"max\")\n                                ]);\n                            } catch (e) {\n                                t.attributes.set(\"activation_params\", \"floats\", [\n                                    s.MIN_CLIP,\n                                    s.MAX_CLIP\n                                ]);\n                            }\n                            else {\n                                if (!(n.inputs.length >= 3 && void 0 !== this._allData[n.inputs[1]].tensor && void 0 !== this._allData[n.inputs[2]].tensor)) continue;\n                                t.attributes.set(\"activation_params\", \"floats\", [\n                                    this._allData[n.inputs[1]].tensor.floatData[0],\n                                    this._allData[n.inputs[2]].tensor.floatData[0]\n                                ]);\n                            }\n                            t.attributes.set(\"activation\", \"string\", n.opType), this.deleteNode(e[0]);\n                        }\n                    }\n                }\n            }\n        },\n        3694: (t, e)=>{\n            \"use strict\";\n            Object.defineProperty(e, \"__esModule\", {\n                value: !0\n            }), e.now = e.Profiler = e.Logger = void 0;\n            const n = {\n                verbose: 1e3,\n                info: 2e3,\n                warning: 4e3,\n                error: 5e3,\n                fatal: 6e3\n            }, r = {\n                none: new class {\n                    log(t, e, n) {}\n                },\n                console: new class {\n                    log(t, e, n) {\n                        console.log(`${this.color(t)} ${n ? \"\\x1b[35m\" + n + \"\\x1b[0m \" : \"\"}${e}`);\n                    }\n                    color(t) {\n                        switch(t){\n                            case \"verbose\":\n                                return \"\\x1b[34;40mv\\x1b[0m\";\n                            case \"info\":\n                                return \"\\x1b[32mi\\x1b[0m\";\n                            case \"warning\":\n                                return \"\\x1b[30;43mw\\x1b[0m\";\n                            case \"error\":\n                                return \"\\x1b[31;40me\\x1b[0m\";\n                            case \"fatal\":\n                                return \"\\x1b[101mf\\x1b[0m\";\n                            default:\n                                throw new Error(`unsupported severity: ${t}`);\n                        }\n                    }\n                }\n            }, i = {\n                provider: \"console\",\n                minimalSeverity: \"warning\",\n                logDateTime: !0,\n                logSourceLocation: !1\n            };\n            let o = {\n                \"\": i\n            };\n            function a(t, e, n, r) {\n                if (void 0 === e) return i = t, {\n                    verbose: a.verbose.bind(null, i),\n                    info: a.info.bind(null, i),\n                    warning: a.warning.bind(null, i),\n                    error: a.error.bind(null, i),\n                    fatal: a.fatal.bind(null, i)\n                };\n                if (void 0 === n) s(t, e);\n                else if (\"number\" == typeof n && void 0 === r) s(t, e);\n                else if (\"string\" == typeof n && void 0 === r) s(t, n, 0, e);\n                else {\n                    if (\"string\" != typeof n || \"number\" != typeof r) throw new TypeError(\"input is valid\");\n                    s(t, n, 0, e);\n                }\n                var i;\n            }\n            function s(t, e, i, a) {\n                const s = o[a || \"\"] || o[\"\"];\n                n[t] < n[s.minimalSeverity] || (s.logDateTime && (e = `${(new Date).toISOString()}|${e}`), s.logSourceLocation, r[s.provider].log(t, e, a));\n            }\n            !function(t) {\n                function e(t) {\n                    o = {}, n(\"\", t || {});\n                }\n                function n(t, n) {\n                    if (\"*\" === t) e(n);\n                    else {\n                        const e = o[t] || i;\n                        o[t] = {\n                            provider: n.provider || e.provider,\n                            minimalSeverity: n.minimalSeverity || e.minimalSeverity,\n                            logDateTime: void 0 === n.logDateTime ? e.logDateTime : n.logDateTime,\n                            logSourceLocation: void 0 === n.logSourceLocation ? e.logSourceLocation : n.logSourceLocation\n                        };\n                    }\n                }\n                t.verbose = function(e, n) {\n                    t(\"verbose\", e, n);\n                }, t.info = function(e, n) {\n                    t(\"info\", e, n);\n                }, t.warning = function(e, n) {\n                    t(\"warning\", e, n);\n                }, t.error = function(e, n) {\n                    t(\"error\", e, n);\n                }, t.fatal = function(e, n) {\n                    t(\"fatal\", e, n);\n                }, t.reset = e, t.set = n, t.setWithEnv = function(t) {\n                    const e = {};\n                    t.logLevel && (e.minimalSeverity = t.logLevel), n(\"\", e);\n                };\n            }(a || (a = {})), e.Logger = a;\n            class u {\n                constructor(t, e, n, r, i, o){\n                    this.category = t, this.name = e, this.startTime = n, this.endCallback = r, this.timer = i, this.ctx = o;\n                }\n                end() {\n                    return this.endCallback(this);\n                }\n                async checkTimer() {\n                    if (void 0 === this.ctx || void 0 === this.timer) throw new Error(\"No webgl timer found\");\n                    return this.ctx.endTimer(), this.ctx.waitForQueryAndGetTime(this.timer);\n                }\n            }\n            class c {\n                constructor(t, e, n, r){\n                    this.category = t, this.name = e, this.startTime = n, this.endTime = r;\n                }\n            }\n            e.Profiler = class {\n                static create(t) {\n                    return void 0 === t ? new this : new this(t.maxNumberEvents, t.flushBatchSize, t.flushIntervalInMilliseconds);\n                }\n                constructor(t, e, n){\n                    this._started = !1, this._flushPointer = 0, this._started = !1, this._maxNumberEvents = void 0 === t ? 1e4 : t, this._flushBatchSize = void 0 === e ? 10 : e, this._flushIntervalInMilliseconds = void 0 === n ? 5e3 : n;\n                }\n                start() {\n                    this._started = !0, this._timingEvents = [], this._flushTime = (0, e.now)(), this._flushPointer = 0;\n                }\n                stop() {\n                    for(this._started = !1; this._flushPointer < this._timingEvents.length; this._flushPointer++)this.logOneEvent(this._timingEvents[this._flushPointer]);\n                }\n                event(t, e, n, r) {\n                    const i = this._started ? this.begin(t, e, r) : void 0;\n                    let o = !1;\n                    const a = n();\n                    if (a && \"function\" == typeof a.then) return o = !0, new Promise((t, e)=>{\n                        a.then(async (e)=>{\n                            i && await i.end(), t(e);\n                        }, async (t)=>{\n                            i && await i.end(), e(t);\n                        });\n                    });\n                    if (!o && i) {\n                        const t = i.end();\n                        if (t && \"function\" == typeof t.then) return new Promise((e, n)=>{\n                            t.then(()=>{\n                                e(a);\n                            }, (t)=>{\n                                n(t);\n                            });\n                        });\n                    }\n                    return a;\n                }\n                begin(t, n, r) {\n                    if (!this._started) throw new Error(\"profiler is not started yet\");\n                    if (void 0 === r) {\n                        const r = (0, e.now)();\n                        return this.flush(r), new u(t, n, r, (t)=>this.endSync(t));\n                    }\n                    {\n                        const e = r.beginTimer();\n                        return new u(t, n, 0, async (t)=>this.end(t), e, r);\n                    }\n                }\n                async end(t) {\n                    const e = await t.checkTimer();\n                    this._timingEvents.length < this._maxNumberEvents && (this._timingEvents.push(new c(t.category, t.name, t.startTime, e)), this.flush(e));\n                }\n                endSync(t) {\n                    const n = (0, e.now)();\n                    this._timingEvents.length < this._maxNumberEvents && (this._timingEvents.push(new c(t.category, t.name, t.startTime, n)), this.flush(n));\n                }\n                logOneEvent(t) {\n                    e.Logger.verbose(`Profiler.${t.category}`, `${(t.endTime - t.startTime).toFixed(2)}ms on event '${t.name}' at ${t.endTime.toFixed(2)}`);\n                }\n                flush(t) {\n                    if (this._timingEvents.length - this._flushPointer >= this._flushBatchSize || t - this._flushTime >= this._flushIntervalInMilliseconds) {\n                        for(const t = this._flushPointer; this._flushPointer < t + this._flushBatchSize && this._flushPointer < this._timingEvents.length; this._flushPointer++)this.logOneEvent(this._timingEvents[this._flushPointer]);\n                        this._flushTime = (0, e.now)();\n                    }\n                }\n                get started() {\n                    return this._started;\n                }\n            }, e.now = \"undefined\" != typeof performance && performance.now ? ()=>performance.now() : Date.now;\n        },\n        2644: (t, e, n)=>{\n            \"use strict\";\n            Object.defineProperty(e, \"__esModule\", {\n                value: !0\n            }), e.Model = void 0;\n            const r = n(5686), i = n(1446), o = n(7070), a = n(9395), s = n(2517);\n            var u = a.onnxruntime.experimental.fbs;\n            e.Model = class {\n                constructor(){}\n                load(t, e, n) {\n                    if (!n) try {\n                        return void this.loadFromOnnxFormat(t, e);\n                    } catch (t) {\n                        if (void 0 !== n) throw t;\n                    }\n                    this.loadFromOrtFormat(t, e);\n                }\n                loadFromOnnxFormat(t, e) {\n                    const n = i.onnx.ModelProto.decode(t);\n                    if (s.LongUtil.longToNumber(n.irVersion) < 3) throw new Error(\"only support ONNX model with IR_VERSION>=3\");\n                    this._opsets = n.opsetImport.map((t)=>({\n                            domain: t.domain,\n                            version: s.LongUtil.longToNumber(t.version)\n                        })), this._graph = o.Graph.from(n.graph, e);\n                }\n                loadFromOrtFormat(t, e) {\n                    const n = new r.flatbuffers.ByteBuffer(t), i = u.InferenceSession.getRootAsInferenceSession(n).model();\n                    if (s.LongUtil.longToNumber(i.irVersion()) < 3) throw new Error(\"only support ONNX model with IR_VERSION>=3\");\n                    this._opsets = [];\n                    for(let t = 0; t < i.opsetImportLength(); t++){\n                        const e = i.opsetImport(t);\n                        this._opsets.push({\n                            domain: null == e ? void 0 : e.domain(),\n                            version: s.LongUtil.longToNumber(e.version())\n                        });\n                    }\n                    this._graph = o.Graph.from(i.graph(), e);\n                }\n                get graph() {\n                    return this._graph;\n                }\n                get opsets() {\n                    return this._opsets;\n                }\n            };\n        },\n        782: (t, e)=>{\n            \"use strict\";\n            Object.defineProperty(e, \"__esModule\", {\n                value: !0\n            }), e.FLOAT_TYPES = e.INT_TYPES = e.NUMBER_TYPES = void 0, e.NUMBER_TYPES = [\n                \"float32\",\n                \"float64\",\n                \"int32\",\n                \"int16\",\n                \"int8\",\n                \"uint16\",\n                \"uint32\",\n                \"uint8\"\n            ], e.INT_TYPES = [\n                \"int32\",\n                \"int16\",\n                \"int8\",\n                \"uint16\",\n                \"uint32\",\n                \"uint8\"\n            ], e.FLOAT_TYPES = [\n                \"float32\",\n                \"float64\"\n            ];\n        },\n        1047: (t, e)=>{\n            \"use strict\";\n            function n(t, e) {\n                if (e.endsWith(\"+\")) {\n                    const n = Number.parseInt(e.substring(0, e.length - 1), 10);\n                    return !isNaN(n) && n <= t;\n                }\n                if (2 === e.split(\"-\").length) {\n                    const n = e.split(\"-\"), r = Number.parseInt(n[0], 10), i = Number.parseInt(n[1], 10);\n                    return !isNaN(r) && !isNaN(i) && r <= t && t <= i;\n                }\n                return Number.parseInt(e, 10) === t;\n            }\n            Object.defineProperty(e, \"__esModule\", {\n                value: !0\n            }), e.resolveOperator = void 0, e.resolveOperator = function(t, e, r) {\n                for (const i of r){\n                    const r = i[0], o = i[1], a = i[2], s = i[3], u = i[4];\n                    if (t.opType === r) {\n                        for (const t of e)if ((t.domain === o || \"ai.onnx\" === t.domain && \"\" === o) && n(t.version, a)) return {\n                            opImpl: s,\n                            opInit: u\n                        };\n                    }\n                }\n                throw new TypeError(`cannot resolve operator '${t.opType}' with opsets: ${e.map((t)=>`${t.domain || \"ai.onnx\"} v${t.version}`).join(\", \")}`);\n            };\n        },\n        9395: (t, e, n)=>{\n            \"use strict\";\n            Object.defineProperty(e, \"__esModule\", {\n                value: !0\n            }), e.onnxruntime = void 0;\n            const r = n(5686);\n            var i, o;\n            i = e.onnxruntime || (e.onnxruntime = {}), function(t) {\n                let e;\n                !function(t) {\n                    t[t.UNDEFINED = 0] = \"UNDEFINED\", t[t.FLOAT = 1] = \"FLOAT\", t[t.INT = 2] = \"INT\", t[t.STRING = 3] = \"STRING\", t[t.TENSOR = 4] = \"TENSOR\", t[t.GRAPH = 5] = \"GRAPH\", t[t.FLOATS = 6] = \"FLOATS\", t[t.INTS = 7] = \"INTS\", t[t.STRINGS = 8] = \"STRINGS\", t[t.TENSORS = 9] = \"TENSORS\", t[t.GRAPHS = 10] = \"GRAPHS\", t[t.SPARSE_TENSOR = 11] = \"SPARSE_TENSOR\", t[t.SPARSE_TENSORS = 12] = \"SPARSE_TENSORS\";\n                }(e = t.AttributeType || (t.AttributeType = {}));\n            }((o = i.experimental || (i.experimental = {})).fbs || (o.fbs = {})), function(t) {\n                !function(t) {\n                    !function(t) {\n                        let e;\n                        !function(t) {\n                            t[t.UNKNOWN = 0] = \"UNKNOWN\", t[t.VALUE = 1] = \"VALUE\", t[t.PARAM = 2] = \"PARAM\";\n                        }(e = t.DimensionValueType || (t.DimensionValueType = {}));\n                    }(t.fbs || (t.fbs = {}));\n                }(t.experimental || (t.experimental = {}));\n            }(e.onnxruntime || (e.onnxruntime = {})), function(t) {\n                !function(t) {\n                    !function(t) {\n                        let e;\n                        !function(t) {\n                            t[t.UNDEFINED = 0] = \"UNDEFINED\", t[t.FLOAT = 1] = \"FLOAT\", t[t.UINT8 = 2] = \"UINT8\", t[t.INT8 = 3] = \"INT8\", t[t.UINT16 = 4] = \"UINT16\", t[t.INT16 = 5] = \"INT16\", t[t.INT32 = 6] = \"INT32\", t[t.INT64 = 7] = \"INT64\", t[t.STRING = 8] = \"STRING\", t[t.BOOL = 9] = \"BOOL\", t[t.FLOAT16 = 10] = \"FLOAT16\", t[t.DOUBLE = 11] = \"DOUBLE\", t[t.UINT32 = 12] = \"UINT32\", t[t.UINT64 = 13] = \"UINT64\", t[t.COMPLEX64 = 14] = \"COMPLEX64\", t[t.COMPLEX128 = 15] = \"COMPLEX128\", t[t.BFLOAT16 = 16] = \"BFLOAT16\";\n                        }(e = t.TensorDataType || (t.TensorDataType = {}));\n                    }(t.fbs || (t.fbs = {}));\n                }(t.experimental || (t.experimental = {}));\n            }(e.onnxruntime || (e.onnxruntime = {})), function(t) {\n                !function(t) {\n                    !function(t) {\n                        let e;\n                        !function(t) {\n                            t[t.Primitive = 0] = \"Primitive\", t[t.Fused = 1] = \"Fused\";\n                        }(e = t.NodeType || (t.NodeType = {}));\n                    }(t.fbs || (t.fbs = {}));\n                }(t.experimental || (t.experimental = {}));\n            }(e.onnxruntime || (e.onnxruntime = {})), function(t) {\n                !function(t) {\n                    !function(t) {\n                        let e;\n                        !function(t) {\n                            t[t.NONE = 0] = \"NONE\", t[t.tensor_type = 1] = \"tensor_type\", t[t.sequence_type = 2] = \"sequence_type\", t[t.map_type = 3] = \"map_type\";\n                        }(e = t.TypeInfoValue || (t.TypeInfoValue = {}));\n                    }(t.fbs || (t.fbs = {}));\n                }(t.experimental || (t.experimental = {}));\n            }(e.onnxruntime || (e.onnxruntime = {})), function(t) {\n                !function(e) {\n                    !function(e) {\n                        class n {\n                            constructor(){\n                                this.bb = null, this.bb_pos = 0;\n                            }\n                            __init(t, e) {\n                                return this.bb_pos = t, this.bb = e, this;\n                            }\n                            static getRootAsShape(t, e) {\n                                return (e || new n).__init(t.readInt32(t.position()) + t.position(), t);\n                            }\n                            static getSizePrefixedRootAsShape(t, e) {\n                                return t.setPosition(t.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (e || new n).__init(t.readInt32(t.position()) + t.position(), t);\n                            }\n                            dim(e, n) {\n                                let r = this.bb.__offset(this.bb_pos, 4);\n                                return r ? (n || new t.experimental.fbs.Dimension).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r) + 4 * e), this.bb) : null;\n                            }\n                            dimLength() {\n                                let t = this.bb.__offset(this.bb_pos, 4);\n                                return t ? this.bb.__vector_len(this.bb_pos + t) : 0;\n                            }\n                            static startShape(t) {\n                                t.startObject(1);\n                            }\n                            static addDim(t, e) {\n                                t.addFieldOffset(0, e, 0);\n                            }\n                            static createDimVector(t, e) {\n                                t.startVector(4, e.length, 4);\n                                for(let n = e.length - 1; n >= 0; n--)t.addOffset(e[n]);\n                                return t.endVector();\n                            }\n                            static startDimVector(t, e) {\n                                t.startVector(4, e, 4);\n                            }\n                            static endShape(t) {\n                                return t.endObject();\n                            }\n                            static createShape(t, e) {\n                                return n.startShape(t), n.addDim(t, e), n.endShape(t);\n                            }\n                        }\n                        e.Shape = n;\n                    }(e.fbs || (e.fbs = {}));\n                }(t.experimental || (t.experimental = {}));\n            }(e.onnxruntime || (e.onnxruntime = {})), function(t) {\n                !function(e) {\n                    !function(e) {\n                        class n {\n                            constructor(){\n                                this.bb = null, this.bb_pos = 0;\n                            }\n                            __init(t, e) {\n                                return this.bb_pos = t, this.bb = e, this;\n                            }\n                            static getRootAsDimension(t, e) {\n                                return (e || new n).__init(t.readInt32(t.position()) + t.position(), t);\n                            }\n                            static getSizePrefixedRootAsDimension(t, e) {\n                                return t.setPosition(t.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (e || new n).__init(t.readInt32(t.position()) + t.position(), t);\n                            }\n                            value(e) {\n                                let n = this.bb.__offset(this.bb_pos, 4);\n                                return n ? (e || new t.experimental.fbs.DimensionValue).__init(this.bb.__indirect(this.bb_pos + n), this.bb) : null;\n                            }\n                            denotation(t) {\n                                let e = this.bb.__offset(this.bb_pos, 6);\n                                return e ? this.bb.__string(this.bb_pos + e, t) : null;\n                            }\n                            static startDimension(t) {\n                                t.startObject(2);\n                            }\n                            static addValue(t, e) {\n                                t.addFieldOffset(0, e, 0);\n                            }\n                            static addDenotation(t, e) {\n                                t.addFieldOffset(1, e, 0);\n                            }\n                            static endDimension(t) {\n                                return t.endObject();\n                            }\n                            static createDimension(t, e, r) {\n                                return n.startDimension(t), n.addValue(t, e), n.addDenotation(t, r), n.endDimension(t);\n                            }\n                        }\n                        e.Dimension = n;\n                    }(e.fbs || (e.fbs = {}));\n                }(t.experimental || (t.experimental = {}));\n            }(e.onnxruntime || (e.onnxruntime = {})), function(t) {\n                !function(e) {\n                    !function(e) {\n                        class n {\n                            constructor(){\n                                this.bb = null, this.bb_pos = 0;\n                            }\n                            __init(t, e) {\n                                return this.bb_pos = t, this.bb = e, this;\n                            }\n                            static getRootAsDimensionValue(t, e) {\n                                return (e || new n).__init(t.readInt32(t.position()) + t.position(), t);\n                            }\n                            static getSizePrefixedRootAsDimensionValue(t, e) {\n                                return t.setPosition(t.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (e || new n).__init(t.readInt32(t.position()) + t.position(), t);\n                            }\n                            dimType() {\n                                let e = this.bb.__offset(this.bb_pos, 4);\n                                return e ? this.bb.readInt8(this.bb_pos + e) : t.experimental.fbs.DimensionValueType.UNKNOWN;\n                            }\n                            dimValue() {\n                                let t = this.bb.__offset(this.bb_pos, 6);\n                                return t ? this.bb.readInt64(this.bb_pos + t) : this.bb.createLong(0, 0);\n                            }\n                            dimParam(t) {\n                                let e = this.bb.__offset(this.bb_pos, 8);\n                                return e ? this.bb.__string(this.bb_pos + e, t) : null;\n                            }\n                            static startDimensionValue(t) {\n                                t.startObject(3);\n                            }\n                            static addDimType(e, n) {\n                                e.addFieldInt8(0, n, t.experimental.fbs.DimensionValueType.UNKNOWN);\n                            }\n                            static addDimValue(t, e) {\n                                t.addFieldInt64(1, e, t.createLong(0, 0));\n                            }\n                            static addDimParam(t, e) {\n                                t.addFieldOffset(2, e, 0);\n                            }\n                            static endDimensionValue(t) {\n                                return t.endObject();\n                            }\n                            static createDimensionValue(t, e, r, i) {\n                                return n.startDimensionValue(t), n.addDimType(t, e), n.addDimValue(t, r), n.addDimParam(t, i), n.endDimensionValue(t);\n                            }\n                        }\n                        e.DimensionValue = n;\n                    }(e.fbs || (e.fbs = {}));\n                }(t.experimental || (t.experimental = {}));\n            }(e.onnxruntime || (e.onnxruntime = {})), function(t) {\n                !function(e) {\n                    !function(e) {\n                        class n {\n                            constructor(){\n                                this.bb = null, this.bb_pos = 0;\n                            }\n                            __init(t, e) {\n                                return this.bb_pos = t, this.bb = e, this;\n                            }\n                            static getRootAsTensorTypeAndShape(t, e) {\n                                return (e || new n).__init(t.readInt32(t.position()) + t.position(), t);\n                            }\n                            static getSizePrefixedRootAsTensorTypeAndShape(t, e) {\n                                return t.setPosition(t.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (e || new n).__init(t.readInt32(t.position()) + t.position(), t);\n                            }\n                            elemType() {\n                                let e = this.bb.__offset(this.bb_pos, 4);\n                                return e ? this.bb.readInt32(this.bb_pos + e) : t.experimental.fbs.TensorDataType.UNDEFINED;\n                            }\n                            shape(e) {\n                                let n = this.bb.__offset(this.bb_pos, 6);\n                                return n ? (e || new t.experimental.fbs.Shape).__init(this.bb.__indirect(this.bb_pos + n), this.bb) : null;\n                            }\n                            static startTensorTypeAndShape(t) {\n                                t.startObject(2);\n                            }\n                            static addElemType(e, n) {\n                                e.addFieldInt32(0, n, t.experimental.fbs.TensorDataType.UNDEFINED);\n                            }\n                            static addShape(t, e) {\n                                t.addFieldOffset(1, e, 0);\n                            }\n                            static endTensorTypeAndShape(t) {\n                                return t.endObject();\n                            }\n                            static createTensorTypeAndShape(t, e, r) {\n                                return n.startTensorTypeAndShape(t), n.addElemType(t, e), n.addShape(t, r), n.endTensorTypeAndShape(t);\n                            }\n                        }\n                        e.TensorTypeAndShape = n;\n                    }(e.fbs || (e.fbs = {}));\n                }(t.experimental || (t.experimental = {}));\n            }(e.onnxruntime || (e.onnxruntime = {})), function(t) {\n                !function(e) {\n                    !function(e) {\n                        class n {\n                            constructor(){\n                                this.bb = null, this.bb_pos = 0;\n                            }\n                            __init(t, e) {\n                                return this.bb_pos = t, this.bb = e, this;\n                            }\n                            static getRootAsMapType(t, e) {\n                                return (e || new n).__init(t.readInt32(t.position()) + t.position(), t);\n                            }\n                            static getSizePrefixedRootAsMapType(t, e) {\n                                return t.setPosition(t.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (e || new n).__init(t.readInt32(t.position()) + t.position(), t);\n                            }\n                            keyType() {\n                                let e = this.bb.__offset(this.bb_pos, 4);\n                                return e ? this.bb.readInt32(this.bb_pos + e) : t.experimental.fbs.TensorDataType.UNDEFINED;\n                            }\n                            valueType(e) {\n                                let n = this.bb.__offset(this.bb_pos, 6);\n                                return n ? (e || new t.experimental.fbs.TypeInfo).__init(this.bb.__indirect(this.bb_pos + n), this.bb) : null;\n                            }\n                            static startMapType(t) {\n                                t.startObject(2);\n                            }\n                            static addKeyType(e, n) {\n                                e.addFieldInt32(0, n, t.experimental.fbs.TensorDataType.UNDEFINED);\n                            }\n                            static addValueType(t, e) {\n                                t.addFieldOffset(1, e, 0);\n                            }\n                            static endMapType(t) {\n                                return t.endObject();\n                            }\n                            static createMapType(t, e, r) {\n                                return n.startMapType(t), n.addKeyType(t, e), n.addValueType(t, r), n.endMapType(t);\n                            }\n                        }\n                        e.MapType = n;\n                    }(e.fbs || (e.fbs = {}));\n                }(t.experimental || (t.experimental = {}));\n            }(e.onnxruntime || (e.onnxruntime = {})), function(t) {\n                !function(e) {\n                    !function(e) {\n                        class n {\n                            constructor(){\n                                this.bb = null, this.bb_pos = 0;\n                            }\n                            __init(t, e) {\n                                return this.bb_pos = t, this.bb = e, this;\n                            }\n                            static getRootAsSequenceType(t, e) {\n                                return (e || new n).__init(t.readInt32(t.position()) + t.position(), t);\n                            }\n                            static getSizePrefixedRootAsSequenceType(t, e) {\n                                return t.setPosition(t.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (e || new n).__init(t.readInt32(t.position()) + t.position(), t);\n                            }\n                            elemType(e) {\n                                let n = this.bb.__offset(this.bb_pos, 4);\n                                return n ? (e || new t.experimental.fbs.TypeInfo).__init(this.bb.__indirect(this.bb_pos + n), this.bb) : null;\n                            }\n                            static startSequenceType(t) {\n                                t.startObject(1);\n                            }\n                            static addElemType(t, e) {\n                                t.addFieldOffset(0, e, 0);\n                            }\n                            static endSequenceType(t) {\n                                return t.endObject();\n                            }\n                            static createSequenceType(t, e) {\n                                return n.startSequenceType(t), n.addElemType(t, e), n.endSequenceType(t);\n                            }\n                        }\n                        e.SequenceType = n;\n                    }(e.fbs || (e.fbs = {}));\n                }(t.experimental || (t.experimental = {}));\n            }(e.onnxruntime || (e.onnxruntime = {})), function(t) {\n                !function(t) {\n                    (t.fbs || (t.fbs = {})).EdgeEnd = class {\n                        constructor(){\n                            this.bb = null, this.bb_pos = 0;\n                        }\n                        __init(t, e) {\n                            return this.bb_pos = t, this.bb = e, this;\n                        }\n                        nodeIndex() {\n                            return this.bb.readUint32(this.bb_pos);\n                        }\n                        srcArgIndex() {\n                            return this.bb.readInt32(this.bb_pos + 4);\n                        }\n                        dstArgIndex() {\n                            return this.bb.readInt32(this.bb_pos + 8);\n                        }\n                        static createEdgeEnd(t, e, n, r) {\n                            return t.prep(4, 12), t.writeInt32(r), t.writeInt32(n), t.writeInt32(e), t.offset();\n                        }\n                    };\n                }(t.experimental || (t.experimental = {}));\n            }(e.onnxruntime || (e.onnxruntime = {})), function(t) {\n                !function(e) {\n                    !function(e) {\n                        class n {\n                            constructor(){\n                                this.bb = null, this.bb_pos = 0;\n                            }\n                            __init(t, e) {\n                                return this.bb_pos = t, this.bb = e, this;\n                            }\n                            static getRootAsNodeEdge(t, e) {\n                                return (e || new n).__init(t.readInt32(t.position()) + t.position(), t);\n                            }\n                            static getSizePrefixedRootAsNodeEdge(t, e) {\n                                return t.setPosition(t.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (e || new n).__init(t.readInt32(t.position()) + t.position(), t);\n                            }\n                            nodeIndex() {\n                                let t = this.bb.__offset(this.bb_pos, 4);\n                                return t ? this.bb.readUint32(this.bb_pos + t) : 0;\n                            }\n                            inputEdges(e, n) {\n                                let r = this.bb.__offset(this.bb_pos, 6);\n                                return r ? (n || new t.experimental.fbs.EdgeEnd).__init(this.bb.__vector(this.bb_pos + r) + 12 * e, this.bb) : null;\n                            }\n                            inputEdgesLength() {\n                                let t = this.bb.__offset(this.bb_pos, 6);\n                                return t ? this.bb.__vector_len(this.bb_pos + t) : 0;\n                            }\n                            outputEdges(e, n) {\n                                let r = this.bb.__offset(this.bb_pos, 8);\n                                return r ? (n || new t.experimental.fbs.EdgeEnd).__init(this.bb.__vector(this.bb_pos + r) + 12 * e, this.bb) : null;\n                            }\n                            outputEdgesLength() {\n                                let t = this.bb.__offset(this.bb_pos, 8);\n                                return t ? this.bb.__vector_len(this.bb_pos + t) : 0;\n                            }\n                            static startNodeEdge(t) {\n                                t.startObject(3);\n                            }\n                            static addNodeIndex(t, e) {\n                                t.addFieldInt32(0, e, 0);\n                            }\n                            static addInputEdges(t, e) {\n                                t.addFieldOffset(1, e, 0);\n                            }\n                            static startInputEdgesVector(t, e) {\n                                t.startVector(12, e, 4);\n                            }\n                            static addOutputEdges(t, e) {\n                                t.addFieldOffset(2, e, 0);\n                            }\n                            static startOutputEdgesVector(t, e) {\n                                t.startVector(12, e, 4);\n                            }\n                            static endNodeEdge(t) {\n                                return t.endObject();\n                            }\n                            static createNodeEdge(t, e, r, i) {\n                                return n.startNodeEdge(t), n.addNodeIndex(t, e), n.addInputEdges(t, r), n.addOutputEdges(t, i), n.endNodeEdge(t);\n                            }\n                        }\n                        e.NodeEdge = n;\n                    }(e.fbs || (e.fbs = {}));\n                }(t.experimental || (t.experimental = {}));\n            }(e.onnxruntime || (e.onnxruntime = {})), function(t) {\n                !function(e) {\n                    !function(e) {\n                        class n {\n                            constructor(){\n                                this.bb = null, this.bb_pos = 0;\n                            }\n                            __init(t, e) {\n                                return this.bb_pos = t, this.bb = e, this;\n                            }\n                            static getRootAsNode(t, e) {\n                                return (e || new n).__init(t.readInt32(t.position()) + t.position(), t);\n                            }\n                            static getSizePrefixedRootAsNode(t, e) {\n                                return t.setPosition(t.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (e || new n).__init(t.readInt32(t.position()) + t.position(), t);\n                            }\n                            name(t) {\n                                let e = this.bb.__offset(this.bb_pos, 4);\n                                return e ? this.bb.__string(this.bb_pos + e, t) : null;\n                            }\n                            docString(t) {\n                                let e = this.bb.__offset(this.bb_pos, 6);\n                                return e ? this.bb.__string(this.bb_pos + e, t) : null;\n                            }\n                            domain(t) {\n                                let e = this.bb.__offset(this.bb_pos, 8);\n                                return e ? this.bb.__string(this.bb_pos + e, t) : null;\n                            }\n                            sinceVersion() {\n                                let t = this.bb.__offset(this.bb_pos, 10);\n                                return t ? this.bb.readInt32(this.bb_pos + t) : 0;\n                            }\n                            index() {\n                                let t = this.bb.__offset(this.bb_pos, 12);\n                                return t ? this.bb.readUint32(this.bb_pos + t) : 0;\n                            }\n                            opType(t) {\n                                let e = this.bb.__offset(this.bb_pos, 14);\n                                return e ? this.bb.__string(this.bb_pos + e, t) : null;\n                            }\n                            type() {\n                                let e = this.bb.__offset(this.bb_pos, 16);\n                                return e ? this.bb.readInt32(this.bb_pos + e) : t.experimental.fbs.NodeType.Primitive;\n                            }\n                            executionProviderType(t) {\n                                let e = this.bb.__offset(this.bb_pos, 18);\n                                return e ? this.bb.__string(this.bb_pos + e, t) : null;\n                            }\n                            inputs(t, e) {\n                                let n = this.bb.__offset(this.bb_pos, 20);\n                                return n ? this.bb.__string(this.bb.__vector(this.bb_pos + n) + 4 * t, e) : null;\n                            }\n                            inputsLength() {\n                                let t = this.bb.__offset(this.bb_pos, 20);\n                                return t ? this.bb.__vector_len(this.bb_pos + t) : 0;\n                            }\n                            outputs(t, e) {\n                                let n = this.bb.__offset(this.bb_pos, 22);\n                                return n ? this.bb.__string(this.bb.__vector(this.bb_pos + n) + 4 * t, e) : null;\n                            }\n                            outputsLength() {\n                                let t = this.bb.__offset(this.bb_pos, 22);\n                                return t ? this.bb.__vector_len(this.bb_pos + t) : 0;\n                            }\n                            attributes(e, n) {\n                                let r = this.bb.__offset(this.bb_pos, 24);\n                                return r ? (n || new t.experimental.fbs.Attribute).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r) + 4 * e), this.bb) : null;\n                            }\n                            attributesLength() {\n                                let t = this.bb.__offset(this.bb_pos, 24);\n                                return t ? this.bb.__vector_len(this.bb_pos + t) : 0;\n                            }\n                            inputArgCounts(t) {\n                                let e = this.bb.__offset(this.bb_pos, 26);\n                                return e ? this.bb.readInt32(this.bb.__vector(this.bb_pos + e) + 4 * t) : 0;\n                            }\n                            inputArgCountsLength() {\n                                let t = this.bb.__offset(this.bb_pos, 26);\n                                return t ? this.bb.__vector_len(this.bb_pos + t) : 0;\n                            }\n                            inputArgCountsArray() {\n                                let t = this.bb.__offset(this.bb_pos, 26);\n                                return t ? new Int32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t), this.bb.__vector_len(this.bb_pos + t)) : null;\n                            }\n                            implicitInputs(t, e) {\n                                let n = this.bb.__offset(this.bb_pos, 28);\n                                return n ? this.bb.__string(this.bb.__vector(this.bb_pos + n) + 4 * t, e) : null;\n                            }\n                            implicitInputsLength() {\n                                let t = this.bb.__offset(this.bb_pos, 28);\n                                return t ? this.bb.__vector_len(this.bb_pos + t) : 0;\n                            }\n                            static startNode(t) {\n                                t.startObject(13);\n                            }\n                            static addName(t, e) {\n                                t.addFieldOffset(0, e, 0);\n                            }\n                            static addDocString(t, e) {\n                                t.addFieldOffset(1, e, 0);\n                            }\n                            static addDomain(t, e) {\n                                t.addFieldOffset(2, e, 0);\n                            }\n                            static addSinceVersion(t, e) {\n                                t.addFieldInt32(3, e, 0);\n                            }\n                            static addIndex(t, e) {\n                                t.addFieldInt32(4, e, 0);\n                            }\n                            static addOpType(t, e) {\n                                t.addFieldOffset(5, e, 0);\n                            }\n                            static addType(e, n) {\n                                e.addFieldInt32(6, n, t.experimental.fbs.NodeType.Primitive);\n                            }\n                            static addExecutionProviderType(t, e) {\n                                t.addFieldOffset(7, e, 0);\n                            }\n                            static addInputs(t, e) {\n                                t.addFieldOffset(8, e, 0);\n                            }\n                            static createInputsVector(t, e) {\n                                t.startVector(4, e.length, 4);\n                                for(let n = e.length - 1; n >= 0; n--)t.addOffset(e[n]);\n                                return t.endVector();\n                            }\n                            static startInputsVector(t, e) {\n                                t.startVector(4, e, 4);\n                            }\n                            static addOutputs(t, e) {\n                                t.addFieldOffset(9, e, 0);\n                            }\n                            static createOutputsVector(t, e) {\n                                t.startVector(4, e.length, 4);\n                                for(let n = e.length - 1; n >= 0; n--)t.addOffset(e[n]);\n                                return t.endVector();\n                            }\n                            static startOutputsVector(t, e) {\n                                t.startVector(4, e, 4);\n                            }\n                            static addAttributes(t, e) {\n                                t.addFieldOffset(10, e, 0);\n                            }\n                            static createAttributesVector(t, e) {\n                                t.startVector(4, e.length, 4);\n                                for(let n = e.length - 1; n >= 0; n--)t.addOffset(e[n]);\n                                return t.endVector();\n                            }\n                            static startAttributesVector(t, e) {\n                                t.startVector(4, e, 4);\n                            }\n                            static addInputArgCounts(t, e) {\n                                t.addFieldOffset(11, e, 0);\n                            }\n                            static createInputArgCountsVector(t, e) {\n                                t.startVector(4, e.length, 4);\n                                for(let n = e.length - 1; n >= 0; n--)t.addInt32(e[n]);\n                                return t.endVector();\n                            }\n                            static startInputArgCountsVector(t, e) {\n                                t.startVector(4, e, 4);\n                            }\n                            static addImplicitInputs(t, e) {\n                                t.addFieldOffset(12, e, 0);\n                            }\n                            static createImplicitInputsVector(t, e) {\n                                t.startVector(4, e.length, 4);\n                                for(let n = e.length - 1; n >= 0; n--)t.addOffset(e[n]);\n                                return t.endVector();\n                            }\n                            static startImplicitInputsVector(t, e) {\n                                t.startVector(4, e, 4);\n                            }\n                            static endNode(t) {\n                                return t.endObject();\n                            }\n                            static createNode(t, e, r, i, o, a, s, u, c, l, p, f, d, h) {\n                                return n.startNode(t), n.addName(t, e), n.addDocString(t, r), n.addDomain(t, i), n.addSinceVersion(t, o), n.addIndex(t, a), n.addOpType(t, s), n.addType(t, u), n.addExecutionProviderType(t, c), n.addInputs(t, l), n.addOutputs(t, p), n.addAttributes(t, f), n.addInputArgCounts(t, d), n.addImplicitInputs(t, h), n.endNode(t);\n                            }\n                        }\n                        e.Node = n;\n                    }(e.fbs || (e.fbs = {}));\n                }(t.experimental || (t.experimental = {}));\n            }(e.onnxruntime || (e.onnxruntime = {})), function(t) {\n                !function(e) {\n                    !function(e) {\n                        class n {\n                            constructor(){\n                                this.bb = null, this.bb_pos = 0;\n                            }\n                            __init(t, e) {\n                                return this.bb_pos = t, this.bb = e, this;\n                            }\n                            static getRootAsValueInfo(t, e) {\n                                return (e || new n).__init(t.readInt32(t.position()) + t.position(), t);\n                            }\n                            static getSizePrefixedRootAsValueInfo(t, e) {\n                                return t.setPosition(t.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (e || new n).__init(t.readInt32(t.position()) + t.position(), t);\n                            }\n                            name(t) {\n                                let e = this.bb.__offset(this.bb_pos, 4);\n                                return e ? this.bb.__string(this.bb_pos + e, t) : null;\n                            }\n                            docString(t) {\n                                let e = this.bb.__offset(this.bb_pos, 6);\n                                return e ? this.bb.__string(this.bb_pos + e, t) : null;\n                            }\n                            type(e) {\n                                let n = this.bb.__offset(this.bb_pos, 8);\n                                return n ? (e || new t.experimental.fbs.TypeInfo).__init(this.bb.__indirect(this.bb_pos + n), this.bb) : null;\n                            }\n                            static startValueInfo(t) {\n                                t.startObject(3);\n                            }\n                            static addName(t, e) {\n                                t.addFieldOffset(0, e, 0);\n                            }\n                            static addDocString(t, e) {\n                                t.addFieldOffset(1, e, 0);\n                            }\n                            static addType(t, e) {\n                                t.addFieldOffset(2, e, 0);\n                            }\n                            static endValueInfo(t) {\n                                return t.endObject();\n                            }\n                            static createValueInfo(t, e, r, i) {\n                                return n.startValueInfo(t), n.addName(t, e), n.addDocString(t, r), n.addType(t, i), n.endValueInfo(t);\n                            }\n                        }\n                        e.ValueInfo = n;\n                    }(e.fbs || (e.fbs = {}));\n                }(t.experimental || (t.experimental = {}));\n            }(e.onnxruntime || (e.onnxruntime = {})), function(t) {\n                !function(e) {\n                    !function(e) {\n                        class n {\n                            constructor(){\n                                this.bb = null, this.bb_pos = 0;\n                            }\n                            __init(t, e) {\n                                return this.bb_pos = t, this.bb = e, this;\n                            }\n                            static getRootAsTypeInfo(t, e) {\n                                return (e || new n).__init(t.readInt32(t.position()) + t.position(), t);\n                            }\n                            static getSizePrefixedRootAsTypeInfo(t, e) {\n                                return t.setPosition(t.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (e || new n).__init(t.readInt32(t.position()) + t.position(), t);\n                            }\n                            denotation(t) {\n                                let e = this.bb.__offset(this.bb_pos, 4);\n                                return e ? this.bb.__string(this.bb_pos + e, t) : null;\n                            }\n                            valueType() {\n                                let e = this.bb.__offset(this.bb_pos, 6);\n                                return e ? this.bb.readUint8(this.bb_pos + e) : t.experimental.fbs.TypeInfoValue.NONE;\n                            }\n                            value(t) {\n                                let e = this.bb.__offset(this.bb_pos, 8);\n                                return e ? this.bb.__union(t, this.bb_pos + e) : null;\n                            }\n                            static startTypeInfo(t) {\n                                t.startObject(3);\n                            }\n                            static addDenotation(t, e) {\n                                t.addFieldOffset(0, e, 0);\n                            }\n                            static addValueType(e, n) {\n                                e.addFieldInt8(1, n, t.experimental.fbs.TypeInfoValue.NONE);\n                            }\n                            static addValue(t, e) {\n                                t.addFieldOffset(2, e, 0);\n                            }\n                            static endTypeInfo(t) {\n                                return t.endObject();\n                            }\n                            static createTypeInfo(t, e, r, i) {\n                                return n.startTypeInfo(t), n.addDenotation(t, e), n.addValueType(t, r), n.addValue(t, i), n.endTypeInfo(t);\n                            }\n                        }\n                        e.TypeInfo = n;\n                    }(e.fbs || (e.fbs = {}));\n                }(t.experimental || (t.experimental = {}));\n            }(e.onnxruntime || (e.onnxruntime = {})), function(t) {\n                !function(t) {\n                    !function(t) {\n                        class e {\n                            constructor(){\n                                this.bb = null, this.bb_pos = 0;\n                            }\n                            __init(t, e) {\n                                return this.bb_pos = t, this.bb = e, this;\n                            }\n                            static getRootAsOperatorSetId(t, n) {\n                                return (n || new e).__init(t.readInt32(t.position()) + t.position(), t);\n                            }\n                            static getSizePrefixedRootAsOperatorSetId(t, n) {\n                                return t.setPosition(t.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (n || new e).__init(t.readInt32(t.position()) + t.position(), t);\n                            }\n                            domain(t) {\n                                let e = this.bb.__offset(this.bb_pos, 4);\n                                return e ? this.bb.__string(this.bb_pos + e, t) : null;\n                            }\n                            version() {\n                                let t = this.bb.__offset(this.bb_pos, 6);\n                                return t ? this.bb.readInt64(this.bb_pos + t) : this.bb.createLong(0, 0);\n                            }\n                            static startOperatorSetId(t) {\n                                t.startObject(2);\n                            }\n                            static addDomain(t, e) {\n                                t.addFieldOffset(0, e, 0);\n                            }\n                            static addVersion(t, e) {\n                                t.addFieldInt64(1, e, t.createLong(0, 0));\n                            }\n                            static endOperatorSetId(t) {\n                                return t.endObject();\n                            }\n                            static createOperatorSetId(t, n, r) {\n                                return e.startOperatorSetId(t), e.addDomain(t, n), e.addVersion(t, r), e.endOperatorSetId(t);\n                            }\n                        }\n                        t.OperatorSetId = e;\n                    }(t.fbs || (t.fbs = {}));\n                }(t.experimental || (t.experimental = {}));\n            }(e.onnxruntime || (e.onnxruntime = {})), function(t) {\n                !function(e) {\n                    !function(e) {\n                        class n {\n                            constructor(){\n                                this.bb = null, this.bb_pos = 0;\n                            }\n                            __init(t, e) {\n                                return this.bb_pos = t, this.bb = e, this;\n                            }\n                            static getRootAsTensor(t, e) {\n                                return (e || new n).__init(t.readInt32(t.position()) + t.position(), t);\n                            }\n                            static getSizePrefixedRootAsTensor(t, e) {\n                                return t.setPosition(t.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (e || new n).__init(t.readInt32(t.position()) + t.position(), t);\n                            }\n                            name(t) {\n                                let e = this.bb.__offset(this.bb_pos, 4);\n                                return e ? this.bb.__string(this.bb_pos + e, t) : null;\n                            }\n                            docString(t) {\n                                let e = this.bb.__offset(this.bb_pos, 6);\n                                return e ? this.bb.__string(this.bb_pos + e, t) : null;\n                            }\n                            dims(t) {\n                                let e = this.bb.__offset(this.bb_pos, 8);\n                                return e ? this.bb.readInt64(this.bb.__vector(this.bb_pos + e) + 8 * t) : this.bb.createLong(0, 0);\n                            }\n                            dimsLength() {\n                                let t = this.bb.__offset(this.bb_pos, 8);\n                                return t ? this.bb.__vector_len(this.bb_pos + t) : 0;\n                            }\n                            dataType() {\n                                let e = this.bb.__offset(this.bb_pos, 10);\n                                return e ? this.bb.readInt32(this.bb_pos + e) : t.experimental.fbs.TensorDataType.UNDEFINED;\n                            }\n                            rawData(t) {\n                                let e = this.bb.__offset(this.bb_pos, 12);\n                                return e ? this.bb.readUint8(this.bb.__vector(this.bb_pos + e) + t) : 0;\n                            }\n                            rawDataLength() {\n                                let t = this.bb.__offset(this.bb_pos, 12);\n                                return t ? this.bb.__vector_len(this.bb_pos + t) : 0;\n                            }\n                            rawDataArray() {\n                                let t = this.bb.__offset(this.bb_pos, 12);\n                                return t ? new Uint8Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t), this.bb.__vector_len(this.bb_pos + t)) : null;\n                            }\n                            stringData(t, e) {\n                                let n = this.bb.__offset(this.bb_pos, 14);\n                                return n ? this.bb.__string(this.bb.__vector(this.bb_pos + n) + 4 * t, e) : null;\n                            }\n                            stringDataLength() {\n                                let t = this.bb.__offset(this.bb_pos, 14);\n                                return t ? this.bb.__vector_len(this.bb_pos + t) : 0;\n                            }\n                            static startTensor(t) {\n                                t.startObject(6);\n                            }\n                            static addName(t, e) {\n                                t.addFieldOffset(0, e, 0);\n                            }\n                            static addDocString(t, e) {\n                                t.addFieldOffset(1, e, 0);\n                            }\n                            static addDims(t, e) {\n                                t.addFieldOffset(2, e, 0);\n                            }\n                            static createDimsVector(t, e) {\n                                t.startVector(8, e.length, 8);\n                                for(let n = e.length - 1; n >= 0; n--)t.addInt64(e[n]);\n                                return t.endVector();\n                            }\n                            static startDimsVector(t, e) {\n                                t.startVector(8, e, 8);\n                            }\n                            static addDataType(e, n) {\n                                e.addFieldInt32(3, n, t.experimental.fbs.TensorDataType.UNDEFINED);\n                            }\n                            static addRawData(t, e) {\n                                t.addFieldOffset(4, e, 0);\n                            }\n                            static createRawDataVector(t, e) {\n                                t.startVector(1, e.length, 1);\n                                for(let n = e.length - 1; n >= 0; n--)t.addInt8(e[n]);\n                                return t.endVector();\n                            }\n                            static startRawDataVector(t, e) {\n                                t.startVector(1, e, 1);\n                            }\n                            static addStringData(t, e) {\n                                t.addFieldOffset(5, e, 0);\n                            }\n                            static createStringDataVector(t, e) {\n                                t.startVector(4, e.length, 4);\n                                for(let n = e.length - 1; n >= 0; n--)t.addOffset(e[n]);\n                                return t.endVector();\n                            }\n                            static startStringDataVector(t, e) {\n                                t.startVector(4, e, 4);\n                            }\n                            static endTensor(t) {\n                                return t.endObject();\n                            }\n                            static createTensor(t, e, r, i, o, a, s) {\n                                return n.startTensor(t), n.addName(t, e), n.addDocString(t, r), n.addDims(t, i), n.addDataType(t, o), n.addRawData(t, a), n.addStringData(t, s), n.endTensor(t);\n                            }\n                        }\n                        e.Tensor = n;\n                    }(e.fbs || (e.fbs = {}));\n                }(t.experimental || (t.experimental = {}));\n            }(e.onnxruntime || (e.onnxruntime = {})), function(t) {\n                !function(e) {\n                    !function(e) {\n                        class n {\n                            constructor(){\n                                this.bb = null, this.bb_pos = 0;\n                            }\n                            __init(t, e) {\n                                return this.bb_pos = t, this.bb = e, this;\n                            }\n                            static getRootAsSparseTensor(t, e) {\n                                return (e || new n).__init(t.readInt32(t.position()) + t.position(), t);\n                            }\n                            static getSizePrefixedRootAsSparseTensor(t, e) {\n                                return t.setPosition(t.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (e || new n).__init(t.readInt32(t.position()) + t.position(), t);\n                            }\n                            values(e) {\n                                let n = this.bb.__offset(this.bb_pos, 4);\n                                return n ? (e || new t.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb_pos + n), this.bb) : null;\n                            }\n                            indices(e) {\n                                let n = this.bb.__offset(this.bb_pos, 6);\n                                return n ? (e || new t.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb_pos + n), this.bb) : null;\n                            }\n                            dims(t) {\n                                let e = this.bb.__offset(this.bb_pos, 8);\n                                return e ? this.bb.readInt64(this.bb.__vector(this.bb_pos + e) + 8 * t) : this.bb.createLong(0, 0);\n                            }\n                            dimsLength() {\n                                let t = this.bb.__offset(this.bb_pos, 8);\n                                return t ? this.bb.__vector_len(this.bb_pos + t) : 0;\n                            }\n                            static startSparseTensor(t) {\n                                t.startObject(3);\n                            }\n                            static addValues(t, e) {\n                                t.addFieldOffset(0, e, 0);\n                            }\n                            static addIndices(t, e) {\n                                t.addFieldOffset(1, e, 0);\n                            }\n                            static addDims(t, e) {\n                                t.addFieldOffset(2, e, 0);\n                            }\n                            static createDimsVector(t, e) {\n                                t.startVector(8, e.length, 8);\n                                for(let n = e.length - 1; n >= 0; n--)t.addInt64(e[n]);\n                                return t.endVector();\n                            }\n                            static startDimsVector(t, e) {\n                                t.startVector(8, e, 8);\n                            }\n                            static endSparseTensor(t) {\n                                return t.endObject();\n                            }\n                            static createSparseTensor(t, e, r, i) {\n                                return n.startSparseTensor(t), n.addValues(t, e), n.addIndices(t, r), n.addDims(t, i), n.endSparseTensor(t);\n                            }\n                        }\n                        e.SparseTensor = n;\n                    }(e.fbs || (e.fbs = {}));\n                }(t.experimental || (t.experimental = {}));\n            }(e.onnxruntime || (e.onnxruntime = {})), function(t) {\n                !function(e) {\n                    !function(e) {\n                        class n {\n                            constructor(){\n                                this.bb = null, this.bb_pos = 0;\n                            }\n                            __init(t, e) {\n                                return this.bb_pos = t, this.bb = e, this;\n                            }\n                            static getRootAsAttribute(t, e) {\n                                return (e || new n).__init(t.readInt32(t.position()) + t.position(), t);\n                            }\n                            static getSizePrefixedRootAsAttribute(t, e) {\n                                return t.setPosition(t.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (e || new n).__init(t.readInt32(t.position()) + t.position(), t);\n                            }\n                            name(t) {\n                                let e = this.bb.__offset(this.bb_pos, 4);\n                                return e ? this.bb.__string(this.bb_pos + e, t) : null;\n                            }\n                            docString(t) {\n                                let e = this.bb.__offset(this.bb_pos, 6);\n                                return e ? this.bb.__string(this.bb_pos + e, t) : null;\n                            }\n                            type() {\n                                let e = this.bb.__offset(this.bb_pos, 8);\n                                return e ? this.bb.readInt32(this.bb_pos + e) : t.experimental.fbs.AttributeType.UNDEFINED;\n                            }\n                            f() {\n                                let t = this.bb.__offset(this.bb_pos, 10);\n                                return t ? this.bb.readFloat32(this.bb_pos + t) : 0;\n                            }\n                            i() {\n                                let t = this.bb.__offset(this.bb_pos, 12);\n                                return t ? this.bb.readInt64(this.bb_pos + t) : this.bb.createLong(0, 0);\n                            }\n                            s(t) {\n                                let e = this.bb.__offset(this.bb_pos, 14);\n                                return e ? this.bb.__string(this.bb_pos + e, t) : null;\n                            }\n                            t(e) {\n                                let n = this.bb.__offset(this.bb_pos, 16);\n                                return n ? (e || new t.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb_pos + n), this.bb) : null;\n                            }\n                            g(e) {\n                                let n = this.bb.__offset(this.bb_pos, 18);\n                                return n ? (e || new t.experimental.fbs.Graph).__init(this.bb.__indirect(this.bb_pos + n), this.bb) : null;\n                            }\n                            floats(t) {\n                                let e = this.bb.__offset(this.bb_pos, 20);\n                                return e ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + e) + 4 * t) : 0;\n                            }\n                            floatsLength() {\n                                let t = this.bb.__offset(this.bb_pos, 20);\n                                return t ? this.bb.__vector_len(this.bb_pos + t) : 0;\n                            }\n                            floatsArray() {\n                                let t = this.bb.__offset(this.bb_pos, 20);\n                                return t ? new Float32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t), this.bb.__vector_len(this.bb_pos + t)) : null;\n                            }\n                            ints(t) {\n                                let e = this.bb.__offset(this.bb_pos, 22);\n                                return e ? this.bb.readInt64(this.bb.__vector(this.bb_pos + e) + 8 * t) : this.bb.createLong(0, 0);\n                            }\n                            intsLength() {\n                                let t = this.bb.__offset(this.bb_pos, 22);\n                                return t ? this.bb.__vector_len(this.bb_pos + t) : 0;\n                            }\n                            strings(t, e) {\n                                let n = this.bb.__offset(this.bb_pos, 24);\n                                return n ? this.bb.__string(this.bb.__vector(this.bb_pos + n) + 4 * t, e) : null;\n                            }\n                            stringsLength() {\n                                let t = this.bb.__offset(this.bb_pos, 24);\n                                return t ? this.bb.__vector_len(this.bb_pos + t) : 0;\n                            }\n                            tensors(e, n) {\n                                let r = this.bb.__offset(this.bb_pos, 26);\n                                return r ? (n || new t.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r) + 4 * e), this.bb) : null;\n                            }\n                            tensorsLength() {\n                                let t = this.bb.__offset(this.bb_pos, 26);\n                                return t ? this.bb.__vector_len(this.bb_pos + t) : 0;\n                            }\n                            graphs(e, n) {\n                                let r = this.bb.__offset(this.bb_pos, 28);\n                                return r ? (n || new t.experimental.fbs.Graph).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r) + 4 * e), this.bb) : null;\n                            }\n                            graphsLength() {\n                                let t = this.bb.__offset(this.bb_pos, 28);\n                                return t ? this.bb.__vector_len(this.bb_pos + t) : 0;\n                            }\n                            static startAttribute(t) {\n                                t.startObject(13);\n                            }\n                            static addName(t, e) {\n                                t.addFieldOffset(0, e, 0);\n                            }\n                            static addDocString(t, e) {\n                                t.addFieldOffset(1, e, 0);\n                            }\n                            static addType(e, n) {\n                                e.addFieldInt32(2, n, t.experimental.fbs.AttributeType.UNDEFINED);\n                            }\n                            static addF(t, e) {\n                                t.addFieldFloat32(3, e, 0);\n                            }\n                            static addI(t, e) {\n                                t.addFieldInt64(4, e, t.createLong(0, 0));\n                            }\n                            static addS(t, e) {\n                                t.addFieldOffset(5, e, 0);\n                            }\n                            static addT(t, e) {\n                                t.addFieldOffset(6, e, 0);\n                            }\n                            static addG(t, e) {\n                                t.addFieldOffset(7, e, 0);\n                            }\n                            static addFloats(t, e) {\n                                t.addFieldOffset(8, e, 0);\n                            }\n                            static createFloatsVector(t, e) {\n                                t.startVector(4, e.length, 4);\n                                for(let n = e.length - 1; n >= 0; n--)t.addFloat32(e[n]);\n                                return t.endVector();\n                            }\n                            static startFloatsVector(t, e) {\n                                t.startVector(4, e, 4);\n                            }\n                            static addInts(t, e) {\n                                t.addFieldOffset(9, e, 0);\n                            }\n                            static createIntsVector(t, e) {\n                                t.startVector(8, e.length, 8);\n                                for(let n = e.length - 1; n >= 0; n--)t.addInt64(e[n]);\n                                return t.endVector();\n                            }\n                            static startIntsVector(t, e) {\n                                t.startVector(8, e, 8);\n                            }\n                            static addStrings(t, e) {\n                                t.addFieldOffset(10, e, 0);\n                            }\n                            static createStringsVector(t, e) {\n                                t.startVector(4, e.length, 4);\n                                for(let n = e.length - 1; n >= 0; n--)t.addOffset(e[n]);\n                                return t.endVector();\n                            }\n                            static startStringsVector(t, e) {\n                                t.startVector(4, e, 4);\n                            }\n                            static addTensors(t, e) {\n                                t.addFieldOffset(11, e, 0);\n                            }\n                            static createTensorsVector(t, e) {\n                                t.startVector(4, e.length, 4);\n                                for(let n = e.length - 1; n >= 0; n--)t.addOffset(e[n]);\n                                return t.endVector();\n                            }\n                            static startTensorsVector(t, e) {\n                                t.startVector(4, e, 4);\n                            }\n                            static addGraphs(t, e) {\n                                t.addFieldOffset(12, e, 0);\n                            }\n                            static createGraphsVector(t, e) {\n                                t.startVector(4, e.length, 4);\n                                for(let n = e.length - 1; n >= 0; n--)t.addOffset(e[n]);\n                                return t.endVector();\n                            }\n                            static startGraphsVector(t, e) {\n                                t.startVector(4, e, 4);\n                            }\n                            static endAttribute(t) {\n                                return t.endObject();\n                            }\n                            static createAttribute(t, e, r, i, o, a, s, u, c, l, p, f, d, h) {\n                                return n.startAttribute(t), n.addName(t, e), n.addDocString(t, r), n.addType(t, i), n.addF(t, o), n.addI(t, a), n.addS(t, s), n.addT(t, u), n.addG(t, c), n.addFloats(t, l), n.addInts(t, p), n.addStrings(t, f), n.addTensors(t, d), n.addGraphs(t, h), n.endAttribute(t);\n                            }\n                        }\n                        e.Attribute = n;\n                    }(e.fbs || (e.fbs = {}));\n                }(t.experimental || (t.experimental = {}));\n            }(e.onnxruntime || (e.onnxruntime = {})), function(t) {\n                !function(e) {\n                    !function(e) {\n                        class n {\n                            constructor(){\n                                this.bb = null, this.bb_pos = 0;\n                            }\n                            __init(t, e) {\n                                return this.bb_pos = t, this.bb = e, this;\n                            }\n                            static getRootAsGraph(t, e) {\n                                return (e || new n).__init(t.readInt32(t.position()) + t.position(), t);\n                            }\n                            static getSizePrefixedRootAsGraph(t, e) {\n                                return t.setPosition(t.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (e || new n).__init(t.readInt32(t.position()) + t.position(), t);\n                            }\n                            initializers(e, n) {\n                                let r = this.bb.__offset(this.bb_pos, 4);\n                                return r ? (n || new t.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r) + 4 * e), this.bb) : null;\n                            }\n                            initializersLength() {\n                                let t = this.bb.__offset(this.bb_pos, 4);\n                                return t ? this.bb.__vector_len(this.bb_pos + t) : 0;\n                            }\n                            nodeArgs(e, n) {\n                                let r = this.bb.__offset(this.bb_pos, 6);\n                                return r ? (n || new t.experimental.fbs.ValueInfo).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r) + 4 * e), this.bb) : null;\n                            }\n                            nodeArgsLength() {\n                                let t = this.bb.__offset(this.bb_pos, 6);\n                                return t ? this.bb.__vector_len(this.bb_pos + t) : 0;\n                            }\n                            nodes(e, n) {\n                                let r = this.bb.__offset(this.bb_pos, 8);\n                                return r ? (n || new t.experimental.fbs.Node).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r) + 4 * e), this.bb) : null;\n                            }\n                            nodesLength() {\n                                let t = this.bb.__offset(this.bb_pos, 8);\n                                return t ? this.bb.__vector_len(this.bb_pos + t) : 0;\n                            }\n                            maxNodeIndex() {\n                                let t = this.bb.__offset(this.bb_pos, 10);\n                                return t ? this.bb.readUint32(this.bb_pos + t) : 0;\n                            }\n                            nodeEdges(e, n) {\n                                let r = this.bb.__offset(this.bb_pos, 12);\n                                return r ? (n || new t.experimental.fbs.NodeEdge).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r) + 4 * e), this.bb) : null;\n                            }\n                            nodeEdgesLength() {\n                                let t = this.bb.__offset(this.bb_pos, 12);\n                                return t ? this.bb.__vector_len(this.bb_pos + t) : 0;\n                            }\n                            inputs(t, e) {\n                                let n = this.bb.__offset(this.bb_pos, 14);\n                                return n ? this.bb.__string(this.bb.__vector(this.bb_pos + n) + 4 * t, e) : null;\n                            }\n                            inputsLength() {\n                                let t = this.bb.__offset(this.bb_pos, 14);\n                                return t ? this.bb.__vector_len(this.bb_pos + t) : 0;\n                            }\n                            outputs(t, e) {\n                                let n = this.bb.__offset(this.bb_pos, 16);\n                                return n ? this.bb.__string(this.bb.__vector(this.bb_pos + n) + 4 * t, e) : null;\n                            }\n                            outputsLength() {\n                                let t = this.bb.__offset(this.bb_pos, 16);\n                                return t ? this.bb.__vector_len(this.bb_pos + t) : 0;\n                            }\n                            sparseInitializers(e, n) {\n                                let r = this.bb.__offset(this.bb_pos, 18);\n                                return r ? (n || new t.experimental.fbs.SparseTensor).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r) + 4 * e), this.bb) : null;\n                            }\n                            sparseInitializersLength() {\n                                let t = this.bb.__offset(this.bb_pos, 18);\n                                return t ? this.bb.__vector_len(this.bb_pos + t) : 0;\n                            }\n                            static startGraph(t) {\n                                t.startObject(8);\n                            }\n                            static addInitializers(t, e) {\n                                t.addFieldOffset(0, e, 0);\n                            }\n                            static createInitializersVector(t, e) {\n                                t.startVector(4, e.length, 4);\n                                for(let n = e.length - 1; n >= 0; n--)t.addOffset(e[n]);\n                                return t.endVector();\n                            }\n                            static startInitializersVector(t, e) {\n                                t.startVector(4, e, 4);\n                            }\n                            static addNodeArgs(t, e) {\n                                t.addFieldOffset(1, e, 0);\n                            }\n                            static createNodeArgsVector(t, e) {\n                                t.startVector(4, e.length, 4);\n                                for(let n = e.length - 1; n >= 0; n--)t.addOffset(e[n]);\n                                return t.endVector();\n                            }\n                            static startNodeArgsVector(t, e) {\n                                t.startVector(4, e, 4);\n                            }\n                            static addNodes(t, e) {\n                                t.addFieldOffset(2, e, 0);\n                            }\n                            static createNodesVector(t, e) {\n                                t.startVector(4, e.length, 4);\n                                for(let n = e.length - 1; n >= 0; n--)t.addOffset(e[n]);\n                                return t.endVector();\n                            }\n                            static startNodesVector(t, e) {\n                                t.startVector(4, e, 4);\n                            }\n                            static addMaxNodeIndex(t, e) {\n                                t.addFieldInt32(3, e, 0);\n                            }\n                            static addNodeEdges(t, e) {\n                                t.addFieldOffset(4, e, 0);\n                            }\n                            static createNodeEdgesVector(t, e) {\n                                t.startVector(4, e.length, 4);\n                                for(let n = e.length - 1; n >= 0; n--)t.addOffset(e[n]);\n                                return t.endVector();\n                            }\n                            static startNodeEdgesVector(t, e) {\n                                t.startVector(4, e, 4);\n                            }\n                            static addInputs(t, e) {\n                                t.addFieldOffset(5, e, 0);\n                            }\n                            static createInputsVector(t, e) {\n                                t.startVector(4, e.length, 4);\n                                for(let n = e.length - 1; n >= 0; n--)t.addOffset(e[n]);\n                                return t.endVector();\n                            }\n                            static startInputsVector(t, e) {\n                                t.startVector(4, e, 4);\n                            }\n                            static addOutputs(t, e) {\n                                t.addFieldOffset(6, e, 0);\n                            }\n                            static createOutputsVector(t, e) {\n                                t.startVector(4, e.length, 4);\n                                for(let n = e.length - 1; n >= 0; n--)t.addOffset(e[n]);\n                                return t.endVector();\n                            }\n                            static startOutputsVector(t, e) {\n                                t.startVector(4, e, 4);\n                            }\n                            static addSparseInitializers(t, e) {\n                                t.addFieldOffset(7, e, 0);\n                            }\n                            static createSparseInitializersVector(t, e) {\n                                t.startVector(4, e.length, 4);\n                                for(let n = e.length - 1; n >= 0; n--)t.addOffset(e[n]);\n                                return t.endVector();\n                            }\n                            static startSparseInitializersVector(t, e) {\n                                t.startVector(4, e, 4);\n                            }\n                            static endGraph(t) {\n                                return t.endObject();\n                            }\n                            static createGraph(t, e, r, i, o, a, s, u, c) {\n                                return n.startGraph(t), n.addInitializers(t, e), n.addNodeArgs(t, r), n.addNodes(t, i), n.addMaxNodeIndex(t, o), n.addNodeEdges(t, a), n.addInputs(t, s), n.addOutputs(t, u), n.addSparseInitializers(t, c), n.endGraph(t);\n                            }\n                        }\n                        e.Graph = n;\n                    }(e.fbs || (e.fbs = {}));\n                }(t.experimental || (t.experimental = {}));\n            }(e.onnxruntime || (e.onnxruntime = {})), function(t) {\n                !function(e) {\n                    !function(e) {\n                        class n {\n                            constructor(){\n                                this.bb = null, this.bb_pos = 0;\n                            }\n                            __init(t, e) {\n                                return this.bb_pos = t, this.bb = e, this;\n                            }\n                            static getRootAsModel(t, e) {\n                                return (e || new n).__init(t.readInt32(t.position()) + t.position(), t);\n                            }\n                            static getSizePrefixedRootAsModel(t, e) {\n                                return t.setPosition(t.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (e || new n).__init(t.readInt32(t.position()) + t.position(), t);\n                            }\n                            irVersion() {\n                                let t = this.bb.__offset(this.bb_pos, 4);\n                                return t ? this.bb.readInt64(this.bb_pos + t) : this.bb.createLong(0, 0);\n                            }\n                            opsetImport(e, n) {\n                                let r = this.bb.__offset(this.bb_pos, 6);\n                                return r ? (n || new t.experimental.fbs.OperatorSetId).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r) + 4 * e), this.bb) : null;\n                            }\n                            opsetImportLength() {\n                                let t = this.bb.__offset(this.bb_pos, 6);\n                                return t ? this.bb.__vector_len(this.bb_pos + t) : 0;\n                            }\n                            producerName(t) {\n                                let e = this.bb.__offset(this.bb_pos, 8);\n                                return e ? this.bb.__string(this.bb_pos + e, t) : null;\n                            }\n                            producerVersion(t) {\n                                let e = this.bb.__offset(this.bb_pos, 10);\n                                return e ? this.bb.__string(this.bb_pos + e, t) : null;\n                            }\n                            domain(t) {\n                                let e = this.bb.__offset(this.bb_pos, 12);\n                                return e ? this.bb.__string(this.bb_pos + e, t) : null;\n                            }\n                            modelVersion() {\n                                let t = this.bb.__offset(this.bb_pos, 14);\n                                return t ? this.bb.readInt64(this.bb_pos + t) : this.bb.createLong(0, 0);\n                            }\n                            docString(t) {\n                                let e = this.bb.__offset(this.bb_pos, 16);\n                                return e ? this.bb.__string(this.bb_pos + e, t) : null;\n                            }\n                            graph(e) {\n                                let n = this.bb.__offset(this.bb_pos, 18);\n                                return n ? (e || new t.experimental.fbs.Graph).__init(this.bb.__indirect(this.bb_pos + n), this.bb) : null;\n                            }\n                            graphDocString(t) {\n                                let e = this.bb.__offset(this.bb_pos, 20);\n                                return e ? this.bb.__string(this.bb_pos + e, t) : null;\n                            }\n                            static startModel(t) {\n                                t.startObject(9);\n                            }\n                            static addIrVersion(t, e) {\n                                t.addFieldInt64(0, e, t.createLong(0, 0));\n                            }\n                            static addOpsetImport(t, e) {\n                                t.addFieldOffset(1, e, 0);\n                            }\n                            static createOpsetImportVector(t, e) {\n                                t.startVector(4, e.length, 4);\n                                for(let n = e.length - 1; n >= 0; n--)t.addOffset(e[n]);\n                                return t.endVector();\n                            }\n                            static startOpsetImportVector(t, e) {\n                                t.startVector(4, e, 4);\n                            }\n                            static addProducerName(t, e) {\n                                t.addFieldOffset(2, e, 0);\n                            }\n                            static addProducerVersion(t, e) {\n                                t.addFieldOffset(3, e, 0);\n                            }\n                            static addDomain(t, e) {\n                                t.addFieldOffset(4, e, 0);\n                            }\n                            static addModelVersion(t, e) {\n                                t.addFieldInt64(5, e, t.createLong(0, 0));\n                            }\n                            static addDocString(t, e) {\n                                t.addFieldOffset(6, e, 0);\n                            }\n                            static addGraph(t, e) {\n                                t.addFieldOffset(7, e, 0);\n                            }\n                            static addGraphDocString(t, e) {\n                                t.addFieldOffset(8, e, 0);\n                            }\n                            static endModel(t) {\n                                return t.endObject();\n                            }\n                            static createModel(t, e, r, i, o, a, s, u, c, l) {\n                                return n.startModel(t), n.addIrVersion(t, e), n.addOpsetImport(t, r), n.addProducerName(t, i), n.addProducerVersion(t, o), n.addDomain(t, a), n.addModelVersion(t, s), n.addDocString(t, u), n.addGraph(t, c), n.addGraphDocString(t, l), n.endModel(t);\n                            }\n                        }\n                        e.Model = n;\n                    }(e.fbs || (e.fbs = {}));\n                }(t.experimental || (t.experimental = {}));\n            }(e.onnxruntime || (e.onnxruntime = {})), function(t) {\n                !function(t) {\n                    !function(t) {\n                        class e {\n                            constructor(){\n                                this.bb = null, this.bb_pos = 0;\n                            }\n                            __init(t, e) {\n                                return this.bb_pos = t, this.bb = e, this;\n                            }\n                            static getRootAsKernelCreateInfos(t, n) {\n                                return (n || new e).__init(t.readInt32(t.position()) + t.position(), t);\n                            }\n                            static getSizePrefixedRootAsKernelCreateInfos(t, n) {\n                                return t.setPosition(t.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (n || new e).__init(t.readInt32(t.position()) + t.position(), t);\n                            }\n                            nodeIndices(t) {\n                                let e = this.bb.__offset(this.bb_pos, 4);\n                                return e ? this.bb.readUint32(this.bb.__vector(this.bb_pos + e) + 4 * t) : 0;\n                            }\n                            nodeIndicesLength() {\n                                let t = this.bb.__offset(this.bb_pos, 4);\n                                return t ? this.bb.__vector_len(this.bb_pos + t) : 0;\n                            }\n                            nodeIndicesArray() {\n                                let t = this.bb.__offset(this.bb_pos, 4);\n                                return t ? new Uint32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t), this.bb.__vector_len(this.bb_pos + t)) : null;\n                            }\n                            kernelDefHashes(t) {\n                                let e = this.bb.__offset(this.bb_pos, 6);\n                                return e ? this.bb.readUint64(this.bb.__vector(this.bb_pos + e) + 8 * t) : this.bb.createLong(0, 0);\n                            }\n                            kernelDefHashesLength() {\n                                let t = this.bb.__offset(this.bb_pos, 6);\n                                return t ? this.bb.__vector_len(this.bb_pos + t) : 0;\n                            }\n                            static startKernelCreateInfos(t) {\n                                t.startObject(2);\n                            }\n                            static addNodeIndices(t, e) {\n                                t.addFieldOffset(0, e, 0);\n                            }\n                            static createNodeIndicesVector(t, e) {\n                                t.startVector(4, e.length, 4);\n                                for(let n = e.length - 1; n >= 0; n--)t.addInt32(e[n]);\n                                return t.endVector();\n                            }\n                            static startNodeIndicesVector(t, e) {\n                                t.startVector(4, e, 4);\n                            }\n                            static addKernelDefHashes(t, e) {\n                                t.addFieldOffset(1, e, 0);\n                            }\n                            static createKernelDefHashesVector(t, e) {\n                                t.startVector(8, e.length, 8);\n                                for(let n = e.length - 1; n >= 0; n--)t.addInt64(e[n]);\n                                return t.endVector();\n                            }\n                            static startKernelDefHashesVector(t, e) {\n                                t.startVector(8, e, 8);\n                            }\n                            static endKernelCreateInfos(t) {\n                                return t.endObject();\n                            }\n                            static createKernelCreateInfos(t, n, r) {\n                                return e.startKernelCreateInfos(t), e.addNodeIndices(t, n), e.addKernelDefHashes(t, r), e.endKernelCreateInfos(t);\n                            }\n                        }\n                        t.KernelCreateInfos = e;\n                    }(t.fbs || (t.fbs = {}));\n                }(t.experimental || (t.experimental = {}));\n            }(e.onnxruntime || (e.onnxruntime = {})), function(t) {\n                !function(e) {\n                    !function(e) {\n                        class n {\n                            constructor(){\n                                this.bb = null, this.bb_pos = 0;\n                            }\n                            __init(t, e) {\n                                return this.bb_pos = t, this.bb = e, this;\n                            }\n                            static getRootAsSubGraphSessionState(t, e) {\n                                return (e || new n).__init(t.readInt32(t.position()) + t.position(), t);\n                            }\n                            static getSizePrefixedRootAsSubGraphSessionState(t, e) {\n                                return t.setPosition(t.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (e || new n).__init(t.readInt32(t.position()) + t.position(), t);\n                            }\n                            graphId(t) {\n                                let e = this.bb.__offset(this.bb_pos, 4);\n                                return e ? this.bb.__string(this.bb_pos + e, t) : null;\n                            }\n                            sessionState(e) {\n                                let n = this.bb.__offset(this.bb_pos, 6);\n                                return n ? (e || new t.experimental.fbs.SessionState).__init(this.bb.__indirect(this.bb_pos + n), this.bb) : null;\n                            }\n                            static startSubGraphSessionState(t) {\n                                t.startObject(2);\n                            }\n                            static addGraphId(t, e) {\n                                t.addFieldOffset(0, e, 0);\n                            }\n                            static addSessionState(t, e) {\n                                t.addFieldOffset(1, e, 0);\n                            }\n                            static endSubGraphSessionState(t) {\n                                let e = t.endObject();\n                                return t.requiredField(e, 4), e;\n                            }\n                            static createSubGraphSessionState(t, e, r) {\n                                return n.startSubGraphSessionState(t), n.addGraphId(t, e), n.addSessionState(t, r), n.endSubGraphSessionState(t);\n                            }\n                        }\n                        e.SubGraphSessionState = n;\n                    }(e.fbs || (e.fbs = {}));\n                }(t.experimental || (t.experimental = {}));\n            }(e.onnxruntime || (e.onnxruntime = {})), function(t) {\n                !function(e) {\n                    !function(e) {\n                        class n {\n                            constructor(){\n                                this.bb = null, this.bb_pos = 0;\n                            }\n                            __init(t, e) {\n                                return this.bb_pos = t, this.bb = e, this;\n                            }\n                            static getRootAsSessionState(t, e) {\n                                return (e || new n).__init(t.readInt32(t.position()) + t.position(), t);\n                            }\n                            static getSizePrefixedRootAsSessionState(t, e) {\n                                return t.setPosition(t.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (e || new n).__init(t.readInt32(t.position()) + t.position(), t);\n                            }\n                            kernels(e) {\n                                let n = this.bb.__offset(this.bb_pos, 4);\n                                return n ? (e || new t.experimental.fbs.KernelCreateInfos).__init(this.bb.__indirect(this.bb_pos + n), this.bb) : null;\n                            }\n                            subGraphSessionStates(e, n) {\n                                let r = this.bb.__offset(this.bb_pos, 6);\n                                return r ? (n || new t.experimental.fbs.SubGraphSessionState).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r) + 4 * e), this.bb) : null;\n                            }\n                            subGraphSessionStatesLength() {\n                                let t = this.bb.__offset(this.bb_pos, 6);\n                                return t ? this.bb.__vector_len(this.bb_pos + t) : 0;\n                            }\n                            static startSessionState(t) {\n                                t.startObject(2);\n                            }\n                            static addKernels(t, e) {\n                                t.addFieldOffset(0, e, 0);\n                            }\n                            static addSubGraphSessionStates(t, e) {\n                                t.addFieldOffset(1, e, 0);\n                            }\n                            static createSubGraphSessionStatesVector(t, e) {\n                                t.startVector(4, e.length, 4);\n                                for(let n = e.length - 1; n >= 0; n--)t.addOffset(e[n]);\n                                return t.endVector();\n                            }\n                            static startSubGraphSessionStatesVector(t, e) {\n                                t.startVector(4, e, 4);\n                            }\n                            static endSessionState(t) {\n                                return t.endObject();\n                            }\n                            static createSessionState(t, e, r) {\n                                return n.startSessionState(t), n.addKernels(t, e), n.addSubGraphSessionStates(t, r), n.endSessionState(t);\n                            }\n                        }\n                        e.SessionState = n;\n                    }(e.fbs || (e.fbs = {}));\n                }(t.experimental || (t.experimental = {}));\n            }(e.onnxruntime || (e.onnxruntime = {})), function(t) {\n                !function(e) {\n                    !function(e) {\n                        class n {\n                            constructor(){\n                                this.bb = null, this.bb_pos = 0;\n                            }\n                            __init(t, e) {\n                                return this.bb_pos = t, this.bb = e, this;\n                            }\n                            static getRootAsInferenceSession(t, e) {\n                                return (e || new n).__init(t.readInt32(t.position()) + t.position(), t);\n                            }\n                            static getSizePrefixedRootAsInferenceSession(t, e) {\n                                return t.setPosition(t.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (e || new n).__init(t.readInt32(t.position()) + t.position(), t);\n                            }\n                            static bufferHasIdentifier(t) {\n                                return t.__has_identifier(\"ORTM\");\n                            }\n                            ortVersion(t) {\n                                let e = this.bb.__offset(this.bb_pos, 4);\n                                return e ? this.bb.__string(this.bb_pos + e, t) : null;\n                            }\n                            model(e) {\n                                let n = this.bb.__offset(this.bb_pos, 6);\n                                return n ? (e || new t.experimental.fbs.Model).__init(this.bb.__indirect(this.bb_pos + n), this.bb) : null;\n                            }\n                            sessionState(e) {\n                                let n = this.bb.__offset(this.bb_pos, 8);\n                                return n ? (e || new t.experimental.fbs.SessionState).__init(this.bb.__indirect(this.bb_pos + n), this.bb) : null;\n                            }\n                            static startInferenceSession(t) {\n                                t.startObject(3);\n                            }\n                            static addOrtVersion(t, e) {\n                                t.addFieldOffset(0, e, 0);\n                            }\n                            static addModel(t, e) {\n                                t.addFieldOffset(1, e, 0);\n                            }\n                            static addSessionState(t, e) {\n                                t.addFieldOffset(2, e, 0);\n                            }\n                            static endInferenceSession(t) {\n                                return t.endObject();\n                            }\n                            static finishInferenceSessionBuffer(t, e) {\n                                t.finish(e, \"ORTM\");\n                            }\n                            static finishSizePrefixedInferenceSessionBuffer(t, e) {\n                                t.finish(e, \"ORTM\", !0);\n                            }\n                            static createInferenceSession(t, e, r, i) {\n                                return n.startInferenceSession(t), n.addOrtVersion(t, e), n.addModel(t, r), n.addSessionState(t, i), n.endInferenceSession(t);\n                            }\n                        }\n                        e.InferenceSession = n;\n                    }(e.fbs || (e.fbs = {}));\n                }(t.experimental || (t.experimental = {}));\n            }(e.onnxruntime || (e.onnxruntime = {}));\n        },\n        7448: (t, e, n)=>{\n            \"use strict\";\n            Object.defineProperty(e, \"__esModule\", {\n                value: !0\n            }), e.OnnxjsSessionHandler = void 0;\n            const r = n(6207), i = n(9162);\n            e.OnnxjsSessionHandler = class {\n                constructor(t){\n                    this.session = t, this.inputNames = this.session.inputNames, this.outputNames = this.session.outputNames;\n                }\n                async dispose() {}\n                async run(t, e, n) {\n                    const o = new Map;\n                    for(const e in t)if (Object.hasOwnProperty.call(t, e)) {\n                        const n = t[e];\n                        o.set(e, new i.Tensor(n.dims, n.type, void 0, void 0, n.data));\n                    }\n                    const a = await this.session.run(o), s = {};\n                    return a.forEach((t, e)=>{\n                        s[e] = new r.Tensor(t.type, t.data, t.dims);\n                    }), s;\n                }\n                startProfiling() {\n                    this.session.startProfiling();\n                }\n                endProfiling() {\n                    this.session.endProfiling();\n                }\n            };\n        },\n        6919: (t, e, n)=>{\n            \"use strict\";\n            Object.defineProperty(e, \"__esModule\", {\n                value: !0\n            }), e.Session = void 0;\n            const r = n(6231), i = n(6464), o = n(7091), a = n(1036), s = n(3694), u = n(2644);\n            e.Session = class {\n                constructor(t = {}){\n                    this._initialized = !1, this.backendHint = t.backendHint, this.profiler = s.Profiler.create(t.profiler), this.context = {\n                        profiler: this.profiler,\n                        graphInputTypes: [],\n                        graphInputDims: []\n                    };\n                }\n                get inputNames() {\n                    return this._model.graph.getInputNames();\n                }\n                get outputNames() {\n                    return this._model.graph.getOutputNames();\n                }\n                startProfiling() {\n                    this.profiler.start();\n                }\n                endProfiling() {\n                    this.profiler.stop();\n                }\n                async loadModel(t, e, n) {\n                    await this.profiler.event(\"session\", \"Session.loadModel\", async ()=>{\n                        const a = await (0, o.resolveBackend)(this.backendHint);\n                        if (this.sessionHandler = a.createSessionHandler(this.context), this._model = new u.Model, \"string\" == typeof t) {\n                            const e = t.endsWith(\".ort\");\n                            if (\"undefined\" == typeof fetch) {\n                                const n = await (0, i.promisify)(r.readFile)(t);\n                                this.initialize(n, e);\n                            } else {\n                                const n = await fetch(t), r = await n.arrayBuffer();\n                                this.initialize(new Uint8Array(r), e);\n                            }\n                        } else if (ArrayBuffer.isView(t)) this.initialize(t);\n                        else {\n                            const r = new Uint8Array(t, e || 0, n || t.byteLength);\n                            this.initialize(r);\n                        }\n                    });\n                }\n                initialize(t, e) {\n                    if (this._initialized) throw new Error(\"already initialized\");\n                    this.profiler.event(\"session\", \"Session.initialize\", ()=>{\n                        const n = this.sessionHandler.transformGraph ? this.sessionHandler : void 0;\n                        this._model.load(t, n, e), this.sessionHandler.onGraphInitialized && this.sessionHandler.onGraphInitialized(this._model.graph), this.initializeOps(this._model.graph), this._executionPlan = new a.ExecutionPlan(this._model.graph, this._ops, this.profiler);\n                    }), this._initialized = !0;\n                }\n                async run(t) {\n                    if (!this._initialized) throw new Error(\"session not initialized yet\");\n                    return this.profiler.event(\"session\", \"Session.run\", async ()=>{\n                        const e = this.normalizeAndValidateInputs(t), n = await this._executionPlan.execute(this.sessionHandler, e);\n                        return this.createOutput(n);\n                    });\n                }\n                normalizeAndValidateInputs(t) {\n                    const e = this._model.graph.getInputNames();\n                    if (Array.isArray(t)) {\n                        if (t.length !== e.length) throw new Error(`incorrect input array length: expected ${e.length} but got ${t.length}`);\n                    } else {\n                        if (t.size !== e.length) throw new Error(`incorrect input map size: expected ${e.length} but got ${t.size}`);\n                        const n = new Array(t.size);\n                        let r = 0;\n                        for(let i = 0; i < e.length; ++i){\n                            const o = t.get(e[i]);\n                            if (!o) throw new Error(`missing input tensor for: '${name}'`);\n                            n[r++] = o;\n                        }\n                        t = n;\n                    }\n                    if (this.context.graphInputTypes && 0 !== this.context.graphInputTypes.length && this.context.graphInputDims && 0 !== this.context.graphInputDims.length) this.validateInputTensorDims(this.context.graphInputDims, t, !1);\n                    else {\n                        const e = this._model.graph.getInputIndices(), n = this._model.graph.getValues(), r = new Array(e.length);\n                        for(let i = 0; i < e.length; ++i){\n                            const o = n[e[i]];\n                            r[i] = o.type.shape.dims, this.context.graphInputTypes.push(o.type.tensorType), this.context.graphInputDims.push(t[i].dims);\n                        }\n                        this.validateInputTensorDims(r, t, !0);\n                    }\n                    return this.validateInputTensorTypes(this.context.graphInputTypes, t), t;\n                }\n                validateInputTensorTypes(t, e) {\n                    for(let n = 0; n < e.length; n++){\n                        const r = t[n], i = e[n].type;\n                        if (r !== i) throw new Error(`input tensor[${n}] check failed: expected type '${r}' but got ${i}`);\n                    }\n                }\n                validateInputTensorDims(t, e, n) {\n                    for(let r = 0; r < e.length; r++){\n                        const i = t[r], o = e[r].dims;\n                        if (!this.compareTensorDims(i, o, n)) throw new Error(`input tensor[${r}] check failed: expected shape '[${i.join(\",\")}]' but got [${o.join(\",\")}]`);\n                    }\n                }\n                compareTensorDims(t, e, n) {\n                    if (t.length !== e.length) return !1;\n                    for(let r = 0; r < t.length; ++r)if (t[r] !== e[r] && (!n || 0 !== t[r])) return !1;\n                    return !0;\n                }\n                createOutput(t) {\n                    const e = this._model.graph.getOutputNames();\n                    if (t.length !== e.length) throw new Error(\"expected number of outputs do not match number of generated outputs\");\n                    const n = new Map;\n                    for(let r = 0; r < e.length; ++r)n.set(e[r], t[r]);\n                    return n;\n                }\n                initializeOps(t) {\n                    const e = t.getNodes();\n                    this._ops = new Array(e.length);\n                    for(let n = 0; n < e.length; n++)this._ops[n] = this.sessionHandler.resolve(e[n], this._model.opsets, t);\n                }\n            };\n        },\n        9162: function(t, e, n) {\n            \"use strict\";\n            var r = this && this.__importDefault || function(t) {\n                return t && t.__esModule ? t : {\n                    default: t\n                };\n            };\n            Object.defineProperty(e, \"__esModule\", {\n                value: !0\n            }), e.Tensor = void 0;\n            const i = n(3442), o = r(n(3720)), a = n(1446), s = n(9395), u = n(2517);\n            var c = s.onnxruntime.experimental.fbs;\n            class l {\n                get data() {\n                    if (void 0 === this.cache) {\n                        const t = this.dataProvider(this.dataId);\n                        if (t.length !== this.size) throw new Error(\"Length of data provided by the Data Provider is inconsistent with the dims of this Tensor.\");\n                        this.cache = t;\n                    }\n                    return this.cache;\n                }\n                get stringData() {\n                    if (\"string\" !== this.type) throw new TypeError(\"data type is not string\");\n                    return this.data;\n                }\n                get integerData() {\n                    switch(this.type){\n                        case \"uint8\":\n                        case \"int8\":\n                        case \"uint16\":\n                        case \"int16\":\n                        case \"int32\":\n                        case \"uint32\":\n                        case \"bool\":\n                            return this.data;\n                        default:\n                            throw new TypeError(\"data type is not integer (uint8, int8, uint16, int16, int32, uint32, bool)\");\n                    }\n                }\n                get floatData() {\n                    switch(this.type){\n                        case \"float32\":\n                        case \"float64\":\n                            return this.data;\n                        default:\n                            throw new TypeError(\"data type is not float (float32, float64)\");\n                    }\n                }\n                get numberData() {\n                    if (\"string\" !== this.type) return this.data;\n                    throw new TypeError(\"type cannot be non-number (string)\");\n                }\n                get(t) {\n                    return this.data[u.ShapeUtil.indicesToOffset(t, this.strides)];\n                }\n                set(t, e) {\n                    this.data[u.ShapeUtil.indicesToOffset(t, this.strides)] = e;\n                }\n                async getData() {\n                    return void 0 === this.cache && (this.cache = await this.asyncDataProvider(this.dataId)), this.cache;\n                }\n                get strides() {\n                    return this._strides || (this._strides = u.ShapeUtil.computeStrides(this.dims)), this._strides;\n                }\n                constructor(t, e, n, r, o, a = i.Guid.create()){\n                    this.dims = t, this.type = e, this.dataProvider = n, this.asyncDataProvider = r, this.cache = o, this.dataId = a, this.size = u.ShapeUtil.validateDimsAndCalcSize(t);\n                    const s = this.size, c = void 0 === n && void 0 === r && void 0 === o;\n                    if (void 0 !== o && o.length !== s) throw new RangeError(\"Input dims doesn't match data length.\");\n                    if (\"string\" === e) {\n                        if (!(void 0 === o || Array.isArray(o) && o.every((t)=>\"string\" == typeof t))) throw new TypeError(\"cache should be a string array\");\n                        c && (this.cache = new Array(s));\n                    } else {\n                        if (void 0 !== o) {\n                            const t = f(e);\n                            if (!(o instanceof t)) throw new TypeError(`cache should be type ${t.name}`);\n                        }\n                        if (c) {\n                            const t = new ArrayBuffer(s * function(t) {\n                                switch(t){\n                                    case \"bool\":\n                                    case \"int8\":\n                                    case \"uint8\":\n                                        return 1;\n                                    case \"int16\":\n                                    case \"uint16\":\n                                        return 2;\n                                    case \"int32\":\n                                    case \"uint32\":\n                                    case \"float32\":\n                                        return 4;\n                                    case \"float64\":\n                                        return 8;\n                                    default:\n                                        throw new Error(`cannot calculate sizeof() on type ${t}`);\n                                }\n                            }(e));\n                            this.cache = function(t, e) {\n                                return new (f(e))(t);\n                            }(t, e);\n                        }\n                    }\n                }\n                static fromProto(t) {\n                    if (!t) throw new Error(\"cannot construct Value from an empty tensor\");\n                    const e = u.ProtoUtil.tensorDataTypeFromProto(t.dataType), n = u.ProtoUtil.tensorDimsFromProto(t.dims), r = new l(n, e);\n                    if (\"string\" === e) t.stringData.forEach((t, e)=>{\n                        r.data[e] = (0, u.decodeUtf8String)(t);\n                    });\n                    else if (t.rawData && \"number\" == typeof t.rawData.byteLength && t.rawData.byteLength > 0) {\n                        const e = r.data, n = new DataView(t.rawData.buffer, t.rawData.byteOffset, t.rawData.byteLength), i = p(t.dataType), o = t.rawData.byteLength / i;\n                        if (t.rawData.byteLength % i != 0) throw new Error(\"invalid buffer length\");\n                        if (e.length !== o) throw new Error(\"buffer length mismatch\");\n                        for(let r = 0; r < o; r++){\n                            const o = h(n, t.dataType, r * i);\n                            e[r] = o;\n                        }\n                    } else {\n                        let e;\n                        switch(t.dataType){\n                            case a.onnx.TensorProto.DataType.FLOAT:\n                                e = t.floatData;\n                                break;\n                            case a.onnx.TensorProto.DataType.INT32:\n                            case a.onnx.TensorProto.DataType.INT16:\n                            case a.onnx.TensorProto.DataType.UINT16:\n                            case a.onnx.TensorProto.DataType.INT8:\n                            case a.onnx.TensorProto.DataType.UINT8:\n                            case a.onnx.TensorProto.DataType.BOOL:\n                                e = t.int32Data;\n                                break;\n                            case a.onnx.TensorProto.DataType.INT64:\n                                e = t.int64Data;\n                                break;\n                            case a.onnx.TensorProto.DataType.DOUBLE:\n                                e = t.doubleData;\n                                break;\n                            case a.onnx.TensorProto.DataType.UINT32:\n                            case a.onnx.TensorProto.DataType.UINT64:\n                                e = t.uint64Data;\n                                break;\n                            default:\n                                throw new Error(\"unspecific error\");\n                        }\n                        if (null == e) throw new Error(\"failed to populate data from a tensorproto value\");\n                        const n = r.data;\n                        if (n.length !== e.length) throw new Error(\"array length mismatch\");\n                        for(let r = 0; r < e.length; r++){\n                            const i = e[r];\n                            o.default.isLong(i) ? n[r] = d(i, t.dataType) : n[r] = i;\n                        }\n                    }\n                    return r;\n                }\n                static fromData(t, e, n) {\n                    return new l(e, n, void 0, void 0, t);\n                }\n                static fromOrtTensor(t) {\n                    if (!t) throw new Error(\"cannot construct Value from an empty tensor\");\n                    const e = u.ProtoUtil.tensorDimsFromORTFormat(t), n = u.ProtoUtil.tensorDataTypeFromProto(t.dataType()), r = new l(e, n);\n                    if (\"string\" === n) for(let e = 0; e < t.stringDataLength(); e++)r.data[e] = t.stringData(e);\n                    else if (t.rawDataArray() && \"number\" == typeof t.rawDataLength() && t.rawDataLength() > 0) {\n                        const e = r.data, n = new DataView(t.rawDataArray().buffer, t.rawDataArray().byteOffset, t.rawDataLength()), i = p(t.dataType()), o = t.rawDataLength() / i;\n                        if (t.rawDataLength() % i != 0) throw new Error(\"invalid buffer length\");\n                        if (e.length !== o) throw new Error(\"buffer length mismatch\");\n                        for(let r = 0; r < o; r++){\n                            const o = h(n, t.dataType(), r * i);\n                            e[r] = o;\n                        }\n                    }\n                    return r;\n                }\n            }\n            function p(t) {\n                switch(t){\n                    case a.onnx.TensorProto.DataType.UINT8:\n                    case a.onnx.TensorProto.DataType.INT8:\n                    case a.onnx.TensorProto.DataType.BOOL:\n                        return 1;\n                    case a.onnx.TensorProto.DataType.UINT16:\n                    case a.onnx.TensorProto.DataType.INT16:\n                        return 2;\n                    case a.onnx.TensorProto.DataType.FLOAT:\n                    case a.onnx.TensorProto.DataType.INT32:\n                    case a.onnx.TensorProto.DataType.UINT32:\n                        return 4;\n                    case a.onnx.TensorProto.DataType.INT64:\n                    case a.onnx.TensorProto.DataType.DOUBLE:\n                    case a.onnx.TensorProto.DataType.UINT64:\n                        return 8;\n                    default:\n                        throw new Error(`cannot calculate sizeof() on type ${a.onnx.TensorProto.DataType[t]}`);\n                }\n            }\n            function f(t) {\n                switch(t){\n                    case \"bool\":\n                    case \"uint8\":\n                        return Uint8Array;\n                    case \"int8\":\n                        return Int8Array;\n                    case \"int16\":\n                        return Int16Array;\n                    case \"uint16\":\n                        return Uint16Array;\n                    case \"int32\":\n                        return Int32Array;\n                    case \"uint32\":\n                        return Uint32Array;\n                    case \"float32\":\n                        return Float32Array;\n                    case \"float64\":\n                        return Float64Array;\n                    default:\n                        throw new Error(\"unspecified error\");\n                }\n            }\n            function d(t, e) {\n                if (e === a.onnx.TensorProto.DataType.INT64 || e === c.TensorDataType.INT64) {\n                    if (t.greaterThanOrEqual(2147483648) || t.lessThan(-2147483648)) throw new TypeError(\"int64 is not supported\");\n                } else {\n                    if (e !== a.onnx.TensorProto.DataType.UINT32 && e !== c.TensorDataType.UINT32 && e !== a.onnx.TensorProto.DataType.UINT64 && e !== c.TensorDataType.UINT64) throw new TypeError(`not a LONG type: ${a.onnx.TensorProto.DataType[e]}`);\n                    if (t.greaterThanOrEqual(4294967296) || t.lessThan(0)) throw new TypeError(\"uint64 is not supported\");\n                }\n                return t.toNumber();\n            }\n            function h(t, e, n) {\n                switch(e){\n                    case a.onnx.TensorProto.DataType.BOOL:\n                    case a.onnx.TensorProto.DataType.UINT8:\n                        return t.getUint8(n);\n                    case a.onnx.TensorProto.DataType.INT8:\n                        return t.getInt8(n);\n                    case a.onnx.TensorProto.DataType.UINT16:\n                        return t.getUint16(n, !0);\n                    case a.onnx.TensorProto.DataType.INT16:\n                        return t.getInt16(n, !0);\n                    case a.onnx.TensorProto.DataType.FLOAT:\n                        return t.getFloat32(n, !0);\n                    case a.onnx.TensorProto.DataType.INT32:\n                        return t.getInt32(n, !0);\n                    case a.onnx.TensorProto.DataType.UINT32:\n                        return t.getUint32(n, !0);\n                    case a.onnx.TensorProto.DataType.INT64:\n                        return d(o.default.fromBits(t.getUint32(n, !0), t.getUint32(n + 4, !0), !1), e);\n                    case a.onnx.TensorProto.DataType.DOUBLE:\n                        return t.getFloat64(n, !0);\n                    case a.onnx.TensorProto.DataType.UINT64:\n                        return d(o.default.fromBits(t.getUint32(n, !0), t.getUint32(n + 4, !0), !0), e);\n                    default:\n                        throw new Error(`cannot read from DataView for type ${a.onnx.TensorProto.DataType[e]}`);\n                }\n            }\n            e.Tensor = l;\n        },\n        2517: function(t, e, n) {\n            \"use strict\";\n            var r = this && this.__importDefault || function(t) {\n                return t && t.__esModule ? t : {\n                    default: t\n                };\n            };\n            Object.defineProperty(e, \"__esModule\", {\n                value: !0\n            }), e.decodeUtf8String = e.MAX_CLIP = e.MIN_CLIP = e.PoolConvUtil = e.ReduceUtil = e.SplitUtil = e.MathUtil = e.ShapeUtil = e.LongUtil = e.ProtoUtil = e.GemmUtil = e.arrayCopyHelper = e.BroadcastUtil = e.MatMulUtil = e.ArrayUtil = e.assert = e.checkInputsShape = void 0;\n            const i = n(5686), o = r(n(3720)), a = n(1446), s = n(9162);\n            e.checkInputsShape = function(t, ...e) {\n                if (!t || t.length !== e.length) return !1;\n                for(let n = 0; n < t.length; n++)if (!t[n].dims || t[n].dims.length !== e[n]) return !1;\n                return !0;\n            }, e.assert = function(t, e) {\n                if (!t) throw new Error(\"string\" == typeof e ? e : e());\n            }, e.ArrayUtil = class {\n                static arraysEqual(t, e) {\n                    if (t.length !== e.length) return !1;\n                    for(let n = 0; n < t.length; n++)if (t[n] !== e[n]) return !1;\n                    return !0;\n                }\n            };\n            class u {\n                static preprocessInputShapes(t, e) {\n                    return [\n                        1 === t.length ? [\n                            1,\n                            t[0]\n                        ] : t,\n                        1 === e.length ? [\n                            e[0],\n                            1\n                        ] : e\n                    ];\n                }\n                static postprocessOutputShape(t, e, n) {\n                    1 === e && t.splice(t.length - 2, 1), 1 === n && t.pop();\n                }\n                static calcMatMulShape(t, e) {\n                    return t[1] !== e[0] ? void 0 : [\n                        t[0],\n                        e[1]\n                    ];\n                }\n            }\n            e.MatMulUtil = u;\n            class c {\n                static calcShape(t, e, n = !1) {\n                    const r = t.length, i = e.length;\n                    if (0 === r) return e;\n                    if (0 === i) return t;\n                    const o = Math.max(t.length, e.length), a = new Array(o);\n                    if (n) {\n                        if (r < 2 || i < 2) return;\n                        const n = u.calcMatMulShape([\n                            t[r - 2],\n                            t[r - 1]\n                        ], [\n                            e[i - 2],\n                            e[i - 1]\n                        ]);\n                        if (void 0 === n) return;\n                        [a[o - 2], a[o - 1]] = n;\n                    }\n                    for(let s = n ? 3 : 1; s <= o; s++){\n                        const n = r - s < 0 ? 1 : t[r - s], u = i - s < 0 ? 1 : e[i - s];\n                        if (n !== u && n > 1 && u > 1) return;\n                        a[o - s] = Math.max(n, u);\n                    }\n                    return a;\n                }\n                static index(t, e) {\n                    const n = new Array(e.length);\n                    return c.fillIndex(t, e, n), n;\n                }\n                static fillIndex(t, e, n) {\n                    const r = t.length - e.length;\n                    for(let i = 0; i < e.length; i++)n[i] = t[r + i] % e[i];\n                }\n                static calc(t, e, n, r, i) {\n                    const o = c.calcShape(t.dims, e.dims);\n                    if (o) {\n                        if (r && !f.areEqual(o, t.dims)) return;\n                        const a = f.size(o), u = r ? t : new s.Tensor(o, i || t.type);\n                        if (0 === o.length) u.set([], n(t.get([]), e.get([])));\n                        else {\n                            const r = new Array(o.length), i = new Array(t.dims.length), s = new Array(e.dims.length);\n                            let l, p = 0, f = 0, d = !1, h = !1;\n                            0 === t.dims.length && (p = t.get([]), d = !0), 0 === e.dims.length && (f = e.get([]), h = !0);\n                            for(let g = 0; g < a; g++){\n                                l = g;\n                                for(let t = o.length - 1; t >= 0; t--)r[t] = l % o[t], l = Math.floor(l / o[t]);\n                                d || (c.fillIndex(r, t.dims, i), p = t.get(i)), h || (c.fillIndex(r, e.dims, s), f = e.get(s)), u.set(r, n(p, f));\n                            }\n                        }\n                        return u;\n                    }\n                }\n                static isValidBroadcast(t, e) {\n                    const n = t.length, r = e.length;\n                    if (n > r) return !1;\n                    for(let i = 1; i <= n; i++)if (1 !== t[n - i] && t[n - i] !== e[r - i]) return !1;\n                    return !0;\n                }\n                static getBroadcastDims(t, e) {\n                    const n = t.length, r = [];\n                    for(let i = 0; i < n; i++){\n                        const o = n - 1 - i, a = t[o] || 1;\n                        (e[e.length - 1 - i] || 1) > 1 && 1 === a && r.unshift(o);\n                    }\n                    return r;\n                }\n            }\n            e.BroadcastUtil = c, e.arrayCopyHelper = function(t, e, n, r, i) {\n                if (r < 0 || r >= e.length) throw new Error(\"sourceIndex out of bounds\");\n                if (n < 0 || n >= t.length) throw new Error(\"targetIndex out of bounds\");\n                if (r + i > e.length) throw new Error(\"source indices to be copied are outside bounds\");\n                if (n + i > t.length) throw new Error(\"target array is too small to hold result\");\n                for(let o = 0; o < i; o++)t[n + o] = e[r + o];\n            }, e.GemmUtil = class {\n                static getShapeOfGemmResult(t, e, n, r, i) {\n                    if (2 !== t.length || 2 !== n.length) throw new Error(\"shape need to be of size 2\");\n                    let o, a, s;\n                    e ? (o = t[1], a = t[0]) : (o = t[0], a = t[1]);\n                    let u = -1;\n                    if (r ? (s = n[0], u = 1) : (s = n[1], u = 0), n[u] !== a) throw new Error(\"dimension mismatch\");\n                    if (o <= 0 || s <= 0 || a <= 0) throw new Error(\"invalid shape specified\");\n                    if (i && !c.isValidBroadcast(i, [\n                        o,\n                        s\n                    ])) throw new Error(\"gemm: invalid bias shape for broadcast\");\n                    return [\n                        o,\n                        s,\n                        a\n                    ];\n                }\n            };\n            class l {\n                static tensorDataTypeFromProto(t) {\n                    switch(t){\n                        case a.onnx.TensorProto.DataType.INT8:\n                            return \"int8\";\n                        case a.onnx.TensorProto.DataType.UINT8:\n                            return \"uint8\";\n                        case a.onnx.TensorProto.DataType.BOOL:\n                            return \"bool\";\n                        case a.onnx.TensorProto.DataType.INT16:\n                            return \"int16\";\n                        case a.onnx.TensorProto.DataType.UINT16:\n                            return \"uint16\";\n                        case a.onnx.TensorProto.DataType.INT32:\n                            return \"int32\";\n                        case a.onnx.TensorProto.DataType.UINT32:\n                            return \"uint32\";\n                        case a.onnx.TensorProto.DataType.FLOAT:\n                            return \"float32\";\n                        case a.onnx.TensorProto.DataType.DOUBLE:\n                            return \"float64\";\n                        case a.onnx.TensorProto.DataType.STRING:\n                            return \"string\";\n                        case a.onnx.TensorProto.DataType.INT64:\n                            return \"int32\";\n                        case a.onnx.TensorProto.DataType.UINT64:\n                            return \"uint32\";\n                        default:\n                            throw new Error(`unsupported data type: ${a.onnx.TensorProto.DataType[t]}`);\n                    }\n                }\n                static tensorDataTypeStringToEnum(t) {\n                    switch(t){\n                        case \"int8\":\n                            return a.onnx.TensorProto.DataType.INT8;\n                        case \"uint8\":\n                            return a.onnx.TensorProto.DataType.UINT8;\n                        case \"bool\":\n                            return a.onnx.TensorProto.DataType.BOOL;\n                        case \"int16\":\n                            return a.onnx.TensorProto.DataType.INT16;\n                        case \"uint16\":\n                            return a.onnx.TensorProto.DataType.UINT16;\n                        case \"int32\":\n                            return a.onnx.TensorProto.DataType.INT32;\n                        case \"uint32\":\n                            return a.onnx.TensorProto.DataType.UINT32;\n                        case \"float32\":\n                            return a.onnx.TensorProto.DataType.FLOAT;\n                        case \"float64\":\n                            return a.onnx.TensorProto.DataType.DOUBLE;\n                        case \"string\":\n                            return a.onnx.TensorProto.DataType.STRING;\n                        case \"int64\":\n                            return a.onnx.TensorProto.DataType.INT64;\n                        case \"uint64\":\n                            return a.onnx.TensorProto.DataType.UINT64;\n                        default:\n                            throw new Error(`unsupported data type: ${t}`);\n                    }\n                }\n                static tensorDimsFromProto(t) {\n                    return t.map((t)=>o.default.isLong(t) ? t.toNumber() : t);\n                }\n                static tensorValueTypeFromProto(t) {\n                    return {\n                        tensorType: l.tensorDataTypeFromProto(t.elemType),\n                        shape: {\n                            dims: l.tensorDimsFromProto(t.shape.dim.map((t)=>t.dimValue))\n                        }\n                    };\n                }\n                static tensorDimsFromORTFormat(t) {\n                    const e = [];\n                    for(let n = 0; n < t.dimsLength(); n++)e.push(p.longToNumber(t.dims(n)));\n                    return e;\n                }\n                static tensorAttributesFromORTFormat(t) {\n                    const e = [];\n                    for(let n = 0; n < t.attributesLength(); n++)e.push(t.attributes(n));\n                    return e;\n                }\n            }\n            e.ProtoUtil = l;\n            class p {\n                static longToNumber(t, e) {\n                    return o.default.isLong(t) ? t.toNumber() : t instanceof i.flatbuffers.Long ? o.default.fromValue({\n                        low: t.low,\n                        high: t.high,\n                        unsigned: null != e && e\n                    }).toNumber() : t;\n                }\n                static isLong(t) {\n                    return o.default.isLong(t) || t instanceof i.flatbuffers.Long;\n                }\n            }\n            e.LongUtil = p;\n            class f {\n                static size(t) {\n                    return f.getSizeFromDimensionRange(t, 0, t.length);\n                }\n                static sizeFromDimension(t, e) {\n                    if (e < 0 || e > t.length) throw new Error(`invalid dimension of ${e} for sizeFromDimension as Tensor has ${t.length} dimensions.`);\n                    return f.getSizeFromDimensionRange(t, e, t.length);\n                }\n                static sizeToDimension(t, e) {\n                    if (e < 0 || e > t.length) throw new Error(`invalid dimension of ${e} for sizeToDimension as Tensor has ${t.length} dimensions.`);\n                    return f.getSizeFromDimensionRange(t, 0, e);\n                }\n                static getSizeFromDimensionRange(t, e, n) {\n                    let r = 1;\n                    for(let i = e; i < n; i++){\n                        if (t[i] <= 0) throw new Error(\"cannot get valid size from specified dimension range. Most likely the range contains 0 or negative values in them.\");\n                        r *= t[i];\n                    }\n                    return r;\n                }\n                static computeStrides(t) {\n                    const e = t.length;\n                    if (0 === e) return [];\n                    if (1 === e) return [\n                        1\n                    ];\n                    const n = new Array(e);\n                    n[e - 1] = 1, n[e - 2] = t[e - 1];\n                    for(let r = e - 3; r >= 0; --r)n[r] = n[r + 1] * t[r + 1];\n                    return n;\n                }\n                static transpose(t) {\n                    return t.slice().reverse();\n                }\n                static indicesToOffset(t, e, n) {\n                    void 0 === n && (n = t.length);\n                    let r = 0;\n                    for(let i = 0; i < n; ++i)r += e[i] * t[i];\n                    return r;\n                }\n                static offsetToIndices(t, e) {\n                    const n = e.length;\n                    if (0 === n) return [];\n                    if (1 === n) return [\n                        t * e[0]\n                    ];\n                    const r = new Array(e.length);\n                    for(let n = 0; n < r.length - 1; ++n)r[n] = Math.floor(t / e[n]), t -= r[n] * e[n];\n                    return r[r.length - 1] = t, r;\n                }\n                static normalizeAxis(t, e) {\n                    if (t < -e && t >= e) throw new Error(\"unsupported axis for this operation.\");\n                    return t < 0 ? t + e : t;\n                }\n                static normalizeAxes(t, e) {\n                    return t.map((t)=>this.normalizeAxis(t, e));\n                }\n                static incrementIndex(t, e, n) {\n                    if (0 === e.length || 0 === t.length) throw new Error(\"Index incrementing unsupported for scalar Tensor\");\n                    if (void 0 === n) n = e.length;\n                    else if (n <= 0 || n > e.length) throw new Error(\"Incorrect axis to increment on\");\n                    for(let r = n - 1; r >= 0 && (t[r]++, !(t[r] < e[r])); --r)t[r] = 0;\n                }\n                static calculateReshapedDims(t, e) {\n                    if (0 === e.length) {\n                        if (0 === t.length || 1 === f.size(t)) return [];\n                        throw new Error(\"cannot reshape to a scalar Tensor\");\n                    }\n                    const n = e.length, r = new Array(n);\n                    let i = -1, o = 1;\n                    for(let a = 0; a < n; a++){\n                        if (e[a] < -1) throw new Error(\"a dimension in shape hints cannot be less than -1\");\n                        if (-1 === e[a]) {\n                            if (-1 !== i) throw new Error(\"at most one dimension in shape hints can be -1\");\n                            i = a;\n                        } else {\n                            if (0 === e[a]) {\n                                if (a >= t.length) throw new Error(\"the dimension with value zero exceeds the dimension size of the input tensor\");\n                                r[a] = t[a];\n                            } else r[a] = e[a];\n                            o *= r[a];\n                        }\n                    }\n                    const a = f.size(t);\n                    if (-1 !== i) {\n                        if (a % o != 0) throw new Error(`the input tensor cannot be reshaped to the requested shape. Input shape: [${t}] Output shape: [${e}]`);\n                        r[i] = a / o;\n                    } else if (o !== a) throw new Error(\"reshapedDims and originalDims don't have matching sizes\");\n                    return r;\n                }\n                static sortBasedOnPerm(t, e) {\n                    return e ? e.map((e)=>t[e]) : t.slice().reverse();\n                }\n                static padShape(t, e) {\n                    const n = t.length;\n                    return t.map((t, r)=>t + e[r] + e[r + n]);\n                }\n                static areEqual(t, e) {\n                    return t.length === e.length && t.every((t, n)=>t === e[n]);\n                }\n                static validateDimsAndCalcSize(t) {\n                    if (t.length > 6) throw new TypeError(\"Only rank 0 to 6 is supported for tensor shape.\");\n                    let e = 1;\n                    for (const n of t){\n                        if (!Number.isInteger(n)) throw new TypeError(`Invalid shape: ${n} is not an integer`);\n                        if (n < 0 || n > 2147483647) throw new TypeError(`Invalid shape: length ${n} is not allowed`);\n                        e *= n;\n                    }\n                    return e;\n                }\n                static flattenShape(t, e) {\n                    e < 0 && (e += t.length);\n                    const n = t.reduce((t, e)=>t * e, 1), r = t.slice(e).reduce((t, e)=>t * e, 1);\n                    return [\n                        n / r,\n                        r\n                    ];\n                }\n                static squeezeShape(t, e) {\n                    const n = new Array;\n                    e = f.normalizeAxes(e, t.length);\n                    for(let r = 0; r < t.length; r++){\n                        const i = e.indexOf(r) >= 0;\n                        if (i && 1 !== t[r]) throw new Error(\"squeeze an axis of size different than 1\");\n                        (0 === e.length && t[r] > 1 || e.length > 0 && !i) && n.push(t[r]);\n                    }\n                    return n;\n                }\n                static unsqueezeShape(t, e) {\n                    const n = new Array(t.length + e.length);\n                    n.fill(0);\n                    for(let t = 0; t < e.length; t++){\n                        const r = f.normalizeAxis(e[t], n.length);\n                        if (r >= n.length) throw new Error(\"'axes' has an out of range axis\");\n                        if (0 !== n[r]) throw new Error(\"'axes' has a duplicate axis\");\n                        n[r] = 1;\n                    }\n                    let r = 0;\n                    for(let e = 0; e < n.length; e++)0 === n[e] && (n[e] = t[r++]);\n                    if (r !== t.length) throw new Error(\"the unsqueezed dimension could not be established\");\n                    return n;\n                }\n            }\n            e.ShapeUtil = f, e.MathUtil = class {\n                static sqr(t, e, n, r, i) {\n                    if (r < 0 || r >= e.length) throw new Error(\"sourceIndex out of bounds\");\n                    if (n < 0 || n >= t.length) throw new Error(\"targetIndex out of bounds\");\n                    if (r + i > e.length) throw new Error(\"source indices to be copied are outside bounds\");\n                    if (n + i > t.length) throw new Error(\"target array is too small to hold result\");\n                    for(let o = 0; o < i; o++)t[n + o] += Math.pow(e[r + o], 2);\n                }\n                static axpy(t, e, n, r, i, o) {\n                    if (r < 0 || r >= e.length) throw new Error(\"sourceIndex out of bounds\");\n                    if (n < 0 || n >= t.length) throw new Error(\"targetIndex out of bounds\");\n                    if (r + i > e.length) throw new Error(\"source indices to be copied are outside bounds\");\n                    if (n + i > t.length) throw new Error(\"target array is too small to hold result\");\n                    for(let a = 0; a < i; a++)t[n + a] += o * e[r + a];\n                }\n                static powx(t, e, n, r, i, o) {\n                    if (r < 0 || r >= e.length) throw new Error(\"sourceIndex out of bounds\");\n                    if (n < 0 || n >= t.length) throw new Error(\"targetIndex out of bounds\");\n                    if (r + i > e.length) throw new Error(\"source indices to be copied are outside bounds\");\n                    if (n + i > t.length) throw new Error(\"target array is too small to hold result\");\n                    for(let a = 0; a < i; a++)t[n + a] = Math.pow(e[r + a], o);\n                }\n                static mul(t, e, n, r, i) {\n                    if (r < 0 || r >= e.length) throw new Error(\"sourceIndex out of bounds\");\n                    if (n < 0 || n >= t.length) throw new Error(\"targetIndex out of bounds\");\n                    if (r + i > e.length) throw new Error(\"source indices to be copied are outside bounds\");\n                    if (n + i > t.length) throw new Error(\"target array is too small to hold result\");\n                    for(let o = 0; o < i; o++)t[n + o] = e[r + o] * t[n + o];\n                }\n            };\n            class d {\n                static splitShape(t, e, n, r) {\n                    if (0 === n.length) {\n                        if (!r) throw new Error(\"need to know number of outputs when the 'split' attribute is not specified\");\n                        d.determineSplit(t[e], r, n);\n                    }\n                    const i = [], o = [\n                        0\n                    ];\n                    for(let r = 0; r < n.length; ++r){\n                        0 !== r && o.push(o[r - 1] + n[r - 1]);\n                        const a = t.slice();\n                        a[e] = n[r], i.push(a);\n                    }\n                    return [\n                        i,\n                        o\n                    ];\n                }\n                static determineSplit(t, e, n) {\n                    if (t % e != 0) throw new Error(\"cannot split tensor to equal sized parts\");\n                    for(let r = 0; r < e; ++r)n.push(t / e);\n                }\n            }\n            e.SplitUtil = d;\n            class h {\n                static calcReduce(t, e, n, r, i) {\n                    const o = t.dims.slice(0);\n                    0 === e.length && o.forEach((t, n)=>e.push(n));\n                    const a = h.calcReduceShape(o, e, !0), u = f.size(a), l = new s.Tensor(a, t.type), p = f.computeStrides(a), d = f.computeStrides(o), g = new Array(o.length);\n                    for(let n = 0; n < u; n++){\n                        const a = f.offsetToIndices(n, p);\n                        c.fillIndex(a, o, g), l.set(a, h.calcReduceByAxis(t.numberData, e, o, 0, f.indicesToOffset(g, d), r, i));\n                    }\n                    return n ? l : new s.Tensor(h.calcReduceShape(o, e, n), l.type, void 0, void 0, l.data, l.dataId);\n                }\n                static calcReduceByAxis(t, e, n, r, i, o, a) {\n                    let s = 0;\n                    if (r >= e.length) return o(t[i]);\n                    const u = e[r], c = u >= n.length ? 1 : f.size(n.slice(u + 1));\n                    for(let l = 0; l < n[u]; l++)s = 0 === l ? h.calcReduceByAxis(t, e, n, r + 1, i, o, a) : a(s, h.calcReduceByAxis(t, e, n, r + 1, i, o, a)), i += c;\n                    return s;\n                }\n                static calcReduceShape(t, e, n) {\n                    const r = t.slice();\n                    for(let t = 0; t < e.length; t++)r[e[t]] = n ? 1 : 0;\n                    return r.filter((t)=>0 !== t);\n                }\n            }\n            e.ReduceUtil = h;\n            class g {\n                static adjustPoolAttributes(t, e, n, r, i, o) {\n                    if (!t && n.length !== e.length - 2) throw new Error(\"length of specified kernel shapes should be 2 less than length of input dimensions\");\n                    if (t) for(let t = 0; t < e.length - 2; t++)t >= n.length ? n.push(e[t + 2]) : n[t] = e[t + 2];\n                    for(let t = 0; t < n.length; t++)if (t < r.length) {\n                        if (r[t] < 0) throw new Error(\"strides should be greater than or equal to 1\");\n                    } else r.push(1);\n                    for(let t = 0; t < n.length; t++)if (t < i.length) {\n                        if (i[t] < 0) throw new Error(\"dilations should be greater than or equal to 1\");\n                    } else i.push(1);\n                    for(let t = 0; t < 2 * n.length; t++)if (t < o.length) {\n                        if (o[t] < 0) throw new Error(\"pad should be greater than or equal to 1\");\n                    } else o.push(0);\n                    for(let t = 0; t < n.length; t++){\n                        if (n[t] <= 0) throw new Error(\"kernel shapes need to be greater than 0\");\n                        if (o[t] >= n[t] || o[t + n.length] >= n[t]) throw new Error(\"pads should be smaller than kernel\");\n                    }\n                }\n                static adjustPadsBasedOnAutoPad(t, e, n, r, i, o) {\n                    if (o) {\n                        if (i.length !== 2 * (t.length - 2)) throw new Error(\"length of pads should be twice the length of data dimensions\");\n                        if (e.length !== t.length - 2) throw new Error(\"length of strides should be the length of data dimensions\");\n                        if (r.length !== t.length - 2) throw new Error(\"length of kernel shapes should be the length of data dimensions\");\n                        for(let a = 0; a < t.length - 2; a++)g.adjustPadAndReturnShape(t[a + 2], e[a], n[a], r[a], i, a, a + t.length - 2, o);\n                    }\n                }\n                static computePoolOutputShape(t, e, n, r, i, o, a) {\n                    if (e.length <= 0) throw new Error(\"input shape must be of size greater than 0\");\n                    const s = [\n                        e[0],\n                        e[1]\n                    ];\n                    return g.computeShapeHelper(t, e, s, n, r, i, o, a), s;\n                }\n                static computeConvOutputShape(t, e, n, r, i, o, a) {\n                    if (t.length <= 0 || e.length <= 0) throw new Error(\"invalid input tensor dims or invalid filter tensor dims\");\n                    const s = [\n                        t[0],\n                        e[0]\n                    ];\n                    return g.computeShapeHelper(!1, t, s, n, r, i, o, a), s;\n                }\n                static computeShapeHelper(t, e, n, r, i, o, a, s) {\n                    if (t) for(let t = 0; t < e.length - 2; t++)n.push(1);\n                    else for(let t = 0; t < e.length - 2; t++)n.push(g.adjustPadAndReturnShape(e[t + 2], r[t], i[t], o[t], a, t, t + e.length - 2, s));\n                }\n                static adjustPadAndReturnShape(t, e, n, r, i, o, a, s) {\n                    const u = n * (r - 1) + 1;\n                    if (!s || \"NOTSET\" === s) return Math.floor((t + i[o] + i[a] - u) / e + 1);\n                    switch(s){\n                        case \"VALID\":\n                            return i[o] = 0, i[a] = 0, Math.floor((t - u) / e + 1);\n                        case \"SAME_LOWER\":\n                        case \"SAME_UPPER\":\n                            if (1 !== n) throw new Error(\"Dilation not supported for SAME_UPPER or SAME_LOWER\");\n                            {\n                                const n = ((t + e - 1) / e - 1) * e + r - t;\n                                return i[o] = \"SAME_LOWER\" === s ? Math.floor((n + 1) / 2) : Math.floor(n / 2), i[a] = n - i[o], Math.floor((t + n - r) / e + 1);\n                            }\n                        default:\n                            throw new Error(\"Unsupported AutoPad type\");\n                    }\n                }\n            }\n            e.PoolConvUtil = g, e.MIN_CLIP = -34028234663852886e22, e.MAX_CLIP = 34028234663852886e22, e.decodeUtf8String = function(t) {\n                return (new TextDecoder).decode(t);\n            };\n        },\n        7967: (t, e)=>{\n            \"use strict\";\n            Object.defineProperty(e, \"__esModule\", {\n                value: !0\n            }), e.iterateExtraOptions = void 0, e.iterateExtraOptions = (t, n, r, i)=>{\n                if (\"object\" == typeof t && null !== t) {\n                    if (r.has(t)) throw new Error(\"Circular reference in options\");\n                    r.add(t);\n                }\n                Object.entries(t).forEach(([t, o])=>{\n                    const a = n ? n + t : t;\n                    if (\"object\" == typeof o) (0, e.iterateExtraOptions)(o, a + \".\", r, i);\n                    else if (\"string\" == typeof o || \"number\" == typeof o) i(a, o.toString());\n                    else {\n                        if (\"boolean\" != typeof o) throw new Error(\"Can't handle extra config type: \" + typeof o);\n                        i(a, o ? \"1\" : \"0\");\n                    }\n                });\n            };\n        },\n        2157: function(t, e, n) {\n            \"use strict\";\n            var r, i = this && this.__createBinding || (Object.create ? function(t, e, n, r) {\n                void 0 === r && (r = n);\n                var i = Object.getOwnPropertyDescriptor(e, n);\n                i && !(\"get\" in i ? !e.__esModule : i.writable || i.configurable) || (i = {\n                    enumerable: !0,\n                    get: function() {\n                        return e[n];\n                    }\n                }), Object.defineProperty(t, r, i);\n            } : function(t, e, n, r) {\n                void 0 === r && (r = n), t[r] = e[n];\n            }), o = this && this.__setModuleDefault || (Object.create ? function(t, e) {\n                Object.defineProperty(t, \"default\", {\n                    enumerable: !0,\n                    value: e\n                });\n            } : function(t, e) {\n                t.default = e;\n            }), a = this && this.__importStar || function(t) {\n                if (t && t.__esModule) return t;\n                var e = {};\n                if (null != t) for(var n in t)\"default\" !== n && Object.prototype.hasOwnProperty.call(t, n) && i(e, t, n);\n                return o(e, t), e;\n            };\n            Object.defineProperty(e, \"__esModule\", {\n                value: !0\n            }), e.endProfiling = e.run = e.releaseSession = e.createSession = e.createSessionFinalize = e.createSessionAllocate = e.initOrt = e.initWasm = void 0;\n            const s = n(6207), u = a(n(349)), c = n(6361), l = ()=>!!s.env.wasm.proxy && \"undefined\" != typeof document;\n            let p, f, d, h = !1, g = !1, b = !1;\n            const m = [], y = [], _ = [], v = [], w = [], x = [], T = ()=>{\n                if (h || !g || b || !p) throw new Error(\"worker not ready\");\n            }, S = (t)=>{\n                switch(t.data.type){\n                    case \"init-wasm\":\n                        h = !1, t.data.err ? (b = !0, f[1](t.data.err)) : (g = !0, f[0]());\n                        break;\n                    case \"init-ort\":\n                        t.data.err ? d[1](t.data.err) : d[0]();\n                        break;\n                    case \"create_allocate\":\n                        t.data.err ? m.shift()[1](t.data.err) : m.shift()[0](t.data.out);\n                        break;\n                    case \"create_finalize\":\n                        t.data.err ? y.shift()[1](t.data.err) : y.shift()[0](t.data.out);\n                        break;\n                    case \"create\":\n                        t.data.err ? _.shift()[1](t.data.err) : _.shift()[0](t.data.out);\n                        break;\n                    case \"release\":\n                        t.data.err ? v.shift()[1](t.data.err) : v.shift()[0]();\n                        break;\n                    case \"run\":\n                        t.data.err ? w.shift()[1](t.data.err) : w.shift()[0](t.data.out);\n                        break;\n                    case \"end-profiling\":\n                        t.data.err ? x.shift()[1](t.data.err) : x.shift()[0]();\n                }\n            }, O = \"undefined\" != typeof document ? null === (r = null === document || void 0 === document ? void 0 : document.currentScript) || void 0 === r ? void 0 : r.src : void 0;\n            e.initWasm = async ()=>{\n                if (l()) {\n                    if (g) return;\n                    if (h) throw new Error(\"multiple calls to 'initWasm()' detected.\");\n                    if (b) throw new Error(\"previous call to 'initWasm()' failed.\");\n                    return h = !0, void 0 === s.env.wasm.wasmPaths && O && 0 !== O.indexOf(\"blob:\") && (s.env.wasm.wasmPaths = O.substr(0, +O.lastIndexOf(\"/\") + 1)), new Promise((t, e)=>{\n                        null == p || p.terminate(), p = n(9710).Z(), p.onmessage = S, f = [\n                            t,\n                            e\n                        ];\n                        const r = {\n                            type: \"init-wasm\",\n                            in: s.env.wasm\n                        };\n                        p.postMessage(r);\n                    });\n                }\n                return (0, c.initializeWebAssembly)(s.env.wasm);\n            }, e.initOrt = async (t, e)=>{\n                if (l()) return T(), new Promise((n, r)=>{\n                    d = [\n                        n,\n                        r\n                    ];\n                    const i = {\n                        type: \"init-ort\",\n                        in: {\n                            numThreads: t,\n                            loggingLevel: e\n                        }\n                    };\n                    p.postMessage(i);\n                });\n                u.initOrt(t, e);\n            }, e.createSessionAllocate = async (t)=>l() ? (T(), new Promise((e, n)=>{\n                    m.push([\n                        e,\n                        n\n                    ]);\n                    const r = {\n                        type: \"create_allocate\",\n                        in: {\n                            model: t\n                        }\n                    };\n                    p.postMessage(r, [\n                        t.buffer\n                    ]);\n                })) : u.createSessionAllocate(t), e.createSessionFinalize = async (t, e)=>l() ? (T(), new Promise((n, r)=>{\n                    y.push([\n                        n,\n                        r\n                    ]);\n                    const i = {\n                        type: \"create_finalize\",\n                        in: {\n                            modeldata: t,\n                            options: e\n                        }\n                    };\n                    p.postMessage(i);\n                })) : u.createSessionFinalize(t, e), e.createSession = async (t, e)=>l() ? (T(), new Promise((n, r)=>{\n                    _.push([\n                        n,\n                        r\n                    ]);\n                    const i = {\n                        type: \"create\",\n                        in: {\n                            model: t,\n                            options: e\n                        }\n                    };\n                    p.postMessage(i, [\n                        t.buffer\n                    ]);\n                })) : u.createSession(t, e), e.releaseSession = async (t)=>{\n                if (l()) return T(), new Promise((e, n)=>{\n                    v.push([\n                        e,\n                        n\n                    ]);\n                    const r = {\n                        type: \"release\",\n                        in: t\n                    };\n                    p.postMessage(r);\n                });\n                u.releaseSession(t);\n            }, e.run = async (t, e, n, r, i)=>l() ? (T(), new Promise((o, a)=>{\n                    w.push([\n                        o,\n                        a\n                    ]);\n                    const s = {\n                        type: \"run\",\n                        in: {\n                            sessionId: t,\n                            inputIndices: e,\n                            inputs: n,\n                            outputIndices: r,\n                            options: i\n                        }\n                    };\n                    p.postMessage(s, u.extractTransferableBuffers(n));\n                })) : u.run(t, e, n, r, i), e.endProfiling = async (t)=>{\n                if (l()) return T(), new Promise((e, n)=>{\n                    x.push([\n                        e,\n                        n\n                    ]);\n                    const r = {\n                        type: \"end-profiling\",\n                        in: t\n                    };\n                    p.postMessage(r);\n                });\n                u.endProfiling(t);\n            };\n        },\n        586: (t, e, n)=>{\n            \"use strict\";\n            Object.defineProperty(e, \"__esModule\", {\n                value: !0\n            }), e.setRunOptions = void 0;\n            const r = n(7967), i = n(4983), o = n(6361);\n            e.setRunOptions = (t)=>{\n                const e = (0, o.getInstance)();\n                let n = 0;\n                const a = [], s = t || {};\n                try {\n                    if (void 0 === (null == t ? void 0 : t.logSeverityLevel)) s.logSeverityLevel = 2;\n                    else if (\"number\" != typeof t.logSeverityLevel || !Number.isInteger(t.logSeverityLevel) || t.logSeverityLevel < 0 || t.logSeverityLevel > 4) throw new Error(`log serverity level is not valid: ${t.logSeverityLevel}`);\n                    if (void 0 === (null == t ? void 0 : t.logVerbosityLevel)) s.logVerbosityLevel = 0;\n                    else if (\"number\" != typeof t.logVerbosityLevel || !Number.isInteger(t.logVerbosityLevel)) throw new Error(`log verbosity level is not valid: ${t.logVerbosityLevel}`);\n                    void 0 === (null == t ? void 0 : t.terminate) && (s.terminate = !1);\n                    let o = 0;\n                    if (void 0 !== (null == t ? void 0 : t.tag) && (o = (0, i.allocWasmString)(t.tag, a)), n = e._OrtCreateRunOptions(s.logSeverityLevel, s.logVerbosityLevel, !!s.terminate, o), 0 === n) throw new Error(\"Can't create run options\");\n                    return void 0 !== (null == t ? void 0 : t.extra) && (0, r.iterateExtraOptions)(t.extra, \"\", new WeakSet, (t, r)=>{\n                        const o = (0, i.allocWasmString)(t, a), s = (0, i.allocWasmString)(r, a);\n                        if (0 !== e._OrtAddRunConfigEntry(n, o, s)) throw new Error(`Can't set a run config entry: ${t} - ${r}`);\n                    }), [\n                        n,\n                        a\n                    ];\n                } catch (t) {\n                    throw 0 !== n && e._OrtReleaseRunOptions(n), a.forEach(e._free), t;\n                }\n            };\n        },\n        2306: (t, e, n)=>{\n            \"use strict\";\n            Object.defineProperty(e, \"__esModule\", {\n                value: !0\n            }), e.OnnxruntimeWebAssemblySessionHandler = void 0;\n            const r = n(6231), i = n(6207), o = n(6464), a = n(2157);\n            let s;\n            e.OnnxruntimeWebAssemblySessionHandler = class {\n                async createSessionAllocate(t) {\n                    const e = await fetch(t), n = await e.arrayBuffer();\n                    return (0, a.createSessionAllocate)(new Uint8Array(n));\n                }\n                async loadModel(t, e) {\n                    if (s || (await (0, a.initOrt)(i.env.wasm.numThreads, ((t)=>{\n                        switch(t){\n                            case \"verbose\":\n                                return 0;\n                            case \"info\":\n                                return 1;\n                            case \"warning\":\n                                return 2;\n                            case \"error\":\n                                return 3;\n                            case \"fatal\":\n                                return 4;\n                            default:\n                                throw new Error(`unsupported logging level: ${t}`);\n                        }\n                    })(i.env.logLevel)), s = !0), \"string\" == typeof t) if (\"undefined\" == typeof fetch) {\n                        const n = await (0, o.promisify)(r.readFile)(t);\n                        [this.sessionId, this.inputNames, this.outputNames] = await (0, a.createSession)(n, e);\n                    } else {\n                        const n = await this.createSessionAllocate(t);\n                        [this.sessionId, this.inputNames, this.outputNames] = await (0, a.createSessionFinalize)(n, e);\n                    }\n                    else [this.sessionId, this.inputNames, this.outputNames] = await (0, a.createSession)(t, e);\n                }\n                async dispose() {\n                    return (0, a.releaseSession)(this.sessionId);\n                }\n                async run(t, e, n) {\n                    const r = [], o = [];\n                    Object.entries(t).forEach((t)=>{\n                        const e = t[0], n = t[1], i = this.inputNames.indexOf(e);\n                        if (-1 === i) throw new Error(`invalid input '${e}'`);\n                        r.push(n), o.push(i);\n                    });\n                    const s = [];\n                    Object.entries(e).forEach((t)=>{\n                        const e = t[0], n = this.outputNames.indexOf(e);\n                        if (-1 === n) throw new Error(`invalid output '${e}'`);\n                        s.push(n);\n                    });\n                    const u = await (0, a.run)(this.sessionId, o, r.map((t)=>[\n                            t.type,\n                            t.dims,\n                            t.data\n                        ]), s, n), c = {};\n                    for(let t = 0; t < u.length; t++)c[this.outputNames[s[t]]] = new i.Tensor(u[t][0], u[t][2], u[t][1]);\n                    return c;\n                }\n                startProfiling() {}\n                endProfiling() {\n                    (0, a.endProfiling)(this.sessionId);\n                }\n            };\n        },\n        4919: (t, e, n)=>{\n            \"use strict\";\n            Object.defineProperty(e, \"__esModule\", {\n                value: !0\n            }), e.setSessionOptions = void 0;\n            const r = n(7967), i = n(4983), o = n(6361);\n            e.setSessionOptions = (t)=>{\n                const e = (0, o.getInstance)();\n                let n = 0;\n                const a = [], s = t || {};\n                ((t)=>{\n                    t.extra || (t.extra = {}), t.extra.session || (t.extra.session = {});\n                    const e = t.extra.session;\n                    e.use_ort_model_bytes_directly || (e.use_ort_model_bytes_directly = \"1\");\n                })(s);\n                try {\n                    void 0 === (null == t ? void 0 : t.graphOptimizationLevel) && (s.graphOptimizationLevel = \"all\");\n                    const u = ((t)=>{\n                        switch(t){\n                            case \"disabled\":\n                                return 0;\n                            case \"basic\":\n                                return 1;\n                            case \"extended\":\n                                return 2;\n                            case \"all\":\n                                return 99;\n                            default:\n                                throw new Error(`unsupported graph optimization level: ${t}`);\n                        }\n                    })(s.graphOptimizationLevel);\n                    void 0 === (null == t ? void 0 : t.enableCpuMemArena) && (s.enableCpuMemArena = !0), void 0 === (null == t ? void 0 : t.enableMemPattern) && (s.enableMemPattern = !0), void 0 === (null == t ? void 0 : t.executionMode) && (s.executionMode = \"sequential\");\n                    const c = ((t)=>{\n                        switch(t){\n                            case \"sequential\":\n                                return 0;\n                            case \"parallel\":\n                                return 1;\n                            default:\n                                throw new Error(`unsupported execution mode: ${t}`);\n                        }\n                    })(s.executionMode);\n                    let l = 0;\n                    if (void 0 !== (null == t ? void 0 : t.logId) && (l = (0, i.allocWasmString)(t.logId, a)), void 0 === (null == t ? void 0 : t.logSeverityLevel)) s.logSeverityLevel = 2;\n                    else if (\"number\" != typeof t.logSeverityLevel || !Number.isInteger(t.logSeverityLevel) || t.logSeverityLevel < 0 || t.logSeverityLevel > 4) throw new Error(`log serverity level is not valid: ${t.logSeverityLevel}`);\n                    if (void 0 === (null == t ? void 0 : t.logVerbosityLevel)) s.logVerbosityLevel = 0;\n                    else if (\"number\" != typeof t.logVerbosityLevel || !Number.isInteger(t.logVerbosityLevel)) throw new Error(`log verbosity level is not valid: ${t.logVerbosityLevel}`);\n                    if (void 0 === (null == t ? void 0 : t.enableProfiling) && (s.enableProfiling = !1), n = e._OrtCreateSessionOptions(u, !!s.enableCpuMemArena, !!s.enableMemPattern, c, !!s.enableProfiling, 0, l, s.logSeverityLevel, s.logVerbosityLevel), 0 === n) throw new Error(\"Can't create session options\");\n                    return (null == t ? void 0 : t.executionProviders) && ((t, e, n)=>{\n                        for (const r of e){\n                            let e = \"string\" == typeof r ? r : r.name;\n                            switch(e){\n                                case \"xnnpack\":\n                                    e = \"XNNPACK\";\n                                    break;\n                                case \"wasm\":\n                                case \"cpu\":\n                                    continue;\n                                default:\n                                    throw new Error(`not supported EP: ${e}`);\n                            }\n                            const a = (0, i.allocWasmString)(e, n);\n                            if (0 !== (0, o.getInstance)()._OrtAppendExecutionProvider(t, a)) throw new Error(`Can't append execution provider: ${e}`);\n                        }\n                    })(n, t.executionProviders, a), void 0 !== (null == t ? void 0 : t.extra) && (0, r.iterateExtraOptions)(t.extra, \"\", new WeakSet, (t, r)=>{\n                        const o = (0, i.allocWasmString)(t, a), s = (0, i.allocWasmString)(r, a);\n                        if (0 !== e._OrtAddSessionConfigEntry(n, o, s)) throw new Error(`Can't set a session config entry: ${t} - ${r}`);\n                    }), [\n                        n,\n                        a\n                    ];\n                } catch (t) {\n                    throw 0 !== n && e._OrtReleaseSessionOptions(n), a.forEach(e._free), t;\n                }\n            };\n        },\n        4983: (t, e, n)=>{\n            \"use strict\";\n            Object.defineProperty(e, \"__esModule\", {\n                value: !0\n            }), e.allocWasmString = void 0;\n            const r = n(6361);\n            e.allocWasmString = (t, e)=>{\n                const n = (0, r.getInstance)(), i = n.lengthBytesUTF8(t) + 1, o = n._malloc(i);\n                return n.stringToUTF8(t, o, i), e.push(o), o;\n            };\n        },\n        349: (t, e, n)=>{\n            \"use strict\";\n            Object.defineProperty(e, \"__esModule\", {\n                value: !0\n            }), e.extractTransferableBuffers = e.endProfiling = e.run = e.releaseSession = e.createSession = e.createSessionFinalize = e.createSessionAllocate = e.initOrt = void 0;\n            const r = n(586), i = n(4919), o = n(4983), a = n(6361);\n            e.initOrt = (t, e)=>{\n                const n = (0, a.getInstance)()._OrtInit(t, e);\n                if (0 !== n) throw new Error(`Can't initialize onnxruntime. error code = ${n}`);\n            };\n            const s = new Map;\n            e.createSessionAllocate = (t)=>{\n                const e = (0, a.getInstance)(), n = e._malloc(t.byteLength);\n                return e.HEAPU8.set(t, n), [\n                    n,\n                    t.byteLength\n                ];\n            }, e.createSessionFinalize = (t, e)=>{\n                const n = (0, a.getInstance)();\n                let r = 0, o = 0, u = [];\n                try {\n                    if ([o, u] = (0, i.setSessionOptions)(e), r = n._OrtCreateSession(t[0], t[1], o), 0 === r) throw new Error(\"Can't create a session\");\n                } finally{\n                    n._free(t[0]), n._OrtReleaseSessionOptions(o), u.forEach(n._free);\n                }\n                const c = n._OrtGetInputCount(r), l = n._OrtGetOutputCount(r), p = [], f = [], d = [], h = [];\n                for(let t = 0; t < c; t++){\n                    const e = n._OrtGetInputName(r, t);\n                    if (0 === e) throw new Error(\"Can't get an input name\");\n                    f.push(e), p.push(n.UTF8ToString(e));\n                }\n                for(let t = 0; t < l; t++){\n                    const e = n._OrtGetOutputName(r, t);\n                    if (0 === e) throw new Error(\"Can't get an output name\");\n                    h.push(e), d.push(n.UTF8ToString(e));\n                }\n                return s.set(r, [\n                    r,\n                    f,\n                    h\n                ]), [\n                    r,\n                    p,\n                    d\n                ];\n            }, e.createSession = (t, n)=>{\n                const r = (0, e.createSessionAllocate)(t);\n                return (0, e.createSessionFinalize)(r, n);\n            }, e.releaseSession = (t)=>{\n                const e = (0, a.getInstance)(), n = s.get(t);\n                if (!n) throw new Error(\"invalid session id\");\n                const r = n[0], i = n[1], o = n[2];\n                i.forEach(e._OrtFree), o.forEach(e._OrtFree), e._OrtReleaseSession(r), s.delete(t);\n            };\n            const u = (t)=>{\n                switch(t){\n                    case \"int8\":\n                        return 3;\n                    case \"uint8\":\n                        return 2;\n                    case \"bool\":\n                        return 9;\n                    case \"int16\":\n                        return 5;\n                    case \"uint16\":\n                        return 4;\n                    case \"int32\":\n                        return 6;\n                    case \"uint32\":\n                        return 12;\n                    case \"float32\":\n                        return 1;\n                    case \"float64\":\n                        return 11;\n                    case \"string\":\n                        return 8;\n                    case \"int64\":\n                        return 7;\n                    case \"uint64\":\n                        return 13;\n                    default:\n                        throw new Error(`unsupported data type: ${t}`);\n                }\n            }, c = (t)=>{\n                switch(t){\n                    case 3:\n                        return \"int8\";\n                    case 2:\n                        return \"uint8\";\n                    case 9:\n                        return \"bool\";\n                    case 5:\n                        return \"int16\";\n                    case 4:\n                        return \"uint16\";\n                    case 6:\n                        return \"int32\";\n                    case 12:\n                        return \"uint32\";\n                    case 1:\n                        return \"float32\";\n                    case 11:\n                        return \"float64\";\n                    case 8:\n                        return \"string\";\n                    case 7:\n                        return \"int64\";\n                    case 13:\n                        return \"uint64\";\n                    default:\n                        throw new Error(`unsupported data type: ${t}`);\n                }\n            }, l = (t)=>{\n                switch(t){\n                    case \"float32\":\n                        return Float32Array;\n                    case \"uint8\":\n                    case \"bool\":\n                        return Uint8Array;\n                    case \"int8\":\n                        return Int8Array;\n                    case \"uint16\":\n                        return Uint16Array;\n                    case \"int16\":\n                        return Int16Array;\n                    case \"int32\":\n                        return Int32Array;\n                    case \"float64\":\n                        return Float64Array;\n                    case \"uint32\":\n                        return Uint32Array;\n                    case \"int64\":\n                        return BigInt64Array;\n                    case \"uint64\":\n                        return BigUint64Array;\n                    default:\n                        throw new Error(`unsupported type: ${t}`);\n                }\n            };\n            e.run = (t, e, n, i, p)=>{\n                const f = (0, a.getInstance)(), d = s.get(t);\n                if (!d) throw new Error(\"invalid session id\");\n                const h = d[0], g = d[1], b = d[2], m = e.length, y = i.length;\n                let _ = 0, v = [];\n                const w = [], x = [];\n                try {\n                    [_, v] = (0, r.setRunOptions)(p);\n                    for(let t = 0; t < m; t++){\n                        const e = n[t][0], r = n[t][1], i = n[t][2];\n                        let a, s;\n                        if (Array.isArray(i)) {\n                            s = 4 * i.length, a = f._malloc(s), x.push(a);\n                            let t = a / 4;\n                            for(let e = 0; e < i.length; e++){\n                                if (\"string\" != typeof i[e]) throw new TypeError(`tensor data at index ${e} is not a string`);\n                                f.HEAPU32[t++] = (0, o.allocWasmString)(i[e], x);\n                            }\n                        } else s = i.byteLength, a = f._malloc(s), x.push(a), f.HEAPU8.set(new Uint8Array(i.buffer, i.byteOffset, s), a);\n                        const c = f.stackSave(), l = f.stackAlloc(4 * r.length);\n                        try {\n                            let t = l / 4;\n                            r.forEach((e)=>f.HEAP32[t++] = e);\n                            const n = f._OrtCreateTensor(u(e), a, s, l, r.length);\n                            if (0 === n) throw new Error(\"Can't create a tensor\");\n                            w.push(n);\n                        } finally{\n                            f.stackRestore(c);\n                        }\n                    }\n                    const t = f.stackSave(), a = f.stackAlloc(4 * m), s = f.stackAlloc(4 * m), d = f.stackAlloc(4 * y), T = f.stackAlloc(4 * y);\n                    try {\n                        let n = a / 4, r = s / 4, o = d / 4, u = T / 4;\n                        for(let t = 0; t < m; t++)f.HEAPU32[n++] = w[t], f.HEAPU32[r++] = g[e[t]];\n                        for(let t = 0; t < y; t++)f.HEAPU32[o++] = 0, f.HEAPU32[u++] = b[i[t]];\n                        let p = f._OrtRun(h, s, a, m, T, y, d, _);\n                        const v = [];\n                        if (0 === p) for(let t = 0; t < y; t++){\n                            const e = f.HEAPU32[d / 4 + t], n = f.stackSave(), r = f.stackAlloc(16);\n                            let i, o = 0;\n                            try {\n                                if (p = f._OrtGetTensorData(e, r, r + 4, r + 8, r + 12), 0 !== p) throw new Error(`Can't access output tensor data. error code = ${p}`);\n                                let t = r / 4;\n                                const a = f.HEAPU32[t++];\n                                o = f.HEAPU32[t++];\n                                const s = f.HEAPU32[t++], u = f.HEAPU32[t++], d = [];\n                                for(let t = 0; t < u; t++)d.push(f.HEAPU32[s / 4 + t]);\n                                f._OrtFree(s);\n                                const h = 0 === d.length ? 1 : d.reduce((t, e)=>t * e);\n                                if (i = c(a), \"string\" === i) {\n                                    const t = [];\n                                    let e = o / 4;\n                                    for(let n = 0; n < h; n++){\n                                        const r = f.HEAPU32[e++], i = n === h - 1 ? void 0 : f.HEAPU32[e] - r;\n                                        t.push(f.UTF8ToString(r, i));\n                                    }\n                                    v.push([\n                                        i,\n                                        d,\n                                        t\n                                    ]);\n                                } else {\n                                    const t = new (l(i))(h);\n                                    new Uint8Array(t.buffer, t.byteOffset, t.byteLength).set(f.HEAPU8.subarray(o, o + t.byteLength)), v.push([\n                                        i,\n                                        d,\n                                        t\n                                    ]);\n                                }\n                            } finally{\n                                f.stackRestore(n), \"string\" === i && o && f._free(o), f._OrtReleaseTensor(e);\n                            }\n                        }\n                        if (0 === p) return v;\n                        throw new Error(`failed to call OrtRun(). error code = ${p}.`);\n                    } finally{\n                        f.stackRestore(t);\n                    }\n                } finally{\n                    w.forEach(f._OrtReleaseTensor), x.forEach(f._free), f._OrtReleaseRunOptions(_), v.forEach(f._free);\n                }\n            }, e.endProfiling = (t)=>{\n                const e = (0, a.getInstance)(), n = s.get(t);\n                if (!n) throw new Error(\"invalid session id\");\n                const r = n[0], i = e._OrtEndProfiling(r);\n                if (0 === i) throw new Error(\"Can't get an profile file name\");\n                e._OrtFree(i);\n            }, e.extractTransferableBuffers = (t)=>{\n                const e = [];\n                for (const n of t){\n                    const t = n[2];\n                    !Array.isArray(t) && t.buffer && e.push(t.buffer);\n                }\n                return e;\n            };\n        },\n        6361: function(t, e, n) {\n            \"use strict\";\n            var r = this && this.__createBinding || (Object.create ? function(t, e, n, r) {\n                void 0 === r && (r = n);\n                var i = Object.getOwnPropertyDescriptor(e, n);\n                i && !(\"get\" in i ? !e.__esModule : i.writable || i.configurable) || (i = {\n                    enumerable: !0,\n                    get: function() {\n                        return e[n];\n                    }\n                }), Object.defineProperty(t, r, i);\n            } : function(t, e, n, r) {\n                void 0 === r && (r = n), t[r] = e[n];\n            }), i = this && this.__setModuleDefault || (Object.create ? function(t, e) {\n                Object.defineProperty(t, \"default\", {\n                    enumerable: !0,\n                    value: e\n                });\n            } : function(t, e) {\n                t.default = e;\n            }), o = this && this.__importStar || function(t) {\n                if (t && t.__esModule) return t;\n                var e = {};\n                if (null != t) for(var n in t)\"default\" !== n && Object.prototype.hasOwnProperty.call(t, n) && r(e, t, n);\n                return i(e, t), e;\n            }, a = this && this.__importDefault || function(t) {\n                return t && t.__esModule ? t : {\n                    default: t\n                };\n            };\n            Object.defineProperty(e, \"__esModule\", {\n                value: !0\n            }), e.dispose = e.getInstance = e.initializeWebAssembly = void 0;\n            const s = o(n(1423)), u = a(n(932)), c = n(3474);\n            let l, p = !1, f = !1, d = !1;\n            const h = (t, e)=>e ? t ? \"ort-wasm-simd-threaded.wasm\" : \"ort-wasm-threaded.wasm\" : t ? \"ort-wasm-simd.wasm\" : \"ort-wasm.wasm\";\n            e.initializeWebAssembly = async (t)=>{\n                if (p) return Promise.resolve();\n                if (f) throw new Error(\"multiple calls to 'initializeWebAssembly()' detected.\");\n                if (d) throw new Error(\"previous call to 'initializeWebAssembly()' failed.\");\n                f = !0;\n                const e = t.initTimeout, r = t.numThreads, i = t.simd, o = r > 1 && (()=>{\n                    try {\n                        return \"undefined\" != typeof SharedArrayBuffer && (\"undefined\" != typeof MessageChannel && (new MessageChannel).port1.postMessage(new SharedArrayBuffer(1)), WebAssembly.validate(new Uint8Array([\n                            0,\n                            97,\n                            115,\n                            109,\n                            1,\n                            0,\n                            0,\n                            0,\n                            1,\n                            4,\n                            1,\n                            96,\n                            0,\n                            0,\n                            3,\n                            2,\n                            1,\n                            0,\n                            5,\n                            4,\n                            1,\n                            3,\n                            1,\n                            1,\n                            10,\n                            11,\n                            1,\n                            9,\n                            0,\n                            65,\n                            0,\n                            254,\n                            16,\n                            2,\n                            0,\n                            26,\n                            11\n                        ])));\n                    } catch (t) {\n                        return !1;\n                    }\n                })(), a = i && (()=>{\n                    try {\n                        return WebAssembly.validate(new Uint8Array([\n                            0,\n                            97,\n                            115,\n                            109,\n                            1,\n                            0,\n                            0,\n                            0,\n                            1,\n                            4,\n                            1,\n                            96,\n                            0,\n                            0,\n                            3,\n                            2,\n                            1,\n                            0,\n                            10,\n                            30,\n                            1,\n                            28,\n                            0,\n                            65,\n                            0,\n                            253,\n                            15,\n                            253,\n                            12,\n                            0,\n                            0,\n                            0,\n                            0,\n                            0,\n                            0,\n                            0,\n                            0,\n                            0,\n                            0,\n                            0,\n                            0,\n                            0,\n                            0,\n                            0,\n                            0,\n                            253,\n                            186,\n                            1,\n                            26,\n                            11\n                        ]));\n                    } catch (t) {\n                        return !1;\n                    }\n                })(), g = \"string\" == typeof t.wasmPaths ? t.wasmPaths : void 0, b = h(!1, o), m = h(a, o), y = \"object\" == typeof t.wasmPaths ? t.wasmPaths[m] : void 0;\n                let _ = !1;\n                const v = [];\n                if (e > 0 && v.push(new Promise((t)=>{\n                    setTimeout(()=>{\n                        _ = !0, t();\n                    }, e);\n                })), v.push(new Promise((t, e)=>{\n                    const r = o ? c : u.default, i = {\n                        locateFile: (t, e)=>o && t.endsWith(\".worker.js\") && \"undefined\" != typeof Blob ? URL.createObjectURL(new Blob([\n                                n(4154)\n                            ], {\n                                type: \"text/javascript\"\n                            })) : t === b ? null != y ? y : (null != g ? g : e) + m : e + t\n                    };\n                    if (o) if (\"undefined\" == typeof Blob) i.mainScriptUrlOrBlob = s.join(__dirname, \"ort-wasm-threaded.js\");\n                    else {\n                        const t = `var ortWasmThreaded=(function(){var _scriptDir;return ${r.toString()}})();`;\n                        i.mainScriptUrlOrBlob = new Blob([\n                            t\n                        ], {\n                            type: \"text/javascript\"\n                        });\n                    }\n                    r(i).then((e)=>{\n                        f = !1, p = !0, l = e, t();\n                    }, (t)=>{\n                        f = !1, d = !0, e(t);\n                    });\n                })), await Promise.race(v), _) throw new Error(`WebAssembly backend initializing failed due to timeout: ${e}ms`);\n            }, e.getInstance = ()=>{\n                if (p && l) return l;\n                throw new Error(\"WebAssembly is not initialized yet.\");\n            }, e.dispose = ()=>{\n                var t;\n                !p || f || d || (f = !0, null === (t = l.PThread) || void 0 === t || t.terminateAllThreads(), l = void 0, f = !1, p = !1, d = !0);\n            };\n        },\n        9710: (t, e, n)=>{\n            \"use strict\";\n            n.d(e, {\n                Z: ()=>o\n            });\n            var r = n(477), i = n.n(r);\n            function o() {\n                return i()('/*!\\n* ONNX Runtime Web v1.14.0\\n* Copyright (c) Microsoft Corporation. All rights reserved.\\n* Licensed under the MIT License.\\n*/\\n(()=>{var t={474:(t,e,n)=>{var _scriptDir,r=(_scriptDir=(_scriptDir=\"undefined\"!=typeof document&&document.currentScript?document.currentScript.src:void 0)||__filename,function(t){function e(){return k.buffer!=D&&N(k.buffer),P}function r(){return k.buffer!=D&&N(k.buffer),U}function a(){return k.buffer!=D&&N(k.buffer),F}function i(){return k.buffer!=D&&N(k.buffer),I}function o(){return k.buffer!=D&&N(k.buffer),W}var u,s,c;t=t||{},u||(u=void 0!==t?t:{}),u.ready=new Promise((function(t,e){s=t,c=e}));var l,f,p,h,d,y,b=Object.assign({},u),m=\"./this.program\",g=(t,e)=>{throw e},v=\"object\"==typeof window,_=\"function\"==typeof importScripts,w=\"object\"==typeof process&&\"object\"==typeof process.versions&&\"string\"==typeof process.versions.node,O=u.ENVIRONMENT_IS_PTHREAD||!1,A=\"\";function S(t){return u.locateFile?u.locateFile(t,A):A+t}if(w){let e;A=_?n(17).dirname(A)+\"/\":__dirname+\"/\",y=()=>{d||(h=n(147),d=n(17))},l=function(t,e){return y(),t=d.normalize(t),h.readFileSync(t,e?void 0:\"utf8\")},p=t=>((t=l(t,!0)).buffer||(t=new Uint8Array(t)),t),f=(t,e,n)=>{y(),t=d.normalize(t),h.readFile(t,(function(t,r){t?n(t):e(r.buffer)}))},1<process.argv.length&&(m=process.argv[1].replace(/\\\\\\\\/g,\"/\")),process.argv.slice(2),process.on(\"uncaughtException\",(function(t){if(!(t instanceof st))throw t})),process.on(\"unhandledRejection\",(function(t){throw t})),g=(t,e)=>{if(Q())throw process.exitCode=t,e;e instanceof st||x(\"exiting due to exception: \"+e),process.exit(t)},u.inspect=function(){return\"[Emscripten Module object]\"};try{e=n(267)}catch(t){throw console.error(\\'The \"worker_threads\" module is not supported in this node.js build - perhaps a newer version is needed?\\'),t}global.Worker=e.Worker}else(v||_)&&(_?A=self.location.href:\"undefined\"!=typeof document&&document.currentScript&&(A=document.currentScript.src),_scriptDir&&(A=_scriptDir),A=0!==A.indexOf(\"blob:\")?A.substr(0,A.replace(/[?#].*/,\"\").lastIndexOf(\"/\")+1):\"\",w||(l=t=>{var e=new XMLHttpRequest;return e.open(\"GET\",t,!1),e.send(null),e.responseText},_&&(p=t=>{var e=new XMLHttpRequest;return e.open(\"GET\",t,!1),e.responseType=\"arraybuffer\",e.send(null),new Uint8Array(e.response)}),f=(t,e,n)=>{var r=new XMLHttpRequest;r.open(\"GET\",t,!0),r.responseType=\"arraybuffer\",r.onload=()=>{200==r.status||0==r.status&&r.response?e(r.response):n()},r.onerror=n,r.send(null)}));w&&\"undefined\"==typeof performance&&(global.performance=n(74).performance);var T=console.log.bind(console),E=console.warn.bind(console);w&&(y(),T=t=>h.writeSync(1,t+\"\\\\n\"),E=t=>h.writeSync(2,t+\"\\\\n\"));var M,C=u.print||T,x=u.printErr||E;Object.assign(u,b),b=null,u.thisProgram&&(m=u.thisProgram),u.quit&&(g=u.quit),u.wasmBinary&&(M=u.wasmBinary);var R=u.noExitRuntime||!1;\"object\"!=typeof WebAssembly&&at(\"no native wasm support detected\");var k,j,D,P,U,F,I,W,H=!1,z=\"undefined\"!=typeof TextDecoder?new TextDecoder(\"utf8\"):void 0;function L(t,e,n){var r=(e>>>=0)+n;for(n=e;t[n]&&!(n>=r);)++n;if(16<n-e&&t.buffer&&z)return z.decode(t.buffer instanceof SharedArrayBuffer?t.slice(e,n):t.subarray(e,n));for(r=\"\";e<n;){var a=t[e++];if(128&a){var i=63&t[e++];if(192==(224&a))r+=String.fromCharCode((31&a)<<6|i);else{var o=63&t[e++];65536>(a=224==(240&a)?(15&a)<<12|i<<6|o:(7&a)<<18|i<<12|o<<6|63&t[e++])?r+=String.fromCharCode(a):(a-=65536,r+=String.fromCharCode(55296|a>>10,56320|1023&a))}}else r+=String.fromCharCode(a)}return r}function Y(t,e){return(t>>>=0)?L(r(),t,e):\"\"}function B(t,e,n,r){if(!(0<r))return 0;var a=n>>>=0;r=n+r-1;for(var i=0;i<t.length;++i){var o=t.charCodeAt(i);if(55296<=o&&57343>=o&&(o=65536+((1023&o)<<10)|1023&t.charCodeAt(++i)),127>=o){if(n>=r)break;e[n++>>>0]=o}else{if(2047>=o){if(n+1>=r)break;e[n++>>>0]=192|o>>6}else{if(65535>=o){if(n+2>=r)break;e[n++>>>0]=224|o>>12}else{if(n+3>=r)break;e[n++>>>0]=240|o>>18,e[n++>>>0]=128|o>>12&63}e[n++>>>0]=128|o>>6&63}e[n++>>>0]=128|63&o}}return e[n>>>0]=0,n-a}function G(t){for(var e=0,n=0;n<t.length;++n){var r=t.charCodeAt(n);127>=r?e++:2047>=r?e+=2:55296<=r&&57343>=r?(e+=4,++n):e+=3}return e}function N(t){D=t,u.HEAP8=P=new Int8Array(t),u.HEAP16=new Int16Array(t),u.HEAP32=F=new Int32Array(t),u.HEAPU8=U=new Uint8Array(t),u.HEAPU16=new Uint16Array(t),u.HEAPU32=I=new Uint32Array(t),u.HEAPF32=new Float32Array(t),u.HEAPF64=W=new Float64Array(t)}O&&(D=u.buffer);var V=u.INITIAL_MEMORY||16777216;if(O)k=u.wasmMemory,D=u.buffer;else if(u.wasmMemory)k=u.wasmMemory;else if(!((k=new WebAssembly.Memory({initial:V/65536,maximum:65536,shared:!0})).buffer instanceof SharedArrayBuffer))throw x(\"requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag\"),w&&console.log(\"(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and also use a recent version)\"),Error(\"bad memory\");k&&(D=k.buffer),V=D.byteLength,N(D);var q,$=[],X=[],J=[],Z=[];function Q(){return R||!1}function K(){var t=u.preRun.shift();$.unshift(t)}var tt,et=0,nt=null,rt=null;function at(t){throw O?postMessage({cmd:\"onAbort\",arg:t}):u.onAbort&&u.onAbort(t),x(t=\"Aborted(\"+t+\")\"),H=!0,t=new WebAssembly.RuntimeError(t+\". Build with -sASSERTIONS for more info.\"),c(t),t}function it(){return tt.startsWith(\"data:application/octet-stream;base64,\")}function ot(){var t=tt;try{if(t==tt&&M)return new Uint8Array(M);if(p)return p(t);throw\"both async and sync fetching of the wasm failed\"}catch(t){at(t)}}tt=\"ort-wasm-threaded.wasm\",it()||(tt=S(tt));var ut={};function st(t){this.name=\"ExitStatus\",this.message=\"Program terminated with exit(\"+t+\")\",this.status=t}function ct(t){(t=ht.Vb[t])||at(),ht.mc(t)}function lt(t){var e=ht.Cc();if(!e)return 6;ht.ac.push(e),ht.Vb[t.Ub]=e,e.Ub=t.Ub;var n={cmd:\"run\",start_routine:t.Ic,arg:t.zc,pthread_ptr:t.Ub};return e.$b=()=>{n.time=performance.now(),e.postMessage(n,t.Nc)},e.loaded&&(e.$b(),delete e.$b),0}function ft(t){if(O)return qt(1,1,t);Q()||(ht.oc(),u.onExit&&u.onExit(t),H=!0),g(t,new st(t))}function pt(t,e){if(!e&&O)throw bt(t),\"unwind\";Q()||O||(me(),dt(J),be(0),re[1].length&&ae(1,10),re[2].length&&ae(2,10),ht.oc()),ft(t)}var ht={Yb:[],ac:[],qc:[],Vb:{},fc:function(){O&&ht.Ec()},Pc:function(){},Ec:function(){ht.receiveObjectTransfer=ht.Gc,ht.threadInitTLS=ht.pc,ht.setExitStatus=ht.nc,R=!1},nc:function(){},oc:function(){for(var t of Object.values(ht.Vb))ht.mc(t);for(t of ht.Yb)t.terminate();ht.Yb=[]},mc:function(t){var e=t.Ub;delete ht.Vb[e],ht.Yb.push(t),ht.ac.splice(ht.ac.indexOf(t),1),t.Ub=0,Oe(e)},Gc:function(){},pc:function(){ht.qc.forEach((t=>t()))},Fc:function(t,e){t.onmessage=n=>{var r=(n=n.data).cmd;if(t.Ub&&(ht.Bc=t.Ub),n.targetThread&&n.targetThread!=he()){var a=ht.Vb[n.Qc];a?a.postMessage(n,n.transferList):x(\\'Internal error! Worker sent a message \"\\'+r+\\'\" to target pthread \\'+n.targetThread+\", but that thread no longer exists!\")}else\"processProxyingQueue\"===r?Lt(n.queue):\"spawnThread\"===r?lt(n):\"cleanupThread\"===r?ct(n.thread):\"killThread\"===r?(n=n.thread,r=ht.Vb[n],delete ht.Vb[n],r.terminate(),Oe(n),ht.ac.splice(ht.ac.indexOf(r),1),r.Ub=0):\"cancelThread\"===r?ht.Vb[n.thread].postMessage({cmd:\"cancel\"}):\"loaded\"===r?(t.loaded=!0,e&&e(t),t.$b&&(t.$b(),delete t.$b)):\"print\"===r?C(\"Thread \"+n.threadId+\": \"+n.text):\"printErr\"===r?x(\"Thread \"+n.threadId+\": \"+n.text):\"alert\"===r?alert(\"Thread \"+n.threadId+\": \"+n.text):\"setimmediate\"===n.target?t.postMessage(n):\"onAbort\"===r?u.onAbort&&u.onAbort(n.arg):r&&x(\"worker sent an unknown command \"+r);ht.Bc=void 0},t.onerror=t=>{throw x(\"worker sent an error! \"+t.filename+\":\"+t.lineno+\": \"+t.message),t},w&&(t.on(\"message\",(function(e){t.onmessage({data:e})})),t.on(\"error\",(function(e){t.onerror(e)})),t.on(\"detachedExit\",(function(){}))),t.postMessage({cmd:\"load\",urlOrBlob:u.mainScriptUrlOrBlob||_scriptDir,wasmMemory:k,wasmModule:j})},yc:function(){var t=S(\"ort-wasm-threaded.worker.js\");ht.Yb.push(new Worker(t))},Cc:function(){return 0==ht.Yb.length&&(ht.yc(),ht.Fc(ht.Yb[0])),ht.Yb.pop()}};function dt(t){for(;0<t.length;)t.shift()(u)}function yt(t){var e=Ee();return t=t(),Me(e),t}function bt(t){if(O)return qt(2,0,t);try{pt(t)}catch(t){t instanceof st||\"unwind\"==t||g(1,t)}}u.PThread=ht,u.establishStackSpace=function(){var t=he(),e=a()[t+44>>2>>>0];t=a()[t+48>>2>>>0],Te(e,e-t),Me(e)};var mt=[];function gt(t){var e=mt[t];return e||(t>=mt.length&&(mt.length=t+1),mt[t]=e=q.get(t)),e}u.invokeEntryPoint=function(t,e){t=gt(t)(e),Q()?ht.nc(t):Ae(t)};var vt,_t,wt=[],Ot=0,At=0;function St(t){this.Zb=t,this.Sb=t-24,this.xc=function(t){i()[this.Sb+4>>2>>>0]=t},this.bc=function(){return i()[this.Sb+4>>2>>>0]},this.wc=function(t){i()[this.Sb+8>>2>>>0]=t},this.Dc=function(){return i()[this.Sb+8>>2>>>0]},this.rc=function(){a()[this.Sb>>2>>>0]=0},this.hc=function(t){t=t?1:0,e()[this.Sb+12>>0>>>0]=t},this.uc=function(){return 0!=e()[this.Sb+12>>0>>>0]},this.ic=function(t){t=t?1:0,e()[this.Sb+13>>0>>>0]=t},this.kc=function(){return 0!=e()[this.Sb+13>>0>>>0]},this.fc=function(t,e){this.cc(0),this.xc(t),this.wc(e),this.rc(),this.hc(!1),this.ic(!1)},this.sc=function(){Atomics.add(a(),this.Sb>>2,1)},this.Hc=function(){return 1===Atomics.sub(a(),this.Sb>>2,1)},this.cc=function(t){i()[this.Sb+16>>2>>>0]=t},this.tc=function(){return i()[this.Sb+16>>2>>>0]},this.vc=function(){if(Re(this.bc()))return i()[this.Zb>>2>>>0];var t=this.tc();return 0!==t?t:this.Zb}}function Tt(t){return ye(new St(t).Sb)}function Et(t,e,n,r){return O?qt(3,1,t,e,n,r):Mt(t,e,n,r)}function Mt(t,e,n,r){if(\"undefined\"==typeof SharedArrayBuffer)return x(\"Current environment does not support SharedArrayBuffer, pthreads are not available!\"),6;var a=[];return O&&0===a.length?Et(t,e,n,r):(t={Ic:n,Ub:t,zc:r,Nc:a},O?(t.Oc=\"spawnThread\",postMessage(t,a),0):lt(t))}function Ct(t,e,n){return O?qt(4,1,t,e,n):0}function xt(t,e){if(O)return qt(5,1,t,e)}function Rt(t,e){if(O)return qt(6,1,t,e)}function kt(t,e,n){if(O)return qt(7,1,t,e,n)}function jt(t,e,n){return O?qt(8,1,t,e,n):0}function Dt(t,e){if(O)return qt(9,1,t,e)}function Pt(t,e,n){if(O)return qt(10,1,t,e,n)}function Ut(t,e,n,r){if(O)return qt(11,1,t,e,n,r)}function Ft(t,e,n,r){if(O)return qt(12,1,t,e,n,r)}function It(t,e,n,r){if(O)return qt(13,1,t,e,n,r)}function Wt(t){if(O)return qt(14,1,t)}function Ht(t,e){if(O)return qt(15,1,t,e)}function zt(t,e,n){if(O)return qt(16,1,t,e,n)}function Lt(t){Atomics.store(a(),t>>2,1),he()&&we(t),Atomics.compareExchange(a(),t>>2,1,0)}function Yt(t){return i()[t>>>2]+4294967296*a()[t+4>>>2]}function Bt(t,e,n,r,a,i){return O?qt(17,1,t,e,n,r,a,i):-52}function Gt(t,e,n,r,a,i){if(O)return qt(18,1,t,e,n,r,a,i)}function Nt(t){var n=G(t)+1,r=de(n);return r&&B(t,e(),r,n),r}function Vt(t,e,n){function r(t){return(t=t.toTimeString().match(/\\\\(([A-Za-z ]+)\\\\)$/))?t[1]:\"GMT\"}if(O)return qt(19,1,t,e,n);var o=(new Date).getFullYear(),u=new Date(o,0,1),s=new Date(o,6,1);o=u.getTimezoneOffset();var c=s.getTimezoneOffset(),l=Math.max(o,c);a()[t>>2>>>0]=60*l,a()[e>>2>>>0]=Number(o!=c),t=r(u),e=r(s),t=Nt(t),e=Nt(e),c<o?(i()[n>>2>>>0]=t,i()[n+4>>2>>>0]=e):(i()[n>>2>>>0]=e,i()[n+4>>2>>>0]=t)}function qt(t,e){var n=arguments.length-2,r=arguments;return yt((()=>{for(var a=Ce(8*n),i=a>>3,u=0;u<n;u++){var s=r[2+u];o()[i+u>>>0]=s}return _e(t,n,a,e)}))}u.executeNotifiedProxyingQueue=Lt,_t=w?()=>{var t=process.hrtime();return 1e3*t[0]+t[1]/1e6}:O?()=>performance.now()-u.__performance_now_clock_drift:()=>performance.now();var $t,Xt=[],Jt={};function Zt(){if(!$t){var t,e={USER:\"web_user\",LOGNAME:\"web_user\",PATH:\"/\",PWD:\"/\",HOME:\"/home/web_user\",LANG:(\"object\"==typeof navigator&&navigator.languages&&navigator.languages[0]||\"C\").replace(\"-\",\"_\")+\".UTF-8\",_:m||\"./this.program\"};for(t in Jt)void 0===Jt[t]?delete e[t]:e[t]=Jt[t];var n=[];for(t in e)n.push(t+\"=\"+e[t]);$t=n}return $t}function Qt(t,n){if(O)return qt(20,1,t,n);var r=0;return Zt().forEach((function(a,o){var u=n+r;for(o=i()[t+4*o>>2>>>0]=u,u=0;u<a.length;++u)e()[o++>>0>>>0]=a.charCodeAt(u);e()[o>>0>>>0]=0,r+=a.length+1})),0}function Kt(t,e){if(O)return qt(21,1,t,e);var n=Zt();i()[t>>2>>>0]=n.length;var r=0;return n.forEach((function(t){r+=t.length+1})),i()[e>>2>>>0]=r,0}function te(t){return O?qt(22,1,t):52}function ee(t,e,n,r){return O?qt(23,1,t,e,n,r):52}function ne(t,e,n,r,a){return O?qt(24,1,t,e,n,r,a):70}var re=[null,[],[]];function ae(t,e){var n=re[t];0===e||10===e?((1===t?C:x)(L(n,0)),n.length=0):n.push(e)}function ie(t,e,n,a){if(O)return qt(25,1,t,e,n,a);for(var o=0,u=0;u<n;u++){var s=i()[e>>2>>>0],c=i()[e+4>>2>>>0];e+=8;for(var l=0;l<c;l++)ae(t,r()[s+l>>>0]);o+=c}return i()[a>>2>>>0]=o,0}var oe=0;function ue(t){return 0==t%4&&(0!=t%100||0==t%400)}var se=[31,29,31,30,31,30,31,31,30,31,30,31],ce=[31,28,31,30,31,30,31,31,30,31,30,31];function le(t,n,r,i){function o(t,e,n){for(t=\"number\"==typeof t?t.toString():t||\"\";t.length<e;)t=n[0]+t;return t}function u(t,e){return o(t,e,\"0\")}function s(t,e){function n(t){return 0>t?-1:0<t?1:0}var r;return 0===(r=n(t.getFullYear()-e.getFullYear()))&&0===(r=n(t.getMonth()-e.getMonth()))&&(r=n(t.getDate()-e.getDate())),r}function c(t){switch(t.getDay()){case 0:return new Date(t.getFullYear()-1,11,29);case 1:return t;case 2:return new Date(t.getFullYear(),0,3);case 3:return new Date(t.getFullYear(),0,2);case 4:return new Date(t.getFullYear(),0,1);case 5:return new Date(t.getFullYear()-1,11,31);case 6:return new Date(t.getFullYear()-1,11,30)}}function l(t){var e=t.Wb;for(t=new Date(new Date(t.Xb+1900,0,1).getTime());0<e;){var n=t.getMonth(),r=(ue(t.getFullYear())?se:ce)[n];if(!(e>r-t.getDate())){t.setDate(t.getDate()+e);break}e-=r-t.getDate()+1,t.setDate(1),11>n?t.setMonth(n+1):(t.setMonth(0),t.setFullYear(t.getFullYear()+1))}return n=new Date(t.getFullYear()+1,0,4),e=c(new Date(t.getFullYear(),0,4)),n=c(n),0>=s(e,t)?0>=s(n,t)?t.getFullYear()+1:t.getFullYear():t.getFullYear()-1}var f=a()[i+40>>2>>>0];for(var p in i={Lc:a()[i>>2>>>0],Kc:a()[i+4>>2>>>0],dc:a()[i+8>>2>>>0],jc:a()[i+12>>2>>>0],ec:a()[i+16>>2>>>0],Xb:a()[i+20>>2>>>0],Tb:a()[i+24>>2>>>0],Wb:a()[i+28>>2>>>0],Rc:a()[i+32>>2>>>0],Jc:a()[i+36>>2>>>0],Mc:f?Y(f):\"\"},r=Y(r),f={\"%c\":\"%a %b %d %H:%M:%S %Y\",\"%D\":\"%m/%d/%y\",\"%F\":\"%Y-%m-%d\",\"%h\":\"%b\",\"%r\":\"%I:%M:%S %p\",\"%R\":\"%H:%M\",\"%T\":\"%H:%M:%S\",\"%x\":\"%m/%d/%y\",\"%X\":\"%H:%M:%S\",\"%Ec\":\"%c\",\"%EC\":\"%C\",\"%Ex\":\"%m/%d/%y\",\"%EX\":\"%H:%M:%S\",\"%Ey\":\"%y\",\"%EY\":\"%Y\",\"%Od\":\"%d\",\"%Oe\":\"%e\",\"%OH\":\"%H\",\"%OI\":\"%I\",\"%Om\":\"%m\",\"%OM\":\"%M\",\"%OS\":\"%S\",\"%Ou\":\"%u\",\"%OU\":\"%U\",\"%OV\":\"%V\",\"%Ow\":\"%w\",\"%OW\":\"%W\",\"%Oy\":\"%y\"})r=r.replace(new RegExp(p,\"g\"),f[p]);var h=\"Sunday Monday Tuesday Wednesday Thursday Friday Saturday\".split(\" \"),d=\"January February March April May June July August September October November December\".split(\" \");for(p in f={\"%a\":function(t){return h[t.Tb].substring(0,3)},\"%A\":function(t){return h[t.Tb]},\"%b\":function(t){return d[t.ec].substring(0,3)},\"%B\":function(t){return d[t.ec]},\"%C\":function(t){return u((t.Xb+1900)/100|0,2)},\"%d\":function(t){return u(t.jc,2)},\"%e\":function(t){return o(t.jc,2,\" \")},\"%g\":function(t){return l(t).toString().substring(2)},\"%G\":function(t){return l(t)},\"%H\":function(t){return u(t.dc,2)},\"%I\":function(t){return 0==(t=t.dc)?t=12:12<t&&(t-=12),u(t,2)},\"%j\":function(t){for(var e=0,n=0;n<=t.ec-1;e+=(ue(t.Xb+1900)?se:ce)[n++]);return u(t.jc+e,3)},\"%m\":function(t){return u(t.ec+1,2)},\"%M\":function(t){return u(t.Kc,2)},\"%n\":function(){return\"\\\\n\"},\"%p\":function(t){return 0<=t.dc&&12>t.dc?\"AM\":\"PM\"},\"%S\":function(t){return u(t.Lc,2)},\"%t\":function(){return\"\\\\t\"},\"%u\":function(t){return t.Tb||7},\"%U\":function(t){return u(Math.floor((t.Wb+7-t.Tb)/7),2)},\"%V\":function(t){var e=Math.floor((t.Wb+7-(t.Tb+6)%7)/7);if(2>=(t.Tb+371-t.Wb-2)%7&&e++,e)53==e&&(4==(n=(t.Tb+371-t.Wb)%7)||3==n&&ue(t.Xb)||(e=1));else{e=52;var n=(t.Tb+7-t.Wb-1)%7;(4==n||5==n&&ue(t.Xb%400-1))&&e++}return u(e,2)},\"%w\":function(t){return t.Tb},\"%W\":function(t){return u(Math.floor((t.Wb+7-(t.Tb+6)%7)/7),2)},\"%y\":function(t){return(t.Xb+1900).toString().substring(2)},\"%Y\":function(t){return t.Xb+1900},\"%z\":function(t){var e=0<=(t=t.Jc);return t=Math.abs(t)/60,(e?\"+\":\"-\")+String(\"0000\"+(t/60*100+t%60)).slice(-4)},\"%Z\":function(t){return t.Mc},\"%%\":function(){return\"%\"}},r=r.replace(/%%/g,\"\\\\0\\\\0\"),f)r.includes(p)&&(r=r.replace(new RegExp(p,\"g\"),f[p](i)));return p=function(t){var e=Array(G(t)+1);return B(t,e,0,e.length),e}(r=r.replace(/\\\\0\\\\0/g,\"%\")),p.length>n?0:(function(t,n){e().set(t,n>>>0)}(p,t),p.length-1)}ht.fc();var fe=[null,ft,bt,Et,Ct,xt,Rt,kt,jt,Dt,Pt,Ut,Ft,It,Wt,Ht,zt,Bt,Gt,Vt,Qt,Kt,te,ee,ne,ie],pe={b:function(t){return de(t+24)+24},n:function(t){return(t=new St(t)).uc()||(t.hc(!0),Ot--),t.ic(!1),wt.push(t),t.sc(),t.vc()},ma:function(t){throw x(\"Unexpected exception thrown, this is not properly supported - aborting\"),H=!0,t},x:function(){Se(0);var t=wt.pop();if(t.Hc()&&!t.kc()){var e=t.Dc();e&&gt(e)(t.Zb),Tt(t.Zb)}At=0},e:function(){var t=At;if(!t)return oe=0;var e=new St(t);e.cc(t);var n=e.bc();if(!n)return oe=0,t;for(var r=Array.prototype.slice.call(arguments),a=0;a<r.length;a++){var i=r[a];if(0===i||i===n)break;if(xe(i,n,e.Sb+16))return oe=i,t}return oe=n,t},l:function(){var t=At;if(!t)return oe=0;var e=new St(t);e.cc(t);var n=e.bc();if(!n)return oe=0,t;for(var r=Array.prototype.slice.call(arguments),a=0;a<r.length;a++){var i=r[a];if(0===i||i===n)break;if(xe(i,n,e.Sb+16))return oe=i,t}return oe=n,t},h:function(){var t=At;if(!t)return oe=0;var e=new St(t);e.cc(t);var n=e.bc();if(!n)return oe=0,t;for(var r=Array.prototype.slice.call(arguments),a=0;a<r.length;a++){var i=r[a];if(0===i||i===n)break;if(xe(i,n,e.Sb+16))return oe=i,t}return oe=n,t},t:Tt,M:function(){var t=wt.pop();t||at(\"no exception to throw\");var e=t.Zb;throw t.kc()||(wt.push(t),t.ic(!0),t.hc(!1),Ot++),At=e,e},c:function(t,e,n){throw new St(t).fc(e,n),At=t,Ot++,t},pa:function(){return Ot},Fa:function(t){ge(t,!_,1,!v),ht.pc()},T:function(t){O?postMessage({cmd:\"cleanupThread\",thread:t}):ct(t)},xa:Mt,j:function(t){throw At||(At=t),t},H:Ct,Ma:xt,ua:Rt,wa:kt,oa:jt,Ka:Dt,Ca:Pt,Ja:Ut,V:Ft,va:It,sa:Wt,La:Ht,ta:zt,Ta:function(){},X:function(){at(\"To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking\")},Ua:function(){at(\"To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking\")},W:function(){return Date.now()},ya:function(){return 2097152},Oa:function(){return!0},za:function(t,e,n,r){if(t==e)setTimeout((()=>Lt(r)));else if(O)postMessage({targetThread:t,cmd:\"processProxyingQueue\",queue:r});else{if(!(t=ht.Vb[t]))return;t.postMessage({cmd:\"processProxyingQueue\",queue:r})}return 1},Ea:function(){return-1},Pa:function(t,e){t=new Date(1e3*Yt(t)),a()[e>>2>>>0]=t.getUTCSeconds(),a()[e+4>>2>>>0]=t.getUTCMinutes(),a()[e+8>>2>>>0]=t.getUTCHours(),a()[e+12>>2>>>0]=t.getUTCDate(),a()[e+16>>2>>>0]=t.getUTCMonth(),a()[e+20>>2>>>0]=t.getUTCFullYear()-1900,a()[e+24>>2>>>0]=t.getUTCDay(),t=(t.getTime()-Date.UTC(t.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,a()[e+28>>2>>>0]=t},Qa:function(t,e){t=new Date(1e3*Yt(t)),a()[e>>2>>>0]=t.getSeconds(),a()[e+4>>2>>>0]=t.getMinutes(),a()[e+8>>2>>>0]=t.getHours(),a()[e+12>>2>>>0]=t.getDate(),a()[e+16>>2>>>0]=t.getMonth(),a()[e+20>>2>>>0]=t.getFullYear()-1900,a()[e+24>>2>>>0]=t.getDay();var n=new Date(t.getFullYear(),0,1),r=(t.getTime()-n.getTime())/864e5|0;a()[e+28>>2>>>0]=r,a()[e+36>>2>>>0]=-60*t.getTimezoneOffset(),r=new Date(t.getFullYear(),6,1).getTimezoneOffset(),t=0|(r!=(n=n.getTimezoneOffset())&&t.getTimezoneOffset()==Math.min(n,r)),a()[e+32>>2>>>0]=t},Ra:function(t){var e=new Date(a()[t+20>>2>>>0]+1900,a()[t+16>>2>>>0],a()[t+12>>2>>>0],a()[t+8>>2>>>0],a()[t+4>>2>>>0],a()[t>>2>>>0],0),n=a()[t+32>>2>>>0],r=e.getTimezoneOffset(),i=new Date(e.getFullYear(),0,1),o=new Date(e.getFullYear(),6,1).getTimezoneOffset(),u=i.getTimezoneOffset(),s=Math.min(u,o);return 0>n?a()[t+32>>2>>>0]=Number(o!=u&&s==r):0<n!=(s==r)&&(o=Math.max(u,o),e.setTime(e.getTime()+6e4*((0<n?s:o)-r))),a()[t+24>>2>>>0]=e.getDay(),n=(e.getTime()-i.getTime())/864e5|0,a()[t+28>>2>>>0]=n,a()[t>>2>>>0]=e.getSeconds(),a()[t+4>>2>>>0]=e.getMinutes(),a()[t+8>>2>>>0]=e.getHours(),a()[t+12>>2>>>0]=e.getDate(),a()[t+16>>2>>>0]=e.getMonth(),e.getTime()/1e3|0},Aa:Bt,Ba:Gt,Sa:function t(e,n,r){t.Ac||(t.Ac=!0,Vt(e,n,r))},y:function(){at(\"\")},U:function(){if(!w&&!_){var t=\"Blocking on the main thread is very dangerous, see https://emscripten.org/docs/porting/pthreads.html#blocking-on-the-main-browser-thread\";vt||(vt={}),vt[t]||(vt[t]=1,w&&(t=\"warning: \"+t),x(t))}},ra:function(){return 4294901760},B:_t,Ia:function(t,e,n){r().copyWithin(t>>>0,e>>>0,e+n>>>0)},F:function(){return w?n(37).cpus().length:navigator.hardwareConcurrency},Da:function(t,e,n){Xt.length=e,n>>=3;for(var r=0;r<e;r++)Xt[r]=o()[n+r>>>0];return(0>t?ut[-t-1]:fe[t]).apply(null,Xt)},qa:function(t){var e=r().length;if((t>>>=0)<=e||4294901760<t)return!1;for(var n=1;4>=n;n*=2){var a=e*(1+.2/n);a=Math.min(a,t+100663296);var i=Math;a=Math.max(t,a),i=i.min.call(i,4294901760,a+(65536-a%65536)%65536);t:{try{k.grow(i-D.byteLength+65535>>>16),N(k.buffer);var o=1;break t}catch(t){}o=void 0}if(o)return!0}return!1},Na:function(){throw\"unwind\"},Ga:Qt,Ha:Kt,J:pt,I:te,S:ee,ga:ne,R:ie,d:function(){return oe},na:function t(r,a){t.lc||(t.lc=function(){if(\"object\"==typeof crypto&&\"function\"==typeof crypto.getRandomValues){var t=new Uint8Array(1);return()=>(crypto.getRandomValues(t),t[0])}if(w)try{var e=n(113);return()=>e.randomBytes(1)[0]}catch(t){}return()=>at(\"randomDevice\")}());for(var i=0;i<a;i++)e()[r+i>>0>>>0]=t.lc();return 0},ia:function(t,e,n){var r=Ee();try{return gt(t)(e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},ja:function(t,e,n){var r=Ee();try{return gt(t)(e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},K:function(t){var e=Ee();try{return gt(t)()}catch(t){if(Me(e),t!==t+0)throw t;Se(1,0)}},f:function(t,e){var n=Ee();try{return gt(t)(e)}catch(t){if(Me(n),t!==t+0)throw t;Se(1,0)}},P:function(t,e,n){var r=Ee();try{return gt(t)(e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},Q:function(t,e,n){var r=Ee();try{return gt(t)(e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},k:function(t,e,n){var r=Ee();try{return gt(t)(e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},p:function(t,e,n,r){var a=Ee();try{return gt(t)(e,n,r)}catch(t){if(Me(a),t!==t+0)throw t;Se(1,0)}},q:function(t,e,n,r,a){var i=Ee();try{return gt(t)(e,n,r,a)}catch(t){if(Me(i),t!==t+0)throw t;Se(1,0)}},N:function(t,e,n,r,a,i){var o=Ee();try{return gt(t)(e,n,r,a,i)}catch(t){if(Me(o),t!==t+0)throw t;Se(1,0)}},s:function(t,e,n,r,a,i){var o=Ee();try{return gt(t)(e,n,r,a,i)}catch(t){if(Me(o),t!==t+0)throw t;Se(1,0)}},w:function(t,e,n,r,a,i,o){var u=Ee();try{return gt(t)(e,n,r,a,i,o)}catch(t){if(Me(u),t!==t+0)throw t;Se(1,0)}},L:function(t,e,n,r,a,i,o,u){var s=Ee();try{return gt(t)(e,n,r,a,i,o,u)}catch(t){if(Me(s),t!==t+0)throw t;Se(1,0)}},E:function(t,e,n,r,a,i,o,u,s,c,l,f){var p=Ee();try{return gt(t)(e,n,r,a,i,o,u,s,c,l,f)}catch(t){if(Me(p),t!==t+0)throw t;Se(1,0)}},aa:function(t,e,n,r,a,i,o,u){var s=Ee();try{return He(t,e,n,r,a,i,o,u)}catch(t){if(Me(s),t!==t+0)throw t;Se(1,0)}},_:function(t,e,n,r,a,i,o){var u=Ee();try{return je(t,e,n,r,a,i,o)}catch(t){if(Me(u),t!==t+0)throw t;Se(1,0)}},Z:function(t,e,n,r,a){var i=Ee();try{return ze(t,e,n,r,a)}catch(t){if(Me(i),t!==t+0)throw t;Se(1,0)}},ca:function(t,e,n,r){var a=Ee();try{return Ie(t,e,n,r)}catch(t){if(Me(a),t!==t+0)throw t;Se(1,0)}},$:function(t){var e=Ee();try{return ke(t)}catch(t){if(Me(e),t!==t+0)throw t;Se(1,0)}},ba:function(t,e){var n=Ee();try{return We(t,e)}catch(t){if(Me(n),t!==t+0)throw t;Se(1,0)}},Y:function(t,e,n){var r=Ee();try{return De(t,e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},g:function(t){var e=Ee();try{gt(t)()}catch(t){if(Me(e),t!==t+0)throw t;Se(1,0)}},r:function(t,e){var n=Ee();try{gt(t)(e)}catch(t){if(Me(n),t!==t+0)throw t;Se(1,0)}},i:function(t,e,n){var r=Ee();try{gt(t)(e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},ha:function(t,e,n,r){var a=Ee();try{gt(t)(e,n,r)}catch(t){if(Me(a),t!==t+0)throw t;Se(1,0)}},m:function(t,e,n,r){var a=Ee();try{gt(t)(e,n,r)}catch(t){if(Me(a),t!==t+0)throw t;Se(1,0)}},v:function(t,e,n,r,a){var i=Ee();try{gt(t)(e,n,r,a)}catch(t){if(Me(i),t!==t+0)throw t;Se(1,0)}},u:function(t,e,n,r,a,i){var o=Ee();try{gt(t)(e,n,r,a,i)}catch(t){if(Me(o),t!==t+0)throw t;Se(1,0)}},O:function(t,e,n,r,a,i,o){var u=Ee();try{gt(t)(e,n,r,a,i,o)}catch(t){if(Me(u),t!==t+0)throw t;Se(1,0)}},A:function(t,e,n,r,a,i,o,u){var s=Ee();try{gt(t)(e,n,r,a,i,o,u)}catch(t){if(Me(s),t!==t+0)throw t;Se(1,0)}},ka:function(t,e,n,r,a,i,o,u,s){var c=Ee();try{gt(t)(e,n,r,a,i,o,u,s)}catch(t){if(Me(c),t!==t+0)throw t;Se(1,0)}},C:function(t,e,n,r,a,i,o,u,s,c,l){var f=Ee();try{gt(t)(e,n,r,a,i,o,u,s,c,l)}catch(t){if(Me(f),t!==t+0)throw t;Se(1,0)}},D:function(t,e,n,r,a,i,o,u,s,c,l,f,p,h,d,y){var b=Ee();try{gt(t)(e,n,r,a,i,o,u,s,c,l,f,p,h,d,y)}catch(t){if(Me(b),t!==t+0)throw t;Se(1,0)}},fa:function(t,e,n,r,a,i,o,u){var s=Ee();try{Pe(t,e,n,r,a,i,o,u)}catch(t){if(Me(s),t!==t+0)throw t;Se(1,0)}},da:function(t,e,n,r,a,i,o,u,s,c,l,f){var p=Ee();try{Fe(t,e,n,r,a,i,o,u,s,c,l,f)}catch(t){if(Me(p),t!==t+0)throw t;Se(1,0)}},ea:function(t,e,n,r,a,i){var o=Ee();try{Ue(t,e,n,r,a,i)}catch(t){if(Me(o),t!==t+0)throw t;Se(1,0)}},o:function(t){return t},a:k||u.wasmMemory,G:function(t){oe=t},la:le,z:function(t,e,n,r){return le(t,e,n,r)}};!function(){function t(t,e){u.asm=t.exports,ht.qc.push(u.asm.sb),q=u.asm.ub,X.unshift(u.asm.Va),j=e,O||(et--,u.monitorRunDependencies&&u.monitorRunDependencies(et),0==et&&(null!==nt&&(clearInterval(nt),nt=null),rt&&(t=rt,rt=null,t())))}function e(e){t(e.instance,e.module)}function n(t){return function(){if(!M&&(v||_)){if(\"function\"==typeof fetch&&!tt.startsWith(\"file://\"))return fetch(tt,{credentials:\"same-origin\"}).then((function(t){if(!t.ok)throw\"failed to load wasm binary file at \\'\"+tt+\"\\'\";return t.arrayBuffer()})).catch((function(){return ot()}));if(f)return new Promise((function(t,e){f(tt,(function(e){t(new Uint8Array(e))}),e)}))}return Promise.resolve().then((function(){return ot()}))}().then((function(t){return WebAssembly.instantiate(t,r)})).then((function(t){return t})).then(t,(function(t){x(\"failed to asynchronously prepare wasm: \"+t),at(t)}))}var r={a:pe};if(O||(et++,u.monitorRunDependencies&&u.monitorRunDependencies(et)),u.instantiateWasm)try{return u.instantiateWasm(r,t)}catch(t){return x(\"Module.instantiateWasm callback failed with error: \"+t),!1}(M||\"function\"!=typeof WebAssembly.instantiateStreaming||it()||tt.startsWith(\"file://\")||w||\"function\"!=typeof fetch?n(e):fetch(tt,{credentials:\"same-origin\"}).then((function(t){return WebAssembly.instantiateStreaming(t,r).then(e,(function(t){return x(\"wasm streaming compile failed: \"+t),x(\"falling back to ArrayBuffer instantiation\"),n(e)}))}))).catch(c)}(),u.___wasm_call_ctors=function(){return(u.___wasm_call_ctors=u.asm.Va).apply(null,arguments)},u._OrtInit=function(){return(u._OrtInit=u.asm.Wa).apply(null,arguments)},u._OrtCreateSessionOptions=function(){return(u._OrtCreateSessionOptions=u.asm.Xa).apply(null,arguments)},u._OrtAppendExecutionProvider=function(){return(u._OrtAppendExecutionProvider=u.asm.Ya).apply(null,arguments)},u._OrtAddSessionConfigEntry=function(){return(u._OrtAddSessionConfigEntry=u.asm.Za).apply(null,arguments)},u._OrtReleaseSessionOptions=function(){return(u._OrtReleaseSessionOptions=u.asm._a).apply(null,arguments)},u._OrtCreateSession=function(){return(u._OrtCreateSession=u.asm.$a).apply(null,arguments)},u._OrtReleaseSession=function(){return(u._OrtReleaseSession=u.asm.ab).apply(null,arguments)},u._OrtGetInputCount=function(){return(u._OrtGetInputCount=u.asm.bb).apply(null,arguments)},u._OrtGetOutputCount=function(){return(u._OrtGetOutputCount=u.asm.cb).apply(null,arguments)},u._OrtGetInputName=function(){return(u._OrtGetInputName=u.asm.db).apply(null,arguments)},u._OrtGetOutputName=function(){return(u._OrtGetOutputName=u.asm.eb).apply(null,arguments)},u._OrtFree=function(){return(u._OrtFree=u.asm.fb).apply(null,arguments)},u._OrtCreateTensor=function(){return(u._OrtCreateTensor=u.asm.gb).apply(null,arguments)},u._OrtGetTensorData=function(){return(u._OrtGetTensorData=u.asm.hb).apply(null,arguments)},u._OrtReleaseTensor=function(){return(u._OrtReleaseTensor=u.asm.ib).apply(null,arguments)},u._OrtCreateRunOptions=function(){return(u._OrtCreateRunOptions=u.asm.jb).apply(null,arguments)},u._OrtAddRunConfigEntry=function(){return(u._OrtAddRunConfigEntry=u.asm.kb).apply(null,arguments)},u._OrtReleaseRunOptions=function(){return(u._OrtReleaseRunOptions=u.asm.lb).apply(null,arguments)},u._OrtRun=function(){return(u._OrtRun=u.asm.mb).apply(null,arguments)},u._OrtEndProfiling=function(){return(u._OrtEndProfiling=u.asm.nb).apply(null,arguments)};var he=u._pthread_self=function(){return(he=u._pthread_self=u.asm.ob).apply(null,arguments)},de=u._malloc=function(){return(de=u._malloc=u.asm.pb).apply(null,arguments)},ye=u._free=function(){return(ye=u._free=u.asm.qb).apply(null,arguments)},be=u._fflush=function(){return(be=u._fflush=u.asm.rb).apply(null,arguments)};u.__emscripten_tls_init=function(){return(u.__emscripten_tls_init=u.asm.sb).apply(null,arguments)};var me=u.___funcs_on_exit=function(){return(me=u.___funcs_on_exit=u.asm.tb).apply(null,arguments)},ge=u.__emscripten_thread_init=function(){return(ge=u.__emscripten_thread_init=u.asm.vb).apply(null,arguments)};u.__emscripten_thread_crashed=function(){return(u.__emscripten_thread_crashed=u.asm.wb).apply(null,arguments)};var ve,_e=u._emscripten_run_in_main_runtime_thread_js=function(){return(_e=u._emscripten_run_in_main_runtime_thread_js=u.asm.xb).apply(null,arguments)},we=u.__emscripten_proxy_execute_task_queue=function(){return(we=u.__emscripten_proxy_execute_task_queue=u.asm.yb).apply(null,arguments)},Oe=u.__emscripten_thread_free_data=function(){return(Oe=u.__emscripten_thread_free_data=u.asm.zb).apply(null,arguments)},Ae=u.__emscripten_thread_exit=function(){return(Ae=u.__emscripten_thread_exit=u.asm.Ab).apply(null,arguments)},Se=u._setThrew=function(){return(Se=u._setThrew=u.asm.Bb).apply(null,arguments)},Te=u._emscripten_stack_set_limits=function(){return(Te=u._emscripten_stack_set_limits=u.asm.Cb).apply(null,arguments)},Ee=u.stackSave=function(){return(Ee=u.stackSave=u.asm.Db).apply(null,arguments)},Me=u.stackRestore=function(){return(Me=u.stackRestore=u.asm.Eb).apply(null,arguments)},Ce=u.stackAlloc=function(){return(Ce=u.stackAlloc=u.asm.Fb).apply(null,arguments)},xe=u.___cxa_can_catch=function(){return(xe=u.___cxa_can_catch=u.asm.Gb).apply(null,arguments)},Re=u.___cxa_is_pointer_type=function(){return(Re=u.___cxa_is_pointer_type=u.asm.Hb).apply(null,arguments)},ke=u.dynCall_j=function(){return(ke=u.dynCall_j=u.asm.Ib).apply(null,arguments)},je=u.dynCall_iiiiij=function(){return(je=u.dynCall_iiiiij=u.asm.Jb).apply(null,arguments)},De=u.dynCall_jii=function(){return(De=u.dynCall_jii=u.asm.Kb).apply(null,arguments)},Pe=u.dynCall_viiiiij=function(){return(Pe=u.dynCall_viiiiij=u.asm.Lb).apply(null,arguments)},Ue=u.dynCall_vjji=function(){return(Ue=u.dynCall_vjji=u.asm.Mb).apply(null,arguments)},Fe=u.dynCall_viiijjjii=function(){return(Fe=u.dynCall_viiijjjii=u.asm.Nb).apply(null,arguments)},Ie=u.dynCall_iij=function(){return(Ie=u.dynCall_iij=u.asm.Ob).apply(null,arguments)},We=u.dynCall_ji=function(){return(We=u.dynCall_ji=u.asm.Pb).apply(null,arguments)},He=u.dynCall_iiiiiij=function(){return(He=u.dynCall_iiiiiij=u.asm.Qb).apply(null,arguments)},ze=u.dynCall_iiij=function(){return(ze=u.dynCall_iiij=u.asm.Rb).apply(null,arguments)};function Le(){function t(){if(!ve&&(ve=!0,u.calledRun=!0,!H)&&(O||dt(X),s(u),u.onRuntimeInitialized&&u.onRuntimeInitialized(),!O)){if(u.postRun)for(\"function\"==typeof u.postRun&&(u.postRun=[u.postRun]);u.postRun.length;){var t=u.postRun.shift();Z.unshift(t)}dt(Z)}}if(!(0<et))if(O)s(u),O||dt(X),postMessage({cmd:\"loaded\"});else{if(u.preRun)for(\"function\"==typeof u.preRun&&(u.preRun=[u.preRun]);u.preRun.length;)K();dt($),0<et||(u.setStatus?(u.setStatus(\"Running...\"),setTimeout((function(){setTimeout((function(){u.setStatus(\"\")}),1),t()}),1)):t())}}if(u.UTF8ToString=Y,u.stringToUTF8=function(t,e,n){return B(t,r(),e,n)},u.lengthBytesUTF8=G,u.keepRuntimeAlive=Q,u.wasmMemory=k,u.stackSave=Ee,u.stackRestore=Me,u.stackAlloc=Ce,u.ExitStatus=st,u.PThread=ht,rt=function t(){ve||Le(),ve||(rt=t)},u.preInit)for(\"function\"==typeof u.preInit&&(u.preInit=[u.preInit]);0<u.preInit.length;)u.preInit.pop()();return Le(),t.ready});t.exports=r},932:(t,e,n)=>{var _scriptDir,r=(_scriptDir=(_scriptDir=\"undefined\"!=typeof document&&document.currentScript?document.currentScript.src:void 0)||__filename,function(t){var e,r,a;t=t||{},e||(e=void 0!==t?t:{}),e.ready=new Promise((function(t,e){r=t,a=e}));var i,o,u,s,c,l,f=Object.assign({},e),p=\"./this.program\",h=(t,e)=>{throw e},d=\"object\"==typeof window,y=\"function\"==typeof importScripts,b=\"object\"==typeof process&&\"object\"==typeof process.versions&&\"string\"==typeof process.versions.node,m=\"\";b?(m=y?n(17).dirname(m)+\"/\":__dirname+\"/\",l=()=>{c||(s=n(147),c=n(17))},i=function(t,e){return l(),t=c.normalize(t),s.readFileSync(t,e?void 0:\"utf8\")},u=t=>((t=i(t,!0)).buffer||(t=new Uint8Array(t)),t),o=(t,e,n)=>{l(),t=c.normalize(t),s.readFile(t,(function(t,r){t?n(t):e(r.buffer)}))},1<process.argv.length&&(p=process.argv[1].replace(/\\\\\\\\/g,\"/\")),process.argv.slice(2),process.on(\"uncaughtException\",(function(t){if(!(t instanceof J))throw t})),process.on(\"unhandledRejection\",(function(t){throw t})),h=(t,e)=>{if(w||0<z)throw process.exitCode=t,e;e instanceof J||_(\"exiting due to exception: \"+e),process.exit(t)},e.inspect=function(){return\"[Emscripten Module object]\"}):(d||y)&&(y?m=self.location.href:\"undefined\"!=typeof document&&document.currentScript&&(m=document.currentScript.src),_scriptDir&&(m=_scriptDir),m=0!==m.indexOf(\"blob:\")?m.substr(0,m.replace(/[?#].*/,\"\").lastIndexOf(\"/\")+1):\"\",i=t=>{var e=new XMLHttpRequest;return e.open(\"GET\",t,!1),e.send(null),e.responseText},y&&(u=t=>{var e=new XMLHttpRequest;return e.open(\"GET\",t,!1),e.responseType=\"arraybuffer\",e.send(null),new Uint8Array(e.response)}),o=(t,e,n)=>{var r=new XMLHttpRequest;r.open(\"GET\",t,!0),r.responseType=\"arraybuffer\",r.onload=()=>{200==r.status||0==r.status&&r.response?e(r.response):n()},r.onerror=n,r.send(null)});var g,v=e.print||console.log.bind(console),_=e.printErr||console.warn.bind(console);Object.assign(e,f),f=null,e.thisProgram&&(p=e.thisProgram),e.quit&&(h=e.quit),e.wasmBinary&&(g=e.wasmBinary);var w=e.noExitRuntime||!1;\"object\"!=typeof WebAssembly&&V(\"no native wasm support detected\");var O,A,S,T,E,M,C=!1,x=\"undefined\"!=typeof TextDecoder?new TextDecoder(\"utf8\"):void 0;function R(t,e,n){var r=(e>>>=0)+n;for(n=e;t[n]&&!(n>=r);)++n;if(16<n-e&&t.buffer&&x)return x.decode(t.subarray(e,n));for(r=\"\";e<n;){var a=t[e++];if(128&a){var i=63&t[e++];if(192==(224&a))r+=String.fromCharCode((31&a)<<6|i);else{var o=63&t[e++];65536>(a=224==(240&a)?(15&a)<<12|i<<6|o:(7&a)<<18|i<<12|o<<6|63&t[e++])?r+=String.fromCharCode(a):(a-=65536,r+=String.fromCharCode(55296|a>>10,56320|1023&a))}}else r+=String.fromCharCode(a)}return r}function k(t,e){return(t>>>=0)?R(T,t,e):\"\"}function j(t,e,n,r){if(!(0<r))return 0;var a=n>>>=0;r=n+r-1;for(var i=0;i<t.length;++i){var o=t.charCodeAt(i);if(55296<=o&&57343>=o&&(o=65536+((1023&o)<<10)|1023&t.charCodeAt(++i)),127>=o){if(n>=r)break;e[n++>>>0]=o}else{if(2047>=o){if(n+1>=r)break;e[n++>>>0]=192|o>>6}else{if(65535>=o){if(n+2>=r)break;e[n++>>>0]=224|o>>12}else{if(n+3>=r)break;e[n++>>>0]=240|o>>18,e[n++>>>0]=128|o>>12&63}e[n++>>>0]=128|o>>6&63}e[n++>>>0]=128|63&o}}return e[n>>>0]=0,n-a}function D(t){for(var e=0,n=0;n<t.length;++n){var r=t.charCodeAt(n);127>=r?e++:2047>=r?e+=2:55296<=r&&57343>=r?(e+=4,++n):e+=3}return e}function P(){var t=O.buffer;A=t,e.HEAP8=S=new Int8Array(t),e.HEAP16=new Int16Array(t),e.HEAP32=E=new Int32Array(t),e.HEAPU8=T=new Uint8Array(t),e.HEAPU16=new Uint16Array(t),e.HEAPU32=M=new Uint32Array(t),e.HEAPF32=new Float32Array(t),e.HEAPF64=new Float64Array(t)}var U,F=[],I=[],W=[],H=[],z=0;function L(){var t=e.preRun.shift();F.unshift(t)}var Y,B=0,G=null,N=null;function V(t){throw e.onAbort&&e.onAbort(t),_(t=\"Aborted(\"+t+\")\"),C=!0,t=new WebAssembly.RuntimeError(t+\". Build with -sASSERTIONS for more info.\"),a(t),t}function q(){return Y.startsWith(\"data:application/octet-stream;base64,\")}if(Y=\"ort-wasm.wasm\",!q()){var $=Y;Y=e.locateFile?e.locateFile($,m):m+$}function X(){var t=Y;try{if(t==Y&&g)return new Uint8Array(g);if(u)return u(t);throw\"both async and sync fetching of the wasm failed\"}catch(t){V(t)}}function J(t){this.name=\"ExitStatus\",this.message=\"Program terminated with exit(\"+t+\")\",this.status=t}function Z(t){for(;0<t.length;)t.shift()(e)}var Q=[],K=0,tt=0;function et(t){this.Db=t,this.zb=t-24,this.Ub=function(t){M[this.zb+4>>2>>>0]=t},this.Eb=function(){return M[this.zb+4>>2>>>0]},this.Sb=function(t){M[this.zb+8>>2>>>0]=t},this.Wb=function(){return M[this.zb+8>>2>>>0]},this.Tb=function(){E[this.zb>>2>>>0]=0},this.Ib=function(t){S[this.zb+12>>0>>>0]=t?1:0},this.Pb=function(){return 0!=S[this.zb+12>>0>>>0]},this.Jb=function(t){S[this.zb+13>>0>>>0]=t?1:0},this.Lb=function(){return 0!=S[this.zb+13>>0>>>0]},this.Rb=function(t,e){this.Fb(0),this.Ub(t),this.Sb(e),this.Tb(),this.Ib(!1),this.Jb(!1)},this.Nb=function(){E[this.zb>>2>>>0]+=1},this.Xb=function(){var t=E[this.zb>>2>>>0];return E[this.zb>>2>>>0]=t-1,1===t},this.Fb=function(t){M[this.zb+16>>2>>>0]=t},this.Ob=function(){return M[this.zb+16>>2>>>0]},this.Qb=function(){if(Mt(this.Eb()))return M[this.Db>>2>>>0];var t=this.Ob();return 0!==t?t:this.Db}}function nt(t){return vt(new et(t).zb)}var rt=[];function at(t){var e=rt[t];return e||(t>=rt.length&&(rt.length=t+1),rt[t]=e=U.get(t)),e}function it(t){var e=D(t)+1,n=gt(e);return n&&j(t,S,n,e),n}var ot={};function ut(){if(!st){var t,e={USER:\"web_user\",LOGNAME:\"web_user\",PATH:\"/\",PWD:\"/\",HOME:\"/home/web_user\",LANG:(\"object\"==typeof navigator&&navigator.languages&&navigator.languages[0]||\"C\").replace(\"-\",\"_\")+\".UTF-8\",_:p||\"./this.program\"};for(t in ot)void 0===ot[t]?delete e[t]:e[t]=ot[t];var n=[];for(t in e)n.push(t+\"=\"+e[t]);st=n}return st}var st,ct=[null,[],[]];function lt(t,e){var n=ct[t];0===e||10===e?((1===t?v:_)(R(n,0)),n.length=0):n.push(e)}var ft=0;function pt(t){return 0==t%4&&(0!=t%100||0==t%400)}var ht=[31,29,31,30,31,30,31,31,30,31,30,31],dt=[31,28,31,30,31,30,31,31,30,31,30,31];function yt(t,e,n,r){function a(t,e,n){for(t=\"number\"==typeof t?t.toString():t||\"\";t.length<e;)t=n[0]+t;return t}function i(t,e){return a(t,e,\"0\")}function o(t,e){function n(t){return 0>t?-1:0<t?1:0}var r;return 0===(r=n(t.getFullYear()-e.getFullYear()))&&0===(r=n(t.getMonth()-e.getMonth()))&&(r=n(t.getDate()-e.getDate())),r}function u(t){switch(t.getDay()){case 0:return new Date(t.getFullYear()-1,11,29);case 1:return t;case 2:return new Date(t.getFullYear(),0,3);case 3:return new Date(t.getFullYear(),0,2);case 4:return new Date(t.getFullYear(),0,1);case 5:return new Date(t.getFullYear()-1,11,31);case 6:return new Date(t.getFullYear()-1,11,30)}}function s(t){var e=t.Bb;for(t=new Date(new Date(t.Cb+1900,0,1).getTime());0<e;){var n=t.getMonth(),r=(pt(t.getFullYear())?ht:dt)[n];if(!(e>r-t.getDate())){t.setDate(t.getDate()+e);break}e-=r-t.getDate()+1,t.setDate(1),11>n?t.setMonth(n+1):(t.setMonth(0),t.setFullYear(t.getFullYear()+1))}return n=new Date(t.getFullYear()+1,0,4),e=u(new Date(t.getFullYear(),0,4)),n=u(n),0>=o(e,t)?0>=o(n,t)?t.getFullYear()+1:t.getFullYear():t.getFullYear()-1}var c=E[r+40>>2>>>0];for(var l in r={$b:E[r>>2>>>0],Zb:E[r+4>>2>>>0],Gb:E[r+8>>2>>>0],Kb:E[r+12>>2>>>0],Hb:E[r+16>>2>>>0],Cb:E[r+20>>2>>>0],Ab:E[r+24>>2>>>0],Bb:E[r+28>>2>>>0],bc:E[r+32>>2>>>0],Yb:E[r+36>>2>>>0],ac:c?k(c):\"\"},n=k(n),c={\"%c\":\"%a %b %d %H:%M:%S %Y\",\"%D\":\"%m/%d/%y\",\"%F\":\"%Y-%m-%d\",\"%h\":\"%b\",\"%r\":\"%I:%M:%S %p\",\"%R\":\"%H:%M\",\"%T\":\"%H:%M:%S\",\"%x\":\"%m/%d/%y\",\"%X\":\"%H:%M:%S\",\"%Ec\":\"%c\",\"%EC\":\"%C\",\"%Ex\":\"%m/%d/%y\",\"%EX\":\"%H:%M:%S\",\"%Ey\":\"%y\",\"%EY\":\"%Y\",\"%Od\":\"%d\",\"%Oe\":\"%e\",\"%OH\":\"%H\",\"%OI\":\"%I\",\"%Om\":\"%m\",\"%OM\":\"%M\",\"%OS\":\"%S\",\"%Ou\":\"%u\",\"%OU\":\"%U\",\"%OV\":\"%V\",\"%Ow\":\"%w\",\"%OW\":\"%W\",\"%Oy\":\"%y\"})n=n.replace(new RegExp(l,\"g\"),c[l]);var f=\"Sunday Monday Tuesday Wednesday Thursday Friday Saturday\".split(\" \"),p=\"January February March April May June July August September October November December\".split(\" \");for(l in c={\"%a\":function(t){return f[t.Ab].substring(0,3)},\"%A\":function(t){return f[t.Ab]},\"%b\":function(t){return p[t.Hb].substring(0,3)},\"%B\":function(t){return p[t.Hb]},\"%C\":function(t){return i((t.Cb+1900)/100|0,2)},\"%d\":function(t){return i(t.Kb,2)},\"%e\":function(t){return a(t.Kb,2,\" \")},\"%g\":function(t){return s(t).toString().substring(2)},\"%G\":function(t){return s(t)},\"%H\":function(t){return i(t.Gb,2)},\"%I\":function(t){return 0==(t=t.Gb)?t=12:12<t&&(t-=12),i(t,2)},\"%j\":function(t){for(var e=0,n=0;n<=t.Hb-1;e+=(pt(t.Cb+1900)?ht:dt)[n++]);return i(t.Kb+e,3)},\"%m\":function(t){return i(t.Hb+1,2)},\"%M\":function(t){return i(t.Zb,2)},\"%n\":function(){return\"\\\\n\"},\"%p\":function(t){return 0<=t.Gb&&12>t.Gb?\"AM\":\"PM\"},\"%S\":function(t){return i(t.$b,2)},\"%t\":function(){return\"\\\\t\"},\"%u\":function(t){return t.Ab||7},\"%U\":function(t){return i(Math.floor((t.Bb+7-t.Ab)/7),2)},\"%V\":function(t){var e=Math.floor((t.Bb+7-(t.Ab+6)%7)/7);if(2>=(t.Ab+371-t.Bb-2)%7&&e++,e)53==e&&(4==(n=(t.Ab+371-t.Bb)%7)||3==n&&pt(t.Cb)||(e=1));else{e=52;var n=(t.Ab+7-t.Bb-1)%7;(4==n||5==n&&pt(t.Cb%400-1))&&e++}return i(e,2)},\"%w\":function(t){return t.Ab},\"%W\":function(t){return i(Math.floor((t.Bb+7-(t.Ab+6)%7)/7),2)},\"%y\":function(t){return(t.Cb+1900).toString().substring(2)},\"%Y\":function(t){return t.Cb+1900},\"%z\":function(t){var e=0<=(t=t.Yb);return t=Math.abs(t)/60,(e?\"+\":\"-\")+String(\"0000\"+(t/60*100+t%60)).slice(-4)},\"%Z\":function(t){return t.ac},\"%%\":function(){return\"%\"}},n=n.replace(/%%/g,\"\\\\0\\\\0\"),c)n.includes(l)&&(n=n.replace(new RegExp(l,\"g\"),c[l](r)));return l=function(t){var e=Array(D(t)+1);return j(t,e,0,e.length),e}(n=n.replace(/\\\\0\\\\0/g,\"%\")),l.length>e?0:(S.set(l,t>>>0),l.length-1)}var bt={a:function(t){return gt(t+24)+24},m:function(t){return(t=new et(t)).Pb()||(t.Ib(!0),K--),t.Jb(!1),Q.push(t),t.Nb(),t.Qb()},ia:function(t){throw _(\"Unexpected exception thrown, this is not properly supported - aborting\"),C=!0,t},w:function(){Ot(0);var t=Q.pop();if(t.Xb()&&!t.Lb()){var e=t.Wb();e&&at(e)(t.Db),nt(t.Db)}tt=0},d:function(){var t=tt;if(!t)return ft=0;var e=new et(t);e.Fb(t);var n=e.Eb();if(!n)return ft=0,t;for(var r=Array.prototype.slice.call(arguments),a=0;a<r.length;a++){var i=r[a];if(0===i||i===n)break;if(Et(i,n,e.zb+16))return ft=i,t}return ft=n,t},k:function(){var t=tt;if(!t)return ft=0;var e=new et(t);e.Fb(t);var n=e.Eb();if(!n)return ft=0,t;for(var r=Array.prototype.slice.call(arguments),a=0;a<r.length;a++){var i=r[a];if(0===i||i===n)break;if(Et(i,n,e.zb+16))return ft=i,t}return ft=n,t},g:function(){var t=tt;if(!t)return ft=0;var e=new et(t);e.Fb(t);var n=e.Eb();if(!n)return ft=0,t;for(var r=Array.prototype.slice.call(arguments),a=0;a<r.length;a++){var i=r[a];if(0===i||i===n)break;if(Et(i,n,e.zb+16))return ft=i,t}return ft=n,t},s:nt,L:function(){var t=Q.pop();t||V(\"no exception to throw\");var e=t.Db;throw t.Lb()||(Q.push(t),t.Jb(!0),t.Ib(!1),K++),tt=e,e},b:function(t,e,n){throw new et(t).Rb(e,n),tt=t,K++,t},la:function(){return K},i:function(t){throw tt||(tt=t),t},H:function(){return 0},Ba:function(){},pa:function(){},ra:function(){},ka:function(){return 0},za:function(){},ua:function(){},ya:function(){},R:function(){},qa:function(){},na:function(){},Aa:function(){},oa:function(){},Ha:function(){},Ja:function(){V(\"To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking\")},Ia:function(){V(\"To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking\")},S:function(){return Date.now()},Ca:function(){return!0},Da:function(t,e){t=new Date(1e3*(M[t>>>2]+4294967296*E[t+4>>>2])),E[e>>2>>>0]=t.getUTCSeconds(),E[e+4>>2>>>0]=t.getUTCMinutes(),E[e+8>>2>>>0]=t.getUTCHours(),E[e+12>>2>>>0]=t.getUTCDate(),E[e+16>>2>>>0]=t.getUTCMonth(),E[e+20>>2>>>0]=t.getUTCFullYear()-1900,E[e+24>>2>>>0]=t.getUTCDay(),E[e+28>>2>>>0]=(t.getTime()-Date.UTC(t.getUTCFullYear(),0,1,0,0,0,0))/864e5|0},Ea:function(t,e){t=new Date(1e3*(M[t>>>2]+4294967296*E[t+4>>>2])),E[e>>2>>>0]=t.getSeconds(),E[e+4>>2>>>0]=t.getMinutes(),E[e+8>>2>>>0]=t.getHours(),E[e+12>>2>>>0]=t.getDate(),E[e+16>>2>>>0]=t.getMonth(),E[e+20>>2>>>0]=t.getFullYear()-1900,E[e+24>>2>>>0]=t.getDay();var n=new Date(t.getFullYear(),0,1);E[e+28>>2>>>0]=(t.getTime()-n.getTime())/864e5|0,E[e+36>>2>>>0]=-60*t.getTimezoneOffset();var r=new Date(t.getFullYear(),6,1).getTimezoneOffset();n=n.getTimezoneOffset(),E[e+32>>2>>>0]=0|(r!=n&&t.getTimezoneOffset()==Math.min(n,r))},Fa:function(t){var e=new Date(E[t+20>>2>>>0]+1900,E[t+16>>2>>>0],E[t+12>>2>>>0],E[t+8>>2>>>0],E[t+4>>2>>>0],E[t>>2>>>0],0),n=E[t+32>>2>>>0],r=e.getTimezoneOffset(),a=new Date(e.getFullYear(),0,1),i=new Date(e.getFullYear(),6,1).getTimezoneOffset(),o=a.getTimezoneOffset(),u=Math.min(o,i);return 0>n?E[t+32>>2>>>0]=Number(i!=o&&u==r):0<n!=(u==r)&&(i=Math.max(o,i),e.setTime(e.getTime()+6e4*((0<n?u:i)-r))),E[t+24>>2>>>0]=e.getDay(),E[t+28>>2>>>0]=(e.getTime()-a.getTime())/864e5|0,E[t>>2>>>0]=e.getSeconds(),E[t+4>>2>>>0]=e.getMinutes(),E[t+8>>2>>>0]=e.getHours(),E[t+12>>2>>>0]=e.getDate(),E[t+16>>2>>>0]=e.getMonth(),e.getTime()/1e3|0},sa:function(){return-52},ta:function(){},Ga:function t(e,n,r){t.Vb||(t.Vb=!0,function(t,e,n){function r(t){return(t=t.toTimeString().match(/\\\\(([A-Za-z ]+)\\\\)$/))?t[1]:\"GMT\"}var a=(new Date).getFullYear(),i=new Date(a,0,1),o=new Date(a,6,1);a=i.getTimezoneOffset();var u=o.getTimezoneOffset();E[t>>2>>>0]=60*Math.max(a,u),E[e>>2>>>0]=Number(a!=u),t=r(i),e=r(o),t=it(t),e=it(e),u<a?(M[n>>2>>>0]=t,M[n+4>>2>>>0]=e):(M[n>>2>>>0]=e,M[n+4>>2>>>0]=t)}(e,n,r))},B:function(){V(\"\")},ma:function(){return 4294901760},I:b?()=>{var t=process.hrtime();return 1e3*t[0]+t[1]/1e6}:()=>performance.now(),xa:function(t,e,n){T.copyWithin(t>>>0,e>>>0,e+n>>>0)},G:function(t){var e=T.length;if(4294901760<(t>>>=0))return!1;for(var n=1;4>=n;n*=2){var r=e*(1+.2/n);r=Math.min(r,t+100663296);var a=Math;r=Math.max(t,r),a=a.min.call(a,4294901760,r+(65536-r%65536)%65536);t:{try{O.grow(a-A.byteLength+65535>>>16),P();var i=1;break t}catch(t){}i=void 0}if(i)return!0}return!1},va:function(t,e){var n=0;return ut().forEach((function(r,a){var i=e+n;for(a=M[t+4*a>>2>>>0]=i,i=0;i<r.length;++i)S[a++>>0>>>0]=r.charCodeAt(i);S[a>>0>>>0]=0,n+=r.length+1})),0},wa:function(t,e){var n=ut();M[t>>2>>>0]=n.length;var r=0;return n.forEach((function(t){r+=t.length+1})),M[e>>2>>>0]=r,0},ba:function(t){w||0<z||(wt(),Z(W),_t(0),ct[1].length&&lt(1,10),ct[2].length&&lt(2,10)),w||0<z||(e.onExit&&e.onExit(t),C=!0),h(t,new J(t))},E:function(){return 52},Q:function(){return 52},ca:function(){return 70},P:function(t,e,n,r){for(var a=0,i=0;i<n;i++){var o=M[e>>2>>>0],u=M[e+4>>2>>>0];e+=8;for(var s=0;s<u;s++)lt(t,T[o+s>>>0]);a+=u}return M[r>>2>>>0]=a,0},c:function(){return ft},ja:function t(e,r){t.Mb||(t.Mb=function(){if(\"object\"==typeof crypto&&\"function\"==typeof crypto.getRandomValues){var t=new Uint8Array(1);return()=>(crypto.getRandomValues(t),t[0])}if(b)try{var e=n(113);return()=>e.randomBytes(1)[0]}catch(t){}return()=>V(\"randomDevice\")}());for(var a=0;a<r;a++)S[e+a>>0>>>0]=t.Mb();return 0},ea:function(t,e,n){var r=At();try{return at(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},fa:function(t,e,n){var r=At();try{return at(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},J:function(t){var e=At();try{return at(t)()}catch(t){if(St(e),t!==t+0)throw t;Ot(1,0)}},e:function(t,e){var n=At();try{return at(t)(e)}catch(t){if(St(n),t!==t+0)throw t;Ot(1,0)}},N:function(t,e,n){var r=At();try{return at(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},O:function(t,e,n){var r=At();try{return at(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},j:function(t,e,n){var r=At();try{return at(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},o:function(t,e,n,r){var a=At();try{return at(t)(e,n,r)}catch(t){if(St(a),t!==t+0)throw t;Ot(1,0)}},p:function(t,e,n,r,a){var i=At();try{return at(t)(e,n,r,a)}catch(t){if(St(i),t!==t+0)throw t;Ot(1,0)}},M:function(t,e,n,r,a,i){var o=At();try{return at(t)(e,n,r,a,i)}catch(t){if(St(o),t!==t+0)throw t;Ot(1,0)}},r:function(t,e,n,r,a,i){var o=At();try{return at(t)(e,n,r,a,i)}catch(t){if(St(o),t!==t+0)throw t;Ot(1,0)}},v:function(t,e,n,r,a,i,o){var u=At();try{return at(t)(e,n,r,a,i,o)}catch(t){if(St(u),t!==t+0)throw t;Ot(1,0)}},K:function(t,e,n,r,a,i,o,u){var s=At();try{return at(t)(e,n,r,a,i,o,u)}catch(t){if(St(s),t!==t+0)throw t;Ot(1,0)}},D:function(t,e,n,r,a,i,o,u,s,c,l,f){var p=At();try{return at(t)(e,n,r,a,i,o,u,s,c,l,f)}catch(t){if(St(p),t!==t+0)throw t;Ot(1,0)}},X:function(t,e,n,r,a,i,o,u){var s=At();try{return Ft(t,e,n,r,a,i,o,u)}catch(t){if(St(s),t!==t+0)throw t;Ot(1,0)}},V:function(t,e,n,r,a,i,o){var u=At();try{return xt(t,e,n,r,a,i,o)}catch(t){if(St(u),t!==t+0)throw t;Ot(1,0)}},U:function(t,e,n,r,a){var i=At();try{return It(t,e,n,r,a)}catch(t){if(St(i),t!==t+0)throw t;Ot(1,0)}},Z:function(t,e,n,r){var a=At();try{return Pt(t,e,n,r)}catch(t){if(St(a),t!==t+0)throw t;Ot(1,0)}},W:function(t){var e=At();try{return Ct(t)}catch(t){if(St(e),t!==t+0)throw t;Ot(1,0)}},Y:function(t,e){var n=At();try{return Ut(t,e)}catch(t){if(St(n),t!==t+0)throw t;Ot(1,0)}},T:function(t,e,n){var r=At();try{return Rt(t,e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},f:function(t){var e=At();try{at(t)()}catch(t){if(St(e),t!==t+0)throw t;Ot(1,0)}},q:function(t,e){var n=At();try{at(t)(e)}catch(t){if(St(n),t!==t+0)throw t;Ot(1,0)}},h:function(t,e,n){var r=At();try{at(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},da:function(t,e,n,r){var a=At();try{at(t)(e,n,r)}catch(t){if(St(a),t!==t+0)throw t;Ot(1,0)}},l:function(t,e,n,r){var a=At();try{at(t)(e,n,r)}catch(t){if(St(a),t!==t+0)throw t;Ot(1,0)}},t:function(t,e,n,r,a){var i=At();try{at(t)(e,n,r,a)}catch(t){if(St(i),t!==t+0)throw t;Ot(1,0)}},u:function(t,e,n,r,a,i){var o=At();try{at(t)(e,n,r,a,i)}catch(t){if(St(o),t!==t+0)throw t;Ot(1,0)}},x:function(t,e,n,r,a,i,o){var u=At();try{at(t)(e,n,r,a,i,o)}catch(t){if(St(u),t!==t+0)throw t;Ot(1,0)}},z:function(t,e,n,r,a,i,o,u){var s=At();try{at(t)(e,n,r,a,i,o,u)}catch(t){if(St(s),t!==t+0)throw t;Ot(1,0)}},ga:function(t,e,n,r,a,i,o,u,s){var c=At();try{at(t)(e,n,r,a,i,o,u,s)}catch(t){if(St(c),t!==t+0)throw t;Ot(1,0)}},A:function(t,e,n,r,a,i,o,u,s,c,l){var f=At();try{at(t)(e,n,r,a,i,o,u,s,c,l)}catch(t){if(St(f),t!==t+0)throw t;Ot(1,0)}},C:function(t,e,n,r,a,i,o,u,s,c,l,f,p,h,d,y){var b=At();try{at(t)(e,n,r,a,i,o,u,s,c,l,f,p,h,d,y)}catch(t){if(St(b),t!==t+0)throw t;Ot(1,0)}},aa:function(t,e,n,r,a,i,o,u){var s=At();try{kt(t,e,n,r,a,i,o,u)}catch(t){if(St(s),t!==t+0)throw t;Ot(1,0)}},_:function(t,e,n,r,a,i,o,u,s,c,l,f){var p=At();try{Dt(t,e,n,r,a,i,o,u,s,c,l,f)}catch(t){if(St(p),t!==t+0)throw t;Ot(1,0)}},$:function(t,e,n,r,a,i){var o=At();try{jt(t,e,n,r,a,i)}catch(t){if(St(o),t!==t+0)throw t;Ot(1,0)}},n:function(t){return t},F:function(t){ft=t},ha:yt,y:function(t,e,n,r){return yt(t,e,n,r)}};!function(){function t(t){e.asm=t.exports,O=e.asm.Ka,P(),U=e.asm.ib,I.unshift(e.asm.La),B--,e.monitorRunDependencies&&e.monitorRunDependencies(B),0==B&&(null!==G&&(clearInterval(G),G=null),N&&(t=N,N=null,t()))}function n(e){t(e.instance)}function r(t){return function(){if(!g&&(d||y)){if(\"function\"==typeof fetch&&!Y.startsWith(\"file://\"))return fetch(Y,{credentials:\"same-origin\"}).then((function(t){if(!t.ok)throw\"failed to load wasm binary file at \\'\"+Y+\"\\'\";return t.arrayBuffer()})).catch((function(){return X()}));if(o)return new Promise((function(t,e){o(Y,(function(e){t(new Uint8Array(e))}),e)}))}return Promise.resolve().then((function(){return X()}))}().then((function(t){return WebAssembly.instantiate(t,i)})).then((function(t){return t})).then(t,(function(t){_(\"failed to asynchronously prepare wasm: \"+t),V(t)}))}var i={a:bt};if(B++,e.monitorRunDependencies&&e.monitorRunDependencies(B),e.instantiateWasm)try{return e.instantiateWasm(i,t)}catch(t){return _(\"Module.instantiateWasm callback failed with error: \"+t),!1}(g||\"function\"!=typeof WebAssembly.instantiateStreaming||q()||Y.startsWith(\"file://\")||b||\"function\"!=typeof fetch?r(n):fetch(Y,{credentials:\"same-origin\"}).then((function(t){return WebAssembly.instantiateStreaming(t,i).then(n,(function(t){return _(\"wasm streaming compile failed: \"+t),_(\"falling back to ArrayBuffer instantiation\"),r(n)}))}))).catch(a)}(),e.___wasm_call_ctors=function(){return(e.___wasm_call_ctors=e.asm.La).apply(null,arguments)},e._OrtInit=function(){return(e._OrtInit=e.asm.Ma).apply(null,arguments)},e._OrtCreateSessionOptions=function(){return(e._OrtCreateSessionOptions=e.asm.Na).apply(null,arguments)},e._OrtAppendExecutionProvider=function(){return(e._OrtAppendExecutionProvider=e.asm.Oa).apply(null,arguments)},e._OrtAddSessionConfigEntry=function(){return(e._OrtAddSessionConfigEntry=e.asm.Pa).apply(null,arguments)},e._OrtReleaseSessionOptions=function(){return(e._OrtReleaseSessionOptions=e.asm.Qa).apply(null,arguments)},e._OrtCreateSession=function(){return(e._OrtCreateSession=e.asm.Ra).apply(null,arguments)},e._OrtReleaseSession=function(){return(e._OrtReleaseSession=e.asm.Sa).apply(null,arguments)},e._OrtGetInputCount=function(){return(e._OrtGetInputCount=e.asm.Ta).apply(null,arguments)},e._OrtGetOutputCount=function(){return(e._OrtGetOutputCount=e.asm.Ua).apply(null,arguments)},e._OrtGetInputName=function(){return(e._OrtGetInputName=e.asm.Va).apply(null,arguments)},e._OrtGetOutputName=function(){return(e._OrtGetOutputName=e.asm.Wa).apply(null,arguments)},e._OrtFree=function(){return(e._OrtFree=e.asm.Xa).apply(null,arguments)},e._OrtCreateTensor=function(){return(e._OrtCreateTensor=e.asm.Ya).apply(null,arguments)},e._OrtGetTensorData=function(){return(e._OrtGetTensorData=e.asm.Za).apply(null,arguments)},e._OrtReleaseTensor=function(){return(e._OrtReleaseTensor=e.asm._a).apply(null,arguments)},e._OrtCreateRunOptions=function(){return(e._OrtCreateRunOptions=e.asm.$a).apply(null,arguments)},e._OrtAddRunConfigEntry=function(){return(e._OrtAddRunConfigEntry=e.asm.ab).apply(null,arguments)},e._OrtReleaseRunOptions=function(){return(e._OrtReleaseRunOptions=e.asm.bb).apply(null,arguments)},e._OrtRun=function(){return(e._OrtRun=e.asm.cb).apply(null,arguments)},e._OrtEndProfiling=function(){return(e._OrtEndProfiling=e.asm.db).apply(null,arguments)};var mt,gt=e._malloc=function(){return(gt=e._malloc=e.asm.eb).apply(null,arguments)},vt=e._free=function(){return(vt=e._free=e.asm.fb).apply(null,arguments)},_t=e._fflush=function(){return(_t=e._fflush=e.asm.gb).apply(null,arguments)},wt=e.___funcs_on_exit=function(){return(wt=e.___funcs_on_exit=e.asm.hb).apply(null,arguments)},Ot=e._setThrew=function(){return(Ot=e._setThrew=e.asm.jb).apply(null,arguments)},At=e.stackSave=function(){return(At=e.stackSave=e.asm.kb).apply(null,arguments)},St=e.stackRestore=function(){return(St=e.stackRestore=e.asm.lb).apply(null,arguments)},Tt=e.stackAlloc=function(){return(Tt=e.stackAlloc=e.asm.mb).apply(null,arguments)},Et=e.___cxa_can_catch=function(){return(Et=e.___cxa_can_catch=e.asm.nb).apply(null,arguments)},Mt=e.___cxa_is_pointer_type=function(){return(Mt=e.___cxa_is_pointer_type=e.asm.ob).apply(null,arguments)},Ct=e.dynCall_j=function(){return(Ct=e.dynCall_j=e.asm.pb).apply(null,arguments)},xt=e.dynCall_iiiiij=function(){return(xt=e.dynCall_iiiiij=e.asm.qb).apply(null,arguments)},Rt=e.dynCall_jii=function(){return(Rt=e.dynCall_jii=e.asm.rb).apply(null,arguments)},kt=e.dynCall_viiiiij=function(){return(kt=e.dynCall_viiiiij=e.asm.sb).apply(null,arguments)},jt=e.dynCall_vjji=function(){return(jt=e.dynCall_vjji=e.asm.tb).apply(null,arguments)},Dt=e.dynCall_viiijjjii=function(){return(Dt=e.dynCall_viiijjjii=e.asm.ub).apply(null,arguments)},Pt=e.dynCall_iij=function(){return(Pt=e.dynCall_iij=e.asm.vb).apply(null,arguments)},Ut=e.dynCall_ji=function(){return(Ut=e.dynCall_ji=e.asm.wb).apply(null,arguments)},Ft=e.dynCall_iiiiiij=function(){return(Ft=e.dynCall_iiiiiij=e.asm.xb).apply(null,arguments)},It=e.dynCall_iiij=function(){return(It=e.dynCall_iiij=e.asm.yb).apply(null,arguments)};function Wt(){function t(){if(!mt&&(mt=!0,e.calledRun=!0,!C)){if(Z(I),r(e),e.onRuntimeInitialized&&e.onRuntimeInitialized(),e.postRun)for(\"function\"==typeof e.postRun&&(e.postRun=[e.postRun]);e.postRun.length;){var t=e.postRun.shift();H.unshift(t)}Z(H)}}if(!(0<B)){if(e.preRun)for(\"function\"==typeof e.preRun&&(e.preRun=[e.preRun]);e.preRun.length;)L();Z(F),0<B||(e.setStatus?(e.setStatus(\"Running...\"),setTimeout((function(){setTimeout((function(){e.setStatus(\"\")}),1),t()}),1)):t())}}if(e.UTF8ToString=k,e.stringToUTF8=function(t,e,n){return j(t,T,e,n)},e.lengthBytesUTF8=D,e.stackSave=At,e.stackRestore=St,e.stackAlloc=Tt,N=function t(){mt||Wt(),mt||(N=t)},e.preInit)for(\"function\"==typeof e.preInit&&(e.preInit=[e.preInit]);0<e.preInit.length;)e.preInit.pop()();return Wt(),t.ready});t.exports=r},967:(t,e)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.iterateExtraOptions=void 0,e.iterateExtraOptions=(t,n,r,a)=>{if(\"object\"==typeof t&&null!==t){if(r.has(t))throw new Error(\"Circular reference in options\");r.add(t)}Object.entries(t).forEach((([t,i])=>{const o=n?n+t:t;if(\"object\"==typeof i)(0,e.iterateExtraOptions)(i,o+\".\",r,a);else if(\"string\"==typeof i||\"number\"==typeof i)a(o,i.toString());else{if(\"boolean\"!=typeof i)throw new Error(\"Can\\'t handle extra config type: \"+typeof i);a(o,i?\"1\":\"0\")}}))}},586:(t,e,n)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.setRunOptions=void 0;const r=n(967),a=n(983),i=n(361);e.setRunOptions=t=>{const e=(0,i.getInstance)();let n=0;const o=[],u=t||{};try{if(void 0===(null==t?void 0:t.logSeverityLevel))u.logSeverityLevel=2;else if(\"number\"!=typeof t.logSeverityLevel||!Number.isInteger(t.logSeverityLevel)||t.logSeverityLevel<0||t.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${t.logSeverityLevel}`);if(void 0===(null==t?void 0:t.logVerbosityLevel))u.logVerbosityLevel=0;else if(\"number\"!=typeof t.logVerbosityLevel||!Number.isInteger(t.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${t.logVerbosityLevel}`);void 0===(null==t?void 0:t.terminate)&&(u.terminate=!1);let i=0;if(void 0!==(null==t?void 0:t.tag)&&(i=(0,a.allocWasmString)(t.tag,o)),n=e._OrtCreateRunOptions(u.logSeverityLevel,u.logVerbosityLevel,!!u.terminate,i),0===n)throw new Error(\"Can\\'t create run options\");return void 0!==(null==t?void 0:t.extra)&&(0,r.iterateExtraOptions)(t.extra,\"\",new WeakSet,((t,r)=>{const i=(0,a.allocWasmString)(t,o),u=(0,a.allocWasmString)(r,o);if(0!==e._OrtAddRunConfigEntry(n,i,u))throw new Error(`Can\\'t set a run config entry: ${t} - ${r}`)})),[n,o]}catch(t){throw 0!==n&&e._OrtReleaseRunOptions(n),o.forEach(e._free),t}}},919:(t,e,n)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.setSessionOptions=void 0;const r=n(967),a=n(983),i=n(361);e.setSessionOptions=t=>{const e=(0,i.getInstance)();let n=0;const o=[],u=t||{};(t=>{t.extra||(t.extra={}),t.extra.session||(t.extra.session={});const e=t.extra.session;e.use_ort_model_bytes_directly||(e.use_ort_model_bytes_directly=\"1\")})(u);try{void 0===(null==t?void 0:t.graphOptimizationLevel)&&(u.graphOptimizationLevel=\"all\");const s=(t=>{switch(t){case\"disabled\":return 0;case\"basic\":return 1;case\"extended\":return 2;case\"all\":return 99;default:throw new Error(`unsupported graph optimization level: ${t}`)}})(u.graphOptimizationLevel);void 0===(null==t?void 0:t.enableCpuMemArena)&&(u.enableCpuMemArena=!0),void 0===(null==t?void 0:t.enableMemPattern)&&(u.enableMemPattern=!0),void 0===(null==t?void 0:t.executionMode)&&(u.executionMode=\"sequential\");const c=(t=>{switch(t){case\"sequential\":return 0;case\"parallel\":return 1;default:throw new Error(`unsupported execution mode: ${t}`)}})(u.executionMode);let l=0;if(void 0!==(null==t?void 0:t.logId)&&(l=(0,a.allocWasmString)(t.logId,o)),void 0===(null==t?void 0:t.logSeverityLevel))u.logSeverityLevel=2;else if(\"number\"!=typeof t.logSeverityLevel||!Number.isInteger(t.logSeverityLevel)||t.logSeverityLevel<0||t.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${t.logSeverityLevel}`);if(void 0===(null==t?void 0:t.logVerbosityLevel))u.logVerbosityLevel=0;else if(\"number\"!=typeof t.logVerbosityLevel||!Number.isInteger(t.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${t.logVerbosityLevel}`);if(void 0===(null==t?void 0:t.enableProfiling)&&(u.enableProfiling=!1),n=e._OrtCreateSessionOptions(s,!!u.enableCpuMemArena,!!u.enableMemPattern,c,!!u.enableProfiling,0,l,u.logSeverityLevel,u.logVerbosityLevel),0===n)throw new Error(\"Can\\'t create session options\");return(null==t?void 0:t.executionProviders)&&((t,e,n)=>{for(const r of e){let e=\"string\"==typeof r?r:r.name;switch(e){case\"xnnpack\":e=\"XNNPACK\";break;case\"wasm\":case\"cpu\":continue;default:throw new Error(`not supported EP: ${e}`)}const o=(0,a.allocWasmString)(e,n);if(0!==(0,i.getInstance)()._OrtAppendExecutionProvider(t,o))throw new Error(`Can\\'t append execution provider: ${e}`)}})(n,t.executionProviders,o),void 0!==(null==t?void 0:t.extra)&&(0,r.iterateExtraOptions)(t.extra,\"\",new WeakSet,((t,r)=>{const i=(0,a.allocWasmString)(t,o),u=(0,a.allocWasmString)(r,o);if(0!==e._OrtAddSessionConfigEntry(n,i,u))throw new Error(`Can\\'t set a session config entry: ${t} - ${r}`)})),[n,o]}catch(t){throw 0!==n&&e._OrtReleaseSessionOptions(n),o.forEach(e._free),t}}},983:(t,e,n)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.allocWasmString=void 0;const r=n(361);e.allocWasmString=(t,e)=>{const n=(0,r.getInstance)(),a=n.lengthBytesUTF8(t)+1,i=n._malloc(a);return n.stringToUTF8(t,i,a),e.push(i),i}},349:(t,e,n)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.extractTransferableBuffers=e.endProfiling=e.run=e.releaseSession=e.createSession=e.createSessionFinalize=e.createSessionAllocate=e.initOrt=void 0;const r=n(586),a=n(919),i=n(983),o=n(361);e.initOrt=(t,e)=>{const n=(0,o.getInstance)()._OrtInit(t,e);if(0!==n)throw new Error(`Can\\'t initialize onnxruntime. error code = ${n}`)};const u=new Map;e.createSessionAllocate=t=>{const e=(0,o.getInstance)(),n=e._malloc(t.byteLength);return e.HEAPU8.set(t,n),[n,t.byteLength]},e.createSessionFinalize=(t,e)=>{const n=(0,o.getInstance)();let r=0,i=0,s=[];try{if([i,s]=(0,a.setSessionOptions)(e),r=n._OrtCreateSession(t[0],t[1],i),0===r)throw new Error(\"Can\\'t create a session\")}finally{n._free(t[0]),n._OrtReleaseSessionOptions(i),s.forEach(n._free)}const c=n._OrtGetInputCount(r),l=n._OrtGetOutputCount(r),f=[],p=[],h=[],d=[];for(let t=0;t<c;t++){const e=n._OrtGetInputName(r,t);if(0===e)throw new Error(\"Can\\'t get an input name\");p.push(e),f.push(n.UTF8ToString(e))}for(let t=0;t<l;t++){const e=n._OrtGetOutputName(r,t);if(0===e)throw new Error(\"Can\\'t get an output name\");d.push(e),h.push(n.UTF8ToString(e))}return u.set(r,[r,p,d]),[r,f,h]},e.createSession=(t,n)=>{const r=(0,e.createSessionAllocate)(t);return(0,e.createSessionFinalize)(r,n)},e.releaseSession=t=>{const e=(0,o.getInstance)(),n=u.get(t);if(!n)throw new Error(\"invalid session id\");const r=n[0],a=n[1],i=n[2];a.forEach(e._OrtFree),i.forEach(e._OrtFree),e._OrtReleaseSession(r),u.delete(t)};const s=t=>{switch(t){case\"int8\":return 3;case\"uint8\":return 2;case\"bool\":return 9;case\"int16\":return 5;case\"uint16\":return 4;case\"int32\":return 6;case\"uint32\":return 12;case\"float32\":return 1;case\"float64\":return 11;case\"string\":return 8;case\"int64\":return 7;case\"uint64\":return 13;default:throw new Error(`unsupported data type: ${t}`)}},c=t=>{switch(t){case 3:return\"int8\";case 2:return\"uint8\";case 9:return\"bool\";case 5:return\"int16\";case 4:return\"uint16\";case 6:return\"int32\";case 12:return\"uint32\";case 1:return\"float32\";case 11:return\"float64\";case 8:return\"string\";case 7:return\"int64\";case 13:return\"uint64\";default:throw new Error(`unsupported data type: ${t}`)}},l=t=>{switch(t){case\"float32\":return Float32Array;case\"uint8\":case\"bool\":return Uint8Array;case\"int8\":return Int8Array;case\"uint16\":return Uint16Array;case\"int16\":return Int16Array;case\"int32\":return Int32Array;case\"float64\":return Float64Array;case\"uint32\":return Uint32Array;case\"int64\":return BigInt64Array;case\"uint64\":return BigUint64Array;default:throw new Error(`unsupported type: ${t}`)}};e.run=(t,e,n,a,f)=>{const p=(0,o.getInstance)(),h=u.get(t);if(!h)throw new Error(\"invalid session id\");const d=h[0],y=h[1],b=h[2],m=e.length,g=a.length;let v=0,_=[];const w=[],O=[];try{[v,_]=(0,r.setRunOptions)(f);for(let t=0;t<m;t++){const e=n[t][0],r=n[t][1],a=n[t][2];let o,u;if(Array.isArray(a)){u=4*a.length,o=p._malloc(u),O.push(o);let t=o/4;for(let e=0;e<a.length;e++){if(\"string\"!=typeof a[e])throw new TypeError(`tensor data at index ${e} is not a string`);p.HEAPU32[t++]=(0,i.allocWasmString)(a[e],O)}}else u=a.byteLength,o=p._malloc(u),O.push(o),p.HEAPU8.set(new Uint8Array(a.buffer,a.byteOffset,u),o);const c=p.stackSave(),l=p.stackAlloc(4*r.length);try{let t=l/4;r.forEach((e=>p.HEAP32[t++]=e));const n=p._OrtCreateTensor(s(e),o,u,l,r.length);if(0===n)throw new Error(\"Can\\'t create a tensor\");w.push(n)}finally{p.stackRestore(c)}}const t=p.stackSave(),o=p.stackAlloc(4*m),u=p.stackAlloc(4*m),h=p.stackAlloc(4*g),A=p.stackAlloc(4*g);try{let n=o/4,r=u/4,i=h/4,s=A/4;for(let t=0;t<m;t++)p.HEAPU32[n++]=w[t],p.HEAPU32[r++]=y[e[t]];for(let t=0;t<g;t++)p.HEAPU32[i++]=0,p.HEAPU32[s++]=b[a[t]];let f=p._OrtRun(d,u,o,m,A,g,h,v);const _=[];if(0===f)for(let t=0;t<g;t++){const e=p.HEAPU32[h/4+t],n=p.stackSave(),r=p.stackAlloc(16);let a,i=0;try{if(f=p._OrtGetTensorData(e,r,r+4,r+8,r+12),0!==f)throw new Error(`Can\\'t access output tensor data. error code = ${f}`);let t=r/4;const o=p.HEAPU32[t++];i=p.HEAPU32[t++];const u=p.HEAPU32[t++],s=p.HEAPU32[t++],h=[];for(let t=0;t<s;t++)h.push(p.HEAPU32[u/4+t]);p._OrtFree(u);const d=0===h.length?1:h.reduce(((t,e)=>t*e));if(a=c(o),\"string\"===a){const t=[];let e=i/4;for(let n=0;n<d;n++){const r=p.HEAPU32[e++],a=n===d-1?void 0:p.HEAPU32[e]-r;t.push(p.UTF8ToString(r,a))}_.push([a,h,t])}else{const t=new(l(a))(d);new Uint8Array(t.buffer,t.byteOffset,t.byteLength).set(p.HEAPU8.subarray(i,i+t.byteLength)),_.push([a,h,t])}}finally{p.stackRestore(n),\"string\"===a&&i&&p._free(i),p._OrtReleaseTensor(e)}}if(0===f)return _;throw new Error(`failed to call OrtRun(). error code = ${f}.`)}finally{p.stackRestore(t)}}finally{w.forEach(p._OrtReleaseTensor),O.forEach(p._free),p._OrtReleaseRunOptions(v),_.forEach(p._free)}},e.endProfiling=t=>{const e=(0,o.getInstance)(),n=u.get(t);if(!n)throw new Error(\"invalid session id\");const r=n[0],a=e._OrtEndProfiling(r);if(0===a)throw new Error(\"Can\\'t get an profile file name\");e._OrtFree(a)},e.extractTransferableBuffers=t=>{const e=[];for(const n of t){const t=n[2];!Array.isArray(t)&&t.buffer&&e.push(t.buffer)}return e}},361:function(t,e,n){\"use strict\";var r=this&&this.__createBinding||(Object.create?function(t,e,n,r){void 0===r&&(r=n);var a=Object.getOwnPropertyDescriptor(e,n);a&&!(\"get\"in a?!e.__esModule:a.writable||a.configurable)||(a={enumerable:!0,get:function(){return e[n]}}),Object.defineProperty(t,r,a)}:function(t,e,n,r){void 0===r&&(r=n),t[r]=e[n]}),a=this&&this.__setModuleDefault||(Object.create?function(t,e){Object.defineProperty(t,\"default\",{enumerable:!0,value:e})}:function(t,e){t.default=e}),i=this&&this.__importStar||function(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var n in t)\"default\"!==n&&Object.prototype.hasOwnProperty.call(t,n)&&r(e,t,n);return a(e,t),e},o=this&&this.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(e,\"__esModule\",{value:!0}),e.dispose=e.getInstance=e.initializeWebAssembly=void 0;const u=i(n(17)),s=o(n(932)),c=n(474);let l,f=!1,p=!1,h=!1;const d=(t,e)=>e?t?\"ort-wasm-simd-threaded.wasm\":\"ort-wasm-threaded.wasm\":t?\"ort-wasm-simd.wasm\":\"ort-wasm.wasm\";e.initializeWebAssembly=async t=>{if(f)return Promise.resolve();if(p)throw new Error(\"multiple calls to \\'initializeWebAssembly()\\' detected.\");if(h)throw new Error(\"previous call to \\'initializeWebAssembly()\\' failed.\");p=!0;const e=t.initTimeout,r=t.numThreads,a=t.simd,i=r>1&&(()=>{try{return\"undefined\"!=typeof SharedArrayBuffer&&(\"undefined\"!=typeof MessageChannel&&(new MessageChannel).port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11])))}catch(t){return!1}})(),o=a&&(()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch(t){return!1}})(),y=\"string\"==typeof t.wasmPaths?t.wasmPaths:void 0,b=d(!1,i),m=d(o,i),g=\"object\"==typeof t.wasmPaths?t.wasmPaths[m]:void 0;let v=!1;const _=[];if(e>0&&_.push(new Promise((t=>{setTimeout((()=>{v=!0,t()}),e)}))),_.push(new Promise(((t,e)=>{const r=i?c:s.default,a={locateFile:(t,e)=>i&&t.endsWith(\".worker.js\")&&\"undefined\"!=typeof Blob?URL.createObjectURL(new Blob([n(154)],{type:\"text/javascript\"})):t===b?null!=g?g:(null!=y?y:e)+m:e+t};if(i)if(\"undefined\"==typeof Blob)a.mainScriptUrlOrBlob=u.join(__dirname,\"ort-wasm-threaded.js\");else{const t=`var ortWasmThreaded=(function(){var _scriptDir;return ${r.toString()}})();`;a.mainScriptUrlOrBlob=new Blob([t],{type:\"text/javascript\"})}r(a).then((e=>{p=!1,f=!0,l=e,t()}),(t=>{p=!1,h=!0,e(t)}))}))),await Promise.race(_),v)throw new Error(`WebAssembly backend initializing failed due to timeout: ${e}ms`)},e.getInstance=()=>{if(f&&l)return l;throw new Error(\"WebAssembly is not initialized yet.\")},e.dispose=()=>{var t;!f||p||h||(p=!0,null===(t=l.PThread)||void 0===t||t.terminateAllThreads(),l=void 0,p=!1,f=!1,h=!0)}},154:t=>{\"use strict\";t.exports=\\'\"use strict\";var e={},t=\"object\"==typeof process&&\"object\"==typeof process.versions&&\"string\"==typeof process.versions.node;if(t){var r=require(\"worker_threads\"),a=r.parentPort;a.on(\"message\",(e=>onmessage({data:e})));var o=require(\"fs\");Object.assign(global,{self:global,require:require,Module:e,location:{href:__filename},Worker:r.Worker,importScripts:function(e){(0,eval)(o.readFileSync(e,\"utf8\"))},postMessage:function(e){a.postMessage(e)},performance:global.performance||{now:function(){return Date.now()}}})}var s=!1,n=[],i=function(){var e=Array.prototype.slice.call(arguments).join(\" \");t?o.writeSync(2,e+\"\\\\\\\\n\"):console.error(e)};self.alert=function(){var t=Array.prototype.slice.call(arguments).join(\" \");postMessage({cmd:\"alert\",text:t,threadId:e._pthread_self()})},e.instantiateWasm=(t,r)=>{var a=new WebAssembly.Instance(e.wasmModule,t);return r(a),e.wasmModule=null,a.exports},self.onunhandledrejection=e=>{throw e.reason??e},self.onmessage=t=>{try{if(\"load\"===t.data.cmd){if(e.wasmModule=t.data.wasmModule,e.wasmMemory=t.data.wasmMemory,e.buffer=e.wasmMemory.buffer,e.ENVIRONMENT_IS_PTHREAD=!0,\"string\"==typeof t.data.urlOrBlob)importScripts(t.data.urlOrBlob);else{var r=URL.createObjectURL(t.data.urlOrBlob);importScripts(r),URL.revokeObjectURL(r)}ortWasmThreaded(e).then((function(t){e=t}))}else if(\"run\"===t.data.cmd){e.__performance_now_clock_drift=performance.now()-t.data.time,e.__emscripten_thread_init(t.data.pthread_ptr,0,0,1),e.establishStackSpace(),e.PThread.receiveObjectTransfer(t.data),e.PThread.threadInitTLS(),s||(n.forEach((t=>{e.executeNotifiedProxyingQueue(t)})),n=[],s=!0);try{e.invokeEntryPoint(t.data.start_routine,t.data.arg)}catch(t){if(\"unwind\"!=t){if(!(t instanceof e.ExitStatus))throw t;e.keepRuntimeAlive()||e.__emscripten_thread_exit(t.status)}}}else\"cancel\"===t.data.cmd?e._pthread_self()&&e.__emscripten_thread_exit(-1):\"setimmediate\"===t.data.target||(\"processProxyingQueue\"===t.data.cmd?s?e.executeNotifiedProxyingQueue(t.data.queue):n.push(t.data.queue):(i(\"worker.js received unknown command \"+t.data.cmd),i(t.data)))}catch(t){throw i(\"worker.js onmessage() captured an uncaught exception: \"+t),t&&t.stack&&i(t.stack),e.__emscripten_thread_crashed&&e.__emscripten_thread_crashed(),t}};\\\\n\\'},113:t=>{\"use strict\";t.exports=require(\"crypto\")},147:t=>{\"use strict\";t.exports=require(\"fs\")},37:t=>{\"use strict\";t.exports=require(\"os\")},17:t=>{\"use strict\";t.exports=require(\"path\")},74:t=>{\"use strict\";t.exports=require(\"perf_hooks\")},267:t=>{\"use strict\";t.exports=require(\"worker_threads\")}},e={};function n(r){var a=e[r];if(void 0!==a)return a.exports;var i=e[r]={exports:{}};return t[r].call(i.exports,i,i.exports,n),i.exports}(()=>{\"use strict\";const t=n(349),e=n(361);self.onmessage=n=>{switch(n.data.type){case\"init-wasm\":(0,e.initializeWebAssembly)(n.data.in).then((()=>postMessage({type:\"init-wasm\"})),(t=>postMessage({type:\"init-wasm\",err:t})));break;case\"init-ort\":try{const{numThreads:e,loggingLevel:r}=n.data.in;(0,t.initOrt)(e,r),postMessage({type:\"init-ort\"})}catch(t){postMessage({type:\"init-ort\",err:t})}break;case\"create_allocate\":try{const{model:e}=n.data.in,r=(0,t.createSessionAllocate)(e);postMessage({type:\"create_allocate\",out:r})}catch(t){postMessage({type:\"create_allocate\",err:t})}break;case\"create_finalize\":try{const{modeldata:e,options:r}=n.data.in,a=(0,t.createSessionFinalize)(e,r);postMessage({type:\"create_finalize\",out:a})}catch(t){postMessage({type:\"create_finalize\",err:t})}break;case\"create\":try{const{model:e,options:r}=n.data.in,a=(0,t.createSession)(e,r);postMessage({type:\"create\",out:a})}catch(t){postMessage({type:\"create\",err:t})}break;case\"release\":try{const e=n.data.in;(0,t.releaseSession)(e),postMessage({type:\"release\"})}catch(t){postMessage({type:\"release\",err:t})}break;case\"run\":try{const{sessionId:e,inputIndices:r,inputs:a,outputIndices:i,options:o}=n.data.in,u=(0,t.run)(e,r,a,i,o);postMessage({type:\"run\",out:u},(0,t.extractTransferableBuffers)(u))}catch(t){postMessage({type:\"run\",err:t})}break;case\"end-profiling\":try{const e=n.data.in;(0,t.endProfiling)(e),postMessage({type:\"end-profiling\"})}catch(t){postMessage({type:\"end-profiling\",err:t})}}}})()})();\\n', \"Worker\", void 0, void 0);\n            }\n        },\n        477: (t)=>{\n            \"use strict\";\n            t.exports = function(t, e, n, r) {\n                var i = self || window;\n                try {\n                    try {\n                        var o;\n                        try {\n                            o = new i.Blob([\n                                t\n                            ]);\n                        } catch (e) {\n                            (o = new (i.BlobBuilder || i.WebKitBlobBuilder || i.MozBlobBuilder || i.MSBlobBuilder)).append(t), o = o.getBlob();\n                        }\n                        var a = i.URL || i.webkitURL, s = a.createObjectURL(o), u = new i[e](s, n);\n                        return a.revokeObjectURL(s), u;\n                    } catch (r) {\n                        return new i[e](\"data:application/javascript,\".concat(encodeURIComponent(t)), n);\n                    }\n                } catch (t) {\n                    if (!r) throw Error(\"Inline worker is not supported\");\n                    return new i[e](r, n);\n                }\n            };\n        },\n        4154: (t)=>{\n            \"use strict\";\n            t.exports = '\"use strict\";var e={},t=\"object\"==typeof process&&\"object\"==typeof process.versions&&\"string\"==typeof process.versions.node;if(t){var r=require(\"worker_threads\"),a=r.parentPort;a.on(\"message\",(e=>onmessage({data:e})));var o=require(\"fs\");Object.assign(global,{self:global,require:require,Module:e,location:{href:__filename},Worker:r.Worker,importScripts:function(e){(0,eval)(o.readFileSync(e,\"utf8\"))},postMessage:function(e){a.postMessage(e)},performance:global.performance||{now:function(){return Date.now()}}})}var s=!1,n=[],i=function(){var e=Array.prototype.slice.call(arguments).join(\" \");t?o.writeSync(2,e+\"\\\\n\"):console.error(e)};self.alert=function(){var t=Array.prototype.slice.call(arguments).join(\" \");postMessage({cmd:\"alert\",text:t,threadId:e._pthread_self()})},e.instantiateWasm=(t,r)=>{var a=new WebAssembly.Instance(e.wasmModule,t);return r(a),e.wasmModule=null,a.exports},self.onunhandledrejection=e=>{throw e.reason??e},self.onmessage=t=>{try{if(\"load\"===t.data.cmd){if(e.wasmModule=t.data.wasmModule,e.wasmMemory=t.data.wasmMemory,e.buffer=e.wasmMemory.buffer,e.ENVIRONMENT_IS_PTHREAD=!0,\"string\"==typeof t.data.urlOrBlob)importScripts(t.data.urlOrBlob);else{var r=URL.createObjectURL(t.data.urlOrBlob);importScripts(r),URL.revokeObjectURL(r)}ortWasmThreaded(e).then((function(t){e=t}))}else if(\"run\"===t.data.cmd){e.__performance_now_clock_drift=performance.now()-t.data.time,e.__emscripten_thread_init(t.data.pthread_ptr,0,0,1),e.establishStackSpace(),e.PThread.receiveObjectTransfer(t.data),e.PThread.threadInitTLS(),s||(n.forEach((t=>{e.executeNotifiedProxyingQueue(t)})),n=[],s=!0);try{e.invokeEntryPoint(t.data.start_routine,t.data.arg)}catch(t){if(\"unwind\"!=t){if(!(t instanceof e.ExitStatus))throw t;e.keepRuntimeAlive()||e.__emscripten_thread_exit(t.status)}}}else\"cancel\"===t.data.cmd?e._pthread_self()&&e.__emscripten_thread_exit(-1):\"setimmediate\"===t.data.target||(\"processProxyingQueue\"===t.data.cmd?s?e.executeNotifiedProxyingQueue(t.data.queue):n.push(t.data.queue):(i(\"worker.js received unknown command \"+t.data.cmd),i(t.data)))}catch(t){throw i(\"worker.js onmessage() captured an uncaught exception: \"+t),t&&t.stack&&i(t.stack),e.__emscripten_thread_crashed&&e.__emscripten_thread_crashed(),t}};\\n';\n        },\n        6231: (t)=>{\n            \"use strict\";\n            t.exports = __webpack_require__(/*! fs */ \"fs\");\n        },\n        9719: (t)=>{\n            \"use strict\";\n            t.exports = __webpack_require__(/*! os */ \"os\");\n        },\n        1423: (t)=>{\n            \"use strict\";\n            t.exports = __webpack_require__(/*! path */ \"path\");\n        },\n        498: (t)=>{\n            \"use strict\";\n            t.exports = __webpack_require__(/*! perf_hooks */ \"perf_hooks\");\n        },\n        6464: (t)=>{\n            \"use strict\";\n            t.exports = __webpack_require__(/*! util */ \"util\");\n        },\n        4564: (t)=>{\n            \"use strict\";\n            t.exports = __webpack_require__(/*! worker_threads */ \"worker_threads\");\n        },\n        6207: (t)=>{\n            \"use strict\";\n            t.exports = __webpack_require__(/*! onnxruntime-common */ \"(ssr)/../node_modules/onnxruntime-common/dist/lib/index.js\");\n        },\n        6113: (t)=>{\n            \"use strict\";\n            t.exports = __webpack_require__(/*! crypto */ \"crypto\");\n        },\n        5686: (t, e, n)=>{\n            \"use strict\";\n            n.r(e), n.d(e, {\n                flatbuffers: ()=>r\n            });\n            var r = {};\n            r.Offset, r.Table, r.SIZEOF_SHORT = 2, r.SIZEOF_INT = 4, r.FILE_IDENTIFIER_LENGTH = 4, r.SIZE_PREFIX_LENGTH = 4, r.Encoding = {\n                UTF8_BYTES: 1,\n                UTF16_STRING: 2\n            }, r.int32 = new Int32Array(2), r.float32 = new Float32Array(r.int32.buffer), r.float64 = new Float64Array(r.int32.buffer), r.isLittleEndian = 1 === new Uint16Array(new Uint8Array([\n                1,\n                0\n            ]).buffer)[0], r.Long = function(t, e) {\n                this.low = 0 | t, this.high = 0 | e;\n            }, r.Long.create = function(t, e) {\n                return 0 == t && 0 == e ? r.Long.ZERO : new r.Long(t, e);\n            }, r.Long.prototype.toFloat64 = function() {\n                return (this.low >>> 0) + 4294967296 * this.high;\n            }, r.Long.prototype.equals = function(t) {\n                return this.low == t.low && this.high == t.high;\n            }, r.Long.ZERO = new r.Long(0, 0), r.Builder = function(t) {\n                if (t) e = t;\n                else var e = 1024;\n                this.bb = r.ByteBuffer.allocate(e), this.space = e, this.minalign = 1, this.vtable = null, this.vtable_in_use = 0, this.isNested = !1, this.object_start = 0, this.vtables = [], this.vector_num_elems = 0, this.force_defaults = !1;\n            }, r.Builder.prototype.clear = function() {\n                this.bb.clear(), this.space = this.bb.capacity(), this.minalign = 1, this.vtable = null, this.vtable_in_use = 0, this.isNested = !1, this.object_start = 0, this.vtables = [], this.vector_num_elems = 0, this.force_defaults = !1;\n            }, r.Builder.prototype.forceDefaults = function(t) {\n                this.force_defaults = t;\n            }, r.Builder.prototype.dataBuffer = function() {\n                return this.bb;\n            }, r.Builder.prototype.asUint8Array = function() {\n                return this.bb.bytes().subarray(this.bb.position(), this.bb.position() + this.offset());\n            }, r.Builder.prototype.prep = function(t, e) {\n                t > this.minalign && (this.minalign = t);\n                for(var n = 1 + ~(this.bb.capacity() - this.space + e) & t - 1; this.space < n + t + e;){\n                    var i = this.bb.capacity();\n                    this.bb = r.Builder.growByteBuffer(this.bb), this.space += this.bb.capacity() - i;\n                }\n                this.pad(n);\n            }, r.Builder.prototype.pad = function(t) {\n                for(var e = 0; e < t; e++)this.bb.writeInt8(--this.space, 0);\n            }, r.Builder.prototype.writeInt8 = function(t) {\n                this.bb.writeInt8(this.space -= 1, t);\n            }, r.Builder.prototype.writeInt16 = function(t) {\n                this.bb.writeInt16(this.space -= 2, t);\n            }, r.Builder.prototype.writeInt32 = function(t) {\n                this.bb.writeInt32(this.space -= 4, t);\n            }, r.Builder.prototype.writeInt64 = function(t) {\n                this.bb.writeInt64(this.space -= 8, t);\n            }, r.Builder.prototype.writeFloat32 = function(t) {\n                this.bb.writeFloat32(this.space -= 4, t);\n            }, r.Builder.prototype.writeFloat64 = function(t) {\n                this.bb.writeFloat64(this.space -= 8, t);\n            }, r.Builder.prototype.addInt8 = function(t) {\n                this.prep(1, 0), this.writeInt8(t);\n            }, r.Builder.prototype.addInt16 = function(t) {\n                this.prep(2, 0), this.writeInt16(t);\n            }, r.Builder.prototype.addInt32 = function(t) {\n                this.prep(4, 0), this.writeInt32(t);\n            }, r.Builder.prototype.addInt64 = function(t) {\n                this.prep(8, 0), this.writeInt64(t);\n            }, r.Builder.prototype.addFloat32 = function(t) {\n                this.prep(4, 0), this.writeFloat32(t);\n            }, r.Builder.prototype.addFloat64 = function(t) {\n                this.prep(8, 0), this.writeFloat64(t);\n            }, r.Builder.prototype.addFieldInt8 = function(t, e, n) {\n                (this.force_defaults || e != n) && (this.addInt8(e), this.slot(t));\n            }, r.Builder.prototype.addFieldInt16 = function(t, e, n) {\n                (this.force_defaults || e != n) && (this.addInt16(e), this.slot(t));\n            }, r.Builder.prototype.addFieldInt32 = function(t, e, n) {\n                (this.force_defaults || e != n) && (this.addInt32(e), this.slot(t));\n            }, r.Builder.prototype.addFieldInt64 = function(t, e, n) {\n                !this.force_defaults && e.equals(n) || (this.addInt64(e), this.slot(t));\n            }, r.Builder.prototype.addFieldFloat32 = function(t, e, n) {\n                (this.force_defaults || e != n) && (this.addFloat32(e), this.slot(t));\n            }, r.Builder.prototype.addFieldFloat64 = function(t, e, n) {\n                (this.force_defaults || e != n) && (this.addFloat64(e), this.slot(t));\n            }, r.Builder.prototype.addFieldOffset = function(t, e, n) {\n                (this.force_defaults || e != n) && (this.addOffset(e), this.slot(t));\n            }, r.Builder.prototype.addFieldStruct = function(t, e, n) {\n                e != n && (this.nested(e), this.slot(t));\n            }, r.Builder.prototype.nested = function(t) {\n                if (t != this.offset()) throw new Error(\"FlatBuffers: struct must be serialized inline.\");\n            }, r.Builder.prototype.notNested = function() {\n                if (this.isNested) throw new Error(\"FlatBuffers: object serialization must not be nested.\");\n            }, r.Builder.prototype.slot = function(t) {\n                this.vtable[t] = this.offset();\n            }, r.Builder.prototype.offset = function() {\n                return this.bb.capacity() - this.space;\n            }, r.Builder.growByteBuffer = function(t) {\n                var e = t.capacity();\n                if (3221225472 & e) throw new Error(\"FlatBuffers: cannot grow buffer beyond 2 gigabytes.\");\n                var n = e << 1, i = r.ByteBuffer.allocate(n);\n                return i.setPosition(n - e), i.bytes().set(t.bytes(), n - e), i;\n            }, r.Builder.prototype.addOffset = function(t) {\n                this.prep(r.SIZEOF_INT, 0), this.writeInt32(this.offset() - t + r.SIZEOF_INT);\n            }, r.Builder.prototype.startObject = function(t) {\n                this.notNested(), null == this.vtable && (this.vtable = []), this.vtable_in_use = t;\n                for(var e = 0; e < t; e++)this.vtable[e] = 0;\n                this.isNested = !0, this.object_start = this.offset();\n            }, r.Builder.prototype.endObject = function() {\n                if (null == this.vtable || !this.isNested) throw new Error(\"FlatBuffers: endObject called without startObject\");\n                this.addInt32(0);\n                for(var t = this.offset(), e = this.vtable_in_use - 1; e >= 0 && 0 == this.vtable[e]; e--);\n                for(var n = e + 1; e >= 0; e--)this.addInt16(0 != this.vtable[e] ? t - this.vtable[e] : 0);\n                this.addInt16(t - this.object_start);\n                var i = (n + 2) * r.SIZEOF_SHORT;\n                this.addInt16(i);\n                var o = 0, a = this.space;\n                t: for(e = 0; e < this.vtables.length; e++){\n                    var s = this.bb.capacity() - this.vtables[e];\n                    if (i == this.bb.readInt16(s)) {\n                        for(var u = r.SIZEOF_SHORT; u < i; u += r.SIZEOF_SHORT)if (this.bb.readInt16(a + u) != this.bb.readInt16(s + u)) continue t;\n                        o = this.vtables[e];\n                        break;\n                    }\n                }\n                return o ? (this.space = this.bb.capacity() - t, this.bb.writeInt32(this.space, o - t)) : (this.vtables.push(this.offset()), this.bb.writeInt32(this.bb.capacity() - t, this.offset() - t)), this.isNested = !1, t;\n            }, r.Builder.prototype.finish = function(t, e, n) {\n                var i = n ? r.SIZE_PREFIX_LENGTH : 0;\n                if (e) {\n                    var o = e;\n                    if (this.prep(this.minalign, r.SIZEOF_INT + r.FILE_IDENTIFIER_LENGTH + i), o.length != r.FILE_IDENTIFIER_LENGTH) throw new Error(\"FlatBuffers: file identifier must be length \" + r.FILE_IDENTIFIER_LENGTH);\n                    for(var a = r.FILE_IDENTIFIER_LENGTH - 1; a >= 0; a--)this.writeInt8(o.charCodeAt(a));\n                }\n                this.prep(this.minalign, r.SIZEOF_INT + i), this.addOffset(t), i && this.addInt32(this.bb.capacity() - this.space), this.bb.setPosition(this.space);\n            }, r.Builder.prototype.finishSizePrefixed = function(t, e) {\n                this.finish(t, e, !0);\n            }, r.Builder.prototype.requiredField = function(t, e) {\n                var n = this.bb.capacity() - t, r = n - this.bb.readInt32(n);\n                if (0 == this.bb.readInt16(r + e)) throw new Error(\"FlatBuffers: field \" + e + \" must be set\");\n            }, r.Builder.prototype.startVector = function(t, e, n) {\n                this.notNested(), this.vector_num_elems = e, this.prep(r.SIZEOF_INT, t * e), this.prep(n, t * e);\n            }, r.Builder.prototype.endVector = function() {\n                return this.writeInt32(this.vector_num_elems), this.offset();\n            }, r.Builder.prototype.createString = function(t) {\n                if (t instanceof Uint8Array) var e = t;\n                else {\n                    e = [];\n                    for(var n = 0; n < t.length;){\n                        var r, i = t.charCodeAt(n++);\n                        (r = i < 55296 || i >= 56320 ? i : (i << 10) + t.charCodeAt(n++) + -56613888) < 128 ? e.push(r) : (r < 2048 ? e.push(r >> 6 & 31 | 192) : (r < 65536 ? e.push(r >> 12 & 15 | 224) : e.push(r >> 18 & 7 | 240, r >> 12 & 63 | 128), e.push(r >> 6 & 63 | 128)), e.push(63 & r | 128));\n                    }\n                }\n                this.addInt8(0), this.startVector(1, e.length, 1), this.bb.setPosition(this.space -= e.length), n = 0;\n                for(var o = this.space, a = this.bb.bytes(); n < e.length; n++)a[o++] = e[n];\n                return this.endVector();\n            }, r.Builder.prototype.createLong = function(t, e) {\n                return r.Long.create(t, e);\n            }, r.ByteBuffer = function(t) {\n                this.bytes_ = t, this.position_ = 0;\n            }, r.ByteBuffer.allocate = function(t) {\n                return new r.ByteBuffer(new Uint8Array(t));\n            }, r.ByteBuffer.prototype.clear = function() {\n                this.position_ = 0;\n            }, r.ByteBuffer.prototype.bytes = function() {\n                return this.bytes_;\n            }, r.ByteBuffer.prototype.position = function() {\n                return this.position_;\n            }, r.ByteBuffer.prototype.setPosition = function(t) {\n                this.position_ = t;\n            }, r.ByteBuffer.prototype.capacity = function() {\n                return this.bytes_.length;\n            }, r.ByteBuffer.prototype.readInt8 = function(t) {\n                return this.readUint8(t) << 24 >> 24;\n            }, r.ByteBuffer.prototype.readUint8 = function(t) {\n                return this.bytes_[t];\n            }, r.ByteBuffer.prototype.readInt16 = function(t) {\n                return this.readUint16(t) << 16 >> 16;\n            }, r.ByteBuffer.prototype.readUint16 = function(t) {\n                return this.bytes_[t] | this.bytes_[t + 1] << 8;\n            }, r.ByteBuffer.prototype.readInt32 = function(t) {\n                return this.bytes_[t] | this.bytes_[t + 1] << 8 | this.bytes_[t + 2] << 16 | this.bytes_[t + 3] << 24;\n            }, r.ByteBuffer.prototype.readUint32 = function(t) {\n                return this.readInt32(t) >>> 0;\n            }, r.ByteBuffer.prototype.readInt64 = function(t) {\n                return new r.Long(this.readInt32(t), this.readInt32(t + 4));\n            }, r.ByteBuffer.prototype.readUint64 = function(t) {\n                return new r.Long(this.readUint32(t), this.readUint32(t + 4));\n            }, r.ByteBuffer.prototype.readFloat32 = function(t) {\n                return r.int32[0] = this.readInt32(t), r.float32[0];\n            }, r.ByteBuffer.prototype.readFloat64 = function(t) {\n                return r.int32[r.isLittleEndian ? 0 : 1] = this.readInt32(t), r.int32[r.isLittleEndian ? 1 : 0] = this.readInt32(t + 4), r.float64[0];\n            }, r.ByteBuffer.prototype.writeInt8 = function(t, e) {\n                this.bytes_[t] = e;\n            }, r.ByteBuffer.prototype.writeUint8 = function(t, e) {\n                this.bytes_[t] = e;\n            }, r.ByteBuffer.prototype.writeInt16 = function(t, e) {\n                this.bytes_[t] = e, this.bytes_[t + 1] = e >> 8;\n            }, r.ByteBuffer.prototype.writeUint16 = function(t, e) {\n                this.bytes_[t] = e, this.bytes_[t + 1] = e >> 8;\n            }, r.ByteBuffer.prototype.writeInt32 = function(t, e) {\n                this.bytes_[t] = e, this.bytes_[t + 1] = e >> 8, this.bytes_[t + 2] = e >> 16, this.bytes_[t + 3] = e >> 24;\n            }, r.ByteBuffer.prototype.writeUint32 = function(t, e) {\n                this.bytes_[t] = e, this.bytes_[t + 1] = e >> 8, this.bytes_[t + 2] = e >> 16, this.bytes_[t + 3] = e >> 24;\n            }, r.ByteBuffer.prototype.writeInt64 = function(t, e) {\n                this.writeInt32(t, e.low), this.writeInt32(t + 4, e.high);\n            }, r.ByteBuffer.prototype.writeUint64 = function(t, e) {\n                this.writeUint32(t, e.low), this.writeUint32(t + 4, e.high);\n            }, r.ByteBuffer.prototype.writeFloat32 = function(t, e) {\n                r.float32[0] = e, this.writeInt32(t, r.int32[0]);\n            }, r.ByteBuffer.prototype.writeFloat64 = function(t, e) {\n                r.float64[0] = e, this.writeInt32(t, r.int32[r.isLittleEndian ? 0 : 1]), this.writeInt32(t + 4, r.int32[r.isLittleEndian ? 1 : 0]);\n            }, r.ByteBuffer.prototype.getBufferIdentifier = function() {\n                if (this.bytes_.length < this.position_ + r.SIZEOF_INT + r.FILE_IDENTIFIER_LENGTH) throw new Error(\"FlatBuffers: ByteBuffer is too short to contain an identifier.\");\n                for(var t = \"\", e = 0; e < r.FILE_IDENTIFIER_LENGTH; e++)t += String.fromCharCode(this.readInt8(this.position_ + r.SIZEOF_INT + e));\n                return t;\n            }, r.ByteBuffer.prototype.__offset = function(t, e) {\n                var n = t - this.readInt32(t);\n                return e < this.readInt16(n) ? this.readInt16(n + e) : 0;\n            }, r.ByteBuffer.prototype.__union = function(t, e) {\n                return t.bb_pos = e + this.readInt32(e), t.bb = this, t;\n            }, r.ByteBuffer.prototype.__string = function(t, e) {\n                t += this.readInt32(t);\n                var n = this.readInt32(t), i = \"\", o = 0;\n                if (t += r.SIZEOF_INT, e === r.Encoding.UTF8_BYTES) return this.bytes_.subarray(t, t + n);\n                for(; o < n;){\n                    var a, s = this.readUint8(t + o++);\n                    if (s < 192) a = s;\n                    else {\n                        var u = this.readUint8(t + o++);\n                        if (s < 224) a = (31 & s) << 6 | 63 & u;\n                        else {\n                            var c = this.readUint8(t + o++);\n                            a = s < 240 ? (15 & s) << 12 | (63 & u) << 6 | 63 & c : (7 & s) << 18 | (63 & u) << 12 | (63 & c) << 6 | 63 & this.readUint8(t + o++);\n                        }\n                    }\n                    a < 65536 ? i += String.fromCharCode(a) : (a -= 65536, i += String.fromCharCode(55296 + (a >> 10), 56320 + (1023 & a)));\n                }\n                return i;\n            }, r.ByteBuffer.prototype.__indirect = function(t) {\n                return t + this.readInt32(t);\n            }, r.ByteBuffer.prototype.__vector = function(t) {\n                return t + this.readInt32(t) + r.SIZEOF_INT;\n            }, r.ByteBuffer.prototype.__vector_len = function(t) {\n                return this.readInt32(t + this.readInt32(t));\n            }, r.ByteBuffer.prototype.__has_identifier = function(t) {\n                if (t.length != r.FILE_IDENTIFIER_LENGTH) throw new Error(\"FlatBuffers: file identifier must be length \" + r.FILE_IDENTIFIER_LENGTH);\n                for(var e = 0; e < r.FILE_IDENTIFIER_LENGTH; e++)if (t.charCodeAt(e) != this.readInt8(this.position_ + r.SIZEOF_INT + e)) return !1;\n                return !0;\n            }, r.ByteBuffer.prototype.createLong = function(t, e) {\n                return r.Long.create(t, e);\n            };\n        }\n    }, __webpack_module_cache__ = {};\n    function __nested_webpack_require_934761__(t) {\n        var e = __webpack_module_cache__[t];\n        if (void 0 !== e) return e.exports;\n        var n = __webpack_module_cache__[t] = {\n            exports: {}\n        };\n        return __webpack_modules__[t].call(n.exports, n, n.exports, __nested_webpack_require_934761__), n.exports;\n    }\n    __nested_webpack_require_934761__.n = (t)=>{\n        var e = t && t.__esModule ? ()=>t.default : ()=>t;\n        return __nested_webpack_require_934761__.d(e, {\n            a: e\n        }), e;\n    }, __nested_webpack_require_934761__.d = (t, e)=>{\n        for(var n in e)__nested_webpack_require_934761__.o(e, n) && !__nested_webpack_require_934761__.o(t, n) && Object.defineProperty(t, n, {\n            enumerable: !0,\n            get: e[n]\n        });\n    }, __nested_webpack_require_934761__.o = (t, e)=>Object.prototype.hasOwnProperty.call(t, e), __nested_webpack_require_934761__.r = (t)=>{\n        \"undefined\" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, {\n            value: \"Module\"\n        }), Object.defineProperty(t, \"__esModule\", {\n            value: !0\n        });\n    };\n    var __nested_webpack_exports__ = __nested_webpack_require_934761__(6018), __webpack_export_target__ = exports;\n    for(var i in __nested_webpack_exports__)__webpack_export_target__[i] = __nested_webpack_exports__[i];\n    __nested_webpack_exports__.__esModule && Object.defineProperty(__webpack_export_target__, \"__esModule\", {\n        value: !0\n    });\n})(); //# sourceMappingURL=ort-web.node.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL29ubnhydW50aW1lLXdlYi9kaXN0L29ydC13ZWIubm9kZS5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7OztBQUlBLEdBQ0M7SUFBSyxJQUFJQSxzQkFBb0I7UUFBQyxNQUFLLENBQUNDLEdBQUVDLEdBQUVDO1lBQUssSUFBSUMsWUFBV0MsSUFBR0QsQ0FBQUEsYUFBVyxDQUFDQSxhQUFXLGVBQWEsT0FBT0UsWUFBVUEsU0FBU0MsYUFBYSxHQUFDRCxTQUFTQyxhQUFhLENBQUNDLEdBQUcsR0FBQyxLQUFLLE1BQUlDLFlBQVcsU0FBU1IsQ0FBQztnQkFBRSxTQUFTQztvQkFBSSxPQUFPUSxFQUFFQyxNQUFNLElBQUVDLEtBQUdDLEVBQUVILEVBQUVDLE1BQU0sR0FBRUc7Z0JBQUM7Z0JBQUMsU0FBU1Q7b0JBQUksT0FBT0ssRUFBRUMsTUFBTSxJQUFFQyxLQUFHQyxFQUFFSCxFQUFFQyxNQUFNLEdBQUVJO2dCQUFDO2dCQUFDLFNBQVNDO29CQUFJLE9BQU9OLEVBQUVDLE1BQU0sSUFBRUMsS0FBR0MsRUFBRUgsRUFBRUMsTUFBTSxHQUFFTTtnQkFBQztnQkFBQyxTQUFTQztvQkFBSSxPQUFPUixFQUFFQyxNQUFNLElBQUVDLEtBQUdDLEVBQUVILEVBQUVDLE1BQU0sR0FBRVE7Z0JBQUM7Z0JBQUMsU0FBU0M7b0JBQUksT0FBT1YsRUFBRUMsTUFBTSxJQUFFQyxLQUFHQyxFQUFFSCxFQUFFQyxNQUFNLEdBQUVVO2dCQUFDO2dCQUFDLElBQUlDLEdBQUVDLEdBQUVDO2dCQUFFdkIsSUFBRUEsS0FBRyxDQUFDLEdBQUVxQixLQUFJQSxDQUFBQSxJQUFFLEtBQUssTUFBSXJCLElBQUVBLElBQUUsQ0FBQyxJQUFHcUIsRUFBRUcsS0FBSyxHQUFDLElBQUlDLFFBQVMsU0FBU3pCLENBQUMsRUFBQ0MsQ0FBQztvQkFBRXFCLElBQUV0QixHQUFFdUIsSUFBRXRCO2dCQUFDO2dCQUFJLElBQUl5QixHQUFFQyxHQUFFQyxHQUFFQyxHQUFFQyxH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QUFFNm1CLElBQUksR0FBQzVtQjtRQUFDO1FBQUUsTUFBS0YsQ0FBQUE7WUFBSUEsRUFBRWljLE9BQU8sR0FBQy9iO1lBQUUsSUFBSUQsSUFBRTtZQUFLLElBQUc7Z0JBQUNBLElBQUUsSUFBSW9HLFlBQVkwZ0IsUUFBUSxDQUFDLElBQUkxZ0IsWUFBWTJnQixNQUFNLENBQUMsSUFBSTNqQixXQUFXO29CQUFDO29CQUFFO29CQUFHO29CQUFJO29CQUFJO29CQUFFO29CQUFFO29CQUFFO29CQUFFO29CQUFFO29CQUFHO29CQUFFO29CQUFHO29CQUFFO29CQUFFO29CQUFJO29CQUFHO29CQUFFO29CQUFJO29CQUFJO29CQUFJO29CQUFJO29CQUFFO29CQUFJO29CQUFFO29CQUFFO29CQUFFO29CQUFFO29CQUFFO29CQUFFO29CQUFFO29CQUFFO29CQUFFO29CQUFFO29CQUFFO29CQUFFO29CQUFJO29CQUFFO29CQUFHO29CQUFFO29CQUFHO29CQUFFO29CQUFHO29CQUFFO29CQUFFO29CQUFJO29CQUFJO29CQUFJO29CQUFFO29CQUFFO29CQUFFO29CQUFJO29CQUFJO29CQUFJO29CQUFHO29CQUFJO29CQUFFO29CQUFFO29CQUFFO29CQUFJO29CQUFJO29CQUFJO29CQUFHO29CQUFJO29CQUFFO29CQUFFO29CQUFFO29CQUFJO29CQUFJO29CQUFJO29CQUFHO29CQUFJO29CQUFFO29CQUFFO29CQUFFO29CQUFJO29CQUFJO29CQUFJO29CQUFHO29CQUFJO29CQUFFO29CQUFFO29CQUFFO29CQUFJO29CQUFJO29CQUFJO29CQUFHO29CQUFJO29CQUFJO29CQUFJO29CQUFJO29CQUFFO29CQUFFO29CQUFHO29CQUFJO29CQUFFO29CQUFFO29CQUFFO29CQUFFO29CQUFHO29CQUFFO29CQUFHO29CQUFHO29CQUFFO29CQUFFO29CQUFJO29CQUFHO29CQUFFO29CQUFJO29CQUFHO29CQUFFO29CQUFJO29CQUFHO29CQUFHO29CQUFJO29CQUFJO29CQUFHO29CQUFFO29CQUFJO29CQUFHO29CQUFFO29CQUFJO29CQUFHO29CQUFHO29CQUFJO29CQUFJO29CQUFJO29CQUFHO29CQUFFO29CQUFHO29CQUFHO29CQUFJO29CQUFJO29CQUFHO29CQUFFO29CQUFHO29CQUFFO29CQUFJO29CQUFHO29CQUFHO29CQUFFO29CQUFFO29CQUFJO29CQUFHO29CQUFFO29CQUFJO29CQUFHO29CQUFFO29CQUFJO29CQUFHO29CQUFHO29CQUFJO29CQUFJO29CQUFHO29CQUFFO29CQUFJO29CQUFHO29CQUFFO29CQUFJO29CQUFHO29CQUFHO29CQUFJO29CQUFJO29CQUFJO29CQUFHO29CQUFFO29CQUFHO29CQUFHO29CQUFJO29CQUFJO29CQUFHO29CQUFFO29CQUFHO29CQUFFO29CQUFJO29CQUFHO29CQUFHO29CQUFFO29CQUFFO29CQUFJO29CQUFHO29CQUFFO29CQUFJO29CQUFHO29CQUFFO29CQUFJO29CQUFHO29CQUFHO29CQUFJO29CQUFJO29CQUFHO29CQUFFO29CQUFJO29CQUFHO29CQUFFO29CQUFJO29CQUFHO29CQUFHO29CQUFJO29CQUFJO29CQUFJO29CQUFHO29CQUFFO29CQUFHO29CQUFHO29CQUFJO29CQUFJO29CQUFHO29CQUFFO29CQUFHO29CQUFFO29CQUFJO29CQUFHO29CQUFHO29CQUFFO29CQUFFO29CQUFJO29CQUFHO29CQUFFO29CQUFJO29CQUFHO29CQUFFO29CQUFJO29CQUFHO29CQUFHO29CQUFJO29CQUFJO29CQUFHO29CQUFFO29CQUFJO29CQUFHO29CQUFFO29CQUFJO29CQUFHO29CQUFHO29CQUFJO29CQUFJO29CQUFJO29CQUFHO29CQUFFO29CQUFHO29CQUFHO29CQUFJO29CQUFJO29CQUFHO29CQUFFO29CQUFHO29CQUFFO29CQUFJO29CQUFHO29CQUFHO29CQUFFO29CQUFFO29CQUFJO29CQUFHO29CQUFFO29CQUFJO29CQUFHO29CQUFFO29CQUFJO29CQUFHO29CQUFHO29CQUFJO29CQUFJO29CQUFHO29CQUFFO29CQUFJO29CQUFHO29CQUFFO29CQUFJO29CQUFHO29CQUFH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T0FBT0MsV0FBVyxJQUFFM3BFLE9BQU9vbEIsY0FBYyxDQUFDcm5CLEdBQUUyckUsT0FBT0MsV0FBVyxFQUFDO1lBQUMzbEQsT0FBTTtRQUFRLElBQUdoa0IsT0FBT29sQixjQUFjLENBQUNybkIsR0FBRSxjQUFhO1lBQUNpbUIsT0FBTSxDQUFDO1FBQUM7SUFBRTtJQUFFLElBQUk0bEQsMEJBQW1CQSxHQUFDSCxpQ0FBbUJBLENBQUMsT0FBTUksNEJBQTBCN3ZEO0lBQVEsSUFBSSxJQUFJbGIsS0FBSzhxRSwwQkFBbUJBLENBQUNDLHlCQUF5QixDQUFDL3FFLEVBQUUsR0FBQzhxRSwwQkFBbUIsQ0FBQzlxRSxFQUFFO0lBQUM4cUUsMEJBQW1CQSxDQUFDOWxELFVBQVUsSUFBRTlqQixPQUFPb2xCLGNBQWMsQ0FBQ3lrRCwyQkFBMEIsY0FBYTtRQUFDN2xELE9BQU0sQ0FBQztJQUFDO0FBQUUsTUFDamh0aEIsd0NBQXdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vanN2b2ljZS1kZW1vLy4uL25vZGVfbW9kdWxlcy9vbm54cnVudGltZS13ZWIvZGlzdC9vcnQtd2ViLm5vZGUuanM/MDhlNSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiogT05OWCBSdW50aW1lIFdlYiB2MS4xNC4wXG4qIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4qL1xuKCgpPT57dmFyIF9fd2VicGFja19tb2R1bGVzX189ezM0NzQ6KHQsZSxuKT0+e3ZhciBfc2NyaXB0RGlyLHI9KF9zY3JpcHREaXI9KF9zY3JpcHREaXI9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGRvY3VtZW50JiZkb2N1bWVudC5jdXJyZW50U2NyaXB0P2RvY3VtZW50LmN1cnJlbnRTY3JpcHQuc3JjOnZvaWQgMCl8fF9fZmlsZW5hbWUsZnVuY3Rpb24odCl7ZnVuY3Rpb24gZSgpe3JldHVybiAkLmJ1ZmZlciE9QyYmSCgkLmJ1ZmZlciksRn1mdW5jdGlvbiByKCl7cmV0dXJuICQuYnVmZmVyIT1DJiZIKCQuYnVmZmVyKSxOfWZ1bmN0aW9uIGkoKXtyZXR1cm4gJC5idWZmZXIhPUMmJkgoJC5idWZmZXIpLFJ9ZnVuY3Rpb24gbygpe3JldHVybiAkLmJ1ZmZlciE9QyYmSCgkLmJ1ZmZlciksTH1mdW5jdGlvbiBhKCl7cmV0dXJuICQuYnVmZmVyIT1DJiZIKCQuYnVmZmVyKSxNfXZhciBzLHUsYzt0PXR8fHt9LHN8fChzPXZvaWQgMCE9PXQ/dDp7fSkscy5yZWFkeT1uZXcgUHJvbWlzZSgoZnVuY3Rpb24odCxlKXt1PXQsYz1lfSkpO3ZhciBsLHAsZixkLGgsZyxiPU9iamVjdC5hc3NpZ24oe30scyksbT1cIi4vdGhpcy5wcm9ncmFtXCIseT0odCxlKT0+e3Rocm93IGV9LF89XCJvYmplY3RcIj09dHlwZW9mIHdpbmRvdyx2PVwiZnVuY3Rpb25cIj09dHlwZW9mIGltcG9ydFNjcmlwdHMsdz1cIm9iamVjdFwiPT10eXBlb2YgcHJvY2VzcyYmXCJvYmplY3RcIj09dHlwZW9mIHByb2Nlc3MudmVyc2lvbnMmJlwic3RyaW5nXCI9PXR5cGVvZiBwcm9jZXNzLnZlcnNpb25zLm5vZGUseD1zLkVOVklST05NRU5UX0lTX1BUSFJFQUR8fCExLFQ9XCJcIjtmdW5jdGlvbiBTKHQpe3JldHVybiBzLmxvY2F0ZUZpbGU/cy5sb2NhdGVGaWxlKHQsVCk6VCt0fWlmKHcpe2xldCBlO1Q9dj9uKDE0MjMpLmRpcm5hbWUoVCkrXCIvXCI6X19kaXJuYW1lK1wiL1wiLGc9KCk9PntofHwoZD1uKDYyMzEpLGg9bigxNDIzKSl9LGw9ZnVuY3Rpb24odCxlKXtyZXR1cm4gZygpLHQ9aC5ub3JtYWxpemUodCksZC5yZWFkRmlsZVN5bmModCxlP3ZvaWQgMDpcInV0ZjhcIil9LGY9dD0+KCh0PWwodCwhMCkpLmJ1ZmZlcnx8KHQ9bmV3IFVpbnQ4QXJyYXkodCkpLHQpLHA9KHQsZSxuKT0+e2coKSx0PWgubm9ybWFsaXplKHQpLGQucmVhZEZpbGUodCwoZnVuY3Rpb24odCxyKXt0P24odCk6ZShyLmJ1ZmZlcil9KSl9LDE8cHJvY2Vzcy5hcmd2Lmxlbmd0aCYmKG09cHJvY2Vzcy5hcmd2WzFdLnJlcGxhY2UoL1xcXFwvZyxcIi9cIikpLHByb2Nlc3MuYXJndi5zbGljZSgyKSxwcm9jZXNzLm9uKFwidW5jYXVnaHRFeGNlcHRpb25cIiwoZnVuY3Rpb24odCl7aWYoISh0IGluc3RhbmNlb2YgdXQpKXRocm93IHR9KSkscHJvY2Vzcy5vbihcInVuaGFuZGxlZFJlamVjdGlvblwiLChmdW5jdGlvbih0KXt0aHJvdyB0fSkpLHk9KHQsZSk9PntpZihKKCkpdGhyb3cgcHJvY2Vzcy5leGl0Q29kZT10LGU7ZSBpbnN0YW5jZW9mIHV0fHxQKFwiZXhpdGluZyBkdWUgdG8gZXhjZXB0aW9uOiBcIitlKSxwcm9jZXNzLmV4aXQodCl9LHMuaW5zcGVjdD1mdW5jdGlvbigpe3JldHVyblwiW0Vtc2NyaXB0ZW4gTW9kdWxlIG9iamVjdF1cIn07dHJ5e2U9big0NTY0KX1jYXRjaCh0KXt0aHJvdyBjb25zb2xlLmVycm9yKCdUaGUgXCJ3b3JrZXJfdGhyZWFkc1wiIG1vZHVsZSBpcyBub3Qgc3VwcG9ydGVkIGluIHRoaXMgbm9kZS5qcyBidWlsZCAtIHBlcmhhcHMgYSBuZXdlciB2ZXJzaW9uIGlzIG5lZWRlZD8nKSx0fWdsb2JhbC5Xb3JrZXI9ZS5Xb3JrZXJ9ZWxzZShffHx2KSYmKHY/VD1zZWxmLmxvY2F0aW9uLmhyZWY6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGRvY3VtZW50JiZkb2N1bWVudC5jdXJyZW50U2NyaXB0JiYoVD1kb2N1bWVudC5jdXJyZW50U2NyaXB0LnNyYyksX3NjcmlwdERpciYmKFQ9X3NjcmlwdERpciksVD0wIT09VC5pbmRleE9mKFwiYmxvYjpcIik/VC5zdWJzdHIoMCxULnJlcGxhY2UoL1s/I10uKi8sXCJcIikubGFzdEluZGV4T2YoXCIvXCIpKzEpOlwiXCIsd3x8KGw9dD0+e3ZhciBlPW5ldyBYTUxIdHRwUmVxdWVzdDtyZXR1cm4gZS5vcGVuKFwiR0VUXCIsdCwhMSksZS5zZW5kKG51bGwpLGUucmVzcG9uc2VUZXh0fSx2JiYoZj10PT57dmFyIGU9bmV3IFhNTEh0dHBSZXF1ZXN0O3JldHVybiBlLm9wZW4oXCJHRVRcIix0LCExKSxlLnJlc3BvbnNlVHlwZT1cImFycmF5YnVmZmVyXCIsZS5zZW5kKG51bGwpLG5ldyBVaW50OEFycmF5KGUucmVzcG9uc2UpfSkscD0odCxlLG4pPT57dmFyIHI9bmV3IFhNTEh0dHBSZXF1ZXN0O3Iub3BlbihcIkdFVFwiLHQsITApLHIucmVzcG9uc2VUeXBlPVwiYXJyYXlidWZmZXJcIixyLm9ubG9hZD0oKT0+ezIwMD09ci5zdGF0dXN8fDA9PXIuc3RhdHVzJiZyLnJlc3BvbnNlP2Uoci5yZXNwb25zZSk6bigpfSxyLm9uZXJyb3I9bixyLnNlbmQobnVsbCl9KSk7dyYmXCJ1bmRlZmluZWRcIj09dHlwZW9mIHBlcmZvcm1hbmNlJiYoZ2xvYmFsLnBlcmZvcm1hbmNlPW4oNDk4KS5wZXJmb3JtYW5jZSk7dmFyIE89Y29uc29sZS5sb2cuYmluZChjb25zb2xlKSxBPWNvbnNvbGUud2Fybi5iaW5kKGNvbnNvbGUpO3cmJihnKCksTz10PT5kLndyaXRlU3luYygxLHQrXCJcXG5cIiksQT10PT5kLndyaXRlU3luYygyLHQrXCJcXG5cIikpO3ZhciBFLEk9cy5wcmludHx8TyxQPXMucHJpbnRFcnJ8fEE7T2JqZWN0LmFzc2lnbihzLGIpLGI9bnVsbCxzLnRoaXNQcm9ncmFtJiYobT1zLnRoaXNQcm9ncmFtKSxzLnF1aXQmJih5PXMucXVpdCkscy53YXNtQmluYXJ5JiYoRT1zLndhc21CaW5hcnkpO3ZhciBEPXMubm9FeGl0UnVudGltZXx8ITE7XCJvYmplY3RcIiE9dHlwZW9mIFdlYkFzc2VtYmx5JiZpdChcIm5vIG5hdGl2ZSB3YXNtIHN1cHBvcnQgZGV0ZWN0ZWRcIik7dmFyICQsayxDLEYsTixSLEwsTSxqPSExLFU9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIFRleHREZWNvZGVyP25ldyBUZXh0RGVjb2RlcihcInV0ZjhcIik6dm9pZCAwO2Z1bmN0aW9uIFYodCxlLG4pe3ZhciByPShlPj4+PTApK247Zm9yKG49ZTt0W25dJiYhKG4+PXIpOykrK247aWYoMTY8bi1lJiZ0LmJ1ZmZlciYmVSlyZXR1cm4gVS5kZWNvZGUodC5idWZmZXIgaW5zdGFuY2VvZiBTaGFyZWRBcnJheUJ1ZmZlcj90LnNsaWNlKGUsbik6dC5zdWJhcnJheShlLG4pKTtmb3Iocj1cIlwiO2U8bjspe3ZhciBpPXRbZSsrXTtpZigxMjgmaSl7dmFyIG89NjMmdFtlKytdO2lmKDE5Mj09KDIyNCZpKSlyKz1TdHJpbmcuZnJvbUNoYXJDb2RlKCgzMSZpKTw8NnxvKTtlbHNle3ZhciBhPTYzJnRbZSsrXTs2NTUzNj4oaT0yMjQ9PSgyNDAmaSk/KDE1JmkpPDwxMnxvPDw2fGE6KDcmaSk8PDE4fG88PDEyfGE8PDZ8NjMmdFtlKytdKT9yKz1TdHJpbmcuZnJvbUNoYXJDb2RlKGkpOihpLT02NTUzNixyKz1TdHJpbmcuZnJvbUNoYXJDb2RlKDU1Mjk2fGk+PjEwLDU2MzIwfDEwMjMmaSkpfX1lbHNlIHIrPVN0cmluZy5mcm9tQ2hhckNvZGUoaSl9cmV0dXJuIHJ9ZnVuY3Rpb24gQih0LGUpe3JldHVybih0Pj4+PTApP1YocigpLHQsZSk6XCJcIn1mdW5jdGlvbiB6KHQsZSxuLHIpe2lmKCEoMDxyKSlyZXR1cm4gMDt2YXIgaT1uPj4+PTA7cj1uK3ItMTtmb3IodmFyIG89MDtvPHQubGVuZ3RoOysrbyl7dmFyIGE9dC5jaGFyQ29kZUF0KG8pO2lmKDU1Mjk2PD1hJiY1NzM0Mz49YSYmKGE9NjU1MzYrKCgxMDIzJmEpPDwxMCl8MTAyMyZ0LmNoYXJDb2RlQXQoKytvKSksMTI3Pj1hKXtpZihuPj1yKWJyZWFrO2VbbisrPj4+MF09YX1lbHNle2lmKDIwNDc+PWEpe2lmKG4rMT49cilicmVhaztlW24rKz4+PjBdPTE5MnxhPj42fWVsc2V7aWYoNjU1MzU+PWEpe2lmKG4rMj49cilicmVhaztlW24rKz4+PjBdPTIyNHxhPj4xMn1lbHNle2lmKG4rMz49cilicmVhaztlW24rKz4+PjBdPTI0MHxhPj4xOCxlW24rKz4+PjBdPTEyOHxhPj4xMiY2M31lW24rKz4+PjBdPTEyOHxhPj42JjYzfWVbbisrPj4+MF09MTI4fDYzJmF9fXJldHVybiBlW24+Pj4wXT0wLG4taX1mdW5jdGlvbiBHKHQpe2Zvcih2YXIgZT0wLG49MDtuPHQubGVuZ3RoOysrbil7dmFyIHI9dC5jaGFyQ29kZUF0KG4pOzEyNz49cj9lKys6MjA0Nz49cj9lKz0yOjU1Mjk2PD1yJiY1NzM0Mz49cj8oZSs9NCwrK24pOmUrPTN9cmV0dXJuIGV9ZnVuY3Rpb24gSCh0KXtDPXQscy5IRUFQOD1GPW5ldyBJbnQ4QXJyYXkodCkscy5IRUFQMTY9bmV3IEludDE2QXJyYXkodCkscy5IRUFQMzI9Uj1uZXcgSW50MzJBcnJheSh0KSxzLkhFQVBVOD1OPW5ldyBVaW50OEFycmF5KHQpLHMuSEVBUFUxNj1uZXcgVWludDE2QXJyYXkodCkscy5IRUFQVTMyPUw9bmV3IFVpbnQzMkFycmF5KHQpLHMuSEVBUEYzMj1uZXcgRmxvYXQzMkFycmF5KHQpLHMuSEVBUEY2ND1NPW5ldyBGbG9hdDY0QXJyYXkodCl9eCYmKEM9cy5idWZmZXIpO3ZhciBxPXMuSU5JVElBTF9NRU1PUll8fDE2Nzc3MjE2O2lmKHgpJD1zLndhc21NZW1vcnksQz1zLmJ1ZmZlcjtlbHNlIGlmKHMud2FzbU1lbW9yeSkkPXMud2FzbU1lbW9yeTtlbHNlIGlmKCEoKCQ9bmV3IFdlYkFzc2VtYmx5Lk1lbW9yeSh7aW5pdGlhbDpxLzY1NTM2LG1heGltdW06NjU1MzYsc2hhcmVkOiEwfSkpLmJ1ZmZlciBpbnN0YW5jZW9mIFNoYXJlZEFycmF5QnVmZmVyKSl0aHJvdyBQKFwicmVxdWVzdGVkIGEgc2hhcmVkIFdlYkFzc2VtYmx5Lk1lbW9yeSBidXQgdGhlIHJldHVybmVkIGJ1ZmZlciBpcyBub3QgYSBTaGFyZWRBcnJheUJ1ZmZlciwgaW5kaWNhdGluZyB0aGF0IHdoaWxlIHRoZSBicm93c2VyIGhhcyBTaGFyZWRBcnJheUJ1ZmZlciBpdCBkb2VzIG5vdCBoYXZlIFdlYkFzc2VtYmx5IHRocmVhZHMgc3VwcG9ydCAtIHlvdSBtYXkgbmVlZCB0byBzZXQgYSBmbGFnXCIpLHcmJmNvbnNvbGUubG9nKFwiKG9uIG5vZGUgeW91IG1heSBuZWVkOiAtLWV4cGVyaW1lbnRhbC13YXNtLXRocmVhZHMgLS1leHBlcmltZW50YWwtd2FzbS1idWxrLW1lbW9yeSBhbmQgYWxzbyB1c2UgYSByZWNlbnQgdmVyc2lvbilcIiksRXJyb3IoXCJiYWQgbWVtb3J5XCIpOyQmJihDPSQuYnVmZmVyKSxxPUMuYnl0ZUxlbmd0aCxIKEMpO3ZhciBXLFg9W10sWT1bXSxLPVtdLFo9W107ZnVuY3Rpb24gSigpe3JldHVybiBEfHwhMX1mdW5jdGlvbiBRKCl7dmFyIHQ9cy5wcmVSdW4uc2hpZnQoKTtYLnVuc2hpZnQodCl9dmFyIHR0LGV0PTAsbnQ9bnVsbCxydD1udWxsO2Z1bmN0aW9uIGl0KHQpe3Rocm93IHg/cG9zdE1lc3NhZ2Uoe2NtZDpcIm9uQWJvcnRcIixhcmc6dH0pOnMub25BYm9ydCYmcy5vbkFib3J0KHQpLFAodD1cIkFib3J0ZWQoXCIrdCtcIilcIiksaj0hMCx0PW5ldyBXZWJBc3NlbWJseS5SdW50aW1lRXJyb3IodCtcIi4gQnVpbGQgd2l0aCAtc0FTU0VSVElPTlMgZm9yIG1vcmUgaW5mby5cIiksYyh0KSx0fWZ1bmN0aW9uIG90KCl7cmV0dXJuIHR0LnN0YXJ0c1dpdGgoXCJkYXRhOmFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbTtiYXNlNjQsXCIpfWZ1bmN0aW9uIGF0KCl7dmFyIHQ9dHQ7dHJ5e2lmKHQ9PXR0JiZFKXJldHVybiBuZXcgVWludDhBcnJheShFKTtpZihmKXJldHVybiBmKHQpO3Rocm93XCJib3RoIGFzeW5jIGFuZCBzeW5jIGZldGNoaW5nIG9mIHRoZSB3YXNtIGZhaWxlZFwifWNhdGNoKHQpe2l0KHQpfX10dD1cIm9ydC13YXNtLXRocmVhZGVkLndhc21cIixvdCgpfHwodHQ9Uyh0dCkpO3ZhciBzdD17fTtmdW5jdGlvbiB1dCh0KXt0aGlzLm5hbWU9XCJFeGl0U3RhdHVzXCIsdGhpcy5tZXNzYWdlPVwiUHJvZ3JhbSB0ZXJtaW5hdGVkIHdpdGggZXhpdChcIit0K1wiKVwiLHRoaXMuc3RhdHVzPXR9ZnVuY3Rpb24gY3QodCl7KHQ9ZHQuVmJbdF0pfHxpdCgpLGR0Lm1jKHQpfWZ1bmN0aW9uIGx0KHQpe3ZhciBlPWR0LkNjKCk7aWYoIWUpcmV0dXJuIDY7ZHQuYWMucHVzaChlKSxkdC5WYlt0LlViXT1lLGUuVWI9dC5VYjt2YXIgbj17Y21kOlwicnVuXCIsc3RhcnRfcm91dGluZTp0LkljLGFyZzp0LnpjLHB0aHJlYWRfcHRyOnQuVWJ9O3JldHVybiBlLiRiPSgpPT57bi50aW1lPXBlcmZvcm1hbmNlLm5vdygpLGUucG9zdE1lc3NhZ2Uobix0Lk5jKX0sZS5sb2FkZWQmJihlLiRiKCksZGVsZXRlIGUuJGIpLDB9ZnVuY3Rpb24gcHQodCl7aWYoeClyZXR1cm4gV3QoMSwxLHQpO0ooKXx8KGR0Lm9jKCkscy5vbkV4aXQmJnMub25FeGl0KHQpLGo9ITApLHkodCxuZXcgdXQodCkpfWZ1bmN0aW9uIGZ0KHQsZSl7aWYoIWUmJngpdGhyb3cgYnQodCksXCJ1bndpbmRcIjtKKCl8fHh8fChtZSgpLGh0KEspLGJlKDApLHJlWzFdLmxlbmd0aCYmaWUoMSwxMCkscmVbMl0ubGVuZ3RoJiZpZSgyLDEwKSxkdC5vYygpKSxwdCh0KX12YXIgZHQ9e1liOltdLGFjOltdLHFjOltdLFZiOnt9LGZjOmZ1bmN0aW9uKCl7eCYmZHQuRWMoKX0sUGM6ZnVuY3Rpb24oKXt9LEVjOmZ1bmN0aW9uKCl7ZHQucmVjZWl2ZU9iamVjdFRyYW5zZmVyPWR0LkdjLGR0LnRocmVhZEluaXRUTFM9ZHQucGMsZHQuc2V0RXhpdFN0YXR1cz1kdC5uYyxEPSExfSxuYzpmdW5jdGlvbigpe30sb2M6ZnVuY3Rpb24oKXtmb3IodmFyIHQgb2YgT2JqZWN0LnZhbHVlcyhkdC5WYikpZHQubWModCk7Zm9yKHQgb2YgZHQuWWIpdC50ZXJtaW5hdGUoKTtkdC5ZYj1bXX0sbWM6ZnVuY3Rpb24odCl7dmFyIGU9dC5VYjtkZWxldGUgZHQuVmJbZV0sZHQuWWIucHVzaCh0KSxkdC5hYy5zcGxpY2UoZHQuYWMuaW5kZXhPZih0KSwxKSx0LlViPTAseGUoZSl9LEdjOmZ1bmN0aW9uKCl7fSxwYzpmdW5jdGlvbigpe2R0LnFjLmZvckVhY2goKHQ9PnQoKSkpfSxGYzpmdW5jdGlvbih0LGUpe3Qub25tZXNzYWdlPW49Pnt2YXIgcj0obj1uLmRhdGEpLmNtZDtpZih0LlViJiYoZHQuQmM9dC5VYiksbi50YXJnZXRUaHJlYWQmJm4udGFyZ2V0VGhyZWFkIT1kZSgpKXt2YXIgaT1kdC5WYltuLlFjXTtpP2kucG9zdE1lc3NhZ2UobixuLnRyYW5zZmVyTGlzdCk6UCgnSW50ZXJuYWwgZXJyb3IhIFdvcmtlciBzZW50IGEgbWVzc2FnZSBcIicrcisnXCIgdG8gdGFyZ2V0IHB0aHJlYWQgJytuLnRhcmdldFRocmVhZCtcIiwgYnV0IHRoYXQgdGhyZWFkIG5vIGxvbmdlciBleGlzdHMhXCIpfWVsc2VcInByb2Nlc3NQcm94eWluZ1F1ZXVlXCI9PT1yP1Z0KG4ucXVldWUpOlwic3Bhd25UaHJlYWRcIj09PXI/bHQobik6XCJjbGVhbnVwVGhyZWFkXCI9PT1yP2N0KG4udGhyZWFkKTpcImtpbGxUaHJlYWRcIj09PXI/KG49bi50aHJlYWQscj1kdC5WYltuXSxkZWxldGUgZHQuVmJbbl0sci50ZXJtaW5hdGUoKSx4ZShuKSxkdC5hYy5zcGxpY2UoZHQuYWMuaW5kZXhPZihyKSwxKSxyLlViPTApOlwiY2FuY2VsVGhyZWFkXCI9PT1yP2R0LlZiW24udGhyZWFkXS5wb3N0TWVzc2FnZSh7Y21kOlwiY2FuY2VsXCJ9KTpcImxvYWRlZFwiPT09cj8odC5sb2FkZWQ9ITAsZSYmZSh0KSx0LiRiJiYodC4kYigpLGRlbGV0ZSB0LiRiKSk6XCJwcmludFwiPT09cj9JKFwiVGhyZWFkIFwiK24udGhyZWFkSWQrXCI6IFwiK24udGV4dCk6XCJwcmludEVyclwiPT09cj9QKFwiVGhyZWFkIFwiK24udGhyZWFkSWQrXCI6IFwiK24udGV4dCk6XCJhbGVydFwiPT09cj9hbGVydChcIlRocmVhZCBcIituLnRocmVhZElkK1wiOiBcIituLnRleHQpOlwic2V0aW1tZWRpYXRlXCI9PT1uLnRhcmdldD90LnBvc3RNZXNzYWdlKG4pOlwib25BYm9ydFwiPT09cj9zLm9uQWJvcnQmJnMub25BYm9ydChuLmFyZyk6ciYmUChcIndvcmtlciBzZW50IGFuIHVua25vd24gY29tbWFuZCBcIityKTtkdC5CYz12b2lkIDB9LHQub25lcnJvcj10PT57dGhyb3cgUChcIndvcmtlciBzZW50IGFuIGVycm9yISBcIit0LmZpbGVuYW1lK1wiOlwiK3QubGluZW5vK1wiOiBcIit0Lm1lc3NhZ2UpLHR9LHcmJih0Lm9uKFwibWVzc2FnZVwiLChmdW5jdGlvbihlKXt0Lm9ubWVzc2FnZSh7ZGF0YTplfSl9KSksdC5vbihcImVycm9yXCIsKGZ1bmN0aW9uKGUpe3Qub25lcnJvcihlKX0pKSx0Lm9uKFwiZGV0YWNoZWRFeGl0XCIsKGZ1bmN0aW9uKCl7fSkpKSx0LnBvc3RNZXNzYWdlKHtjbWQ6XCJsb2FkXCIsdXJsT3JCbG9iOnMubWFpblNjcmlwdFVybE9yQmxvYnx8X3NjcmlwdERpcix3YXNtTWVtb3J5OiQsd2FzbU1vZHVsZTprfSl9LHljOmZ1bmN0aW9uKCl7dmFyIHQ9UyhcIm9ydC13YXNtLXRocmVhZGVkLndvcmtlci5qc1wiKTtkdC5ZYi5wdXNoKG5ldyBXb3JrZXIodCkpfSxDYzpmdW5jdGlvbigpe3JldHVybiAwPT1kdC5ZYi5sZW5ndGgmJihkdC55YygpLGR0LkZjKGR0LlliWzBdKSksZHQuWWIucG9wKCl9fTtmdW5jdGlvbiBodCh0KXtmb3IoOzA8dC5sZW5ndGg7KXQuc2hpZnQoKShzKX1mdW5jdGlvbiBndCh0KXt2YXIgZT1BZSgpO3JldHVybiB0PXQoKSxFZShlKSx0fWZ1bmN0aW9uIGJ0KHQpe2lmKHgpcmV0dXJuIFd0KDIsMCx0KTt0cnl7ZnQodCl9Y2F0Y2godCl7dCBpbnN0YW5jZW9mIHV0fHxcInVud2luZFwiPT10fHx5KDEsdCl9fXMuUFRocmVhZD1kdCxzLmVzdGFibGlzaFN0YWNrU3BhY2U9ZnVuY3Rpb24oKXt2YXIgdD1kZSgpLGU9aSgpW3QrNDQ+PjI+Pj4wXTt0PWkoKVt0KzQ4Pj4yPj4+MF0sT2UoZSxlLXQpLEVlKGUpfTt2YXIgbXQ9W107ZnVuY3Rpb24geXQodCl7dmFyIGU9bXRbdF07cmV0dXJuIGV8fCh0Pj1tdC5sZW5ndGgmJihtdC5sZW5ndGg9dCsxKSxtdFt0XT1lPVcuZ2V0KHQpKSxlfXMuaW52b2tlRW50cnlQb2ludD1mdW5jdGlvbih0LGUpe3Q9eXQodCkoZSksSigpP2R0Lm5jKHQpOlRlKHQpfTt2YXIgX3QsdnQsd3Q9W10seHQ9MCxUdD0wO2Z1bmN0aW9uIFN0KHQpe3RoaXMuWmI9dCx0aGlzLlNiPXQtMjQsdGhpcy54Yz1mdW5jdGlvbih0KXtvKClbdGhpcy5TYis0Pj4yPj4+MF09dH0sdGhpcy5iYz1mdW5jdGlvbigpe3JldHVybiBvKClbdGhpcy5TYis0Pj4yPj4+MF19LHRoaXMud2M9ZnVuY3Rpb24odCl7bygpW3RoaXMuU2IrOD4+Mj4+PjBdPXR9LHRoaXMuRGM9ZnVuY3Rpb24oKXtyZXR1cm4gbygpW3RoaXMuU2IrOD4+Mj4+PjBdfSx0aGlzLnJjPWZ1bmN0aW9uKCl7aSgpW3RoaXMuU2I+PjI+Pj4wXT0wfSx0aGlzLmhjPWZ1bmN0aW9uKHQpe3Q9dD8xOjAsZSgpW3RoaXMuU2IrMTI+PjA+Pj4wXT10fSx0aGlzLnVjPWZ1bmN0aW9uKCl7cmV0dXJuIDAhPWUoKVt0aGlzLlNiKzEyPj4wPj4+MF19LHRoaXMuaWM9ZnVuY3Rpb24odCl7dD10PzE6MCxlKClbdGhpcy5TYisxMz4+MD4+PjBdPXR9LHRoaXMua2M9ZnVuY3Rpb24oKXtyZXR1cm4gMCE9ZSgpW3RoaXMuU2IrMTM+PjA+Pj4wXX0sdGhpcy5mYz1mdW5jdGlvbih0LGUpe3RoaXMuY2MoMCksdGhpcy54Yyh0KSx0aGlzLndjKGUpLHRoaXMucmMoKSx0aGlzLmhjKCExKSx0aGlzLmljKCExKX0sdGhpcy5zYz1mdW5jdGlvbigpe0F0b21pY3MuYWRkKGkoKSx0aGlzLlNiPj4yLDEpfSx0aGlzLkhjPWZ1bmN0aW9uKCl7cmV0dXJuIDE9PT1BdG9taWNzLnN1YihpKCksdGhpcy5TYj4+MiwxKX0sdGhpcy5jYz1mdW5jdGlvbih0KXtvKClbdGhpcy5TYisxNj4+Mj4+PjBdPXR9LHRoaXMudGM9ZnVuY3Rpb24oKXtyZXR1cm4gbygpW3RoaXMuU2IrMTY+PjI+Pj4wXX0sdGhpcy52Yz1mdW5jdGlvbigpe2lmKERlKHRoaXMuYmMoKSkpcmV0dXJuIG8oKVt0aGlzLlpiPj4yPj4+MF07dmFyIHQ9dGhpcy50YygpO3JldHVybiAwIT09dD90OnRoaXMuWmJ9fWZ1bmN0aW9uIE90KHQpe3JldHVybiBnZShuZXcgU3QodCkuU2IpfWZ1bmN0aW9uIEF0KHQsZSxuLHIpe3JldHVybiB4P1d0KDMsMSx0LGUsbixyKTpFdCh0LGUsbixyKX1mdW5jdGlvbiBFdCh0LGUsbixyKXtpZihcInVuZGVmaW5lZFwiPT10eXBlb2YgU2hhcmVkQXJyYXlCdWZmZXIpcmV0dXJuIFAoXCJDdXJyZW50IGVudmlyb25tZW50IGRvZXMgbm90IHN1cHBvcnQgU2hhcmVkQXJyYXlCdWZmZXIsIHB0aHJlYWRzIGFyZSBub3QgYXZhaWxhYmxlIVwiKSw2O3ZhciBpPVtdO3JldHVybiB4JiYwPT09aS5sZW5ndGg/QXQodCxlLG4scik6KHQ9e0ljOm4sVWI6dCx6YzpyLE5jOml9LHg/KHQuT2M9XCJzcGF3blRocmVhZFwiLHBvc3RNZXNzYWdlKHQsaSksMCk6bHQodCkpfWZ1bmN0aW9uIEl0KHQsZSxuKXtyZXR1cm4geD9XdCg0LDEsdCxlLG4pOjB9ZnVuY3Rpb24gUHQodCxlKXtpZih4KXJldHVybiBXdCg1LDEsdCxlKX1mdW5jdGlvbiBEdCh0LGUpe2lmKHgpcmV0dXJuIFd0KDYsMSx0LGUpfWZ1bmN0aW9uICR0KHQsZSxuKXtpZih4KXJldHVybiBXdCg3LDEsdCxlLG4pfWZ1bmN0aW9uIGt0KHQsZSxuKXtyZXR1cm4geD9XdCg4LDEsdCxlLG4pOjB9ZnVuY3Rpb24gQ3QodCxlKXtpZih4KXJldHVybiBXdCg5LDEsdCxlKX1mdW5jdGlvbiBGdCh0LGUsbil7aWYoeClyZXR1cm4gV3QoMTAsMSx0LGUsbil9ZnVuY3Rpb24gTnQodCxlLG4scil7aWYoeClyZXR1cm4gV3QoMTEsMSx0LGUsbixyKX1mdW5jdGlvbiBSdCh0LGUsbixyKXtpZih4KXJldHVybiBXdCgxMiwxLHQsZSxuLHIpfWZ1bmN0aW9uIEx0KHQsZSxuLHIpe2lmKHgpcmV0dXJuIFd0KDEzLDEsdCxlLG4scil9ZnVuY3Rpb24gTXQodCl7aWYoeClyZXR1cm4gV3QoMTQsMSx0KX1mdW5jdGlvbiBqdCh0LGUpe2lmKHgpcmV0dXJuIFd0KDE1LDEsdCxlKX1mdW5jdGlvbiBVdCh0LGUsbil7aWYoeClyZXR1cm4gV3QoMTYsMSx0LGUsbil9ZnVuY3Rpb24gVnQodCl7QXRvbWljcy5zdG9yZShpKCksdD4+MiwxKSxkZSgpJiZ3ZSh0KSxBdG9taWNzLmNvbXBhcmVFeGNoYW5nZShpKCksdD4+MiwxLDApfWZ1bmN0aW9uIEJ0KHQpe3JldHVybiBvKClbdD4+PjJdKzQyOTQ5NjcyOTYqaSgpW3QrND4+PjJdfWZ1bmN0aW9uIHp0KHQsZSxuLHIsaSxvKXtyZXR1cm4geD9XdCgxNywxLHQsZSxuLHIsaSxvKTotNTJ9ZnVuY3Rpb24gR3QodCxlLG4scixpLG8pe2lmKHgpcmV0dXJuIFd0KDE4LDEsdCxlLG4scixpLG8pfWZ1bmN0aW9uIEh0KHQpe3ZhciBuPUcodCkrMSxyPWhlKG4pO3JldHVybiByJiZ6KHQsZSgpLHIsbikscn1mdW5jdGlvbiBxdCh0LGUsbil7ZnVuY3Rpb24gcih0KXtyZXR1cm4odD10LnRvVGltZVN0cmluZygpLm1hdGNoKC9cXCgoW0EtWmEteiBdKylcXCkkLykpP3RbMV06XCJHTVRcIn1pZih4KXJldHVybiBXdCgxOSwxLHQsZSxuKTt2YXIgYT0obmV3IERhdGUpLmdldEZ1bGxZZWFyKCkscz1uZXcgRGF0ZShhLDAsMSksdT1uZXcgRGF0ZShhLDYsMSk7YT1zLmdldFRpbWV6b25lT2Zmc2V0KCk7dmFyIGM9dS5nZXRUaW1lem9uZU9mZnNldCgpLGw9TWF0aC5tYXgoYSxjKTtpKClbdD4+Mj4+PjBdPTYwKmwsaSgpW2U+PjI+Pj4wXT1OdW1iZXIoYSE9YyksdD1yKHMpLGU9cih1KSx0PUh0KHQpLGU9SHQoZSksYzxhPyhvKClbbj4+Mj4+PjBdPXQsbygpW24rND4+Mj4+PjBdPWUpOihvKClbbj4+Mj4+PjBdPWUsbygpW24rND4+Mj4+PjBdPXQpfWZ1bmN0aW9uIFd0KHQsZSl7dmFyIG49YXJndW1lbnRzLmxlbmd0aC0yLHI9YXJndW1lbnRzO3JldHVybiBndCgoKCk9Pntmb3IodmFyIGk9SWUoOCpuKSxvPWk+PjMscz0wO3M8bjtzKyspe3ZhciB1PXJbMitzXTthKClbbytzPj4+MF09dX1yZXR1cm4gdmUodCxuLGksZSl9KSl9cy5leGVjdXRlTm90aWZpZWRQcm94eWluZ1F1ZXVlPVZ0LHZ0PXc/KCk9Pnt2YXIgdD1wcm9jZXNzLmhydGltZSgpO3JldHVybiAxZTMqdFswXSt0WzFdLzFlNn06eD8oKT0+cGVyZm9ybWFuY2Uubm93KCktcy5fX3BlcmZvcm1hbmNlX25vd19jbG9ja19kcmlmdDooKT0+cGVyZm9ybWFuY2Uubm93KCk7dmFyIFh0LFl0PVtdLEt0PXt9O2Z1bmN0aW9uIFp0KCl7aWYoIVh0KXt2YXIgdCxlPXtVU0VSOlwid2ViX3VzZXJcIixMT0dOQU1FOlwid2ViX3VzZXJcIixQQVRIOlwiL1wiLFBXRDpcIi9cIixIT01FOlwiL2hvbWUvd2ViX3VzZXJcIixMQU5HOihcIm9iamVjdFwiPT10eXBlb2YgbmF2aWdhdG9yJiZuYXZpZ2F0b3IubGFuZ3VhZ2VzJiZuYXZpZ2F0b3IubGFuZ3VhZ2VzWzBdfHxcIkNcIikucmVwbGFjZShcIi1cIixcIl9cIikrXCIuVVRGLThcIixfOm18fFwiLi90aGlzLnByb2dyYW1cIn07Zm9yKHQgaW4gS3Qpdm9pZCAwPT09S3RbdF0/ZGVsZXRlIGVbdF06ZVt0XT1LdFt0XTt2YXIgbj1bXTtmb3IodCBpbiBlKW4ucHVzaCh0K1wiPVwiK2VbdF0pO1h0PW59cmV0dXJuIFh0fWZ1bmN0aW9uIEp0KHQsbil7aWYoeClyZXR1cm4gV3QoMjAsMSx0LG4pO3ZhciByPTA7cmV0dXJuIFp0KCkuZm9yRWFjaCgoZnVuY3Rpb24oaSxhKXt2YXIgcz1uK3I7Zm9yKGE9bygpW3QrNCphPj4yPj4+MF09cyxzPTA7czxpLmxlbmd0aDsrK3MpZSgpW2ErKz4+MD4+PjBdPWkuY2hhckNvZGVBdChzKTtlKClbYT4+MD4+PjBdPTAscis9aS5sZW5ndGgrMX0pKSwwfWZ1bmN0aW9uIFF0KHQsZSl7aWYoeClyZXR1cm4gV3QoMjEsMSx0LGUpO3ZhciBuPVp0KCk7bygpW3Q+PjI+Pj4wXT1uLmxlbmd0aDt2YXIgcj0wO3JldHVybiBuLmZvckVhY2goKGZ1bmN0aW9uKHQpe3IrPXQubGVuZ3RoKzF9KSksbygpW2U+PjI+Pj4wXT1yLDB9ZnVuY3Rpb24gdGUodCl7cmV0dXJuIHg/V3QoMjIsMSx0KTo1Mn1mdW5jdGlvbiBlZSh0LGUsbixyKXtyZXR1cm4geD9XdCgyMywxLHQsZSxuLHIpOjUyfWZ1bmN0aW9uIG5lKHQsZSxuLHIsaSl7cmV0dXJuIHg/V3QoMjQsMSx0LGUsbixyLGkpOjcwfXZhciByZT1bbnVsbCxbXSxbXV07ZnVuY3Rpb24gaWUodCxlKXt2YXIgbj1yZVt0XTswPT09ZXx8MTA9PT1lPygoMT09PXQ/STpQKShWKG4sMCkpLG4ubGVuZ3RoPTApOm4ucHVzaChlKX1mdW5jdGlvbiBvZSh0LGUsbixpKXtpZih4KXJldHVybiBXdCgyNSwxLHQsZSxuLGkpO2Zvcih2YXIgYT0wLHM9MDtzPG47cysrKXt2YXIgdT1vKClbZT4+Mj4+PjBdLGM9bygpW2UrND4+Mj4+PjBdO2UrPTg7Zm9yKHZhciBsPTA7bDxjO2wrKylpZSh0LHIoKVt1K2w+Pj4wXSk7YSs9Y31yZXR1cm4gbygpW2k+PjI+Pj4wXT1hLDB9dmFyIGFlPTA7ZnVuY3Rpb24gc2UodCl7cmV0dXJuIDA9PXQlNCYmKDAhPXQlMTAwfHwwPT10JTQwMCl9dmFyIHVlPVszMSwyOSwzMSwzMCwzMSwzMCwzMSwzMSwzMCwzMSwzMCwzMV0sY2U9WzMxLDI4LDMxLDMwLDMxLDMwLDMxLDMxLDMwLDMxLDMwLDMxXTtmdW5jdGlvbiBsZSh0LG4scixvKXtmdW5jdGlvbiBhKHQsZSxuKXtmb3IodD1cIm51bWJlclwiPT10eXBlb2YgdD90LnRvU3RyaW5nKCk6dHx8XCJcIjt0Lmxlbmd0aDxlOyl0PW5bMF0rdDtyZXR1cm4gdH1mdW5jdGlvbiBzKHQsZSl7cmV0dXJuIGEodCxlLFwiMFwiKX1mdW5jdGlvbiB1KHQsZSl7ZnVuY3Rpb24gbih0KXtyZXR1cm4gMD50Py0xOjA8dD8xOjB9dmFyIHI7cmV0dXJuIDA9PT0ocj1uKHQuZ2V0RnVsbFllYXIoKS1lLmdldEZ1bGxZZWFyKCkpKSYmMD09PShyPW4odC5nZXRNb250aCgpLWUuZ2V0TW9udGgoKSkpJiYocj1uKHQuZ2V0RGF0ZSgpLWUuZ2V0RGF0ZSgpKSkscn1mdW5jdGlvbiBjKHQpe3N3aXRjaCh0LmdldERheSgpKXtjYXNlIDA6cmV0dXJuIG5ldyBEYXRlKHQuZ2V0RnVsbFllYXIoKS0xLDExLDI5KTtjYXNlIDE6cmV0dXJuIHQ7Y2FzZSAyOnJldHVybiBuZXcgRGF0ZSh0LmdldEZ1bGxZZWFyKCksMCwzKTtjYXNlIDM6cmV0dXJuIG5ldyBEYXRlKHQuZ2V0RnVsbFllYXIoKSwwLDIpO2Nhc2UgNDpyZXR1cm4gbmV3IERhdGUodC5nZXRGdWxsWWVhcigpLDAsMSk7Y2FzZSA1OnJldHVybiBuZXcgRGF0ZSh0LmdldEZ1bGxZZWFyKCktMSwxMSwzMSk7Y2FzZSA2OnJldHVybiBuZXcgRGF0ZSh0LmdldEZ1bGxZZWFyKCktMSwxMSwzMCl9fWZ1bmN0aW9uIGwodCl7dmFyIGU9dC5XYjtmb3IodD1uZXcgRGF0ZShuZXcgRGF0ZSh0LlhiKzE5MDAsMCwxKS5nZXRUaW1lKCkpOzA8ZTspe3ZhciBuPXQuZ2V0TW9udGgoKSxyPShzZSh0LmdldEZ1bGxZZWFyKCkpP3VlOmNlKVtuXTtpZighKGU+ci10LmdldERhdGUoKSkpe3Quc2V0RGF0ZSh0LmdldERhdGUoKStlKTticmVha31lLT1yLXQuZ2V0RGF0ZSgpKzEsdC5zZXREYXRlKDEpLDExPm4/dC5zZXRNb250aChuKzEpOih0LnNldE1vbnRoKDApLHQuc2V0RnVsbFllYXIodC5nZXRGdWxsWWVhcigpKzEpKX1yZXR1cm4gbj1uZXcgRGF0ZSh0LmdldEZ1bGxZZWFyKCkrMSwwLDQpLGU9YyhuZXcgRGF0ZSh0LmdldEZ1bGxZZWFyKCksMCw0KSksbj1jKG4pLDA+PXUoZSx0KT8wPj11KG4sdCk/dC5nZXRGdWxsWWVhcigpKzE6dC5nZXRGdWxsWWVhcigpOnQuZ2V0RnVsbFllYXIoKS0xfXZhciBwPWkoKVtvKzQwPj4yPj4+MF07Zm9yKHZhciBmIGluIG89e0xjOmkoKVtvPj4yPj4+MF0sS2M6aSgpW28rND4+Mj4+PjBdLGRjOmkoKVtvKzg+PjI+Pj4wXSxqYzppKClbbysxMj4+Mj4+PjBdLGVjOmkoKVtvKzE2Pj4yPj4+MF0sWGI6aSgpW28rMjA+PjI+Pj4wXSxUYjppKClbbysyND4+Mj4+PjBdLFdiOmkoKVtvKzI4Pj4yPj4+MF0sUmM6aSgpW28rMzI+PjI+Pj4wXSxKYzppKClbbyszNj4+Mj4+PjBdLE1jOnA/QihwKTpcIlwifSxyPUIocikscD17XCIlY1wiOlwiJWEgJWIgJWQgJUg6JU06JVMgJVlcIixcIiVEXCI6XCIlbS8lZC8leVwiLFwiJUZcIjpcIiVZLSVtLSVkXCIsXCIlaFwiOlwiJWJcIixcIiVyXCI6XCIlSTolTTolUyAlcFwiLFwiJVJcIjpcIiVIOiVNXCIsXCIlVFwiOlwiJUg6JU06JVNcIixcIiV4XCI6XCIlbS8lZC8leVwiLFwiJVhcIjpcIiVIOiVNOiVTXCIsXCIlRWNcIjpcIiVjXCIsXCIlRUNcIjpcIiVDXCIsXCIlRXhcIjpcIiVtLyVkLyV5XCIsXCIlRVhcIjpcIiVIOiVNOiVTXCIsXCIlRXlcIjpcIiV5XCIsXCIlRVlcIjpcIiVZXCIsXCIlT2RcIjpcIiVkXCIsXCIlT2VcIjpcIiVlXCIsXCIlT0hcIjpcIiVIXCIsXCIlT0lcIjpcIiVJXCIsXCIlT21cIjpcIiVtXCIsXCIlT01cIjpcIiVNXCIsXCIlT1NcIjpcIiVTXCIsXCIlT3VcIjpcIiV1XCIsXCIlT1VcIjpcIiVVXCIsXCIlT1ZcIjpcIiVWXCIsXCIlT3dcIjpcIiV3XCIsXCIlT1dcIjpcIiVXXCIsXCIlT3lcIjpcIiV5XCJ9KXI9ci5yZXBsYWNlKG5ldyBSZWdFeHAoZixcImdcIikscFtmXSk7dmFyIGQ9XCJTdW5kYXkgTW9uZGF5IFR1ZXNkYXkgV2VkbmVzZGF5IFRodXJzZGF5IEZyaWRheSBTYXR1cmRheVwiLnNwbGl0KFwiIFwiKSxoPVwiSmFudWFyeSBGZWJydWFyeSBNYXJjaCBBcHJpbCBNYXkgSnVuZSBKdWx5IEF1Z3VzdCBTZXB0ZW1iZXIgT2N0b2JlciBOb3ZlbWJlciBEZWNlbWJlclwiLnNwbGl0KFwiIFwiKTtmb3IoZiBpbiBwPXtcIiVhXCI6ZnVuY3Rpb24odCl7cmV0dXJuIGRbdC5UYl0uc3Vic3RyaW5nKDAsMyl9LFwiJUFcIjpmdW5jdGlvbih0KXtyZXR1cm4gZFt0LlRiXX0sXCIlYlwiOmZ1bmN0aW9uKHQpe3JldHVybiBoW3QuZWNdLnN1YnN0cmluZygwLDMpfSxcIiVCXCI6ZnVuY3Rpb24odCl7cmV0dXJuIGhbdC5lY119LFwiJUNcIjpmdW5jdGlvbih0KXtyZXR1cm4gcygodC5YYisxOTAwKS8xMDB8MCwyKX0sXCIlZFwiOmZ1bmN0aW9uKHQpe3JldHVybiBzKHQuamMsMil9LFwiJWVcIjpmdW5jdGlvbih0KXtyZXR1cm4gYSh0LmpjLDIsXCIgXCIpfSxcIiVnXCI6ZnVuY3Rpb24odCl7cmV0dXJuIGwodCkudG9TdHJpbmcoKS5zdWJzdHJpbmcoMil9LFwiJUdcIjpmdW5jdGlvbih0KXtyZXR1cm4gbCh0KX0sXCIlSFwiOmZ1bmN0aW9uKHQpe3JldHVybiBzKHQuZGMsMil9LFwiJUlcIjpmdW5jdGlvbih0KXtyZXR1cm4gMD09KHQ9dC5kYyk/dD0xMjoxMjx0JiYodC09MTIpLHModCwyKX0sXCIlalwiOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT0wLG49MDtuPD10LmVjLTE7ZSs9KHNlKHQuWGIrMTkwMCk/dWU6Y2UpW24rK10pO3JldHVybiBzKHQuamMrZSwzKX0sXCIlbVwiOmZ1bmN0aW9uKHQpe3JldHVybiBzKHQuZWMrMSwyKX0sXCIlTVwiOmZ1bmN0aW9uKHQpe3JldHVybiBzKHQuS2MsMil9LFwiJW5cIjpmdW5jdGlvbigpe3JldHVyblwiXFxuXCJ9LFwiJXBcIjpmdW5jdGlvbih0KXtyZXR1cm4gMDw9dC5kYyYmMTI+dC5kYz9cIkFNXCI6XCJQTVwifSxcIiVTXCI6ZnVuY3Rpb24odCl7cmV0dXJuIHModC5MYywyKX0sXCIldFwiOmZ1bmN0aW9uKCl7cmV0dXJuXCJcXHRcIn0sXCIldVwiOmZ1bmN0aW9uKHQpe3JldHVybiB0LlRifHw3fSxcIiVVXCI6ZnVuY3Rpb24odCl7cmV0dXJuIHMoTWF0aC5mbG9vcigodC5XYis3LXQuVGIpLzcpLDIpfSxcIiVWXCI6ZnVuY3Rpb24odCl7dmFyIGU9TWF0aC5mbG9vcigodC5XYis3LSh0LlRiKzYpJTcpLzcpO2lmKDI+PSh0LlRiKzM3MS10LldiLTIpJTcmJmUrKyxlKTUzPT1lJiYoND09KG49KHQuVGIrMzcxLXQuV2IpJTcpfHwzPT1uJiZzZSh0LlhiKXx8KGU9MSkpO2Vsc2V7ZT01Mjt2YXIgbj0odC5UYis3LXQuV2ItMSklNzsoND09bnx8NT09biYmc2UodC5YYiU0MDAtMSkpJiZlKyt9cmV0dXJuIHMoZSwyKX0sXCIld1wiOmZ1bmN0aW9uKHQpe3JldHVybiB0LlRifSxcIiVXXCI6ZnVuY3Rpb24odCl7cmV0dXJuIHMoTWF0aC5mbG9vcigodC5XYis3LSh0LlRiKzYpJTcpLzcpLDIpfSxcIiV5XCI6ZnVuY3Rpb24odCl7cmV0dXJuKHQuWGIrMTkwMCkudG9TdHJpbmcoKS5zdWJzdHJpbmcoMil9LFwiJVlcIjpmdW5jdGlvbih0KXtyZXR1cm4gdC5YYisxOTAwfSxcIiV6XCI6ZnVuY3Rpb24odCl7dmFyIGU9MDw9KHQ9dC5KYyk7cmV0dXJuIHQ9TWF0aC5hYnModCkvNjAsKGU/XCIrXCI6XCItXCIpK1N0cmluZyhcIjAwMDBcIisodC82MCoxMDArdCU2MCkpLnNsaWNlKC00KX0sXCIlWlwiOmZ1bmN0aW9uKHQpe3JldHVybiB0Lk1jfSxcIiUlXCI6ZnVuY3Rpb24oKXtyZXR1cm5cIiVcIn19LHI9ci5yZXBsYWNlKC8lJS9nLFwiXFwwXFwwXCIpLHApci5pbmNsdWRlcyhmKSYmKHI9ci5yZXBsYWNlKG5ldyBSZWdFeHAoZixcImdcIikscFtmXShvKSkpO3JldHVybiBmPWZ1bmN0aW9uKHQpe3ZhciBlPUFycmF5KEcodCkrMSk7cmV0dXJuIHoodCxlLDAsZS5sZW5ndGgpLGV9KHI9ci5yZXBsYWNlKC9cXDBcXDAvZyxcIiVcIikpLGYubGVuZ3RoPm4/MDooZnVuY3Rpb24odCxuKXtlKCkuc2V0KHQsbj4+PjApfShmLHQpLGYubGVuZ3RoLTEpfWR0LmZjKCk7dmFyIHBlPVtudWxsLHB0LGJ0LEF0LEl0LFB0LER0LCR0LGt0LEN0LEZ0LE50LFJ0LEx0LE10LGp0LFV0LHp0LEd0LHF0LEp0LFF0LHRlLGVlLG5lLG9lXSxmZT17YjpmdW5jdGlvbih0KXtyZXR1cm4gaGUodCsyNCkrMjR9LG46ZnVuY3Rpb24odCl7cmV0dXJuKHQ9bmV3IFN0KHQpKS51YygpfHwodC5oYyghMCkseHQtLSksdC5pYyghMSksd3QucHVzaCh0KSx0LnNjKCksdC52YygpfSxtYTpmdW5jdGlvbih0KXt0aHJvdyBQKFwiVW5leHBlY3RlZCBleGNlcHRpb24gdGhyb3duLCB0aGlzIGlzIG5vdCBwcm9wZXJseSBzdXBwb3J0ZWQgLSBhYm9ydGluZ1wiKSxqPSEwLHR9LHg6ZnVuY3Rpb24oKXtTZSgwKTt2YXIgdD13dC5wb3AoKTtpZih0LkhjKCkmJiF0LmtjKCkpe3ZhciBlPXQuRGMoKTtlJiZ5dChlKSh0LlpiKSxPdCh0LlpiKX1UdD0wfSxlOmZ1bmN0aW9uKCl7dmFyIHQ9VHQ7aWYoIXQpcmV0dXJuIGFlPTA7dmFyIGU9bmV3IFN0KHQpO2UuY2ModCk7dmFyIG49ZS5iYygpO2lmKCFuKXJldHVybiBhZT0wLHQ7Zm9yKHZhciByPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyksaT0wO2k8ci5sZW5ndGg7aSsrKXt2YXIgbz1yW2ldO2lmKDA9PT1vfHxvPT09bilicmVhaztpZihQZShvLG4sZS5TYisxNikpcmV0dXJuIGFlPW8sdH1yZXR1cm4gYWU9bix0fSxsOmZ1bmN0aW9uKCl7dmFyIHQ9VHQ7aWYoIXQpcmV0dXJuIGFlPTA7dmFyIGU9bmV3IFN0KHQpO2UuY2ModCk7dmFyIG49ZS5iYygpO2lmKCFuKXJldHVybiBhZT0wLHQ7Zm9yKHZhciByPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyksaT0wO2k8ci5sZW5ndGg7aSsrKXt2YXIgbz1yW2ldO2lmKDA9PT1vfHxvPT09bilicmVhaztpZihQZShvLG4sZS5TYisxNikpcmV0dXJuIGFlPW8sdH1yZXR1cm4gYWU9bix0fSxoOmZ1bmN0aW9uKCl7dmFyIHQ9VHQ7aWYoIXQpcmV0dXJuIGFlPTA7dmFyIGU9bmV3IFN0KHQpO2UuY2ModCk7dmFyIG49ZS5iYygpO2lmKCFuKXJldHVybiBhZT0wLHQ7Zm9yKHZhciByPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyksaT0wO2k8ci5sZW5ndGg7aSsrKXt2YXIgbz1yW2ldO2lmKDA9PT1vfHxvPT09bilicmVhaztpZihQZShvLG4sZS5TYisxNikpcmV0dXJuIGFlPW8sdH1yZXR1cm4gYWU9bix0fSx0Ok90LE06ZnVuY3Rpb24oKXt2YXIgdD13dC5wb3AoKTt0fHxpdChcIm5vIGV4Y2VwdGlvbiB0byB0aHJvd1wiKTt2YXIgZT10LlpiO3Rocm93IHQua2MoKXx8KHd0LnB1c2godCksdC5pYyghMCksdC5oYyghMSkseHQrKyksVHQ9ZSxlfSxjOmZ1bmN0aW9uKHQsZSxuKXt0aHJvdyBuZXcgU3QodCkuZmMoZSxuKSxUdD10LHh0KyssdH0scGE6ZnVuY3Rpb24oKXtyZXR1cm4geHR9LEZhOmZ1bmN0aW9uKHQpe3llKHQsIXYsMSwhXyksZHQucGMoKX0sVDpmdW5jdGlvbih0KXt4P3Bvc3RNZXNzYWdlKHtjbWQ6XCJjbGVhbnVwVGhyZWFkXCIsdGhyZWFkOnR9KTpjdCh0KX0seGE6RXQsajpmdW5jdGlvbih0KXt0aHJvdyBUdHx8KFR0PXQpLHR9LEg6SXQsTWE6UHQsdWE6RHQsd2E6JHQsb2E6a3QsS2E6Q3QsQ2E6RnQsSmE6TnQsVjpSdCx2YTpMdCxzYTpNdCxMYTpqdCx0YTpVdCxUYTpmdW5jdGlvbigpe30sWDpmdW5jdGlvbigpe2l0KFwiVG8gdXNlIGRsb3BlbiwgeW91IG5lZWQgZW5hYmxlIGR5bmFtaWMgbGlua2luZywgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9lbXNjcmlwdGVuLWNvcmUvZW1zY3JpcHRlbi93aWtpL0xpbmtpbmdcIil9LFVhOmZ1bmN0aW9uKCl7aXQoXCJUbyB1c2UgZGxvcGVuLCB5b3UgbmVlZCBlbmFibGUgZHluYW1pYyBsaW5raW5nLCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2Vtc2NyaXB0ZW4tY29yZS9lbXNjcmlwdGVuL3dpa2kvTGlua2luZ1wiKX0sVzpmdW5jdGlvbigpe3JldHVybiBEYXRlLm5vdygpfSx5YTpmdW5jdGlvbigpe3JldHVybiAyMDk3MTUyfSxPYTpmdW5jdGlvbigpe3JldHVybiEwfSx6YTpmdW5jdGlvbih0LGUsbixyKXtpZih0PT1lKXNldFRpbWVvdXQoKCgpPT5WdChyKSkpO2Vsc2UgaWYoeClwb3N0TWVzc2FnZSh7dGFyZ2V0VGhyZWFkOnQsY21kOlwicHJvY2Vzc1Byb3h5aW5nUXVldWVcIixxdWV1ZTpyfSk7ZWxzZXtpZighKHQ9ZHQuVmJbdF0pKXJldHVybjt0LnBvc3RNZXNzYWdlKHtjbWQ6XCJwcm9jZXNzUHJveHlpbmdRdWV1ZVwiLHF1ZXVlOnJ9KX1yZXR1cm4gMX0sRWE6ZnVuY3Rpb24oKXtyZXR1cm4tMX0sUGE6ZnVuY3Rpb24odCxlKXt0PW5ldyBEYXRlKDFlMypCdCh0KSksaSgpW2U+PjI+Pj4wXT10LmdldFVUQ1NlY29uZHMoKSxpKClbZSs0Pj4yPj4+MF09dC5nZXRVVENNaW51dGVzKCksaSgpW2UrOD4+Mj4+PjBdPXQuZ2V0VVRDSG91cnMoKSxpKClbZSsxMj4+Mj4+PjBdPXQuZ2V0VVRDRGF0ZSgpLGkoKVtlKzE2Pj4yPj4+MF09dC5nZXRVVENNb250aCgpLGkoKVtlKzIwPj4yPj4+MF09dC5nZXRVVENGdWxsWWVhcigpLTE5MDAsaSgpW2UrMjQ+PjI+Pj4wXT10LmdldFVUQ0RheSgpLHQ9KHQuZ2V0VGltZSgpLURhdGUuVVRDKHQuZ2V0VVRDRnVsbFllYXIoKSwwLDEsMCwwLDAsMCkpLzg2NGU1fDAsaSgpW2UrMjg+PjI+Pj4wXT10fSxRYTpmdW5jdGlvbih0LGUpe3Q9bmV3IERhdGUoMWUzKkJ0KHQpKSxpKClbZT4+Mj4+PjBdPXQuZ2V0U2Vjb25kcygpLGkoKVtlKzQ+PjI+Pj4wXT10LmdldE1pbnV0ZXMoKSxpKClbZSs4Pj4yPj4+MF09dC5nZXRIb3VycygpLGkoKVtlKzEyPj4yPj4+MF09dC5nZXREYXRlKCksaSgpW2UrMTY+PjI+Pj4wXT10LmdldE1vbnRoKCksaSgpW2UrMjA+PjI+Pj4wXT10LmdldEZ1bGxZZWFyKCktMTkwMCxpKClbZSsyND4+Mj4+PjBdPXQuZ2V0RGF5KCk7dmFyIG49bmV3IERhdGUodC5nZXRGdWxsWWVhcigpLDAsMSkscj0odC5nZXRUaW1lKCktbi5nZXRUaW1lKCkpLzg2NGU1fDA7aSgpW2UrMjg+PjI+Pj4wXT1yLGkoKVtlKzM2Pj4yPj4+MF09LTYwKnQuZ2V0VGltZXpvbmVPZmZzZXQoKSxyPW5ldyBEYXRlKHQuZ2V0RnVsbFllYXIoKSw2LDEpLmdldFRpbWV6b25lT2Zmc2V0KCksdD0wfChyIT0obj1uLmdldFRpbWV6b25lT2Zmc2V0KCkpJiZ0LmdldFRpbWV6b25lT2Zmc2V0KCk9PU1hdGgubWluKG4scikpLGkoKVtlKzMyPj4yPj4+MF09dH0sUmE6ZnVuY3Rpb24odCl7dmFyIGU9bmV3IERhdGUoaSgpW3QrMjA+PjI+Pj4wXSsxOTAwLGkoKVt0KzE2Pj4yPj4+MF0saSgpW3QrMTI+PjI+Pj4wXSxpKClbdCs4Pj4yPj4+MF0saSgpW3QrND4+Mj4+PjBdLGkoKVt0Pj4yPj4+MF0sMCksbj1pKClbdCszMj4+Mj4+PjBdLHI9ZS5nZXRUaW1lem9uZU9mZnNldCgpLG89bmV3IERhdGUoZS5nZXRGdWxsWWVhcigpLDAsMSksYT1uZXcgRGF0ZShlLmdldEZ1bGxZZWFyKCksNiwxKS5nZXRUaW1lem9uZU9mZnNldCgpLHM9by5nZXRUaW1lem9uZU9mZnNldCgpLHU9TWF0aC5taW4ocyxhKTtyZXR1cm4gMD5uP2koKVt0KzMyPj4yPj4+MF09TnVtYmVyKGEhPXMmJnU9PXIpOjA8biE9KHU9PXIpJiYoYT1NYXRoLm1heChzLGEpLGUuc2V0VGltZShlLmdldFRpbWUoKSs2ZTQqKCgwPG4/dTphKS1yKSkpLGkoKVt0KzI0Pj4yPj4+MF09ZS5nZXREYXkoKSxuPShlLmdldFRpbWUoKS1vLmdldFRpbWUoKSkvODY0ZTV8MCxpKClbdCsyOD4+Mj4+PjBdPW4saSgpW3Q+PjI+Pj4wXT1lLmdldFNlY29uZHMoKSxpKClbdCs0Pj4yPj4+MF09ZS5nZXRNaW51dGVzKCksaSgpW3QrOD4+Mj4+PjBdPWUuZ2V0SG91cnMoKSxpKClbdCsxMj4+Mj4+PjBdPWUuZ2V0RGF0ZSgpLGkoKVt0KzE2Pj4yPj4+MF09ZS5nZXRNb250aCgpLGUuZ2V0VGltZSgpLzFlM3wwfSxBYTp6dCxCYTpHdCxTYTpmdW5jdGlvbiB0KGUsbixyKXt0LkFjfHwodC5BYz0hMCxxdChlLG4scikpfSx5OmZ1bmN0aW9uKCl7aXQoXCJcIil9LFU6ZnVuY3Rpb24oKXtpZighdyYmIXYpe3ZhciB0PVwiQmxvY2tpbmcgb24gdGhlIG1haW4gdGhyZWFkIGlzIHZlcnkgZGFuZ2Vyb3VzLCBzZWUgaHR0cHM6Ly9lbXNjcmlwdGVuLm9yZy9kb2NzL3BvcnRpbmcvcHRocmVhZHMuaHRtbCNibG9ja2luZy1vbi10aGUtbWFpbi1icm93c2VyLXRocmVhZFwiO190fHwoX3Q9e30pLF90W3RdfHwoX3RbdF09MSx3JiYodD1cIndhcm5pbmc6IFwiK3QpLFAodCkpfX0scmE6ZnVuY3Rpb24oKXtyZXR1cm4gNDI5NDkwMTc2MH0sQjp2dCxJYTpmdW5jdGlvbih0LGUsbil7cigpLmNvcHlXaXRoaW4odD4+PjAsZT4+PjAsZStuPj4+MCl9LEY6ZnVuY3Rpb24oKXtyZXR1cm4gdz9uKDk3MTkpLmNwdXMoKS5sZW5ndGg6bmF2aWdhdG9yLmhhcmR3YXJlQ29uY3VycmVuY3l9LERhOmZ1bmN0aW9uKHQsZSxuKXtZdC5sZW5ndGg9ZSxuPj49Mztmb3IodmFyIHI9MDtyPGU7cisrKVl0W3JdPWEoKVtuK3I+Pj4wXTtyZXR1cm4oMD50P3N0Wy10LTFdOnBlW3RdKS5hcHBseShudWxsLFl0KX0scWE6ZnVuY3Rpb24odCl7dmFyIGU9cigpLmxlbmd0aDtpZigodD4+Pj0wKTw9ZXx8NDI5NDkwMTc2MDx0KXJldHVybiExO2Zvcih2YXIgbj0xOzQ+PW47bio9Mil7dmFyIGk9ZSooMSsuMi9uKTtpPU1hdGgubWluKGksdCsxMDA2NjMyOTYpO3ZhciBvPU1hdGg7aT1NYXRoLm1heCh0LGkpLG89by5taW4uY2FsbChvLDQyOTQ5MDE3NjAsaSsoNjU1MzYtaSU2NTUzNiklNjU1MzYpO3Q6e3RyeXskLmdyb3coby1DLmJ5dGVMZW5ndGgrNjU1MzU+Pj4xNiksSCgkLmJ1ZmZlcik7dmFyIGE9MTticmVhayB0fWNhdGNoKHQpe31hPXZvaWQgMH1pZihhKXJldHVybiEwfXJldHVybiExfSxOYTpmdW5jdGlvbigpe3Rocm93XCJ1bndpbmRcIn0sR2E6SnQsSGE6UXQsSjpmdCxJOnRlLFM6ZWUsZ2E6bmUsUjpvZSxkOmZ1bmN0aW9uKCl7cmV0dXJuIGFlfSxuYTpmdW5jdGlvbiB0KHIsaSl7dC5sY3x8KHQubGM9ZnVuY3Rpb24oKXtpZihcIm9iamVjdFwiPT10eXBlb2YgY3J5cHRvJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKXt2YXIgdD1uZXcgVWludDhBcnJheSgxKTtyZXR1cm4oKT0+KGNyeXB0by5nZXRSYW5kb21WYWx1ZXModCksdFswXSl9aWYodyl0cnl7dmFyIGU9big2MTEzKTtyZXR1cm4oKT0+ZS5yYW5kb21CeXRlcygxKVswXX1jYXRjaCh0KXt9cmV0dXJuKCk9Pml0KFwicmFuZG9tRGV2aWNlXCIpfSgpKTtmb3IodmFyIG89MDtvPGk7bysrKWUoKVtyK28+PjA+Pj4wXT10LmxjKCk7cmV0dXJuIDB9LGlhOmZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1BZSgpO3RyeXtyZXR1cm4geXQodCkoZSxuKX1jYXRjaCh0KXtpZihFZShyKSx0IT09dCswKXRocm93IHQ7U2UoMSwwKX19LGphOmZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1BZSgpO3RyeXtyZXR1cm4geXQodCkoZSxuKX1jYXRjaCh0KXtpZihFZShyKSx0IT09dCswKXRocm93IHQ7U2UoMSwwKX19LEs6ZnVuY3Rpb24odCl7dmFyIGU9QWUoKTt0cnl7cmV0dXJuIHl0KHQpKCl9Y2F0Y2godCl7aWYoRWUoZSksdCE9PXQrMCl0aHJvdyB0O1NlKDEsMCl9fSxmOmZ1bmN0aW9uKHQsZSl7dmFyIG49QWUoKTt0cnl7cmV0dXJuIHl0KHQpKGUpfWNhdGNoKHQpe2lmKEVlKG4pLHQhPT10KzApdGhyb3cgdDtTZSgxLDApfX0sUDpmdW5jdGlvbih0LGUsbil7dmFyIHI9QWUoKTt0cnl7cmV0dXJuIHl0KHQpKGUsbil9Y2F0Y2godCl7aWYoRWUociksdCE9PXQrMCl0aHJvdyB0O1NlKDEsMCl9fSxROmZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1BZSgpO3RyeXtyZXR1cm4geXQodCkoZSxuKX1jYXRjaCh0KXtpZihFZShyKSx0IT09dCswKXRocm93IHQ7U2UoMSwwKX19LGs6ZnVuY3Rpb24odCxlLG4pe3ZhciByPUFlKCk7dHJ5e3JldHVybiB5dCh0KShlLG4pfWNhdGNoKHQpe2lmKEVlKHIpLHQhPT10KzApdGhyb3cgdDtTZSgxLDApfX0scDpmdW5jdGlvbih0LGUsbixyKXt2YXIgaT1BZSgpO3RyeXtyZXR1cm4geXQodCkoZSxuLHIpfWNhdGNoKHQpe2lmKEVlKGkpLHQhPT10KzApdGhyb3cgdDtTZSgxLDApfX0scTpmdW5jdGlvbih0LGUsbixyLGkpe3ZhciBvPUFlKCk7dHJ5e3JldHVybiB5dCh0KShlLG4scixpKX1jYXRjaCh0KXtpZihFZShvKSx0IT09dCswKXRocm93IHQ7U2UoMSwwKX19LE46ZnVuY3Rpb24odCxlLG4scixpLG8pe3ZhciBhPUFlKCk7dHJ5e3JldHVybiB5dCh0KShlLG4scixpLG8pfWNhdGNoKHQpe2lmKEVlKGEpLHQhPT10KzApdGhyb3cgdDtTZSgxLDApfX0sczpmdW5jdGlvbih0LGUsbixyLGksbyl7dmFyIGE9QWUoKTt0cnl7cmV0dXJuIHl0KHQpKGUsbixyLGksbyl9Y2F0Y2godCl7aWYoRWUoYSksdCE9PXQrMCl0aHJvdyB0O1NlKDEsMCl9fSx3OmZ1bmN0aW9uKHQsZSxuLHIsaSxvLGEpe3ZhciBzPUFlKCk7dHJ5e3JldHVybiB5dCh0KShlLG4scixpLG8sYSl9Y2F0Y2godCl7aWYoRWUocyksdCE9PXQrMCl0aHJvdyB0O1NlKDEsMCl9fSxMOmZ1bmN0aW9uKHQsZSxuLHIsaSxvLGEscyl7dmFyIHU9QWUoKTt0cnl7cmV0dXJuIHl0KHQpKGUsbixyLGksbyxhLHMpfWNhdGNoKHQpe2lmKEVlKHUpLHQhPT10KzApdGhyb3cgdDtTZSgxLDApfX0sRTpmdW5jdGlvbih0LGUsbixyLGksbyxhLHMsdSxjLGwscCl7dmFyIGY9QWUoKTt0cnl7cmV0dXJuIHl0KHQpKGUsbixyLGksbyxhLHMsdSxjLGwscCl9Y2F0Y2godCl7aWYoRWUoZiksdCE9PXQrMCl0aHJvdyB0O1NlKDEsMCl9fSxhYTpmdW5jdGlvbih0LGUsbixyLGksbyxhLHMpe3ZhciB1PUFlKCk7dHJ5e3JldHVybiBqZSh0LGUsbixyLGksbyxhLHMpfWNhdGNoKHQpe2lmKEVlKHUpLHQhPT10KzApdGhyb3cgdDtTZSgxLDApfX0sXzpmdW5jdGlvbih0LGUsbixyLGksbyxhKXt2YXIgcz1BZSgpO3RyeXtyZXR1cm4ga2UodCxlLG4scixpLG8sYSl9Y2F0Y2godCl7aWYoRWUocyksdCE9PXQrMCl0aHJvdyB0O1NlKDEsMCl9fSxaOmZ1bmN0aW9uKHQsZSxuLHIsaSl7dmFyIG89QWUoKTt0cnl7cmV0dXJuIFVlKHQsZSxuLHIsaSl9Y2F0Y2godCl7aWYoRWUobyksdCE9PXQrMCl0aHJvdyB0O1NlKDEsMCl9fSxjYTpmdW5jdGlvbih0LGUsbixyKXt2YXIgaT1BZSgpO3RyeXtyZXR1cm4gTGUodCxlLG4scil9Y2F0Y2godCl7aWYoRWUoaSksdCE9PXQrMCl0aHJvdyB0O1NlKDEsMCl9fSwkOmZ1bmN0aW9uKHQpe3ZhciBlPUFlKCk7dHJ5e3JldHVybiAkZSh0KX1jYXRjaCh0KXtpZihFZShlKSx0IT09dCswKXRocm93IHQ7U2UoMSwwKX19LGJhOmZ1bmN0aW9uKHQsZSl7dmFyIG49QWUoKTt0cnl7cmV0dXJuIE1lKHQsZSl9Y2F0Y2godCl7aWYoRWUobiksdCE9PXQrMCl0aHJvdyB0O1NlKDEsMCl9fSxZOmZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1BZSgpO3RyeXtyZXR1cm4gQ2UodCxlLG4pfWNhdGNoKHQpe2lmKEVlKHIpLHQhPT10KzApdGhyb3cgdDtTZSgxLDApfX0sZzpmdW5jdGlvbih0KXt2YXIgZT1BZSgpO3RyeXt5dCh0KSgpfWNhdGNoKHQpe2lmKEVlKGUpLHQhPT10KzApdGhyb3cgdDtTZSgxLDApfX0scjpmdW5jdGlvbih0LGUpe3ZhciBuPUFlKCk7dHJ5e3l0KHQpKGUpfWNhdGNoKHQpe2lmKEVlKG4pLHQhPT10KzApdGhyb3cgdDtTZSgxLDApfX0saTpmdW5jdGlvbih0LGUsbil7dmFyIHI9QWUoKTt0cnl7eXQodCkoZSxuKX1jYXRjaCh0KXtpZihFZShyKSx0IT09dCswKXRocm93IHQ7U2UoMSwwKX19LGhhOmZ1bmN0aW9uKHQsZSxuLHIpe3ZhciBpPUFlKCk7dHJ5e3l0KHQpKGUsbixyKX1jYXRjaCh0KXtpZihFZShpKSx0IT09dCswKXRocm93IHQ7U2UoMSwwKX19LG06ZnVuY3Rpb24odCxlLG4scil7dmFyIGk9QWUoKTt0cnl7eXQodCkoZSxuLHIpfWNhdGNoKHQpe2lmKEVlKGkpLHQhPT10KzApdGhyb3cgdDtTZSgxLDApfX0sdjpmdW5jdGlvbih0LGUsbixyLGkpe3ZhciBvPUFlKCk7dHJ5e3l0KHQpKGUsbixyLGkpfWNhdGNoKHQpe2lmKEVlKG8pLHQhPT10KzApdGhyb3cgdDtTZSgxLDApfX0sdTpmdW5jdGlvbih0LGUsbixyLGksbyl7dmFyIGE9QWUoKTt0cnl7eXQodCkoZSxuLHIsaSxvKX1jYXRjaCh0KXtpZihFZShhKSx0IT09dCswKXRocm93IHQ7U2UoMSwwKX19LE86ZnVuY3Rpb24odCxlLG4scixpLG8sYSl7dmFyIHM9QWUoKTt0cnl7eXQodCkoZSxuLHIsaSxvLGEpfWNhdGNoKHQpe2lmKEVlKHMpLHQhPT10KzApdGhyb3cgdDtTZSgxLDApfX0sQTpmdW5jdGlvbih0LGUsbixyLGksbyxhLHMpe3ZhciB1PUFlKCk7dHJ5e3l0KHQpKGUsbixyLGksbyxhLHMpfWNhdGNoKHQpe2lmKEVlKHUpLHQhPT10KzApdGhyb3cgdDtTZSgxLDApfX0sa2E6ZnVuY3Rpb24odCxlLG4scixpLG8sYSxzLHUpe3ZhciBjPUFlKCk7dHJ5e3l0KHQpKGUsbixyLGksbyxhLHMsdSl9Y2F0Y2godCl7aWYoRWUoYyksdCE9PXQrMCl0aHJvdyB0O1NlKDEsMCl9fSxDOmZ1bmN0aW9uKHQsZSxuLHIsaSxvLGEscyx1LGMsbCl7dmFyIHA9QWUoKTt0cnl7eXQodCkoZSxuLHIsaSxvLGEscyx1LGMsbCl9Y2F0Y2godCl7aWYoRWUocCksdCE9PXQrMCl0aHJvdyB0O1NlKDEsMCl9fSxEOmZ1bmN0aW9uKHQsZSxuLHIsaSxvLGEscyx1LGMsbCxwLGYsZCxoLGcpe3ZhciBiPUFlKCk7dHJ5e3l0KHQpKGUsbixyLGksbyxhLHMsdSxjLGwscCxmLGQsaCxnKX1jYXRjaCh0KXtpZihFZShiKSx0IT09dCswKXRocm93IHQ7U2UoMSwwKX19LGZhOmZ1bmN0aW9uKHQsZSxuLHIsaSxvLGEscyl7dmFyIHU9QWUoKTt0cnl7RmUodCxlLG4scixpLG8sYSxzKX1jYXRjaCh0KXtpZihFZSh1KSx0IT09dCswKXRocm93IHQ7U2UoMSwwKX19LGRhOmZ1bmN0aW9uKHQsZSxuLHIsaSxvLGEscyx1LGMsbCxwKXt2YXIgZj1BZSgpO3RyeXtSZSh0LGUsbixyLGksbyxhLHMsdSxjLGwscCl9Y2F0Y2godCl7aWYoRWUoZiksdCE9PXQrMCl0aHJvdyB0O1NlKDEsMCl9fSxlYTpmdW5jdGlvbih0LGUsbixyLGksbyl7dmFyIGE9QWUoKTt0cnl7TmUodCxlLG4scixpLG8pfWNhdGNoKHQpe2lmKEVlKGEpLHQhPT10KzApdGhyb3cgdDtTZSgxLDApfX0sbzpmdW5jdGlvbih0KXtyZXR1cm4gdH0sYTokfHxzLndhc21NZW1vcnksRzpmdW5jdGlvbih0KXthZT10fSxsYTpsZSx6OmZ1bmN0aW9uKHQsZSxuLHIpe3JldHVybiBsZSh0LGUsbixyKX19OyFmdW5jdGlvbigpe2Z1bmN0aW9uIHQodCxlKXtzLmFzbT10LmV4cG9ydHMsZHQucWMucHVzaChzLmFzbS5zYiksVz1zLmFzbS51YixZLnVuc2hpZnQocy5hc20uVmEpLGs9ZSx4fHwoZXQtLSxzLm1vbml0b3JSdW5EZXBlbmRlbmNpZXMmJnMubW9uaXRvclJ1bkRlcGVuZGVuY2llcyhldCksMD09ZXQmJihudWxsIT09bnQmJihjbGVhckludGVydmFsKG50KSxudD1udWxsKSxydCYmKHQ9cnQscnQ9bnVsbCx0KCkpKSl9ZnVuY3Rpb24gZShlKXt0KGUuaW5zdGFuY2UsZS5tb2R1bGUpfWZ1bmN0aW9uIG4odCl7cmV0dXJuIGZ1bmN0aW9uKCl7aWYoIUUmJihffHx2KSl7aWYoXCJmdW5jdGlvblwiPT10eXBlb2YgZmV0Y2gmJiF0dC5zdGFydHNXaXRoKFwiZmlsZTovL1wiKSlyZXR1cm4gZmV0Y2godHQse2NyZWRlbnRpYWxzOlwic2FtZS1vcmlnaW5cIn0pLnRoZW4oKGZ1bmN0aW9uKHQpe2lmKCF0Lm9rKXRocm93XCJmYWlsZWQgdG8gbG9hZCB3YXNtIGJpbmFyeSBmaWxlIGF0ICdcIit0dCtcIidcIjtyZXR1cm4gdC5hcnJheUJ1ZmZlcigpfSkpLmNhdGNoKChmdW5jdGlvbigpe3JldHVybiBhdCgpfSkpO2lmKHApcmV0dXJuIG5ldyBQcm9taXNlKChmdW5jdGlvbih0LGUpe3AodHQsKGZ1bmN0aW9uKGUpe3QobmV3IFVpbnQ4QXJyYXkoZSkpfSksZSl9KSl9cmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKGZ1bmN0aW9uKCl7cmV0dXJuIGF0KCl9KSl9KCkudGhlbigoZnVuY3Rpb24odCl7cmV0dXJuIFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlKHQscil9KSkudGhlbigoZnVuY3Rpb24odCl7cmV0dXJuIHR9KSkudGhlbih0LChmdW5jdGlvbih0KXtQKFwiZmFpbGVkIHRvIGFzeW5jaHJvbm91c2x5IHByZXBhcmUgd2FzbTogXCIrdCksaXQodCl9KSl9dmFyIHI9e2E6ZmV9O2lmKHh8fChldCsrLHMubW9uaXRvclJ1bkRlcGVuZGVuY2llcyYmcy5tb25pdG9yUnVuRGVwZW5kZW5jaWVzKGV0KSkscy5pbnN0YW50aWF0ZVdhc20pdHJ5e3JldHVybiBzLmluc3RhbnRpYXRlV2FzbShyLHQpfWNhdGNoKHQpe3JldHVybiBQKFwiTW9kdWxlLmluc3RhbnRpYXRlV2FzbSBjYWxsYmFjayBmYWlsZWQgd2l0aCBlcnJvcjogXCIrdCksITF9KEV8fFwiZnVuY3Rpb25cIiE9dHlwZW9mIFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlU3RyZWFtaW5nfHxvdCgpfHx0dC5zdGFydHNXaXRoKFwiZmlsZTovL1wiKXx8d3x8XCJmdW5jdGlvblwiIT10eXBlb2YgZmV0Y2g/bihlKTpmZXRjaCh0dCx7Y3JlZGVudGlhbHM6XCJzYW1lLW9yaWdpblwifSkudGhlbigoZnVuY3Rpb24odCl7cmV0dXJuIFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlU3RyZWFtaW5nKHQscikudGhlbihlLChmdW5jdGlvbih0KXtyZXR1cm4gUChcIndhc20gc3RyZWFtaW5nIGNvbXBpbGUgZmFpbGVkOiBcIit0KSxQKFwiZmFsbGluZyBiYWNrIHRvIEFycmF5QnVmZmVyIGluc3RhbnRpYXRpb25cIiksbihlKX0pKX0pKSkuY2F0Y2goYyl9KCkscy5fX193YXNtX2NhbGxfY3RvcnM9ZnVuY3Rpb24oKXtyZXR1cm4ocy5fX193YXNtX2NhbGxfY3RvcnM9cy5hc20uVmEpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0scy5fT3J0SW5pdD1mdW5jdGlvbigpe3JldHVybihzLl9PcnRJbml0PXMuYXNtLldhKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHMuX09ydENyZWF0ZVNlc3Npb25PcHRpb25zPWZ1bmN0aW9uKCl7cmV0dXJuKHMuX09ydENyZWF0ZVNlc3Npb25PcHRpb25zPXMuYXNtLlhhKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHMuX09ydEFwcGVuZEV4ZWN1dGlvblByb3ZpZGVyPWZ1bmN0aW9uKCl7cmV0dXJuKHMuX09ydEFwcGVuZEV4ZWN1dGlvblByb3ZpZGVyPXMuYXNtLllhKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHMuX09ydEFkZFNlc3Npb25Db25maWdFbnRyeT1mdW5jdGlvbigpe3JldHVybihzLl9PcnRBZGRTZXNzaW9uQ29uZmlnRW50cnk9cy5hc20uWmEpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0scy5fT3J0UmVsZWFzZVNlc3Npb25PcHRpb25zPWZ1bmN0aW9uKCl7cmV0dXJuKHMuX09ydFJlbGVhc2VTZXNzaW9uT3B0aW9ucz1zLmFzbS5fYSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxzLl9PcnRDcmVhdGVTZXNzaW9uPWZ1bmN0aW9uKCl7cmV0dXJuKHMuX09ydENyZWF0ZVNlc3Npb249cy5hc20uJGEpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0scy5fT3J0UmVsZWFzZVNlc3Npb249ZnVuY3Rpb24oKXtyZXR1cm4ocy5fT3J0UmVsZWFzZVNlc3Npb249cy5hc20uYWIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0scy5fT3J0R2V0SW5wdXRDb3VudD1mdW5jdGlvbigpe3JldHVybihzLl9PcnRHZXRJbnB1dENvdW50PXMuYXNtLmJiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHMuX09ydEdldE91dHB1dENvdW50PWZ1bmN0aW9uKCl7cmV0dXJuKHMuX09ydEdldE91dHB1dENvdW50PXMuYXNtLmNiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHMuX09ydEdldElucHV0TmFtZT1mdW5jdGlvbigpe3JldHVybihzLl9PcnRHZXRJbnB1dE5hbWU9cy5hc20uZGIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0scy5fT3J0R2V0T3V0cHV0TmFtZT1mdW5jdGlvbigpe3JldHVybihzLl9PcnRHZXRPdXRwdXROYW1lPXMuYXNtLmViKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHMuX09ydEZyZWU9ZnVuY3Rpb24oKXtyZXR1cm4ocy5fT3J0RnJlZT1zLmFzbS5mYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxzLl9PcnRDcmVhdGVUZW5zb3I9ZnVuY3Rpb24oKXtyZXR1cm4ocy5fT3J0Q3JlYXRlVGVuc29yPXMuYXNtLmdiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHMuX09ydEdldFRlbnNvckRhdGE9ZnVuY3Rpb24oKXtyZXR1cm4ocy5fT3J0R2V0VGVuc29yRGF0YT1zLmFzbS5oYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxzLl9PcnRSZWxlYXNlVGVuc29yPWZ1bmN0aW9uKCl7cmV0dXJuKHMuX09ydFJlbGVhc2VUZW5zb3I9cy5hc20uaWIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0scy5fT3J0Q3JlYXRlUnVuT3B0aW9ucz1mdW5jdGlvbigpe3JldHVybihzLl9PcnRDcmVhdGVSdW5PcHRpb25zPXMuYXNtLmpiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHMuX09ydEFkZFJ1bkNvbmZpZ0VudHJ5PWZ1bmN0aW9uKCl7cmV0dXJuKHMuX09ydEFkZFJ1bkNvbmZpZ0VudHJ5PXMuYXNtLmtiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHMuX09ydFJlbGVhc2VSdW5PcHRpb25zPWZ1bmN0aW9uKCl7cmV0dXJuKHMuX09ydFJlbGVhc2VSdW5PcHRpb25zPXMuYXNtLmxiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHMuX09ydFJ1bj1mdW5jdGlvbigpe3JldHVybihzLl9PcnRSdW49cy5hc20ubWIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0scy5fT3J0RW5kUHJvZmlsaW5nPWZ1bmN0aW9uKCl7cmV0dXJuKHMuX09ydEVuZFByb2ZpbGluZz1zLmFzbS5uYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfTt2YXIgZGU9cy5fcHRocmVhZF9zZWxmPWZ1bmN0aW9uKCl7cmV0dXJuKGRlPXMuX3B0aHJlYWRfc2VsZj1zLmFzbS5vYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxoZT1zLl9tYWxsb2M9ZnVuY3Rpb24oKXtyZXR1cm4oaGU9cy5fbWFsbG9jPXMuYXNtLnBiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGdlPXMuX2ZyZWU9ZnVuY3Rpb24oKXtyZXR1cm4oZ2U9cy5fZnJlZT1zLmFzbS5xYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxiZT1zLl9mZmx1c2g9ZnVuY3Rpb24oKXtyZXR1cm4oYmU9cy5fZmZsdXNoPXMuYXNtLnJiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O3MuX19lbXNjcmlwdGVuX3Rsc19pbml0PWZ1bmN0aW9uKCl7cmV0dXJuKHMuX19lbXNjcmlwdGVuX3Rsc19pbml0PXMuYXNtLnNiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O3ZhciBtZT1zLl9fX2Z1bmNzX29uX2V4aXQ9ZnVuY3Rpb24oKXtyZXR1cm4obWU9cy5fX19mdW5jc19vbl9leGl0PXMuYXNtLnRiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHllPXMuX19lbXNjcmlwdGVuX3RocmVhZF9pbml0PWZ1bmN0aW9uKCl7cmV0dXJuKHllPXMuX19lbXNjcmlwdGVuX3RocmVhZF9pbml0PXMuYXNtLnZiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O3MuX19lbXNjcmlwdGVuX3RocmVhZF9jcmFzaGVkPWZ1bmN0aW9uKCl7cmV0dXJuKHMuX19lbXNjcmlwdGVuX3RocmVhZF9jcmFzaGVkPXMuYXNtLndiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O3ZhciBfZSx2ZT1zLl9lbXNjcmlwdGVuX3J1bl9pbl9tYWluX3J1bnRpbWVfdGhyZWFkX2pzPWZ1bmN0aW9uKCl7cmV0dXJuKHZlPXMuX2Vtc2NyaXB0ZW5fcnVuX2luX21haW5fcnVudGltZV90aHJlYWRfanM9cy5hc20ueGIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sd2U9cy5fX2Vtc2NyaXB0ZW5fcHJveHlfZXhlY3V0ZV90YXNrX3F1ZXVlPWZ1bmN0aW9uKCl7cmV0dXJuKHdlPXMuX19lbXNjcmlwdGVuX3Byb3h5X2V4ZWN1dGVfdGFza19xdWV1ZT1zLmFzbS55YikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSx4ZT1zLl9fZW1zY3JpcHRlbl90aHJlYWRfZnJlZV9kYXRhPWZ1bmN0aW9uKCl7cmV0dXJuKHhlPXMuX19lbXNjcmlwdGVuX3RocmVhZF9mcmVlX2RhdGE9cy5hc20uemIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sVGU9cy5fX2Vtc2NyaXB0ZW5fdGhyZWFkX2V4aXQ9ZnVuY3Rpb24oKXtyZXR1cm4oVGU9cy5fX2Vtc2NyaXB0ZW5fdGhyZWFkX2V4aXQ9cy5hc20uQWIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sU2U9cy5fc2V0VGhyZXc9ZnVuY3Rpb24oKXtyZXR1cm4oU2U9cy5fc2V0VGhyZXc9cy5hc20uQmIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sT2U9cy5fZW1zY3JpcHRlbl9zdGFja19zZXRfbGltaXRzPWZ1bmN0aW9uKCl7cmV0dXJuKE9lPXMuX2Vtc2NyaXB0ZW5fc3RhY2tfc2V0X2xpbWl0cz1zLmFzbS5DYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxBZT1zLnN0YWNrU2F2ZT1mdW5jdGlvbigpe3JldHVybihBZT1zLnN0YWNrU2F2ZT1zLmFzbS5EYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxFZT1zLnN0YWNrUmVzdG9yZT1mdW5jdGlvbigpe3JldHVybihFZT1zLnN0YWNrUmVzdG9yZT1zLmFzbS5FYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxJZT1zLnN0YWNrQWxsb2M9ZnVuY3Rpb24oKXtyZXR1cm4oSWU9cy5zdGFja0FsbG9jPXMuYXNtLkZiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LFBlPXMuX19fY3hhX2Nhbl9jYXRjaD1mdW5jdGlvbigpe3JldHVybihQZT1zLl9fX2N4YV9jYW5fY2F0Y2g9cy5hc20uR2IpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sRGU9cy5fX19jeGFfaXNfcG9pbnRlcl90eXBlPWZ1bmN0aW9uKCl7cmV0dXJuKERlPXMuX19fY3hhX2lzX3BvaW50ZXJfdHlwZT1zLmFzbS5IYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSwkZT1zLmR5bkNhbGxfaj1mdW5jdGlvbigpe3JldHVybigkZT1zLmR5bkNhbGxfaj1zLmFzbS5JYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxrZT1zLmR5bkNhbGxfaWlpaWlqPWZ1bmN0aW9uKCl7cmV0dXJuKGtlPXMuZHluQ2FsbF9paWlpaWo9cy5hc20uSmIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sQ2U9cy5keW5DYWxsX2ppaT1mdW5jdGlvbigpe3JldHVybihDZT1zLmR5bkNhbGxfamlpPXMuYXNtLktiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LEZlPXMuZHluQ2FsbF92aWlpaWlqPWZ1bmN0aW9uKCl7cmV0dXJuKEZlPXMuZHluQ2FsbF92aWlpaWlqPXMuYXNtLkxiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LE5lPXMuZHluQ2FsbF92amppPWZ1bmN0aW9uKCl7cmV0dXJuKE5lPXMuZHluQ2FsbF92amppPXMuYXNtLk1iKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LFJlPXMuZHluQ2FsbF92aWlpampqaWk9ZnVuY3Rpb24oKXtyZXR1cm4oUmU9cy5keW5DYWxsX3ZpaWlqamppaT1zLmFzbS5OYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxMZT1zLmR5bkNhbGxfaWlqPWZ1bmN0aW9uKCl7cmV0dXJuKExlPXMuZHluQ2FsbF9paWo9cy5hc20uT2IpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sTWU9cy5keW5DYWxsX2ppPWZ1bmN0aW9uKCl7cmV0dXJuKE1lPXMuZHluQ2FsbF9qaT1zLmFzbS5QYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxqZT1zLmR5bkNhbGxfaWlpaWlpaj1mdW5jdGlvbigpe3JldHVybihqZT1zLmR5bkNhbGxfaWlpaWlpaj1zLmFzbS5RYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxVZT1zLmR5bkNhbGxfaWlpaj1mdW5jdGlvbigpe3JldHVybihVZT1zLmR5bkNhbGxfaWlpaj1zLmFzbS5SYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfTtmdW5jdGlvbiBWZSgpe2Z1bmN0aW9uIHQoKXtpZighX2UmJihfZT0hMCxzLmNhbGxlZFJ1bj0hMCwhaikmJih4fHxodChZKSx1KHMpLHMub25SdW50aW1lSW5pdGlhbGl6ZWQmJnMub25SdW50aW1lSW5pdGlhbGl6ZWQoKSwheCkpe2lmKHMucG9zdFJ1bilmb3IoXCJmdW5jdGlvblwiPT10eXBlb2Ygcy5wb3N0UnVuJiYocy5wb3N0UnVuPVtzLnBvc3RSdW5dKTtzLnBvc3RSdW4ubGVuZ3RoOyl7dmFyIHQ9cy5wb3N0UnVuLnNoaWZ0KCk7Wi51bnNoaWZ0KHQpfWh0KFopfX1pZighKDA8ZXQpKWlmKHgpdShzKSx4fHxodChZKSxwb3N0TWVzc2FnZSh7Y21kOlwibG9hZGVkXCJ9KTtlbHNle2lmKHMucHJlUnVuKWZvcihcImZ1bmN0aW9uXCI9PXR5cGVvZiBzLnByZVJ1biYmKHMucHJlUnVuPVtzLnByZVJ1bl0pO3MucHJlUnVuLmxlbmd0aDspUSgpO2h0KFgpLDA8ZXR8fChzLnNldFN0YXR1cz8ocy5zZXRTdGF0dXMoXCJSdW5uaW5nLi4uXCIpLHNldFRpbWVvdXQoKGZ1bmN0aW9uKCl7c2V0VGltZW91dCgoZnVuY3Rpb24oKXtzLnNldFN0YXR1cyhcIlwiKX0pLDEpLHQoKX0pLDEpKTp0KCkpfX1pZihzLlVURjhUb1N0cmluZz1CLHMuc3RyaW5nVG9VVEY4PWZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4geih0LHIoKSxlLG4pfSxzLmxlbmd0aEJ5dGVzVVRGOD1HLHMua2VlcFJ1bnRpbWVBbGl2ZT1KLHMud2FzbU1lbW9yeT0kLHMuc3RhY2tTYXZlPUFlLHMuc3RhY2tSZXN0b3JlPUVlLHMuc3RhY2tBbGxvYz1JZSxzLkV4aXRTdGF0dXM9dXQscy5QVGhyZWFkPWR0LHJ0PWZ1bmN0aW9uIHQoKXtfZXx8VmUoKSxfZXx8KHJ0PXQpfSxzLnByZUluaXQpZm9yKFwiZnVuY3Rpb25cIj09dHlwZW9mIHMucHJlSW5pdCYmKHMucHJlSW5pdD1bcy5wcmVJbml0XSk7MDxzLnByZUluaXQubGVuZ3RoOylzLnByZUluaXQucG9wKCkoKTtyZXR1cm4gVmUoKSx0LnJlYWR5fSk7dC5leHBvcnRzPXJ9LDkzMjoodCxlLG4pPT57dmFyIF9zY3JpcHREaXIscj0oX3NjcmlwdERpcj0oX3NjcmlwdERpcj1cInVuZGVmaW5lZFwiIT10eXBlb2YgZG9jdW1lbnQmJmRvY3VtZW50LmN1cnJlbnRTY3JpcHQ/ZG9jdW1lbnQuY3VycmVudFNjcmlwdC5zcmM6dm9pZCAwKXx8X19maWxlbmFtZSxmdW5jdGlvbih0KXt2YXIgZSxyLGk7dD10fHx7fSxlfHwoZT12b2lkIDAhPT10P3Q6e30pLGUucmVhZHk9bmV3IFByb21pc2UoKGZ1bmN0aW9uKHQsZSl7cj10LGk9ZX0pKTt2YXIgbyxhLHMsdSxjLGwscD1PYmplY3QuYXNzaWduKHt9LGUpLGY9XCIuL3RoaXMucHJvZ3JhbVwiLGQ9KHQsZSk9Pnt0aHJvdyBlfSxoPVwib2JqZWN0XCI9PXR5cGVvZiB3aW5kb3csZz1cImZ1bmN0aW9uXCI9PXR5cGVvZiBpbXBvcnRTY3JpcHRzLGI9XCJvYmplY3RcIj09dHlwZW9mIHByb2Nlc3MmJlwib2JqZWN0XCI9PXR5cGVvZiBwcm9jZXNzLnZlcnNpb25zJiZcInN0cmluZ1wiPT10eXBlb2YgcHJvY2Vzcy52ZXJzaW9ucy5ub2RlLG09XCJcIjtiPyhtPWc/bigxNDIzKS5kaXJuYW1lKG0pK1wiL1wiOl9fZGlybmFtZStcIi9cIixsPSgpPT57Y3x8KHU9big2MjMxKSxjPW4oMTQyMykpfSxvPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIGwoKSx0PWMubm9ybWFsaXplKHQpLHUucmVhZEZpbGVTeW5jKHQsZT92b2lkIDA6XCJ1dGY4XCIpfSxzPXQ9PigodD1vKHQsITApKS5idWZmZXJ8fCh0PW5ldyBVaW50OEFycmF5KHQpKSx0KSxhPSh0LGUsbik9PntsKCksdD1jLm5vcm1hbGl6ZSh0KSx1LnJlYWRGaWxlKHQsKGZ1bmN0aW9uKHQscil7dD9uKHQpOmUoci5idWZmZXIpfSkpfSwxPHByb2Nlc3MuYXJndi5sZW5ndGgmJihmPXByb2Nlc3MuYXJndlsxXS5yZXBsYWNlKC9cXFxcL2csXCIvXCIpKSxwcm9jZXNzLmFyZ3Yuc2xpY2UoMikscHJvY2Vzcy5vbihcInVuY2F1Z2h0RXhjZXB0aW9uXCIsKGZ1bmN0aW9uKHQpe2lmKCEodCBpbnN0YW5jZW9mIEspKXRocm93IHR9KSkscHJvY2Vzcy5vbihcInVuaGFuZGxlZFJlamVjdGlvblwiLChmdW5jdGlvbih0KXt0aHJvdyB0fSkpLGQ9KHQsZSk9PntpZih3fHwwPFUpdGhyb3cgcHJvY2Vzcy5leGl0Q29kZT10LGU7ZSBpbnN0YW5jZW9mIEt8fHYoXCJleGl0aW5nIGR1ZSB0byBleGNlcHRpb246IFwiK2UpLHByb2Nlc3MuZXhpdCh0KX0sZS5pbnNwZWN0PWZ1bmN0aW9uKCl7cmV0dXJuXCJbRW1zY3JpcHRlbiBNb2R1bGUgb2JqZWN0XVwifSk6KGh8fGcpJiYoZz9tPXNlbGYubG9jYXRpb24uaHJlZjpcInVuZGVmaW5lZFwiIT10eXBlb2YgZG9jdW1lbnQmJmRvY3VtZW50LmN1cnJlbnRTY3JpcHQmJihtPWRvY3VtZW50LmN1cnJlbnRTY3JpcHQuc3JjKSxfc2NyaXB0RGlyJiYobT1fc2NyaXB0RGlyKSxtPTAhPT1tLmluZGV4T2YoXCJibG9iOlwiKT9tLnN1YnN0cigwLG0ucmVwbGFjZSgvWz8jXS4qLyxcIlwiKS5sYXN0SW5kZXhPZihcIi9cIikrMSk6XCJcIixvPXQ9Pnt2YXIgZT1uZXcgWE1MSHR0cFJlcXVlc3Q7cmV0dXJuIGUub3BlbihcIkdFVFwiLHQsITEpLGUuc2VuZChudWxsKSxlLnJlc3BvbnNlVGV4dH0sZyYmKHM9dD0+e3ZhciBlPW5ldyBYTUxIdHRwUmVxdWVzdDtyZXR1cm4gZS5vcGVuKFwiR0VUXCIsdCwhMSksZS5yZXNwb25zZVR5cGU9XCJhcnJheWJ1ZmZlclwiLGUuc2VuZChudWxsKSxuZXcgVWludDhBcnJheShlLnJlc3BvbnNlKX0pLGE9KHQsZSxuKT0+e3ZhciByPW5ldyBYTUxIdHRwUmVxdWVzdDtyLm9wZW4oXCJHRVRcIix0LCEwKSxyLnJlc3BvbnNlVHlwZT1cImFycmF5YnVmZmVyXCIsci5vbmxvYWQ9KCk9PnsyMDA9PXIuc3RhdHVzfHwwPT1yLnN0YXR1cyYmci5yZXNwb25zZT9lKHIucmVzcG9uc2UpOm4oKX0sci5vbmVycm9yPW4sci5zZW5kKG51bGwpfSk7dmFyIHksXz1lLnByaW50fHxjb25zb2xlLmxvZy5iaW5kKGNvbnNvbGUpLHY9ZS5wcmludEVycnx8Y29uc29sZS53YXJuLmJpbmQoY29uc29sZSk7T2JqZWN0LmFzc2lnbihlLHApLHA9bnVsbCxlLnRoaXNQcm9ncmFtJiYoZj1lLnRoaXNQcm9ncmFtKSxlLnF1aXQmJihkPWUucXVpdCksZS53YXNtQmluYXJ5JiYoeT1lLndhc21CaW5hcnkpO3ZhciB3PWUubm9FeGl0UnVudGltZXx8ITE7XCJvYmplY3RcIiE9dHlwZW9mIFdlYkFzc2VtYmx5JiZxKFwibm8gbmF0aXZlIHdhc20gc3VwcG9ydCBkZXRlY3RlZFwiKTt2YXIgeCxULFMsTyxBLEUsST0hMSxQPVwidW5kZWZpbmVkXCIhPXR5cGVvZiBUZXh0RGVjb2Rlcj9uZXcgVGV4dERlY29kZXIoXCJ1dGY4XCIpOnZvaWQgMDtmdW5jdGlvbiBEKHQsZSxuKXt2YXIgcj0oZT4+Pj0wKStuO2ZvcihuPWU7dFtuXSYmIShuPj1yKTspKytuO2lmKDE2PG4tZSYmdC5idWZmZXImJlApcmV0dXJuIFAuZGVjb2RlKHQuc3ViYXJyYXkoZSxuKSk7Zm9yKHI9XCJcIjtlPG47KXt2YXIgaT10W2UrK107aWYoMTI4Jmkpe3ZhciBvPTYzJnRbZSsrXTtpZigxOTI9PSgyMjQmaSkpcis9U3RyaW5nLmZyb21DaGFyQ29kZSgoMzEmaSk8PDZ8byk7ZWxzZXt2YXIgYT02MyZ0W2UrK107NjU1MzY+KGk9MjI0PT0oMjQwJmkpPygxNSZpKTw8MTJ8bzw8NnxhOig3JmkpPDwxOHxvPDwxMnxhPDw2fDYzJnRbZSsrXSk/cis9U3RyaW5nLmZyb21DaGFyQ29kZShpKTooaS09NjU1MzYscis9U3RyaW5nLmZyb21DaGFyQ29kZSg1NTI5NnxpPj4xMCw1NjMyMHwxMDIzJmkpKX19ZWxzZSByKz1TdHJpbmcuZnJvbUNoYXJDb2RlKGkpfXJldHVybiByfWZ1bmN0aW9uICQodCxlKXtyZXR1cm4odD4+Pj0wKT9EKE8sdCxlKTpcIlwifWZ1bmN0aW9uIGsodCxlLG4scil7aWYoISgwPHIpKXJldHVybiAwO3ZhciBpPW4+Pj49MDtyPW4rci0xO2Zvcih2YXIgbz0wO288dC5sZW5ndGg7KytvKXt2YXIgYT10LmNoYXJDb2RlQXQobyk7aWYoNTUyOTY8PWEmJjU3MzQzPj1hJiYoYT02NTUzNisoKDEwMjMmYSk8PDEwKXwxMDIzJnQuY2hhckNvZGVBdCgrK28pKSwxMjc+PWEpe2lmKG4+PXIpYnJlYWs7ZVtuKys+Pj4wXT1hfWVsc2V7aWYoMjA0Nz49YSl7aWYobisxPj1yKWJyZWFrO2VbbisrPj4+MF09MTkyfGE+PjZ9ZWxzZXtpZig2NTUzNT49YSl7aWYobisyPj1yKWJyZWFrO2VbbisrPj4+MF09MjI0fGE+PjEyfWVsc2V7aWYobiszPj1yKWJyZWFrO2VbbisrPj4+MF09MjQwfGE+PjE4LGVbbisrPj4+MF09MTI4fGE+PjEyJjYzfWVbbisrPj4+MF09MTI4fGE+PjYmNjN9ZVtuKys+Pj4wXT0xMjh8NjMmYX19cmV0dXJuIGVbbj4+PjBdPTAsbi1pfWZ1bmN0aW9uIEModCl7Zm9yKHZhciBlPTAsbj0wO248dC5sZW5ndGg7KytuKXt2YXIgcj10LmNoYXJDb2RlQXQobik7MTI3Pj1yP2UrKzoyMDQ3Pj1yP2UrPTI6NTUyOTY8PXImJjU3MzQzPj1yPyhlKz00LCsrbik6ZSs9M31yZXR1cm4gZX1mdW5jdGlvbiBGKCl7dmFyIHQ9eC5idWZmZXI7VD10LGUuSEVBUDg9Uz1uZXcgSW50OEFycmF5KHQpLGUuSEVBUDE2PW5ldyBJbnQxNkFycmF5KHQpLGUuSEVBUDMyPUE9bmV3IEludDMyQXJyYXkodCksZS5IRUFQVTg9Tz1uZXcgVWludDhBcnJheSh0KSxlLkhFQVBVMTY9bmV3IFVpbnQxNkFycmF5KHQpLGUuSEVBUFUzMj1FPW5ldyBVaW50MzJBcnJheSh0KSxlLkhFQVBGMzI9bmV3IEZsb2F0MzJBcnJheSh0KSxlLkhFQVBGNjQ9bmV3IEZsb2F0NjRBcnJheSh0KX12YXIgTixSPVtdLEw9W10sTT1bXSxqPVtdLFU9MDtmdW5jdGlvbiBWKCl7dmFyIHQ9ZS5wcmVSdW4uc2hpZnQoKTtSLnVuc2hpZnQodCl9dmFyIEIsej0wLEc9bnVsbCxIPW51bGw7ZnVuY3Rpb24gcSh0KXt0aHJvdyBlLm9uQWJvcnQmJmUub25BYm9ydCh0KSx2KHQ9XCJBYm9ydGVkKFwiK3QrXCIpXCIpLEk9ITAsdD1uZXcgV2ViQXNzZW1ibHkuUnVudGltZUVycm9yKHQrXCIuIEJ1aWxkIHdpdGggLXNBU1NFUlRJT05TIGZvciBtb3JlIGluZm8uXCIpLGkodCksdH1mdW5jdGlvbiBXKCl7cmV0dXJuIEIuc3RhcnRzV2l0aChcImRhdGE6YXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtO2Jhc2U2NCxcIil9aWYoQj1cIm9ydC13YXNtLndhc21cIiwhVygpKXt2YXIgWD1CO0I9ZS5sb2NhdGVGaWxlP2UubG9jYXRlRmlsZShYLG0pOm0rWH1mdW5jdGlvbiBZKCl7dmFyIHQ9Qjt0cnl7aWYodD09QiYmeSlyZXR1cm4gbmV3IFVpbnQ4QXJyYXkoeSk7aWYocylyZXR1cm4gcyh0KTt0aHJvd1wiYm90aCBhc3luYyBhbmQgc3luYyBmZXRjaGluZyBvZiB0aGUgd2FzbSBmYWlsZWRcIn1jYXRjaCh0KXtxKHQpfX1mdW5jdGlvbiBLKHQpe3RoaXMubmFtZT1cIkV4aXRTdGF0dXNcIix0aGlzLm1lc3NhZ2U9XCJQcm9ncmFtIHRlcm1pbmF0ZWQgd2l0aCBleGl0KFwiK3QrXCIpXCIsdGhpcy5zdGF0dXM9dH1mdW5jdGlvbiBaKHQpe2Zvcig7MDx0Lmxlbmd0aDspdC5zaGlmdCgpKGUpfXZhciBKPVtdLFE9MCx0dD0wO2Z1bmN0aW9uIGV0KHQpe3RoaXMuRGI9dCx0aGlzLnpiPXQtMjQsdGhpcy5VYj1mdW5jdGlvbih0KXtFW3RoaXMuemIrND4+Mj4+PjBdPXR9LHRoaXMuRWI9ZnVuY3Rpb24oKXtyZXR1cm4gRVt0aGlzLnpiKzQ+PjI+Pj4wXX0sdGhpcy5TYj1mdW5jdGlvbih0KXtFW3RoaXMuemIrOD4+Mj4+PjBdPXR9LHRoaXMuV2I9ZnVuY3Rpb24oKXtyZXR1cm4gRVt0aGlzLnpiKzg+PjI+Pj4wXX0sdGhpcy5UYj1mdW5jdGlvbigpe0FbdGhpcy56Yj4+Mj4+PjBdPTB9LHRoaXMuSWI9ZnVuY3Rpb24odCl7U1t0aGlzLnpiKzEyPj4wPj4+MF09dD8xOjB9LHRoaXMuUGI9ZnVuY3Rpb24oKXtyZXR1cm4gMCE9U1t0aGlzLnpiKzEyPj4wPj4+MF19LHRoaXMuSmI9ZnVuY3Rpb24odCl7U1t0aGlzLnpiKzEzPj4wPj4+MF09dD8xOjB9LHRoaXMuTGI9ZnVuY3Rpb24oKXtyZXR1cm4gMCE9U1t0aGlzLnpiKzEzPj4wPj4+MF19LHRoaXMuUmI9ZnVuY3Rpb24odCxlKXt0aGlzLkZiKDApLHRoaXMuVWIodCksdGhpcy5TYihlKSx0aGlzLlRiKCksdGhpcy5JYighMSksdGhpcy5KYighMSl9LHRoaXMuTmI9ZnVuY3Rpb24oKXtBW3RoaXMuemI+PjI+Pj4wXSs9MX0sdGhpcy5YYj1mdW5jdGlvbigpe3ZhciB0PUFbdGhpcy56Yj4+Mj4+PjBdO3JldHVybiBBW3RoaXMuemI+PjI+Pj4wXT10LTEsMT09PXR9LHRoaXMuRmI9ZnVuY3Rpb24odCl7RVt0aGlzLnpiKzE2Pj4yPj4+MF09dH0sdGhpcy5PYj1mdW5jdGlvbigpe3JldHVybiBFW3RoaXMuemIrMTY+PjI+Pj4wXX0sdGhpcy5RYj1mdW5jdGlvbigpe2lmKEV0KHRoaXMuRWIoKSkpcmV0dXJuIEVbdGhpcy5EYj4+Mj4+PjBdO3ZhciB0PXRoaXMuT2IoKTtyZXR1cm4gMCE9PXQ/dDp0aGlzLkRifX1mdW5jdGlvbiBudCh0KXtyZXR1cm4gX3QobmV3IGV0KHQpLnpiKX12YXIgcnQ9W107ZnVuY3Rpb24gaXQodCl7dmFyIGU9cnRbdF07cmV0dXJuIGV8fCh0Pj1ydC5sZW5ndGgmJihydC5sZW5ndGg9dCsxKSxydFt0XT1lPU4uZ2V0KHQpKSxlfWZ1bmN0aW9uIG90KHQpe3ZhciBlPUModCkrMSxuPXl0KGUpO3JldHVybiBuJiZrKHQsUyxuLGUpLG59dmFyIGF0PXt9O2Z1bmN0aW9uIHN0KCl7aWYoIXV0KXt2YXIgdCxlPXtVU0VSOlwid2ViX3VzZXJcIixMT0dOQU1FOlwid2ViX3VzZXJcIixQQVRIOlwiL1wiLFBXRDpcIi9cIixIT01FOlwiL2hvbWUvd2ViX3VzZXJcIixMQU5HOihcIm9iamVjdFwiPT10eXBlb2YgbmF2aWdhdG9yJiZuYXZpZ2F0b3IubGFuZ3VhZ2VzJiZuYXZpZ2F0b3IubGFuZ3VhZ2VzWzBdfHxcIkNcIikucmVwbGFjZShcIi1cIixcIl9cIikrXCIuVVRGLThcIixfOmZ8fFwiLi90aGlzLnByb2dyYW1cIn07Zm9yKHQgaW4gYXQpdm9pZCAwPT09YXRbdF0/ZGVsZXRlIGVbdF06ZVt0XT1hdFt0XTt2YXIgbj1bXTtmb3IodCBpbiBlKW4ucHVzaCh0K1wiPVwiK2VbdF0pO3V0PW59cmV0dXJuIHV0fXZhciB1dCxjdD1bbnVsbCxbXSxbXV07ZnVuY3Rpb24gbHQodCxlKXt2YXIgbj1jdFt0XTswPT09ZXx8MTA9PT1lPygoMT09PXQ/Xzp2KShEKG4sMCkpLG4ubGVuZ3RoPTApOm4ucHVzaChlKX12YXIgcHQ9MDtmdW5jdGlvbiBmdCh0KXtyZXR1cm4gMD09dCU0JiYoMCE9dCUxMDB8fDA9PXQlNDAwKX12YXIgZHQ9WzMxLDI5LDMxLDMwLDMxLDMwLDMxLDMxLDMwLDMxLDMwLDMxXSxodD1bMzEsMjgsMzEsMzAsMzEsMzAsMzEsMzEsMzAsMzEsMzAsMzFdO2Z1bmN0aW9uIGd0KHQsZSxuLHIpe2Z1bmN0aW9uIGkodCxlLG4pe2Zvcih0PVwibnVtYmVyXCI9PXR5cGVvZiB0P3QudG9TdHJpbmcoKTp0fHxcIlwiO3QubGVuZ3RoPGU7KXQ9blswXSt0O3JldHVybiB0fWZ1bmN0aW9uIG8odCxlKXtyZXR1cm4gaSh0LGUsXCIwXCIpfWZ1bmN0aW9uIGEodCxlKXtmdW5jdGlvbiBuKHQpe3JldHVybiAwPnQ/LTE6MDx0PzE6MH12YXIgcjtyZXR1cm4gMD09PShyPW4odC5nZXRGdWxsWWVhcigpLWUuZ2V0RnVsbFllYXIoKSkpJiYwPT09KHI9bih0LmdldE1vbnRoKCktZS5nZXRNb250aCgpKSkmJihyPW4odC5nZXREYXRlKCktZS5nZXREYXRlKCkpKSxyfWZ1bmN0aW9uIHModCl7c3dpdGNoKHQuZ2V0RGF5KCkpe2Nhc2UgMDpyZXR1cm4gbmV3IERhdGUodC5nZXRGdWxsWWVhcigpLTEsMTEsMjkpO2Nhc2UgMTpyZXR1cm4gdDtjYXNlIDI6cmV0dXJuIG5ldyBEYXRlKHQuZ2V0RnVsbFllYXIoKSwwLDMpO2Nhc2UgMzpyZXR1cm4gbmV3IERhdGUodC5nZXRGdWxsWWVhcigpLDAsMik7Y2FzZSA0OnJldHVybiBuZXcgRGF0ZSh0LmdldEZ1bGxZZWFyKCksMCwxKTtjYXNlIDU6cmV0dXJuIG5ldyBEYXRlKHQuZ2V0RnVsbFllYXIoKS0xLDExLDMxKTtjYXNlIDY6cmV0dXJuIG5ldyBEYXRlKHQuZ2V0RnVsbFllYXIoKS0xLDExLDMwKX19ZnVuY3Rpb24gdSh0KXt2YXIgZT10LkJiO2Zvcih0PW5ldyBEYXRlKG5ldyBEYXRlKHQuQ2IrMTkwMCwwLDEpLmdldFRpbWUoKSk7MDxlOyl7dmFyIG49dC5nZXRNb250aCgpLHI9KGZ0KHQuZ2V0RnVsbFllYXIoKSk/ZHQ6aHQpW25dO2lmKCEoZT5yLXQuZ2V0RGF0ZSgpKSl7dC5zZXREYXRlKHQuZ2V0RGF0ZSgpK2UpO2JyZWFrfWUtPXItdC5nZXREYXRlKCkrMSx0LnNldERhdGUoMSksMTE+bj90LnNldE1vbnRoKG4rMSk6KHQuc2V0TW9udGgoMCksdC5zZXRGdWxsWWVhcih0LmdldEZ1bGxZZWFyKCkrMSkpfXJldHVybiBuPW5ldyBEYXRlKHQuZ2V0RnVsbFllYXIoKSsxLDAsNCksZT1zKG5ldyBEYXRlKHQuZ2V0RnVsbFllYXIoKSwwLDQpKSxuPXMobiksMD49YShlLHQpPzA+PWEobix0KT90LmdldEZ1bGxZZWFyKCkrMTp0LmdldEZ1bGxZZWFyKCk6dC5nZXRGdWxsWWVhcigpLTF9dmFyIGM9QVtyKzQwPj4yPj4+MF07Zm9yKHZhciBsIGluIHI9eyRiOkFbcj4+Mj4+PjBdLFpiOkFbcis0Pj4yPj4+MF0sR2I6QVtyKzg+PjI+Pj4wXSxLYjpBW3IrMTI+PjI+Pj4wXSxIYjpBW3IrMTY+PjI+Pj4wXSxDYjpBW3IrMjA+PjI+Pj4wXSxBYjpBW3IrMjQ+PjI+Pj4wXSxCYjpBW3IrMjg+PjI+Pj4wXSxiYzpBW3IrMzI+PjI+Pj4wXSxZYjpBW3IrMzY+PjI+Pj4wXSxhYzpjPyQoYyk6XCJcIn0sbj0kKG4pLGM9e1wiJWNcIjpcIiVhICViICVkICVIOiVNOiVTICVZXCIsXCIlRFwiOlwiJW0vJWQvJXlcIixcIiVGXCI6XCIlWS0lbS0lZFwiLFwiJWhcIjpcIiViXCIsXCIlclwiOlwiJUk6JU06JVMgJXBcIixcIiVSXCI6XCIlSDolTVwiLFwiJVRcIjpcIiVIOiVNOiVTXCIsXCIleFwiOlwiJW0vJWQvJXlcIixcIiVYXCI6XCIlSDolTTolU1wiLFwiJUVjXCI6XCIlY1wiLFwiJUVDXCI6XCIlQ1wiLFwiJUV4XCI6XCIlbS8lZC8leVwiLFwiJUVYXCI6XCIlSDolTTolU1wiLFwiJUV5XCI6XCIleVwiLFwiJUVZXCI6XCIlWVwiLFwiJU9kXCI6XCIlZFwiLFwiJU9lXCI6XCIlZVwiLFwiJU9IXCI6XCIlSFwiLFwiJU9JXCI6XCIlSVwiLFwiJU9tXCI6XCIlbVwiLFwiJU9NXCI6XCIlTVwiLFwiJU9TXCI6XCIlU1wiLFwiJU91XCI6XCIldVwiLFwiJU9VXCI6XCIlVVwiLFwiJU9WXCI6XCIlVlwiLFwiJU93XCI6XCIld1wiLFwiJU9XXCI6XCIlV1wiLFwiJU95XCI6XCIleVwifSluPW4ucmVwbGFjZShuZXcgUmVnRXhwKGwsXCJnXCIpLGNbbF0pO3ZhciBwPVwiU3VuZGF5IE1vbmRheSBUdWVzZGF5IFdlZG5lc2RheSBUaHVyc2RheSBGcmlkYXkgU2F0dXJkYXlcIi5zcGxpdChcIiBcIiksZj1cIkphbnVhcnkgRmVicnVhcnkgTWFyY2ggQXByaWwgTWF5IEp1bmUgSnVseSBBdWd1c3QgU2VwdGVtYmVyIE9jdG9iZXIgTm92ZW1iZXIgRGVjZW1iZXJcIi5zcGxpdChcIiBcIik7Zm9yKGwgaW4gYz17XCIlYVwiOmZ1bmN0aW9uKHQpe3JldHVybiBwW3QuQWJdLnN1YnN0cmluZygwLDMpfSxcIiVBXCI6ZnVuY3Rpb24odCl7cmV0dXJuIHBbdC5BYl19LFwiJWJcIjpmdW5jdGlvbih0KXtyZXR1cm4gZlt0LkhiXS5zdWJzdHJpbmcoMCwzKX0sXCIlQlwiOmZ1bmN0aW9uKHQpe3JldHVybiBmW3QuSGJdfSxcIiVDXCI6ZnVuY3Rpb24odCl7cmV0dXJuIG8oKHQuQ2IrMTkwMCkvMTAwfDAsMil9LFwiJWRcIjpmdW5jdGlvbih0KXtyZXR1cm4gbyh0LktiLDIpfSxcIiVlXCI6ZnVuY3Rpb24odCl7cmV0dXJuIGkodC5LYiwyLFwiIFwiKX0sXCIlZ1wiOmZ1bmN0aW9uKHQpe3JldHVybiB1KHQpLnRvU3RyaW5nKCkuc3Vic3RyaW5nKDIpfSxcIiVHXCI6ZnVuY3Rpb24odCl7cmV0dXJuIHUodCl9LFwiJUhcIjpmdW5jdGlvbih0KXtyZXR1cm4gbyh0LkdiLDIpfSxcIiVJXCI6ZnVuY3Rpb24odCl7cmV0dXJuIDA9PSh0PXQuR2IpP3Q9MTI6MTI8dCYmKHQtPTEyKSxvKHQsMil9LFwiJWpcIjpmdW5jdGlvbih0KXtmb3IodmFyIGU9MCxuPTA7bjw9dC5IYi0xO2UrPShmdCh0LkNiKzE5MDApP2R0Omh0KVtuKytdKTtyZXR1cm4gbyh0LktiK2UsMyl9LFwiJW1cIjpmdW5jdGlvbih0KXtyZXR1cm4gbyh0LkhiKzEsMil9LFwiJU1cIjpmdW5jdGlvbih0KXtyZXR1cm4gbyh0LlpiLDIpfSxcIiVuXCI6ZnVuY3Rpb24oKXtyZXR1cm5cIlxcblwifSxcIiVwXCI6ZnVuY3Rpb24odCl7cmV0dXJuIDA8PXQuR2ImJjEyPnQuR2I/XCJBTVwiOlwiUE1cIn0sXCIlU1wiOmZ1bmN0aW9uKHQpe3JldHVybiBvKHQuJGIsMil9LFwiJXRcIjpmdW5jdGlvbigpe3JldHVyblwiXFx0XCJ9LFwiJXVcIjpmdW5jdGlvbih0KXtyZXR1cm4gdC5BYnx8N30sXCIlVVwiOmZ1bmN0aW9uKHQpe3JldHVybiBvKE1hdGguZmxvb3IoKHQuQmIrNy10LkFiKS83KSwyKX0sXCIlVlwiOmZ1bmN0aW9uKHQpe3ZhciBlPU1hdGguZmxvb3IoKHQuQmIrNy0odC5BYis2KSU3KS83KTtpZigyPj0odC5BYiszNzEtdC5CYi0yKSU3JiZlKyssZSk1Mz09ZSYmKDQ9PShuPSh0LkFiKzM3MS10LkJiKSU3KXx8Mz09biYmZnQodC5DYil8fChlPTEpKTtlbHNle2U9NTI7dmFyIG49KHQuQWIrNy10LkJiLTEpJTc7KDQ9PW58fDU9PW4mJmZ0KHQuQ2IlNDAwLTEpKSYmZSsrfXJldHVybiBvKGUsMil9LFwiJXdcIjpmdW5jdGlvbih0KXtyZXR1cm4gdC5BYn0sXCIlV1wiOmZ1bmN0aW9uKHQpe3JldHVybiBvKE1hdGguZmxvb3IoKHQuQmIrNy0odC5BYis2KSU3KS83KSwyKX0sXCIleVwiOmZ1bmN0aW9uKHQpe3JldHVybih0LkNiKzE5MDApLnRvU3RyaW5nKCkuc3Vic3RyaW5nKDIpfSxcIiVZXCI6ZnVuY3Rpb24odCl7cmV0dXJuIHQuQ2IrMTkwMH0sXCIlelwiOmZ1bmN0aW9uKHQpe3ZhciBlPTA8PSh0PXQuWWIpO3JldHVybiB0PU1hdGguYWJzKHQpLzYwLChlP1wiK1wiOlwiLVwiKStTdHJpbmcoXCIwMDAwXCIrKHQvNjAqMTAwK3QlNjApKS5zbGljZSgtNCl9LFwiJVpcIjpmdW5jdGlvbih0KXtyZXR1cm4gdC5hY30sXCIlJVwiOmZ1bmN0aW9uKCl7cmV0dXJuXCIlXCJ9fSxuPW4ucmVwbGFjZSgvJSUvZyxcIlxcMFxcMFwiKSxjKW4uaW5jbHVkZXMobCkmJihuPW4ucmVwbGFjZShuZXcgUmVnRXhwKGwsXCJnXCIpLGNbbF0ocikpKTtyZXR1cm4gbD1mdW5jdGlvbih0KXt2YXIgZT1BcnJheShDKHQpKzEpO3JldHVybiBrKHQsZSwwLGUubGVuZ3RoKSxlfShuPW4ucmVwbGFjZSgvXFwwXFwwL2csXCIlXCIpKSxsLmxlbmd0aD5lPzA6KFMuc2V0KGwsdD4+PjApLGwubGVuZ3RoLTEpfXZhciBidD17YTpmdW5jdGlvbih0KXtyZXR1cm4geXQodCsyNCkrMjR9LG06ZnVuY3Rpb24odCl7cmV0dXJuKHQ9bmV3IGV0KHQpKS5QYigpfHwodC5JYighMCksUS0tKSx0LkpiKCExKSxKLnB1c2godCksdC5OYigpLHQuUWIoKX0saWE6ZnVuY3Rpb24odCl7dGhyb3cgdihcIlVuZXhwZWN0ZWQgZXhjZXB0aW9uIHRocm93biwgdGhpcyBpcyBub3QgcHJvcGVybHkgc3VwcG9ydGVkIC0gYWJvcnRpbmdcIiksST0hMCx0fSx3OmZ1bmN0aW9uKCl7eHQoMCk7dmFyIHQ9Si5wb3AoKTtpZih0LlhiKCkmJiF0LkxiKCkpe3ZhciBlPXQuV2IoKTtlJiZpdChlKSh0LkRiKSxudCh0LkRiKX10dD0wfSxkOmZ1bmN0aW9uKCl7dmFyIHQ9dHQ7aWYoIXQpcmV0dXJuIHB0PTA7dmFyIGU9bmV3IGV0KHQpO2UuRmIodCk7dmFyIG49ZS5FYigpO2lmKCFuKXJldHVybiBwdD0wLHQ7Zm9yKHZhciByPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyksaT0wO2k8ci5sZW5ndGg7aSsrKXt2YXIgbz1yW2ldO2lmKDA9PT1vfHxvPT09bilicmVhaztpZihBdChvLG4sZS56YisxNikpcmV0dXJuIHB0PW8sdH1yZXR1cm4gcHQ9bix0fSxrOmZ1bmN0aW9uKCl7dmFyIHQ9dHQ7aWYoIXQpcmV0dXJuIHB0PTA7dmFyIGU9bmV3IGV0KHQpO2UuRmIodCk7dmFyIG49ZS5FYigpO2lmKCFuKXJldHVybiBwdD0wLHQ7Zm9yKHZhciByPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyksaT0wO2k8ci5sZW5ndGg7aSsrKXt2YXIgbz1yW2ldO2lmKDA9PT1vfHxvPT09bilicmVhaztpZihBdChvLG4sZS56YisxNikpcmV0dXJuIHB0PW8sdH1yZXR1cm4gcHQ9bix0fSxnOmZ1bmN0aW9uKCl7dmFyIHQ9dHQ7aWYoIXQpcmV0dXJuIHB0PTA7dmFyIGU9bmV3IGV0KHQpO2UuRmIodCk7dmFyIG49ZS5FYigpO2lmKCFuKXJldHVybiBwdD0wLHQ7Zm9yKHZhciByPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyksaT0wO2k8ci5sZW5ndGg7aSsrKXt2YXIgbz1yW2ldO2lmKDA9PT1vfHxvPT09bilicmVhaztpZihBdChvLG4sZS56YisxNikpcmV0dXJuIHB0PW8sdH1yZXR1cm4gcHQ9bix0fSxzOm50LEw6ZnVuY3Rpb24oKXt2YXIgdD1KLnBvcCgpO3R8fHEoXCJubyBleGNlcHRpb24gdG8gdGhyb3dcIik7dmFyIGU9dC5EYjt0aHJvdyB0LkxiKCl8fChKLnB1c2godCksdC5KYighMCksdC5JYighMSksUSsrKSx0dD1lLGV9LGI6ZnVuY3Rpb24odCxlLG4pe3Rocm93IG5ldyBldCh0KS5SYihlLG4pLHR0PXQsUSsrLHR9LGxhOmZ1bmN0aW9uKCl7cmV0dXJuIFF9LGk6ZnVuY3Rpb24odCl7dGhyb3cgdHR8fCh0dD10KSx0fSxIOmZ1bmN0aW9uKCl7cmV0dXJuIDB9LEJhOmZ1bmN0aW9uKCl7fSxwYTpmdW5jdGlvbigpe30scmE6ZnVuY3Rpb24oKXt9LGthOmZ1bmN0aW9uKCl7cmV0dXJuIDB9LHphOmZ1bmN0aW9uKCl7fSx1YTpmdW5jdGlvbigpe30seWE6ZnVuY3Rpb24oKXt9LFI6ZnVuY3Rpb24oKXt9LHFhOmZ1bmN0aW9uKCl7fSxuYTpmdW5jdGlvbigpe30sQWE6ZnVuY3Rpb24oKXt9LG9hOmZ1bmN0aW9uKCl7fSxIYTpmdW5jdGlvbigpe30sSmE6ZnVuY3Rpb24oKXtxKFwiVG8gdXNlIGRsb3BlbiwgeW91IG5lZWQgZW5hYmxlIGR5bmFtaWMgbGlua2luZywgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9lbXNjcmlwdGVuLWNvcmUvZW1zY3JpcHRlbi93aWtpL0xpbmtpbmdcIil9LElhOmZ1bmN0aW9uKCl7cShcIlRvIHVzZSBkbG9wZW4sIHlvdSBuZWVkIGVuYWJsZSBkeW5hbWljIGxpbmtpbmcsIHNlZSBodHRwczovL2dpdGh1Yi5jb20vZW1zY3JpcHRlbi1jb3JlL2Vtc2NyaXB0ZW4vd2lraS9MaW5raW5nXCIpfSxTOmZ1bmN0aW9uKCl7cmV0dXJuIERhdGUubm93KCl9LENhOmZ1bmN0aW9uKCl7cmV0dXJuITB9LERhOmZ1bmN0aW9uKHQsZSl7dD1uZXcgRGF0ZSgxZTMqKEVbdD4+PjJdKzQyOTQ5NjcyOTYqQVt0KzQ+Pj4yXSkpLEFbZT4+Mj4+PjBdPXQuZ2V0VVRDU2Vjb25kcygpLEFbZSs0Pj4yPj4+MF09dC5nZXRVVENNaW51dGVzKCksQVtlKzg+PjI+Pj4wXT10LmdldFVUQ0hvdXJzKCksQVtlKzEyPj4yPj4+MF09dC5nZXRVVENEYXRlKCksQVtlKzE2Pj4yPj4+MF09dC5nZXRVVENNb250aCgpLEFbZSsyMD4+Mj4+PjBdPXQuZ2V0VVRDRnVsbFllYXIoKS0xOTAwLEFbZSsyND4+Mj4+PjBdPXQuZ2V0VVRDRGF5KCksQVtlKzI4Pj4yPj4+MF09KHQuZ2V0VGltZSgpLURhdGUuVVRDKHQuZ2V0VVRDRnVsbFllYXIoKSwwLDEsMCwwLDAsMCkpLzg2NGU1fDB9LEVhOmZ1bmN0aW9uKHQsZSl7dD1uZXcgRGF0ZSgxZTMqKEVbdD4+PjJdKzQyOTQ5NjcyOTYqQVt0KzQ+Pj4yXSkpLEFbZT4+Mj4+PjBdPXQuZ2V0U2Vjb25kcygpLEFbZSs0Pj4yPj4+MF09dC5nZXRNaW51dGVzKCksQVtlKzg+PjI+Pj4wXT10LmdldEhvdXJzKCksQVtlKzEyPj4yPj4+MF09dC5nZXREYXRlKCksQVtlKzE2Pj4yPj4+MF09dC5nZXRNb250aCgpLEFbZSsyMD4+Mj4+PjBdPXQuZ2V0RnVsbFllYXIoKS0xOTAwLEFbZSsyND4+Mj4+PjBdPXQuZ2V0RGF5KCk7dmFyIG49bmV3IERhdGUodC5nZXRGdWxsWWVhcigpLDAsMSk7QVtlKzI4Pj4yPj4+MF09KHQuZ2V0VGltZSgpLW4uZ2V0VGltZSgpKS84NjRlNXwwLEFbZSszNj4+Mj4+PjBdPS02MCp0LmdldFRpbWV6b25lT2Zmc2V0KCk7dmFyIHI9bmV3IERhdGUodC5nZXRGdWxsWWVhcigpLDYsMSkuZ2V0VGltZXpvbmVPZmZzZXQoKTtuPW4uZ2V0VGltZXpvbmVPZmZzZXQoKSxBW2UrMzI+PjI+Pj4wXT0wfChyIT1uJiZ0LmdldFRpbWV6b25lT2Zmc2V0KCk9PU1hdGgubWluKG4scikpfSxGYTpmdW5jdGlvbih0KXt2YXIgZT1uZXcgRGF0ZShBW3QrMjA+PjI+Pj4wXSsxOTAwLEFbdCsxNj4+Mj4+PjBdLEFbdCsxMj4+Mj4+PjBdLEFbdCs4Pj4yPj4+MF0sQVt0KzQ+PjI+Pj4wXSxBW3Q+PjI+Pj4wXSwwKSxuPUFbdCszMj4+Mj4+PjBdLHI9ZS5nZXRUaW1lem9uZU9mZnNldCgpLGk9bmV3IERhdGUoZS5nZXRGdWxsWWVhcigpLDAsMSksbz1uZXcgRGF0ZShlLmdldEZ1bGxZZWFyKCksNiwxKS5nZXRUaW1lem9uZU9mZnNldCgpLGE9aS5nZXRUaW1lem9uZU9mZnNldCgpLHM9TWF0aC5taW4oYSxvKTtyZXR1cm4gMD5uP0FbdCszMj4+Mj4+PjBdPU51bWJlcihvIT1hJiZzPT1yKTowPG4hPShzPT1yKSYmKG89TWF0aC5tYXgoYSxvKSxlLnNldFRpbWUoZS5nZXRUaW1lKCkrNmU0KigoMDxuP3M6byktcikpKSxBW3QrMjQ+PjI+Pj4wXT1lLmdldERheSgpLEFbdCsyOD4+Mj4+PjBdPShlLmdldFRpbWUoKS1pLmdldFRpbWUoKSkvODY0ZTV8MCxBW3Q+PjI+Pj4wXT1lLmdldFNlY29uZHMoKSxBW3QrND4+Mj4+PjBdPWUuZ2V0TWludXRlcygpLEFbdCs4Pj4yPj4+MF09ZS5nZXRIb3VycygpLEFbdCsxMj4+Mj4+PjBdPWUuZ2V0RGF0ZSgpLEFbdCsxNj4+Mj4+PjBdPWUuZ2V0TW9udGgoKSxlLmdldFRpbWUoKS8xZTN8MH0sc2E6ZnVuY3Rpb24oKXtyZXR1cm4tNTJ9LHRhOmZ1bmN0aW9uKCl7fSxHYTpmdW5jdGlvbiB0KGUsbixyKXt0LlZifHwodC5WYj0hMCxmdW5jdGlvbih0LGUsbil7ZnVuY3Rpb24gcih0KXtyZXR1cm4odD10LnRvVGltZVN0cmluZygpLm1hdGNoKC9cXCgoW0EtWmEteiBdKylcXCkkLykpP3RbMV06XCJHTVRcIn12YXIgaT0obmV3IERhdGUpLmdldEZ1bGxZZWFyKCksbz1uZXcgRGF0ZShpLDAsMSksYT1uZXcgRGF0ZShpLDYsMSk7aT1vLmdldFRpbWV6b25lT2Zmc2V0KCk7dmFyIHM9YS5nZXRUaW1lem9uZU9mZnNldCgpO0FbdD4+Mj4+PjBdPTYwKk1hdGgubWF4KGkscyksQVtlPj4yPj4+MF09TnVtYmVyKGkhPXMpLHQ9cihvKSxlPXIoYSksdD1vdCh0KSxlPW90KGUpLHM8aT8oRVtuPj4yPj4+MF09dCxFW24rND4+Mj4+PjBdPWUpOihFW24+PjI+Pj4wXT1lLEVbbis0Pj4yPj4+MF09dCl9KGUsbixyKSl9LEI6ZnVuY3Rpb24oKXtxKFwiXCIpfSxtYTpmdW5jdGlvbigpe3JldHVybiA0Mjk0OTAxNzYwfSxJOmI/KCk9Pnt2YXIgdD1wcm9jZXNzLmhydGltZSgpO3JldHVybiAxZTMqdFswXSt0WzFdLzFlNn06KCk9PnBlcmZvcm1hbmNlLm5vdygpLHhhOmZ1bmN0aW9uKHQsZSxuKXtPLmNvcHlXaXRoaW4odD4+PjAsZT4+PjAsZStuPj4+MCl9LEc6ZnVuY3Rpb24odCl7dmFyIGU9Ty5sZW5ndGg7aWYoNDI5NDkwMTc2MDwodD4+Pj0wKSlyZXR1cm4hMTtmb3IodmFyIG49MTs0Pj1uO24qPTIpe3ZhciByPWUqKDErLjIvbik7cj1NYXRoLm1pbihyLHQrMTAwNjYzMjk2KTt2YXIgaT1NYXRoO3I9TWF0aC5tYXgodCxyKSxpPWkubWluLmNhbGwoaSw0Mjk0OTAxNzYwLHIrKDY1NTM2LXIlNjU1MzYpJTY1NTM2KTt0Ont0cnl7eC5ncm93KGktVC5ieXRlTGVuZ3RoKzY1NTM1Pj4+MTYpLEYoKTt2YXIgbz0xO2JyZWFrIHR9Y2F0Y2godCl7fW89dm9pZCAwfWlmKG8pcmV0dXJuITB9cmV0dXJuITF9LHZhOmZ1bmN0aW9uKHQsZSl7dmFyIG49MDtyZXR1cm4gc3QoKS5mb3JFYWNoKChmdW5jdGlvbihyLGkpe3ZhciBvPWUrbjtmb3IoaT1FW3QrNCppPj4yPj4+MF09byxvPTA7bzxyLmxlbmd0aDsrK28pU1tpKys+PjA+Pj4wXT1yLmNoYXJDb2RlQXQobyk7U1tpPj4wPj4+MF09MCxuKz1yLmxlbmd0aCsxfSkpLDB9LHdhOmZ1bmN0aW9uKHQsZSl7dmFyIG49c3QoKTtFW3Q+PjI+Pj4wXT1uLmxlbmd0aDt2YXIgcj0wO3JldHVybiBuLmZvckVhY2goKGZ1bmN0aW9uKHQpe3IrPXQubGVuZ3RoKzF9KSksRVtlPj4yPj4+MF09ciwwfSxiYTpmdW5jdGlvbih0KXt3fHwwPFV8fCh3dCgpLFooTSksdnQoMCksY3RbMV0ubGVuZ3RoJiZsdCgxLDEwKSxjdFsyXS5sZW5ndGgmJmx0KDIsMTApKSx3fHwwPFV8fChlLm9uRXhpdCYmZS5vbkV4aXQodCksST0hMCksZCh0LG5ldyBLKHQpKX0sRTpmdW5jdGlvbigpe3JldHVybiA1Mn0sUTpmdW5jdGlvbigpe3JldHVybiA1Mn0sY2E6ZnVuY3Rpb24oKXtyZXR1cm4gNzB9LFA6ZnVuY3Rpb24odCxlLG4scil7Zm9yKHZhciBpPTAsbz0wO288bjtvKyspe3ZhciBhPUVbZT4+Mj4+PjBdLHM9RVtlKzQ+PjI+Pj4wXTtlKz04O2Zvcih2YXIgdT0wO3U8czt1KyspbHQodCxPW2ErdT4+PjBdKTtpKz1zfXJldHVybiBFW3I+PjI+Pj4wXT1pLDB9LGM6ZnVuY3Rpb24oKXtyZXR1cm4gcHR9LGphOmZ1bmN0aW9uIHQoZSxyKXt0Lk1ifHwodC5NYj1mdW5jdGlvbigpe2lmKFwib2JqZWN0XCI9PXR5cGVvZiBjcnlwdG8mJlwiZnVuY3Rpb25cIj09dHlwZW9mIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMpe3ZhciB0PW5ldyBVaW50OEFycmF5KDEpO3JldHVybigpPT4oY3J5cHRvLmdldFJhbmRvbVZhbHVlcyh0KSx0WzBdKX1pZihiKXRyeXt2YXIgZT1uKDYxMTMpO3JldHVybigpPT5lLnJhbmRvbUJ5dGVzKDEpWzBdfWNhdGNoKHQpe31yZXR1cm4oKT0+cShcInJhbmRvbURldmljZVwiKX0oKSk7Zm9yKHZhciBpPTA7aTxyO2krKylTW2UraT4+MD4+PjBdPXQuTWIoKTtyZXR1cm4gMH0sZWE6ZnVuY3Rpb24odCxlLG4pe3ZhciByPVR0KCk7dHJ5e3JldHVybiBpdCh0KShlLG4pfWNhdGNoKHQpe2lmKFN0KHIpLHQhPT10KzApdGhyb3cgdDt4dCgxLDApfX0sZmE6ZnVuY3Rpb24odCxlLG4pe3ZhciByPVR0KCk7dHJ5e3JldHVybiBpdCh0KShlLG4pfWNhdGNoKHQpe2lmKFN0KHIpLHQhPT10KzApdGhyb3cgdDt4dCgxLDApfX0sSjpmdW5jdGlvbih0KXt2YXIgZT1UdCgpO3RyeXtyZXR1cm4gaXQodCkoKX1jYXRjaCh0KXtpZihTdChlKSx0IT09dCswKXRocm93IHQ7eHQoMSwwKX19LGU6ZnVuY3Rpb24odCxlKXt2YXIgbj1UdCgpO3RyeXtyZXR1cm4gaXQodCkoZSl9Y2F0Y2godCl7aWYoU3QobiksdCE9PXQrMCl0aHJvdyB0O3h0KDEsMCl9fSxOOmZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1UdCgpO3RyeXtyZXR1cm4gaXQodCkoZSxuKX1jYXRjaCh0KXtpZihTdChyKSx0IT09dCswKXRocm93IHQ7eHQoMSwwKX19LE86ZnVuY3Rpb24odCxlLG4pe3ZhciByPVR0KCk7dHJ5e3JldHVybiBpdCh0KShlLG4pfWNhdGNoKHQpe2lmKFN0KHIpLHQhPT10KzApdGhyb3cgdDt4dCgxLDApfX0sajpmdW5jdGlvbih0LGUsbil7dmFyIHI9VHQoKTt0cnl7cmV0dXJuIGl0KHQpKGUsbil9Y2F0Y2godCl7aWYoU3QociksdCE9PXQrMCl0aHJvdyB0O3h0KDEsMCl9fSxvOmZ1bmN0aW9uKHQsZSxuLHIpe3ZhciBpPVR0KCk7dHJ5e3JldHVybiBpdCh0KShlLG4scil9Y2F0Y2godCl7aWYoU3QoaSksdCE9PXQrMCl0aHJvdyB0O3h0KDEsMCl9fSxwOmZ1bmN0aW9uKHQsZSxuLHIsaSl7dmFyIG89VHQoKTt0cnl7cmV0dXJuIGl0KHQpKGUsbixyLGkpfWNhdGNoKHQpe2lmKFN0KG8pLHQhPT10KzApdGhyb3cgdDt4dCgxLDApfX0sTTpmdW5jdGlvbih0LGUsbixyLGksbyl7dmFyIGE9VHQoKTt0cnl7cmV0dXJuIGl0KHQpKGUsbixyLGksbyl9Y2F0Y2godCl7aWYoU3QoYSksdCE9PXQrMCl0aHJvdyB0O3h0KDEsMCl9fSxyOmZ1bmN0aW9uKHQsZSxuLHIsaSxvKXt2YXIgYT1UdCgpO3RyeXtyZXR1cm4gaXQodCkoZSxuLHIsaSxvKX1jYXRjaCh0KXtpZihTdChhKSx0IT09dCswKXRocm93IHQ7eHQoMSwwKX19LHY6ZnVuY3Rpb24odCxlLG4scixpLG8sYSl7dmFyIHM9VHQoKTt0cnl7cmV0dXJuIGl0KHQpKGUsbixyLGksbyxhKX1jYXRjaCh0KXtpZihTdChzKSx0IT09dCswKXRocm93IHQ7eHQoMSwwKX19LEs6ZnVuY3Rpb24odCxlLG4scixpLG8sYSxzKXt2YXIgdT1UdCgpO3RyeXtyZXR1cm4gaXQodCkoZSxuLHIsaSxvLGEscyl9Y2F0Y2godCl7aWYoU3QodSksdCE9PXQrMCl0aHJvdyB0O3h0KDEsMCl9fSxEOmZ1bmN0aW9uKHQsZSxuLHIsaSxvLGEscyx1LGMsbCxwKXt2YXIgZj1UdCgpO3RyeXtyZXR1cm4gaXQodCkoZSxuLHIsaSxvLGEscyx1LGMsbCxwKX1jYXRjaCh0KXtpZihTdChmKSx0IT09dCswKXRocm93IHQ7eHQoMSwwKX19LFg6ZnVuY3Rpb24odCxlLG4scixpLG8sYSxzKXt2YXIgdT1UdCgpO3RyeXtyZXR1cm4gUnQodCxlLG4scixpLG8sYSxzKX1jYXRjaCh0KXtpZihTdCh1KSx0IT09dCswKXRocm93IHQ7eHQoMSwwKX19LFY6ZnVuY3Rpb24odCxlLG4scixpLG8sYSl7dmFyIHM9VHQoKTt0cnl7cmV0dXJuIFB0KHQsZSxuLHIsaSxvLGEpfWNhdGNoKHQpe2lmKFN0KHMpLHQhPT10KzApdGhyb3cgdDt4dCgxLDApfX0sVTpmdW5jdGlvbih0LGUsbixyLGkpe3ZhciBvPVR0KCk7dHJ5e3JldHVybiBMdCh0LGUsbixyLGkpfWNhdGNoKHQpe2lmKFN0KG8pLHQhPT10KzApdGhyb3cgdDt4dCgxLDApfX0sWjpmdW5jdGlvbih0LGUsbixyKXt2YXIgaT1UdCgpO3RyeXtyZXR1cm4gRnQodCxlLG4scil9Y2F0Y2godCl7aWYoU3QoaSksdCE9PXQrMCl0aHJvdyB0O3h0KDEsMCl9fSxXOmZ1bmN0aW9uKHQpe3ZhciBlPVR0KCk7dHJ5e3JldHVybiBJdCh0KX1jYXRjaCh0KXtpZihTdChlKSx0IT09dCswKXRocm93IHQ7eHQoMSwwKX19LFk6ZnVuY3Rpb24odCxlKXt2YXIgbj1UdCgpO3RyeXtyZXR1cm4gTnQodCxlKX1jYXRjaCh0KXtpZihTdChuKSx0IT09dCswKXRocm93IHQ7eHQoMSwwKX19LFQ6ZnVuY3Rpb24odCxlLG4pe3ZhciByPVR0KCk7dHJ5e3JldHVybiBEdCh0LGUsbil9Y2F0Y2godCl7aWYoU3QociksdCE9PXQrMCl0aHJvdyB0O3h0KDEsMCl9fSxmOmZ1bmN0aW9uKHQpe3ZhciBlPVR0KCk7dHJ5e2l0KHQpKCl9Y2F0Y2godCl7aWYoU3QoZSksdCE9PXQrMCl0aHJvdyB0O3h0KDEsMCl9fSxxOmZ1bmN0aW9uKHQsZSl7dmFyIG49VHQoKTt0cnl7aXQodCkoZSl9Y2F0Y2godCl7aWYoU3QobiksdCE9PXQrMCl0aHJvdyB0O3h0KDEsMCl9fSxoOmZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1UdCgpO3RyeXtpdCh0KShlLG4pfWNhdGNoKHQpe2lmKFN0KHIpLHQhPT10KzApdGhyb3cgdDt4dCgxLDApfX0sZGE6ZnVuY3Rpb24odCxlLG4scil7dmFyIGk9VHQoKTt0cnl7aXQodCkoZSxuLHIpfWNhdGNoKHQpe2lmKFN0KGkpLHQhPT10KzApdGhyb3cgdDt4dCgxLDApfX0sbDpmdW5jdGlvbih0LGUsbixyKXt2YXIgaT1UdCgpO3RyeXtpdCh0KShlLG4scil9Y2F0Y2godCl7aWYoU3QoaSksdCE9PXQrMCl0aHJvdyB0O3h0KDEsMCl9fSx0OmZ1bmN0aW9uKHQsZSxuLHIsaSl7dmFyIG89VHQoKTt0cnl7aXQodCkoZSxuLHIsaSl9Y2F0Y2godCl7aWYoU3QobyksdCE9PXQrMCl0aHJvdyB0O3h0KDEsMCl9fSx1OmZ1bmN0aW9uKHQsZSxuLHIsaSxvKXt2YXIgYT1UdCgpO3RyeXtpdCh0KShlLG4scixpLG8pfWNhdGNoKHQpe2lmKFN0KGEpLHQhPT10KzApdGhyb3cgdDt4dCgxLDApfX0seDpmdW5jdGlvbih0LGUsbixyLGksbyxhKXt2YXIgcz1UdCgpO3RyeXtpdCh0KShlLG4scixpLG8sYSl9Y2F0Y2godCl7aWYoU3QocyksdCE9PXQrMCl0aHJvdyB0O3h0KDEsMCl9fSx6OmZ1bmN0aW9uKHQsZSxuLHIsaSxvLGEscyl7dmFyIHU9VHQoKTt0cnl7aXQodCkoZSxuLHIsaSxvLGEscyl9Y2F0Y2godCl7aWYoU3QodSksdCE9PXQrMCl0aHJvdyB0O3h0KDEsMCl9fSxnYTpmdW5jdGlvbih0LGUsbixyLGksbyxhLHMsdSl7dmFyIGM9VHQoKTt0cnl7aXQodCkoZSxuLHIsaSxvLGEscyx1KX1jYXRjaCh0KXtpZihTdChjKSx0IT09dCswKXRocm93IHQ7eHQoMSwwKX19LEE6ZnVuY3Rpb24odCxlLG4scixpLG8sYSxzLHUsYyxsKXt2YXIgcD1UdCgpO3RyeXtpdCh0KShlLG4scixpLG8sYSxzLHUsYyxsKX1jYXRjaCh0KXtpZihTdChwKSx0IT09dCswKXRocm93IHQ7eHQoMSwwKX19LEM6ZnVuY3Rpb24odCxlLG4scixpLG8sYSxzLHUsYyxsLHAsZixkLGgsZyl7dmFyIGI9VHQoKTt0cnl7aXQodCkoZSxuLHIsaSxvLGEscyx1LGMsbCxwLGYsZCxoLGcpfWNhdGNoKHQpe2lmKFN0KGIpLHQhPT10KzApdGhyb3cgdDt4dCgxLDApfX0sYWE6ZnVuY3Rpb24odCxlLG4scixpLG8sYSxzKXt2YXIgdT1UdCgpO3RyeXskdCh0LGUsbixyLGksbyxhLHMpfWNhdGNoKHQpe2lmKFN0KHUpLHQhPT10KzApdGhyb3cgdDt4dCgxLDApfX0sXzpmdW5jdGlvbih0LGUsbixyLGksbyxhLHMsdSxjLGwscCl7dmFyIGY9VHQoKTt0cnl7Q3QodCxlLG4scixpLG8sYSxzLHUsYyxsLHApfWNhdGNoKHQpe2lmKFN0KGYpLHQhPT10KzApdGhyb3cgdDt4dCgxLDApfX0sJDpmdW5jdGlvbih0LGUsbixyLGksbyl7dmFyIGE9VHQoKTt0cnl7a3QodCxlLG4scixpLG8pfWNhdGNoKHQpe2lmKFN0KGEpLHQhPT10KzApdGhyb3cgdDt4dCgxLDApfX0sbjpmdW5jdGlvbih0KXtyZXR1cm4gdH0sRjpmdW5jdGlvbih0KXtwdD10fSxoYTpndCx5OmZ1bmN0aW9uKHQsZSxuLHIpe3JldHVybiBndCh0LGUsbixyKX19OyFmdW5jdGlvbigpe2Z1bmN0aW9uIHQodCl7ZS5hc209dC5leHBvcnRzLHg9ZS5hc20uS2EsRigpLE49ZS5hc20uaWIsTC51bnNoaWZ0KGUuYXNtLkxhKSx6LS0sZS5tb25pdG9yUnVuRGVwZW5kZW5jaWVzJiZlLm1vbml0b3JSdW5EZXBlbmRlbmNpZXMoeiksMD09eiYmKG51bGwhPT1HJiYoY2xlYXJJbnRlcnZhbChHKSxHPW51bGwpLEgmJih0PUgsSD1udWxsLHQoKSkpfWZ1bmN0aW9uIG4oZSl7dChlLmluc3RhbmNlKX1mdW5jdGlvbiByKHQpe3JldHVybiBmdW5jdGlvbigpe2lmKCF5JiYoaHx8Zykpe2lmKFwiZnVuY3Rpb25cIj09dHlwZW9mIGZldGNoJiYhQi5zdGFydHNXaXRoKFwiZmlsZTovL1wiKSlyZXR1cm4gZmV0Y2goQix7Y3JlZGVudGlhbHM6XCJzYW1lLW9yaWdpblwifSkudGhlbigoZnVuY3Rpb24odCl7aWYoIXQub2spdGhyb3dcImZhaWxlZCB0byBsb2FkIHdhc20gYmluYXJ5IGZpbGUgYXQgJ1wiK0IrXCInXCI7cmV0dXJuIHQuYXJyYXlCdWZmZXIoKX0pKS5jYXRjaCgoZnVuY3Rpb24oKXtyZXR1cm4gWSgpfSkpO2lmKGEpcmV0dXJuIG5ldyBQcm9taXNlKChmdW5jdGlvbih0LGUpe2EoQiwoZnVuY3Rpb24oZSl7dChuZXcgVWludDhBcnJheShlKSl9KSxlKX0pKX1yZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoZnVuY3Rpb24oKXtyZXR1cm4gWSgpfSkpfSgpLnRoZW4oKGZ1bmN0aW9uKHQpe3JldHVybiBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZSh0LG8pfSkpLnRoZW4oKGZ1bmN0aW9uKHQpe3JldHVybiB0fSkpLnRoZW4odCwoZnVuY3Rpb24odCl7dihcImZhaWxlZCB0byBhc3luY2hyb25vdXNseSBwcmVwYXJlIHdhc206IFwiK3QpLHEodCl9KSl9dmFyIG89e2E6YnR9O2lmKHorKyxlLm1vbml0b3JSdW5EZXBlbmRlbmNpZXMmJmUubW9uaXRvclJ1bkRlcGVuZGVuY2llcyh6KSxlLmluc3RhbnRpYXRlV2FzbSl0cnl7cmV0dXJuIGUuaW5zdGFudGlhdGVXYXNtKG8sdCl9Y2F0Y2godCl7cmV0dXJuIHYoXCJNb2R1bGUuaW5zdGFudGlhdGVXYXNtIGNhbGxiYWNrIGZhaWxlZCB3aXRoIGVycm9yOiBcIit0KSwhMX0oeXx8XCJmdW5jdGlvblwiIT10eXBlb2YgV2ViQXNzZW1ibHkuaW5zdGFudGlhdGVTdHJlYW1pbmd8fFcoKXx8Qi5zdGFydHNXaXRoKFwiZmlsZTovL1wiKXx8Ynx8XCJmdW5jdGlvblwiIT10eXBlb2YgZmV0Y2g/cihuKTpmZXRjaChCLHtjcmVkZW50aWFsczpcInNhbWUtb3JpZ2luXCJ9KS50aGVuKChmdW5jdGlvbih0KXtyZXR1cm4gV2ViQXNzZW1ibHkuaW5zdGFudGlhdGVTdHJlYW1pbmcodCxvKS50aGVuKG4sKGZ1bmN0aW9uKHQpe3JldHVybiB2KFwid2FzbSBzdHJlYW1pbmcgY29tcGlsZSBmYWlsZWQ6IFwiK3QpLHYoXCJmYWxsaW5nIGJhY2sgdG8gQXJyYXlCdWZmZXIgaW5zdGFudGlhdGlvblwiKSxyKG4pfSkpfSkpKS5jYXRjaChpKX0oKSxlLl9fX3dhc21fY2FsbF9jdG9ycz1mdW5jdGlvbigpe3JldHVybihlLl9fX3dhc21fY2FsbF9jdG9ycz1lLmFzbS5MYSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxlLl9PcnRJbml0PWZ1bmN0aW9uKCl7cmV0dXJuKGUuX09ydEluaXQ9ZS5hc20uTWEpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sZS5fT3J0Q3JlYXRlU2Vzc2lvbk9wdGlvbnM9ZnVuY3Rpb24oKXtyZXR1cm4oZS5fT3J0Q3JlYXRlU2Vzc2lvbk9wdGlvbnM9ZS5hc20uTmEpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sZS5fT3J0QXBwZW5kRXhlY3V0aW9uUHJvdmlkZXI9ZnVuY3Rpb24oKXtyZXR1cm4oZS5fT3J0QXBwZW5kRXhlY3V0aW9uUHJvdmlkZXI9ZS5hc20uT2EpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sZS5fT3J0QWRkU2Vzc2lvbkNvbmZpZ0VudHJ5PWZ1bmN0aW9uKCl7cmV0dXJuKGUuX09ydEFkZFNlc3Npb25Db25maWdFbnRyeT1lLmFzbS5QYSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxlLl9PcnRSZWxlYXNlU2Vzc2lvbk9wdGlvbnM9ZnVuY3Rpb24oKXtyZXR1cm4oZS5fT3J0UmVsZWFzZVNlc3Npb25PcHRpb25zPWUuYXNtLlFhKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGUuX09ydENyZWF0ZVNlc3Npb249ZnVuY3Rpb24oKXtyZXR1cm4oZS5fT3J0Q3JlYXRlU2Vzc2lvbj1lLmFzbS5SYSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxlLl9PcnRSZWxlYXNlU2Vzc2lvbj1mdW5jdGlvbigpe3JldHVybihlLl9PcnRSZWxlYXNlU2Vzc2lvbj1lLmFzbS5TYSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxlLl9PcnRHZXRJbnB1dENvdW50PWZ1bmN0aW9uKCl7cmV0dXJuKGUuX09ydEdldElucHV0Q291bnQ9ZS5hc20uVGEpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sZS5fT3J0R2V0T3V0cHV0Q291bnQ9ZnVuY3Rpb24oKXtyZXR1cm4oZS5fT3J0R2V0T3V0cHV0Q291bnQ9ZS5hc20uVWEpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sZS5fT3J0R2V0SW5wdXROYW1lPWZ1bmN0aW9uKCl7cmV0dXJuKGUuX09ydEdldElucHV0TmFtZT1lLmFzbS5WYSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxlLl9PcnRHZXRPdXRwdXROYW1lPWZ1bmN0aW9uKCl7cmV0dXJuKGUuX09ydEdldE91dHB1dE5hbWU9ZS5hc20uV2EpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sZS5fT3J0RnJlZT1mdW5jdGlvbigpe3JldHVybihlLl9PcnRGcmVlPWUuYXNtLlhhKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGUuX09ydENyZWF0ZVRlbnNvcj1mdW5jdGlvbigpe3JldHVybihlLl9PcnRDcmVhdGVUZW5zb3I9ZS5hc20uWWEpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sZS5fT3J0R2V0VGVuc29yRGF0YT1mdW5jdGlvbigpe3JldHVybihlLl9PcnRHZXRUZW5zb3JEYXRhPWUuYXNtLlphKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGUuX09ydFJlbGVhc2VUZW5zb3I9ZnVuY3Rpb24oKXtyZXR1cm4oZS5fT3J0UmVsZWFzZVRlbnNvcj1lLmFzbS5fYSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxlLl9PcnRDcmVhdGVSdW5PcHRpb25zPWZ1bmN0aW9uKCl7cmV0dXJuKGUuX09ydENyZWF0ZVJ1bk9wdGlvbnM9ZS5hc20uJGEpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sZS5fT3J0QWRkUnVuQ29uZmlnRW50cnk9ZnVuY3Rpb24oKXtyZXR1cm4oZS5fT3J0QWRkUnVuQ29uZmlnRW50cnk9ZS5hc20uYWIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sZS5fT3J0UmVsZWFzZVJ1bk9wdGlvbnM9ZnVuY3Rpb24oKXtyZXR1cm4oZS5fT3J0UmVsZWFzZVJ1bk9wdGlvbnM9ZS5hc20uYmIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sZS5fT3J0UnVuPWZ1bmN0aW9uKCl7cmV0dXJuKGUuX09ydFJ1bj1lLmFzbS5jYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxlLl9PcnRFbmRQcm9maWxpbmc9ZnVuY3Rpb24oKXtyZXR1cm4oZS5fT3J0RW5kUHJvZmlsaW5nPWUuYXNtLmRiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O3ZhciBtdCx5dD1lLl9tYWxsb2M9ZnVuY3Rpb24oKXtyZXR1cm4oeXQ9ZS5fbWFsbG9jPWUuYXNtLmViKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LF90PWUuX2ZyZWU9ZnVuY3Rpb24oKXtyZXR1cm4oX3Q9ZS5fZnJlZT1lLmFzbS5mYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSx2dD1lLl9mZmx1c2g9ZnVuY3Rpb24oKXtyZXR1cm4odnQ9ZS5fZmZsdXNoPWUuYXNtLmdiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHd0PWUuX19fZnVuY3Nfb25fZXhpdD1mdW5jdGlvbigpe3JldHVybih3dD1lLl9fX2Z1bmNzX29uX2V4aXQ9ZS5hc20uaGIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0seHQ9ZS5fc2V0VGhyZXc9ZnVuY3Rpb24oKXtyZXR1cm4oeHQ9ZS5fc2V0VGhyZXc9ZS5hc20uamIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sVHQ9ZS5zdGFja1NhdmU9ZnVuY3Rpb24oKXtyZXR1cm4oVHQ9ZS5zdGFja1NhdmU9ZS5hc20ua2IpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sU3Q9ZS5zdGFja1Jlc3RvcmU9ZnVuY3Rpb24oKXtyZXR1cm4oU3Q9ZS5zdGFja1Jlc3RvcmU9ZS5hc20ubGIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sT3Q9ZS5zdGFja0FsbG9jPWZ1bmN0aW9uKCl7cmV0dXJuKE90PWUuc3RhY2tBbGxvYz1lLmFzbS5tYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxBdD1lLl9fX2N4YV9jYW5fY2F0Y2g9ZnVuY3Rpb24oKXtyZXR1cm4oQXQ9ZS5fX19jeGFfY2FuX2NhdGNoPWUuYXNtLm5iKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LEV0PWUuX19fY3hhX2lzX3BvaW50ZXJfdHlwZT1mdW5jdGlvbigpe3JldHVybihFdD1lLl9fX2N4YV9pc19wb2ludGVyX3R5cGU9ZS5hc20ub2IpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sSXQ9ZS5keW5DYWxsX2o9ZnVuY3Rpb24oKXtyZXR1cm4oSXQ9ZS5keW5DYWxsX2o9ZS5hc20ucGIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sUHQ9ZS5keW5DYWxsX2lpaWlpaj1mdW5jdGlvbigpe3JldHVybihQdD1lLmR5bkNhbGxfaWlpaWlqPWUuYXNtLnFiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LER0PWUuZHluQ2FsbF9qaWk9ZnVuY3Rpb24oKXtyZXR1cm4oRHQ9ZS5keW5DYWxsX2ppaT1lLmFzbS5yYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSwkdD1lLmR5bkNhbGxfdmlpaWlpaj1mdW5jdGlvbigpe3JldHVybigkdD1lLmR5bkNhbGxfdmlpaWlpaj1lLmFzbS5zYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxrdD1lLmR5bkNhbGxfdmpqaT1mdW5jdGlvbigpe3JldHVybihrdD1lLmR5bkNhbGxfdmpqaT1lLmFzbS50YikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxDdD1lLmR5bkNhbGxfdmlpaWpqamlpPWZ1bmN0aW9uKCl7cmV0dXJuKEN0PWUuZHluQ2FsbF92aWlpampqaWk9ZS5hc20udWIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sRnQ9ZS5keW5DYWxsX2lpaj1mdW5jdGlvbigpe3JldHVybihGdD1lLmR5bkNhbGxfaWlqPWUuYXNtLnZiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LE50PWUuZHluQ2FsbF9qaT1mdW5jdGlvbigpe3JldHVybihOdD1lLmR5bkNhbGxfamk9ZS5hc20ud2IpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sUnQ9ZS5keW5DYWxsX2lpaWlpaWo9ZnVuY3Rpb24oKXtyZXR1cm4oUnQ9ZS5keW5DYWxsX2lpaWlpaWo9ZS5hc20ueGIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sTHQ9ZS5keW5DYWxsX2lpaWo9ZnVuY3Rpb24oKXtyZXR1cm4oTHQ9ZS5keW5DYWxsX2lpaWo9ZS5hc20ueWIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX07ZnVuY3Rpb24gTXQoKXtmdW5jdGlvbiB0KCl7aWYoIW10JiYobXQ9ITAsZS5jYWxsZWRSdW49ITAsIUkpKXtpZihaKEwpLHIoZSksZS5vblJ1bnRpbWVJbml0aWFsaXplZCYmZS5vblJ1bnRpbWVJbml0aWFsaXplZCgpLGUucG9zdFJ1bilmb3IoXCJmdW5jdGlvblwiPT10eXBlb2YgZS5wb3N0UnVuJiYoZS5wb3N0UnVuPVtlLnBvc3RSdW5dKTtlLnBvc3RSdW4ubGVuZ3RoOyl7dmFyIHQ9ZS5wb3N0UnVuLnNoaWZ0KCk7ai51bnNoaWZ0KHQpfVooail9fWlmKCEoMDx6KSl7aWYoZS5wcmVSdW4pZm9yKFwiZnVuY3Rpb25cIj09dHlwZW9mIGUucHJlUnVuJiYoZS5wcmVSdW49W2UucHJlUnVuXSk7ZS5wcmVSdW4ubGVuZ3RoOylWKCk7WihSKSwwPHp8fChlLnNldFN0YXR1cz8oZS5zZXRTdGF0dXMoXCJSdW5uaW5nLi4uXCIpLHNldFRpbWVvdXQoKGZ1bmN0aW9uKCl7c2V0VGltZW91dCgoZnVuY3Rpb24oKXtlLnNldFN0YXR1cyhcIlwiKX0pLDEpLHQoKX0pLDEpKTp0KCkpfX1pZihlLlVURjhUb1N0cmluZz0kLGUuc3RyaW5nVG9VVEY4PWZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gayh0LE8sZSxuKX0sZS5sZW5ndGhCeXRlc1VURjg9QyxlLnN0YWNrU2F2ZT1UdCxlLnN0YWNrUmVzdG9yZT1TdCxlLnN0YWNrQWxsb2M9T3QsSD1mdW5jdGlvbiB0KCl7bXR8fE10KCksbXR8fChIPXQpfSxlLnByZUluaXQpZm9yKFwiZnVuY3Rpb25cIj09dHlwZW9mIGUucHJlSW5pdCYmKGUucHJlSW5pdD1bZS5wcmVJbml0XSk7MDxlLnByZUluaXQubGVuZ3RoOyllLnByZUluaXQucG9wKCkoKTtyZXR1cm4gTXQoKSx0LnJlYWR5fSk7dC5leHBvcnRzPXJ9LDQ1Mzc6dD0+e1widXNlIHN0cmljdFwiO3QuZXhwb3J0cz1mdW5jdGlvbih0LGUpe2Zvcih2YXIgbj1uZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aC0xKSxyPTAsaT0yLG89ITA7aTxhcmd1bWVudHMubGVuZ3RoOyluW3IrK109YXJndW1lbnRzW2krK107cmV0dXJuIG5ldyBQcm9taXNlKChmdW5jdGlvbihpLGEpe25bcl09ZnVuY3Rpb24odCl7aWYobylpZihvPSExLHQpYSh0KTtlbHNle2Zvcih2YXIgZT1uZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aC0xKSxuPTA7bjxlLmxlbmd0aDspZVtuKytdPWFyZ3VtZW50c1tuXTtpLmFwcGx5KG51bGwsZSl9fTt0cnl7dC5hcHBseShlfHxudWxsLG4pfWNhdGNoKHQpe28mJihvPSExLGEodCkpfX0pKX19LDc0MTk6KHQsZSk9PntcInVzZSBzdHJpY3RcIjt2YXIgbj1lO24ubGVuZ3RoPWZ1bmN0aW9uKHQpe3ZhciBlPXQubGVuZ3RoO2lmKCFlKXJldHVybiAwO2Zvcih2YXIgbj0wOy0tZSU0PjEmJlwiPVwiPT09dC5jaGFyQXQoZSk7KSsrbjtyZXR1cm4gTWF0aC5jZWlsKDMqdC5sZW5ndGgpLzQtbn07Zm9yKHZhciByPW5ldyBBcnJheSg2NCksaT1uZXcgQXJyYXkoMTIzKSxvPTA7bzw2NDspaVtyW29dPW88MjY/bys2NTpvPDUyP28rNzE6bzw2Mj9vLTQ6by01OXw0M109bysrO24uZW5jb2RlPWZ1bmN0aW9uKHQsZSxuKXtmb3IodmFyIGksbz1udWxsLGE9W10scz0wLHU9MDtlPG47KXt2YXIgYz10W2UrK107c3dpdGNoKHUpe2Nhc2UgMDphW3MrK109cltjPj4yXSxpPSgzJmMpPDw0LHU9MTticmVhaztjYXNlIDE6YVtzKytdPXJbaXxjPj40XSxpPSgxNSZjKTw8Mix1PTI7YnJlYWs7Y2FzZSAyOmFbcysrXT1yW2l8Yz4+Nl0sYVtzKytdPXJbNjMmY10sdT0wfXM+ODE5MSYmKChvfHwobz1bXSkpLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsYSkpLHM9MCl9cmV0dXJuIHUmJihhW3MrK109cltpXSxhW3MrK109NjEsMT09PXUmJihhW3MrK109NjEpKSxvPyhzJiZvLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsYS5zbGljZSgwLHMpKSksby5qb2luKFwiXCIpKTpTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZyxhLnNsaWNlKDAscykpfTt2YXIgYT1cImludmFsaWQgZW5jb2RpbmdcIjtuLmRlY29kZT1mdW5jdGlvbih0LGUsbil7Zm9yKHZhciByLG89bixzPTAsdT0wO3U8dC5sZW5ndGg7KXt2YXIgYz10LmNoYXJDb2RlQXQodSsrKTtpZig2MT09PWMmJnM+MSlicmVhaztpZih2b2lkIDA9PT0oYz1pW2NdKSl0aHJvdyBFcnJvcihhKTtzd2l0Y2gocyl7Y2FzZSAwOnI9YyxzPTE7YnJlYWs7Y2FzZSAxOmVbbisrXT1yPDwyfCg0OCZjKT4+NCxyPWMscz0yO2JyZWFrO2Nhc2UgMjplW24rK109KDE1JnIpPDw0fCg2MCZjKT4+MixyPWMscz0zO2JyZWFrO2Nhc2UgMzplW24rK109KDMmcik8PDZ8YyxzPTB9fWlmKDE9PT1zKXRocm93IEVycm9yKGEpO3JldHVybiBuLW99LG4udGVzdD1mdW5jdGlvbih0KXtyZXR1cm4vXig/OltBLVphLXowLTkrL117NH0pKig/OltBLVphLXowLTkrL117Mn09PXxbQS1aYS16MC05Ky9dezN9PSk/JC8udGVzdCh0KX19LDkyMTE6dD0+e1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIGUoKXt0aGlzLl9saXN0ZW5lcnM9e319dC5leHBvcnRzPWUsZS5wcm90b3R5cGUub249ZnVuY3Rpb24odCxlLG4pe3JldHVybih0aGlzLl9saXN0ZW5lcnNbdF18fCh0aGlzLl9saXN0ZW5lcnNbdF09W10pKS5wdXNoKHtmbjplLGN0eDpufHx0aGlzfSksdGhpc30sZS5wcm90b3R5cGUub2ZmPWZ1bmN0aW9uKHQsZSl7aWYodm9pZCAwPT09dCl0aGlzLl9saXN0ZW5lcnM9e307ZWxzZSBpZih2b2lkIDA9PT1lKXRoaXMuX2xpc3RlbmVyc1t0XT1bXTtlbHNlIGZvcih2YXIgbj10aGlzLl9saXN0ZW5lcnNbdF0scj0wO3I8bi5sZW5ndGg7KW5bcl0uZm49PT1lP24uc3BsaWNlKHIsMSk6KytyO3JldHVybiB0aGlzfSxlLnByb3RvdHlwZS5lbWl0PWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMuX2xpc3RlbmVyc1t0XTtpZihlKXtmb3IodmFyIG49W10scj0xO3I8YXJndW1lbnRzLmxlbmd0aDspbi5wdXNoKGFyZ3VtZW50c1tyKytdKTtmb3Iocj0wO3I8ZS5sZW5ndGg7KWVbcl0uZm4uYXBwbHkoZVtyKytdLmN0eCxuKX1yZXR1cm4gdGhpc319LDk0NTp0PT57XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gZSh0KXtyZXR1cm5cInVuZGVmaW5lZFwiIT10eXBlb2YgRmxvYXQzMkFycmF5P2Z1bmN0aW9uKCl7dmFyIGU9bmV3IEZsb2F0MzJBcnJheShbLTBdKSxuPW5ldyBVaW50OEFycmF5KGUuYnVmZmVyKSxyPTEyOD09PW5bM107ZnVuY3Rpb24gaSh0LHIsaSl7ZVswXT10LHJbaV09blswXSxyW2krMV09blsxXSxyW2krMl09blsyXSxyW2krM109blszXX1mdW5jdGlvbiBvKHQscixpKXtlWzBdPXQscltpXT1uWzNdLHJbaSsxXT1uWzJdLHJbaSsyXT1uWzFdLHJbaSszXT1uWzBdfWZ1bmN0aW9uIGEodCxyKXtyZXR1cm4gblswXT10W3JdLG5bMV09dFtyKzFdLG5bMl09dFtyKzJdLG5bM109dFtyKzNdLGVbMF19ZnVuY3Rpb24gcyh0LHIpe3JldHVybiBuWzNdPXRbcl0sblsyXT10W3IrMV0sblsxXT10W3IrMl0sblswXT10W3IrM10sZVswXX10LndyaXRlRmxvYXRMRT1yP2k6byx0LndyaXRlRmxvYXRCRT1yP286aSx0LnJlYWRGbG9hdExFPXI/YTpzLHQucmVhZEZsb2F0QkU9cj9zOmF9KCk6ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKHQsZSxuLHIpe3ZhciBpPWU8MD8xOjA7aWYoaSYmKGU9LWUpLDA9PT1lKXQoMS9lPjA/MDoyMTQ3NDgzNjQ4LG4scik7ZWxzZSBpZihpc05hTihlKSl0KDIxNDMyODkzNDQsbixyKTtlbHNlIGlmKGU+MzQwMjgyMzQ2NjM4NTI4ODZlMjIpdCgoaTw8MzF8MjEzOTA5NTA0MCk+Pj4wLG4scik7ZWxzZSBpZihlPDExNzU0OTQzNTA4MjIyODc1ZS01NCl0KChpPDwzMXxNYXRoLnJvdW5kKGUvMTQwMTI5ODQ2NDMyNDgxN2UtNjApKT4+PjAsbixyKTtlbHNle3ZhciBvPU1hdGguZmxvb3IoTWF0aC5sb2coZSkvTWF0aC5MTjIpO3QoKGk8PDMxfG8rMTI3PDwyM3w4Mzg4NjA3Jk1hdGgucm91bmQoZSpNYXRoLnBvdygyLC1vKSo4Mzg4NjA4KSk+Pj4wLG4scil9fWZ1bmN0aW9uIGEodCxlLG4pe3ZhciByPXQoZSxuKSxpPTIqKHI+PjMxKSsxLG89cj4+PjIzJjI1NSxhPTgzODg2MDcmcjtyZXR1cm4gMjU1PT09bz9hP05hTjppKigxLzApOjA9PT1vPzE0MDEyOTg0NjQzMjQ4MTdlLTYwKmkqYTppKk1hdGgucG93KDIsby0xNTApKihhKzgzODg2MDgpfXQud3JpdGVGbG9hdExFPWUuYmluZChudWxsLG4pLHQud3JpdGVGbG9hdEJFPWUuYmluZChudWxsLHIpLHQucmVhZEZsb2F0TEU9YS5iaW5kKG51bGwsaSksdC5yZWFkRmxvYXRCRT1hLmJpbmQobnVsbCxvKX0oKSxcInVuZGVmaW5lZFwiIT10eXBlb2YgRmxvYXQ2NEFycmF5P2Z1bmN0aW9uKCl7dmFyIGU9bmV3IEZsb2F0NjRBcnJheShbLTBdKSxuPW5ldyBVaW50OEFycmF5KGUuYnVmZmVyKSxyPTEyOD09PW5bN107ZnVuY3Rpb24gaSh0LHIsaSl7ZVswXT10LHJbaV09blswXSxyW2krMV09blsxXSxyW2krMl09blsyXSxyW2krM109blszXSxyW2krNF09bls0XSxyW2krNV09bls1XSxyW2krNl09bls2XSxyW2krN109bls3XX1mdW5jdGlvbiBvKHQscixpKXtlWzBdPXQscltpXT1uWzddLHJbaSsxXT1uWzZdLHJbaSsyXT1uWzVdLHJbaSszXT1uWzRdLHJbaSs0XT1uWzNdLHJbaSs1XT1uWzJdLHJbaSs2XT1uWzFdLHJbaSs3XT1uWzBdfWZ1bmN0aW9uIGEodCxyKXtyZXR1cm4gblswXT10W3JdLG5bMV09dFtyKzFdLG5bMl09dFtyKzJdLG5bM109dFtyKzNdLG5bNF09dFtyKzRdLG5bNV09dFtyKzVdLG5bNl09dFtyKzZdLG5bN109dFtyKzddLGVbMF19ZnVuY3Rpb24gcyh0LHIpe3JldHVybiBuWzddPXRbcl0sbls2XT10W3IrMV0sbls1XT10W3IrMl0sbls0XT10W3IrM10sblszXT10W3IrNF0sblsyXT10W3IrNV0sblsxXT10W3IrNl0sblswXT10W3IrN10sZVswXX10LndyaXRlRG91YmxlTEU9cj9pOm8sdC53cml0ZURvdWJsZUJFPXI/bzppLHQucmVhZERvdWJsZUxFPXI/YTpzLHQucmVhZERvdWJsZUJFPXI/czphfSgpOmZ1bmN0aW9uKCl7ZnVuY3Rpb24gZSh0LGUsbixyLGksbyl7dmFyIGE9cjwwPzE6MDtpZihhJiYocj0tciksMD09PXIpdCgwLGksbytlKSx0KDEvcj4wPzA6MjE0NzQ4MzY0OCxpLG8rbik7ZWxzZSBpZihpc05hTihyKSl0KDAsaSxvK2UpLHQoMjE0Njk1OTM2MCxpLG8rbik7ZWxzZSBpZihyPjE3OTc2OTMxMzQ4NjIzMTU3ZTI5Mil0KDAsaSxvK2UpLHQoKGE8PDMxfDIxNDY0MzUwNzIpPj4+MCxpLG8rbik7ZWxzZXt2YXIgcztpZihyPDIyMjUwNzM4NTg1MDcyMDE0ZS0zMjQpdCgocz1yLzVlLTMyNCk+Pj4wLGksbytlKSx0KChhPDwzMXxzLzQyOTQ5NjcyOTYpPj4+MCxpLG8rbik7ZWxzZXt2YXIgdT1NYXRoLmZsb29yKE1hdGgubG9nKHIpL01hdGguTE4yKTsxMDI0PT09dSYmKHU9MTAyMyksdCg0NTAzNTk5NjI3MzcwNDk2KihzPXIqTWF0aC5wb3coMiwtdSkpPj4+MCxpLG8rZSksdCgoYTw8MzF8dSsxMDIzPDwyMHwxMDQ4NTc2KnMmMTA0ODU3NSk+Pj4wLGksbytuKX19fWZ1bmN0aW9uIGEodCxlLG4scixpKXt2YXIgbz10KHIsaStlKSxhPXQocixpK24pLHM9MiooYT4+MzEpKzEsdT1hPj4+MjAmMjA0NyxjPTQyOTQ5NjcyOTYqKDEwNDg1NzUmYSkrbztyZXR1cm4gMjA0Nz09PXU/Yz9OYU46cyooMS8wKTowPT09dT81ZS0zMjQqcypjOnMqTWF0aC5wb3coMix1LTEwNzUpKihjKzQ1MDM1OTk2MjczNzA0OTYpfXQud3JpdGVEb3VibGVMRT1lLmJpbmQobnVsbCxuLDAsNCksdC53cml0ZURvdWJsZUJFPWUuYmluZChudWxsLHIsNCwwKSx0LnJlYWREb3VibGVMRT1hLmJpbmQobnVsbCxpLDAsNCksdC5yZWFkRG91YmxlQkU9YS5iaW5kKG51bGwsbyw0LDApfSgpLHR9ZnVuY3Rpb24gbih0LGUsbil7ZVtuXT0yNTUmdCxlW24rMV09dD4+PjgmMjU1LGVbbisyXT10Pj4+MTYmMjU1LGVbbiszXT10Pj4+MjR9ZnVuY3Rpb24gcih0LGUsbil7ZVtuXT10Pj4+MjQsZVtuKzFdPXQ+Pj4xNiYyNTUsZVtuKzJdPXQ+Pj44JjI1NSxlW24rM109MjU1JnR9ZnVuY3Rpb24gaSh0LGUpe3JldHVybih0W2VdfHRbZSsxXTw8OHx0W2UrMl08PDE2fHRbZSszXTw8MjQpPj4+MH1mdW5jdGlvbiBvKHQsZSl7cmV0dXJuKHRbZV08PDI0fHRbZSsxXTw8MTZ8dFtlKzJdPDw4fHRbZSszXSk+Pj4wfXQuZXhwb3J0cz1lKGUpfSw3MTk5Om1vZHVsZT0+e1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIGlucXVpcmUobW9kdWxlTmFtZSl7dHJ5e3ZhciBtb2Q9ZXZhbChcInF1aXJlXCIucmVwbGFjZSgvXi8sXCJyZVwiKSkobW9kdWxlTmFtZSk7aWYobW9kJiYobW9kLmxlbmd0aHx8T2JqZWN0LmtleXMobW9kKS5sZW5ndGgpKXJldHVybiBtb2R9Y2F0Y2godCl7fXJldHVybiBudWxsfW1vZHVsZS5leHBvcnRzPWlucXVpcmV9LDY2NjI6dD0+e1widXNlIHN0cmljdFwiO3QuZXhwb3J0cz1mdW5jdGlvbih0LGUsbil7dmFyIHI9bnx8ODE5MixpPXI+Pj4xLG89bnVsbCxhPXI7cmV0dXJuIGZ1bmN0aW9uKG4pe2lmKG48MXx8bj5pKXJldHVybiB0KG4pO2Erbj5yJiYobz10KHIpLGE9MCk7dmFyIHM9ZS5jYWxsKG8sYSxhKz1uKTtyZXR1cm4gNyZhJiYoYT0xKyg3fGEpKSxzfX19LDQ5OTc6KHQsZSk9PntcInVzZSBzdHJpY3RcIjt2YXIgbj1lO24ubGVuZ3RoPWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT0wLG49MCxyPTA7cjx0Lmxlbmd0aDsrK3IpKG49dC5jaGFyQ29kZUF0KHIpKTwxMjg/ZSs9MTpuPDIwNDg/ZSs9Mjo1NTI5Nj09KDY0NTEyJm4pJiY1NjMyMD09KDY0NTEyJnQuY2hhckNvZGVBdChyKzEpKT8oKytyLGUrPTQpOmUrPTM7cmV0dXJuIGV9LG4ucmVhZD1mdW5jdGlvbih0LGUsbil7aWYobi1lPDEpcmV0dXJuXCJcIjtmb3IodmFyIHIsaT1udWxsLG89W10sYT0wO2U8bjspKHI9dFtlKytdKTwxMjg/b1thKytdPXI6cj4xOTEmJnI8MjI0P29bYSsrXT0oMzEmcik8PDZ8NjMmdFtlKytdOnI+MjM5JiZyPDM2NT8ocj0oKDcmcik8PDE4fCg2MyZ0W2UrK10pPDwxMnwoNjMmdFtlKytdKTw8Nnw2MyZ0W2UrK10pLTY1NTM2LG9bYSsrXT01NTI5Nisocj4+MTApLG9bYSsrXT01NjMyMCsoMTAyMyZyKSk6b1thKytdPSgxNSZyKTw8MTJ8KDYzJnRbZSsrXSk8PDZ8NjMmdFtlKytdLGE+ODE5MSYmKChpfHwoaT1bXSkpLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsbykpLGE9MCk7cmV0dXJuIGk/KGEmJmkucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZyxvLnNsaWNlKDAsYSkpKSxpLmpvaW4oXCJcIikpOlN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLG8uc2xpY2UoMCxhKSl9LG4ud3JpdGU9ZnVuY3Rpb24odCxlLG4pe2Zvcih2YXIgcixpLG89bixhPTA7YTx0Lmxlbmd0aDsrK2EpKHI9dC5jaGFyQ29kZUF0KGEpKTwxMjg/ZVtuKytdPXI6cjwyMDQ4PyhlW24rK109cj4+NnwxOTIsZVtuKytdPTYzJnJ8MTI4KTo1NTI5Nj09KDY0NTEyJnIpJiY1NjMyMD09KDY0NTEyJihpPXQuY2hhckNvZGVBdChhKzEpKSk/KHI9NjU1MzYrKCgxMDIzJnIpPDwxMCkrKDEwMjMmaSksKythLGVbbisrXT1yPj4xOHwyNDAsZVtuKytdPXI+PjEyJjYzfDEyOCxlW24rK109cj4+NiY2M3wxMjgsZVtuKytdPTYzJnJ8MTI4KTooZVtuKytdPXI+PjEyfDIyNCxlW24rK109cj4+NiY2M3wxMjgsZVtuKytdPTYzJnJ8MTI4KTtyZXR1cm4gbi1vfX0sMzQ0MjoodCxlKT0+e1widXNlIHN0cmljdFwiO2UuX19lc01vZHVsZT0hMDt2YXIgbj1mdW5jdGlvbigpe2Z1bmN0aW9uIHQoZSl7aWYoIWUpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXJndW1lbnQ7IGB2YWx1ZWAgaGFzIG5vIHZhbHVlLlwiKTt0aGlzLnZhbHVlPXQuRU1QVFksZSYmdC5pc0d1aWQoZSkmJih0aGlzLnZhbHVlPWUpfXJldHVybiB0LmlzR3VpZD1mdW5jdGlvbihlKXt2YXIgbj1lLnRvU3RyaW5nKCk7cmV0dXJuIGUmJihlIGluc3RhbmNlb2YgdHx8dC52YWxpZGF0b3IudGVzdChuKSl9LHQuY3JlYXRlPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyB0KFt0LmdlbigyKSx0LmdlbigxKSx0LmdlbigxKSx0LmdlbigxKSx0LmdlbigzKV0uam9pbihcIi1cIikpfSx0LmNyZWF0ZUVtcHR5PWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyB0KFwiZW1wdHlndWlkXCIpfSx0LnBhcnNlPWZ1bmN0aW9uKGUpe3JldHVybiBuZXcgdChlKX0sdC5yYXc9ZnVuY3Rpb24oKXtyZXR1cm5bdC5nZW4oMiksdC5nZW4oMSksdC5nZW4oMSksdC5nZW4oMSksdC5nZW4oMyldLmpvaW4oXCItXCIpfSx0Lmdlbj1mdW5jdGlvbih0KXtmb3IodmFyIGU9XCJcIixuPTA7bjx0O24rKyllKz0oNjU1MzYqKDErTWF0aC5yYW5kb20oKSl8MCkudG9TdHJpbmcoMTYpLnN1YnN0cmluZygxKTtyZXR1cm4gZX0sdC5wcm90b3R5cGUuZXF1YWxzPWZ1bmN0aW9uKGUpe3JldHVybiB0LmlzR3VpZChlKSYmdGhpcy52YWx1ZT09PWUudG9TdHJpbmcoKX0sdC5wcm90b3R5cGUuaXNFbXB0eT1mdW5jdGlvbigpe3JldHVybiB0aGlzLnZhbHVlPT09dC5FTVBUWX0sdC5wcm90b3R5cGUudG9TdHJpbmc9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy52YWx1ZX0sdC5wcm90b3R5cGUudG9KU09OPWZ1bmN0aW9uKCl7cmV0dXJue3ZhbHVlOnRoaXMudmFsdWV9fSx0LnZhbGlkYXRvcj1uZXcgUmVnRXhwKFwiXlthLXowLTldezh9LVthLXowLTldezR9LVthLXowLTldezR9LVthLXowLTldezR9LVthLXowLTldezEyfSRcIixcImlcIiksdC5FTVBUWT1cIjAwMDAwMDAwLTAwMDAtMDAwMC0wMDAwLTAwMDAwMDAwMDAwMFwiLHR9KCk7ZS5HdWlkPW59LDM3MjA6dD0+e3QuZXhwb3J0cz1uO3ZhciBlPW51bGw7dHJ5e2U9bmV3IFdlYkFzc2VtYmx5Lkluc3RhbmNlKG5ldyBXZWJBc3NlbWJseS5Nb2R1bGUobmV3IFVpbnQ4QXJyYXkoWzAsOTcsMTE1LDEwOSwxLDAsMCwwLDEsMTMsMiw5NiwwLDEsMTI3LDk2LDQsMTI3LDEyNywxMjcsMTI3LDEsMTI3LDMsNyw2LDAsMSwxLDEsMSwxLDYsNiwxLDEyNywxLDY1LDAsMTEsNyw1MCw2LDMsMTA5LDExNywxMDgsMCwxLDUsMTAwLDEwNSwxMTgsOTUsMTE1LDAsMiw1LDEwMCwxMDUsMTE4LDk1LDExNywwLDMsNSwxMTQsMTAxLDEwOSw5NSwxMTUsMCw0LDUsMTE0LDEwMSwxMDksOTUsMTE3LDAsNSw4LDEwMywxMDEsMTE2LDk1LDEwNCwxMDUsMTAzLDEwNCwwLDAsMTAsMTkxLDEsNiw0LDAsMzUsMCwxMSwzNiwxLDEsMTI2LDMyLDAsMTczLDMyLDEsMTczLDY2LDMyLDEzNCwxMzIsMzIsMiwxNzMsMzIsMywxNzMsNjYsMzIsMTM0LDEzMiwxMjYsMzQsNCw2NiwzMiwxMzUsMTY3LDM2LDAsMzIsNCwxNjcsMTEsMzYsMSwxLDEyNiwzMiwwLDE3MywzMiwxLDE3Myw2NiwzMiwxMzQsMTMyLDMyLDIsMTczLDMyLDMsMTczLDY2LDMyLDEzNCwxMzIsMTI3LDM0LDQsNjYsMzIsMTM1LDE2NywzNiwwLDMyLDQsMTY3LDExLDM2LDEsMSwxMjYsMzIsMCwxNzMsMzIsMSwxNzMsNjYsMzIsMTM0LDEzMiwzMiwyLDE3MywzMiwzLDE3Myw2NiwzMiwxMzQsMTMyLDEyOCwzNCw0LDY2LDMyLDEzNSwxNjcsMzYsMCwzMiw0LDE2NywxMSwzNiwxLDEsMTI2LDMyLDAsMTczLDMyLDEsMTczLDY2LDMyLDEzNCwxMzIsMzIsMiwxNzMsMzIsMywxNzMsNjYsMzIsMTM0LDEzMiwxMjksMzQsNCw2NiwzMiwxMzUsMTY3LDM2LDAsMzIsNCwxNjcsMTEsMzYsMSwxLDEyNiwzMiwwLDE3MywzMiwxLDE3Myw2NiwzMiwxMzQsMTMyLDMyLDIsMTczLDMyLDMsMTczLDY2LDMyLDEzNCwxMzIsMTMwLDM0LDQsNjYsMzIsMTM1LDE2NywzNiwwLDMyLDQsMTY3LDExXSkpLHt9KS5leHBvcnRzfWNhdGNoKHQpe31mdW5jdGlvbiBuKHQsZSxuKXt0aGlzLmxvdz0wfHQsdGhpcy5oaWdoPTB8ZSx0aGlzLnVuc2lnbmVkPSEhbn1mdW5jdGlvbiByKHQpe3JldHVybiEwPT09KHQmJnQuX19pc0xvbmdfXyl9bi5wcm90b3R5cGUuX19pc0xvbmdfXyxPYmplY3QuZGVmaW5lUHJvcGVydHkobi5wcm90b3R5cGUsXCJfX2lzTG9uZ19fXCIse3ZhbHVlOiEwfSksbi5pc0xvbmc9cjt2YXIgaT17fSxvPXt9O2Z1bmN0aW9uIGEodCxlKXt2YXIgbixyLGE7cmV0dXJuIGU/KGE9MDw9KHQ+Pj49MCkmJnQ8MjU2KSYmKHI9b1t0XSk/cjoobj11KHQsKDB8dCk8MD8tMTowLCEwKSxhJiYob1t0XT1uKSxuKTooYT0tMTI4PD0odHw9MCkmJnQ8MTI4KSYmKHI9aVt0XSk/cjoobj11KHQsdDwwPy0xOjAsITEpLGEmJihpW3RdPW4pLG4pfWZ1bmN0aW9uIHModCxlKXtpZihpc05hTih0KSlyZXR1cm4gZT9tOmI7aWYoZSl7aWYodDwwKXJldHVybiBtO2lmKHQ+PWQpcmV0dXJuIHh9ZWxzZXtpZih0PD0taClyZXR1cm4gVDtpZih0KzE+PWgpcmV0dXJuIHd9cmV0dXJuIHQ8MD9zKC10LGUpLm5lZygpOnUodCVmfDAsdC9mfDAsZSl9ZnVuY3Rpb24gdSh0LGUscil7cmV0dXJuIG5ldyBuKHQsZSxyKX1uLmZyb21JbnQ9YSxuLmZyb21OdW1iZXI9cyxuLmZyb21CaXRzPXU7dmFyIGM9TWF0aC5wb3c7ZnVuY3Rpb24gbCh0LGUsbil7aWYoMD09PXQubGVuZ3RoKXRocm93IEVycm9yKFwiZW1wdHkgc3RyaW5nXCIpO2lmKFwiTmFOXCI9PT10fHxcIkluZmluaXR5XCI9PT10fHxcIitJbmZpbml0eVwiPT09dHx8XCItSW5maW5pdHlcIj09PXQpcmV0dXJuIGI7aWYoXCJudW1iZXJcIj09dHlwZW9mIGU/KG49ZSxlPSExKTplPSEhZSwobj1ufHwxMCk8Mnx8MzY8bil0aHJvdyBSYW5nZUVycm9yKFwicmFkaXhcIik7dmFyIHI7aWYoKHI9dC5pbmRleE9mKFwiLVwiKSk+MCl0aHJvdyBFcnJvcihcImludGVyaW9yIGh5cGhlblwiKTtpZigwPT09cilyZXR1cm4gbCh0LnN1YnN0cmluZygxKSxlLG4pLm5lZygpO2Zvcih2YXIgaT1zKGMobiw4KSksbz1iLGE9MDthPHQubGVuZ3RoO2ErPTgpe3ZhciB1PU1hdGgubWluKDgsdC5sZW5ndGgtYSkscD1wYXJzZUludCh0LnN1YnN0cmluZyhhLGErdSksbik7aWYodTw4KXt2YXIgZj1zKGMobix1KSk7bz1vLm11bChmKS5hZGQocyhwKSl9ZWxzZSBvPShvPW8ubXVsKGkpKS5hZGQocyhwKSl9cmV0dXJuIG8udW5zaWduZWQ9ZSxvfWZ1bmN0aW9uIHAodCxlKXtyZXR1cm5cIm51bWJlclwiPT10eXBlb2YgdD9zKHQsZSk6XCJzdHJpbmdcIj09dHlwZW9mIHQ/bCh0LGUpOnUodC5sb3csdC5oaWdoLFwiYm9vbGVhblwiPT10eXBlb2YgZT9lOnQudW5zaWduZWQpfW4uZnJvbVN0cmluZz1sLG4uZnJvbVZhbHVlPXA7dmFyIGY9NDI5NDk2NzI5NixkPWYqZixoPWQvMixnPWEoMTw8MjQpLGI9YSgwKTtuLlpFUk89Yjt2YXIgbT1hKDAsITApO24uVVpFUk89bTt2YXIgeT1hKDEpO24uT05FPXk7dmFyIF89YSgxLCEwKTtuLlVPTkU9Xzt2YXIgdj1hKC0xKTtuLk5FR19PTkU9djt2YXIgdz11KC0xLDIxNDc0ODM2NDcsITEpO24uTUFYX1ZBTFVFPXc7dmFyIHg9dSgtMSwtMSwhMCk7bi5NQVhfVU5TSUdORURfVkFMVUU9eDt2YXIgVD11KDAsLTIxNDc0ODM2NDgsITEpO24uTUlOX1ZBTFVFPVQ7dmFyIFM9bi5wcm90b3R5cGU7Uy50b0ludD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnVuc2lnbmVkP3RoaXMubG93Pj4+MDp0aGlzLmxvd30sUy50b051bWJlcj1mdW5jdGlvbigpe3JldHVybiB0aGlzLnVuc2lnbmVkPyh0aGlzLmhpZ2g+Pj4wKSpmKyh0aGlzLmxvdz4+PjApOnRoaXMuaGlnaCpmKyh0aGlzLmxvdz4+PjApfSxTLnRvU3RyaW5nPWZ1bmN0aW9uKHQpe2lmKCh0PXR8fDEwKTwyfHwzNjx0KXRocm93IFJhbmdlRXJyb3IoXCJyYWRpeFwiKTtpZih0aGlzLmlzWmVybygpKXJldHVyblwiMFwiO2lmKHRoaXMuaXNOZWdhdGl2ZSgpKXtpZih0aGlzLmVxKFQpKXt2YXIgZT1zKHQpLG49dGhpcy5kaXYoZSkscj1uLm11bChlKS5zdWIodGhpcyk7cmV0dXJuIG4udG9TdHJpbmcodCkrci50b0ludCgpLnRvU3RyaW5nKHQpfXJldHVyblwiLVwiK3RoaXMubmVnKCkudG9TdHJpbmcodCl9Zm9yKHZhciBpPXMoYyh0LDYpLHRoaXMudW5zaWduZWQpLG89dGhpcyxhPVwiXCI7Oyl7dmFyIHU9by5kaXYoaSksbD0oby5zdWIodS5tdWwoaSkpLnRvSW50KCk+Pj4wKS50b1N0cmluZyh0KTtpZigobz11KS5pc1plcm8oKSlyZXR1cm4gbCthO2Zvcig7bC5sZW5ndGg8NjspbD1cIjBcIitsO2E9XCJcIitsK2F9fSxTLmdldEhpZ2hCaXRzPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaGlnaH0sUy5nZXRIaWdoQml0c1Vuc2lnbmVkPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaGlnaD4+PjB9LFMuZ2V0TG93Qml0cz1mdW5jdGlvbigpe3JldHVybiB0aGlzLmxvd30sUy5nZXRMb3dCaXRzVW5zaWduZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5sb3c+Pj4wfSxTLmdldE51bUJpdHNBYnM9ZnVuY3Rpb24oKXtpZih0aGlzLmlzTmVnYXRpdmUoKSlyZXR1cm4gdGhpcy5lcShUKT82NDp0aGlzLm5lZygpLmdldE51bUJpdHNBYnMoKTtmb3IodmFyIHQ9MCE9dGhpcy5oaWdoP3RoaXMuaGlnaDp0aGlzLmxvdyxlPTMxO2U+MCYmMD09KHQmMTw8ZSk7ZS0tKTtyZXR1cm4gMCE9dGhpcy5oaWdoP2UrMzM6ZSsxfSxTLmlzWmVybz1mdW5jdGlvbigpe3JldHVybiAwPT09dGhpcy5oaWdoJiYwPT09dGhpcy5sb3d9LFMuZXF6PVMuaXNaZXJvLFMuaXNOZWdhdGl2ZT1mdW5jdGlvbigpe3JldHVybiF0aGlzLnVuc2lnbmVkJiZ0aGlzLmhpZ2g8MH0sUy5pc1Bvc2l0aXZlPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudW5zaWduZWR8fHRoaXMuaGlnaD49MH0sUy5pc09kZD1mdW5jdGlvbigpe3JldHVybiAxPT0oMSZ0aGlzLmxvdyl9LFMuaXNFdmVuPWZ1bmN0aW9uKCl7cmV0dXJuIDA9PSgxJnRoaXMubG93KX0sUy5lcXVhbHM9ZnVuY3Rpb24odCl7cmV0dXJuIHIodCl8fCh0PXAodCkpLCh0aGlzLnVuc2lnbmVkPT09dC51bnNpZ25lZHx8dGhpcy5oaWdoPj4+MzEhPTF8fHQuaGlnaD4+PjMxIT0xKSYmdGhpcy5oaWdoPT09dC5oaWdoJiZ0aGlzLmxvdz09PXQubG93fSxTLmVxPVMuZXF1YWxzLFMubm90RXF1YWxzPWZ1bmN0aW9uKHQpe3JldHVybiF0aGlzLmVxKHQpfSxTLm5lcT1TLm5vdEVxdWFscyxTLm5lPVMubm90RXF1YWxzLFMubGVzc1RoYW49ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuY29tcCh0KTwwfSxTLmx0PVMubGVzc1RoYW4sUy5sZXNzVGhhbk9yRXF1YWw9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuY29tcCh0KTw9MH0sUy5sdGU9Uy5sZXNzVGhhbk9yRXF1YWwsUy5sZT1TLmxlc3NUaGFuT3JFcXVhbCxTLmdyZWF0ZXJUaGFuPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmNvbXAodCk+MH0sUy5ndD1TLmdyZWF0ZXJUaGFuLFMuZ3JlYXRlclRoYW5PckVxdWFsPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmNvbXAodCk+PTB9LFMuZ3RlPVMuZ3JlYXRlclRoYW5PckVxdWFsLFMuZ2U9Uy5ncmVhdGVyVGhhbk9yRXF1YWwsUy5jb21wYXJlPWZ1bmN0aW9uKHQpe2lmKHIodCl8fCh0PXAodCkpLHRoaXMuZXEodCkpcmV0dXJuIDA7dmFyIGU9dGhpcy5pc05lZ2F0aXZlKCksbj10LmlzTmVnYXRpdmUoKTtyZXR1cm4gZSYmIW4/LTE6IWUmJm4/MTp0aGlzLnVuc2lnbmVkP3QuaGlnaD4+PjA+dGhpcy5oaWdoPj4+MHx8dC5oaWdoPT09dGhpcy5oaWdoJiZ0Lmxvdz4+PjA+dGhpcy5sb3c+Pj4wPy0xOjE6dGhpcy5zdWIodCkuaXNOZWdhdGl2ZSgpPy0xOjF9LFMuY29tcD1TLmNvbXBhcmUsUy5uZWdhdGU9ZnVuY3Rpb24oKXtyZXR1cm4hdGhpcy51bnNpZ25lZCYmdGhpcy5lcShUKT9UOnRoaXMubm90KCkuYWRkKHkpfSxTLm5lZz1TLm5lZ2F0ZSxTLmFkZD1mdW5jdGlvbih0KXtyKHQpfHwodD1wKHQpKTt2YXIgZT10aGlzLmhpZ2g+Pj4xNixuPTY1NTM1JnRoaXMuaGlnaCxpPXRoaXMubG93Pj4+MTYsbz02NTUzNSZ0aGlzLmxvdyxhPXQuaGlnaD4+PjE2LHM9NjU1MzUmdC5oaWdoLGM9dC5sb3c+Pj4xNixsPTAsZj0wLGQ9MCxoPTA7cmV0dXJuIGQrPShoKz1vKyg2NTUzNSZ0LmxvdykpPj4+MTYsZis9KGQrPWkrYyk+Pj4xNixsKz0oZis9bitzKT4+PjE2LGwrPWUrYSx1KChkJj02NTUzNSk8PDE2fChoJj02NTUzNSksKGwmPTY1NTM1KTw8MTZ8KGYmPTY1NTM1KSx0aGlzLnVuc2lnbmVkKX0sUy5zdWJ0cmFjdD1mdW5jdGlvbih0KXtyZXR1cm4gcih0KXx8KHQ9cCh0KSksdGhpcy5hZGQodC5uZWcoKSl9LFMuc3ViPVMuc3VidHJhY3QsUy5tdWx0aXBseT1mdW5jdGlvbih0KXtpZih0aGlzLmlzWmVybygpKXJldHVybiBiO2lmKHIodCl8fCh0PXAodCkpLGUpcmV0dXJuIHUoZS5tdWwodGhpcy5sb3csdGhpcy5oaWdoLHQubG93LHQuaGlnaCksZS5nZXRfaGlnaCgpLHRoaXMudW5zaWduZWQpO2lmKHQuaXNaZXJvKCkpcmV0dXJuIGI7aWYodGhpcy5lcShUKSlyZXR1cm4gdC5pc09kZCgpP1Q6YjtpZih0LmVxKFQpKXJldHVybiB0aGlzLmlzT2RkKCk/VDpiO2lmKHRoaXMuaXNOZWdhdGl2ZSgpKXJldHVybiB0LmlzTmVnYXRpdmUoKT90aGlzLm5lZygpLm11bCh0Lm5lZygpKTp0aGlzLm5lZygpLm11bCh0KS5uZWcoKTtpZih0LmlzTmVnYXRpdmUoKSlyZXR1cm4gdGhpcy5tdWwodC5uZWcoKSkubmVnKCk7aWYodGhpcy5sdChnKSYmdC5sdChnKSlyZXR1cm4gcyh0aGlzLnRvTnVtYmVyKCkqdC50b051bWJlcigpLHRoaXMudW5zaWduZWQpO3ZhciBuPXRoaXMuaGlnaD4+PjE2LGk9NjU1MzUmdGhpcy5oaWdoLG89dGhpcy5sb3c+Pj4xNixhPTY1NTM1JnRoaXMubG93LGM9dC5oaWdoPj4+MTYsbD02NTUzNSZ0LmhpZ2gsZj10Lmxvdz4+PjE2LGQ9NjU1MzUmdC5sb3csaD0wLG09MCx5PTAsXz0wO3JldHVybiB5Kz0oXys9YSpkKT4+PjE2LG0rPSh5Kz1vKmQpPj4+MTYseSY9NjU1MzUsbSs9KHkrPWEqZik+Pj4xNixoKz0obSs9aSpkKT4+PjE2LG0mPTY1NTM1LGgrPShtKz1vKmYpPj4+MTYsbSY9NjU1MzUsaCs9KG0rPWEqbCk+Pj4xNixoKz1uKmQraSpmK28qbCthKmMsdSgoeSY9NjU1MzUpPDwxNnwoXyY9NjU1MzUpLChoJj02NTUzNSk8PDE2fChtJj02NTUzNSksdGhpcy51bnNpZ25lZCl9LFMubXVsPVMubXVsdGlwbHksUy5kaXZpZGU9ZnVuY3Rpb24odCl7aWYocih0KXx8KHQ9cCh0KSksdC5pc1plcm8oKSl0aHJvdyBFcnJvcihcImRpdmlzaW9uIGJ5IHplcm9cIik7dmFyIG4saSxvO2lmKGUpcmV0dXJuIHRoaXMudW5zaWduZWR8fC0yMTQ3NDgzNjQ4IT09dGhpcy5oaWdofHwtMSE9PXQubG93fHwtMSE9PXQuaGlnaD91KCh0aGlzLnVuc2lnbmVkP2UuZGl2X3U6ZS5kaXZfcykodGhpcy5sb3csdGhpcy5oaWdoLHQubG93LHQuaGlnaCksZS5nZXRfaGlnaCgpLHRoaXMudW5zaWduZWQpOnRoaXM7aWYodGhpcy5pc1plcm8oKSlyZXR1cm4gdGhpcy51bnNpZ25lZD9tOmI7aWYodGhpcy51bnNpZ25lZCl7aWYodC51bnNpZ25lZHx8KHQ9dC50b1Vuc2lnbmVkKCkpLHQuZ3QodGhpcykpcmV0dXJuIG07aWYodC5ndCh0aGlzLnNocnUoMSkpKXJldHVybiBfO289bX1lbHNle2lmKHRoaXMuZXEoVCkpcmV0dXJuIHQuZXEoeSl8fHQuZXEodik/VDp0LmVxKFQpP3k6KG49dGhpcy5zaHIoMSkuZGl2KHQpLnNobCgxKSkuZXEoYik/dC5pc05lZ2F0aXZlKCk/eTp2OihpPXRoaXMuc3ViKHQubXVsKG4pKSxvPW4uYWRkKGkuZGl2KHQpKSk7aWYodC5lcShUKSlyZXR1cm4gdGhpcy51bnNpZ25lZD9tOmI7aWYodGhpcy5pc05lZ2F0aXZlKCkpcmV0dXJuIHQuaXNOZWdhdGl2ZSgpP3RoaXMubmVnKCkuZGl2KHQubmVnKCkpOnRoaXMubmVnKCkuZGl2KHQpLm5lZygpO2lmKHQuaXNOZWdhdGl2ZSgpKXJldHVybiB0aGlzLmRpdih0Lm5lZygpKS5uZWcoKTtvPWJ9Zm9yKGk9dGhpcztpLmd0ZSh0KTspe249TWF0aC5tYXgoMSxNYXRoLmZsb29yKGkudG9OdW1iZXIoKS90LnRvTnVtYmVyKCkpKTtmb3IodmFyIGE9TWF0aC5jZWlsKE1hdGgubG9nKG4pL01hdGguTE4yKSxsPWE8PTQ4PzE6YygyLGEtNDgpLGY9cyhuKSxkPWYubXVsKHQpO2QuaXNOZWdhdGl2ZSgpfHxkLmd0KGkpOylkPShmPXMobi09bCx0aGlzLnVuc2lnbmVkKSkubXVsKHQpO2YuaXNaZXJvKCkmJihmPXkpLG89by5hZGQoZiksaT1pLnN1YihkKX1yZXR1cm4gb30sUy5kaXY9Uy5kaXZpZGUsUy5tb2R1bG89ZnVuY3Rpb24odCl7cmV0dXJuIHIodCl8fCh0PXAodCkpLGU/dSgodGhpcy51bnNpZ25lZD9lLnJlbV91OmUucmVtX3MpKHRoaXMubG93LHRoaXMuaGlnaCx0Lmxvdyx0LmhpZ2gpLGUuZ2V0X2hpZ2goKSx0aGlzLnVuc2lnbmVkKTp0aGlzLnN1Yih0aGlzLmRpdih0KS5tdWwodCkpfSxTLm1vZD1TLm1vZHVsbyxTLnJlbT1TLm1vZHVsbyxTLm5vdD1mdW5jdGlvbigpe3JldHVybiB1KH50aGlzLmxvdyx+dGhpcy5oaWdoLHRoaXMudW5zaWduZWQpfSxTLmFuZD1mdW5jdGlvbih0KXtyZXR1cm4gcih0KXx8KHQ9cCh0KSksdSh0aGlzLmxvdyZ0Lmxvdyx0aGlzLmhpZ2gmdC5oaWdoLHRoaXMudW5zaWduZWQpfSxTLm9yPWZ1bmN0aW9uKHQpe3JldHVybiByKHQpfHwodD1wKHQpKSx1KHRoaXMubG93fHQubG93LHRoaXMuaGlnaHx0LmhpZ2gsdGhpcy51bnNpZ25lZCl9LFMueG9yPWZ1bmN0aW9uKHQpe3JldHVybiByKHQpfHwodD1wKHQpKSx1KHRoaXMubG93XnQubG93LHRoaXMuaGlnaF50LmhpZ2gsdGhpcy51bnNpZ25lZCl9LFMuc2hpZnRMZWZ0PWZ1bmN0aW9uKHQpe3JldHVybiByKHQpJiYodD10LnRvSW50KCkpLDA9PSh0Jj02Myk/dGhpczp0PDMyP3UodGhpcy5sb3c8PHQsdGhpcy5oaWdoPDx0fHRoaXMubG93Pj4+MzItdCx0aGlzLnVuc2lnbmVkKTp1KDAsdGhpcy5sb3c8PHQtMzIsdGhpcy51bnNpZ25lZCl9LFMuc2hsPVMuc2hpZnRMZWZ0LFMuc2hpZnRSaWdodD1mdW5jdGlvbih0KXtyZXR1cm4gcih0KSYmKHQ9dC50b0ludCgpKSwwPT0odCY9NjMpP3RoaXM6dDwzMj91KHRoaXMubG93Pj4+dHx0aGlzLmhpZ2g8PDMyLXQsdGhpcy5oaWdoPj50LHRoaXMudW5zaWduZWQpOnUodGhpcy5oaWdoPj50LTMyLHRoaXMuaGlnaD49MD8wOi0xLHRoaXMudW5zaWduZWQpfSxTLnNocj1TLnNoaWZ0UmlnaHQsUy5zaGlmdFJpZ2h0VW5zaWduZWQ9ZnVuY3Rpb24odCl7aWYocih0KSYmKHQ9dC50b0ludCgpKSwwPT0odCY9NjMpKXJldHVybiB0aGlzO3ZhciBlPXRoaXMuaGlnaDtyZXR1cm4gdDwzMj91KHRoaXMubG93Pj4+dHxlPDwzMi10LGU+Pj50LHRoaXMudW5zaWduZWQpOnUoMzI9PT10P2U6ZT4+PnQtMzIsMCx0aGlzLnVuc2lnbmVkKX0sUy5zaHJ1PVMuc2hpZnRSaWdodFVuc2lnbmVkLFMuc2hyX3U9Uy5zaGlmdFJpZ2h0VW5zaWduZWQsUy50b1NpZ25lZD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnVuc2lnbmVkP3UodGhpcy5sb3csdGhpcy5oaWdoLCExKTp0aGlzfSxTLnRvVW5zaWduZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy51bnNpZ25lZD90aGlzOnUodGhpcy5sb3csdGhpcy5oaWdoLCEwKX0sUy50b0J5dGVzPWZ1bmN0aW9uKHQpe3JldHVybiB0P3RoaXMudG9CeXRlc0xFKCk6dGhpcy50b0J5dGVzQkUoKX0sUy50b0J5dGVzTEU9ZnVuY3Rpb24oKXt2YXIgdD10aGlzLmhpZ2gsZT10aGlzLmxvdztyZXR1cm5bMjU1JmUsZT4+PjgmMjU1LGU+Pj4xNiYyNTUsZT4+PjI0LDI1NSZ0LHQ+Pj44JjI1NSx0Pj4+MTYmMjU1LHQ+Pj4yNF19LFMudG9CeXRlc0JFPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5oaWdoLGU9dGhpcy5sb3c7cmV0dXJuW3Q+Pj4yNCx0Pj4+MTYmMjU1LHQ+Pj44JjI1NSwyNTUmdCxlPj4+MjQsZT4+PjE2JjI1NSxlPj4+OCYyNTUsMjU1JmVdfSxuLmZyb21CeXRlcz1mdW5jdGlvbih0LGUscil7cmV0dXJuIHI/bi5mcm9tQnl0ZXNMRSh0LGUpOm4uZnJvbUJ5dGVzQkUodCxlKX0sbi5mcm9tQnl0ZXNMRT1mdW5jdGlvbih0LGUpe3JldHVybiBuZXcgbih0WzBdfHRbMV08PDh8dFsyXTw8MTZ8dFszXTw8MjQsdFs0XXx0WzVdPDw4fHRbNl08PDE2fHRbN108PDI0LGUpfSxuLmZyb21CeXRlc0JFPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIG5ldyBuKHRbNF08PDI0fHRbNV08PDE2fHRbNl08PDh8dFs3XSx0WzBdPDwyNHx0WzFdPDwxNnx0WzJdPDw4fHRbM10sZSl9fSwxNDQ2Oih0LGUsbik9PntcInVzZSBzdHJpY3RcIjt2YXIgcixpLG8sYT1uKDIxMDApLHM9YS5SZWFkZXIsdT1hLldyaXRlcixjPWEudXRpbCxsPWEucm9vdHMuZGVmYXVsdHx8KGEucm9vdHMuZGVmYXVsdD17fSk7bC5vbm54PSgobz17fSkuVmVyc2lvbj0ocj17fSwoaT1PYmplY3QuY3JlYXRlKHIpKVtyWzBdPVwiX1NUQVJUX1ZFUlNJT05cIl09MCxpW3JbMV09XCJJUl9WRVJTSU9OXzIwMTdfMTBfMTBcIl09MSxpW3JbMl09XCJJUl9WRVJTSU9OXzIwMTdfMTBfMzBcIl09MixpW3JbM109XCJJUl9WRVJTSU9OXzIwMTdfMTFfM1wiXT0zLGlbcls0XT1cIklSX1ZFUlNJT05fMjAxOV8xXzIyXCJdPTQsaVtyWzVdPVwiSVJfVkVSU0lPTlwiXT01LGkpLG8uQXR0cmlidXRlUHJvdG89ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQpe2lmKHRoaXMuZmxvYXRzPVtdLHRoaXMuaW50cz1bXSx0aGlzLnN0cmluZ3M9W10sdGhpcy50ZW5zb3JzPVtdLHRoaXMuZ3JhcGhzPVtdLHQpZm9yKHZhciBlPU9iamVjdC5rZXlzKHQpLG49MDtuPGUubGVuZ3RoOysrbiludWxsIT10W2Vbbl1dJiYodGhpc1tlW25dXT10W2Vbbl1dKX1yZXR1cm4gdC5wcm90b3R5cGUubmFtZT1cIlwiLHQucHJvdG90eXBlLnJlZkF0dHJOYW1lPVwiXCIsdC5wcm90b3R5cGUuZG9jU3RyaW5nPVwiXCIsdC5wcm90b3R5cGUudHlwZT0wLHQucHJvdG90eXBlLmY9MCx0LnByb3RvdHlwZS5pPWMuTG9uZz9jLkxvbmcuZnJvbUJpdHMoMCwwLCExKTowLHQucHJvdG90eXBlLnM9Yy5uZXdCdWZmZXIoW10pLHQucHJvdG90eXBlLnQ9bnVsbCx0LnByb3RvdHlwZS5nPW51bGwsdC5wcm90b3R5cGUuZmxvYXRzPWMuZW1wdHlBcnJheSx0LnByb3RvdHlwZS5pbnRzPWMuZW1wdHlBcnJheSx0LnByb3RvdHlwZS5zdHJpbmdzPWMuZW1wdHlBcnJheSx0LnByb3RvdHlwZS50ZW5zb3JzPWMuZW1wdHlBcnJheSx0LnByb3RvdHlwZS5ncmFwaHM9Yy5lbXB0eUFycmF5LHQuY3JlYXRlPWZ1bmN0aW9uKGUpe3JldHVybiBuZXcgdChlKX0sdC5lbmNvZGU9ZnVuY3Rpb24odCxlKXtpZihlfHwoZT11LmNyZWF0ZSgpKSxudWxsIT10Lm5hbWUmJnQuaGFzT3duUHJvcGVydHkoXCJuYW1lXCIpJiZlLnVpbnQzMigxMCkuc3RyaW5nKHQubmFtZSksbnVsbCE9dC5mJiZ0Lmhhc093blByb3BlcnR5KFwiZlwiKSYmZS51aW50MzIoMjEpLmZsb2F0KHQuZiksbnVsbCE9dC5pJiZ0Lmhhc093blByb3BlcnR5KFwiaVwiKSYmZS51aW50MzIoMjQpLmludDY0KHQuaSksbnVsbCE9dC5zJiZ0Lmhhc093blByb3BlcnR5KFwic1wiKSYmZS51aW50MzIoMzQpLmJ5dGVzKHQucyksbnVsbCE9dC50JiZ0Lmhhc093blByb3BlcnR5KFwidFwiKSYmbC5vbm54LlRlbnNvclByb3RvLmVuY29kZSh0LnQsZS51aW50MzIoNDIpLmZvcmsoKSkubGRlbGltKCksbnVsbCE9dC5nJiZ0Lmhhc093blByb3BlcnR5KFwiZ1wiKSYmbC5vbm54LkdyYXBoUHJvdG8uZW5jb2RlKHQuZyxlLnVpbnQzMig1MCkuZm9yaygpKS5sZGVsaW0oKSxudWxsIT10LmZsb2F0cyYmdC5mbG9hdHMubGVuZ3RoKXtlLnVpbnQzMig1OCkuZm9yaygpO2Zvcih2YXIgbj0wO248dC5mbG9hdHMubGVuZ3RoOysrbillLmZsb2F0KHQuZmxvYXRzW25dKTtlLmxkZWxpbSgpfWlmKG51bGwhPXQuaW50cyYmdC5pbnRzLmxlbmd0aCl7Zm9yKGUudWludDMyKDY2KS5mb3JrKCksbj0wO248dC5pbnRzLmxlbmd0aDsrK24pZS5pbnQ2NCh0LmludHNbbl0pO2UubGRlbGltKCl9aWYobnVsbCE9dC5zdHJpbmdzJiZ0LnN0cmluZ3MubGVuZ3RoKWZvcihuPTA7bjx0LnN0cmluZ3MubGVuZ3RoOysrbillLnVpbnQzMig3NCkuYnl0ZXModC5zdHJpbmdzW25dKTtpZihudWxsIT10LnRlbnNvcnMmJnQudGVuc29ycy5sZW5ndGgpZm9yKG49MDtuPHQudGVuc29ycy5sZW5ndGg7KytuKWwub25ueC5UZW5zb3JQcm90by5lbmNvZGUodC50ZW5zb3JzW25dLGUudWludDMyKDgyKS5mb3JrKCkpLmxkZWxpbSgpO2lmKG51bGwhPXQuZ3JhcGhzJiZ0LmdyYXBocy5sZW5ndGgpZm9yKG49MDtuPHQuZ3JhcGhzLmxlbmd0aDsrK24pbC5vbm54LkdyYXBoUHJvdG8uZW5jb2RlKHQuZ3JhcGhzW25dLGUudWludDMyKDkwKS5mb3JrKCkpLmxkZWxpbSgpO3JldHVybiBudWxsIT10LmRvY1N0cmluZyYmdC5oYXNPd25Qcm9wZXJ0eShcImRvY1N0cmluZ1wiKSYmZS51aW50MzIoMTA2KS5zdHJpbmcodC5kb2NTdHJpbmcpLG51bGwhPXQudHlwZSYmdC5oYXNPd25Qcm9wZXJ0eShcInR5cGVcIikmJmUudWludDMyKDE2MCkuaW50MzIodC50eXBlKSxudWxsIT10LnJlZkF0dHJOYW1lJiZ0Lmhhc093blByb3BlcnR5KFwicmVmQXR0ck5hbWVcIikmJmUudWludDMyKDE3MCkuc3RyaW5nKHQucmVmQXR0ck5hbWUpLGV9LHQuZW5jb2RlRGVsaW1pdGVkPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMuZW5jb2RlKHQsZSkubGRlbGltKCl9LHQuZGVjb2RlPWZ1bmN0aW9uKHQsZSl7dCBpbnN0YW5jZW9mIHN8fCh0PXMuY3JlYXRlKHQpKTtmb3IodmFyIG49dm9pZCAwPT09ZT90Lmxlbjp0LnBvcytlLHI9bmV3IGwub25ueC5BdHRyaWJ1dGVQcm90bzt0LnBvczxuOyl7dmFyIGk9dC51aW50MzIoKTtzd2l0Y2goaT4+PjMpe2Nhc2UgMTpyLm5hbWU9dC5zdHJpbmcoKTticmVhaztjYXNlIDIxOnIucmVmQXR0ck5hbWU9dC5zdHJpbmcoKTticmVhaztjYXNlIDEzOnIuZG9jU3RyaW5nPXQuc3RyaW5nKCk7YnJlYWs7Y2FzZSAyMDpyLnR5cGU9dC5pbnQzMigpO2JyZWFrO2Nhc2UgMjpyLmY9dC5mbG9hdCgpO2JyZWFrO2Nhc2UgMzpyLmk9dC5pbnQ2NCgpO2JyZWFrO2Nhc2UgNDpyLnM9dC5ieXRlcygpO2JyZWFrO2Nhc2UgNTpyLnQ9bC5vbm54LlRlbnNvclByb3RvLmRlY29kZSh0LHQudWludDMyKCkpO2JyZWFrO2Nhc2UgNjpyLmc9bC5vbm54LkdyYXBoUHJvdG8uZGVjb2RlKHQsdC51aW50MzIoKSk7YnJlYWs7Y2FzZSA3OmlmKHIuZmxvYXRzJiZyLmZsb2F0cy5sZW5ndGh8fChyLmZsb2F0cz1bXSksMj09KDcmaSkpZm9yKHZhciBvPXQudWludDMyKCkrdC5wb3M7dC5wb3M8bzspci5mbG9hdHMucHVzaCh0LmZsb2F0KCkpO2Vsc2Ugci5mbG9hdHMucHVzaCh0LmZsb2F0KCkpO2JyZWFrO2Nhc2UgODppZihyLmludHMmJnIuaW50cy5sZW5ndGh8fChyLmludHM9W10pLDI9PSg3JmkpKWZvcihvPXQudWludDMyKCkrdC5wb3M7dC5wb3M8bzspci5pbnRzLnB1c2godC5pbnQ2NCgpKTtlbHNlIHIuaW50cy5wdXNoKHQuaW50NjQoKSk7YnJlYWs7Y2FzZSA5OnIuc3RyaW5ncyYmci5zdHJpbmdzLmxlbmd0aHx8KHIuc3RyaW5ncz1bXSksci5zdHJpbmdzLnB1c2godC5ieXRlcygpKTticmVhaztjYXNlIDEwOnIudGVuc29ycyYmci50ZW5zb3JzLmxlbmd0aHx8KHIudGVuc29ycz1bXSksci50ZW5zb3JzLnB1c2gobC5vbm54LlRlbnNvclByb3RvLmRlY29kZSh0LHQudWludDMyKCkpKTticmVhaztjYXNlIDExOnIuZ3JhcGhzJiZyLmdyYXBocy5sZW5ndGh8fChyLmdyYXBocz1bXSksci5ncmFwaHMucHVzaChsLm9ubnguR3JhcGhQcm90by5kZWNvZGUodCx0LnVpbnQzMigpKSk7YnJlYWs7ZGVmYXVsdDp0LnNraXBUeXBlKDcmaSl9fXJldHVybiByfSx0LmRlY29kZURlbGltaXRlZD1mdW5jdGlvbih0KXtyZXR1cm4gdCBpbnN0YW5jZW9mIHN8fCh0PW5ldyBzKHQpKSx0aGlzLmRlY29kZSh0LHQudWludDMyKCkpfSx0LnZlcmlmeT1mdW5jdGlvbih0KXtpZihcIm9iamVjdFwiIT10eXBlb2YgdHx8bnVsbD09PXQpcmV0dXJuXCJvYmplY3QgZXhwZWN0ZWRcIjtpZihudWxsIT10Lm5hbWUmJnQuaGFzT3duUHJvcGVydHkoXCJuYW1lXCIpJiYhYy5pc1N0cmluZyh0Lm5hbWUpKXJldHVyblwibmFtZTogc3RyaW5nIGV4cGVjdGVkXCI7aWYobnVsbCE9dC5yZWZBdHRyTmFtZSYmdC5oYXNPd25Qcm9wZXJ0eShcInJlZkF0dHJOYW1lXCIpJiYhYy5pc1N0cmluZyh0LnJlZkF0dHJOYW1lKSlyZXR1cm5cInJlZkF0dHJOYW1lOiBzdHJpbmcgZXhwZWN0ZWRcIjtpZihudWxsIT10LmRvY1N0cmluZyYmdC5oYXNPd25Qcm9wZXJ0eShcImRvY1N0cmluZ1wiKSYmIWMuaXNTdHJpbmcodC5kb2NTdHJpbmcpKXJldHVyblwiZG9jU3RyaW5nOiBzdHJpbmcgZXhwZWN0ZWRcIjtpZihudWxsIT10LnR5cGUmJnQuaGFzT3duUHJvcGVydHkoXCJ0eXBlXCIpKXN3aXRjaCh0LnR5cGUpe2RlZmF1bHQ6cmV0dXJuXCJ0eXBlOiBlbnVtIHZhbHVlIGV4cGVjdGVkXCI7Y2FzZSAwOmNhc2UgMTpjYXNlIDI6Y2FzZSAzOmNhc2UgNDpjYXNlIDU6Y2FzZSA2OmNhc2UgNzpjYXNlIDg6Y2FzZSA5OmNhc2UgMTA6fWlmKG51bGwhPXQuZiYmdC5oYXNPd25Qcm9wZXJ0eShcImZcIikmJlwibnVtYmVyXCIhPXR5cGVvZiB0LmYpcmV0dXJuXCJmOiBudW1iZXIgZXhwZWN0ZWRcIjtpZihudWxsIT10LmkmJnQuaGFzT3duUHJvcGVydHkoXCJpXCIpJiYhKGMuaXNJbnRlZ2VyKHQuaSl8fHQuaSYmYy5pc0ludGVnZXIodC5pLmxvdykmJmMuaXNJbnRlZ2VyKHQuaS5oaWdoKSkpcmV0dXJuXCJpOiBpbnRlZ2VyfExvbmcgZXhwZWN0ZWRcIjtpZihudWxsIT10LnMmJnQuaGFzT3duUHJvcGVydHkoXCJzXCIpJiYhKHQucyYmXCJudW1iZXJcIj09dHlwZW9mIHQucy5sZW5ndGh8fGMuaXNTdHJpbmcodC5zKSkpcmV0dXJuXCJzOiBidWZmZXIgZXhwZWN0ZWRcIjtpZihudWxsIT10LnQmJnQuaGFzT3duUHJvcGVydHkoXCJ0XCIpJiYobj1sLm9ubnguVGVuc29yUHJvdG8udmVyaWZ5KHQudCkpKXJldHVyblwidC5cIituO2lmKG51bGwhPXQuZyYmdC5oYXNPd25Qcm9wZXJ0eShcImdcIikmJihuPWwub25ueC5HcmFwaFByb3RvLnZlcmlmeSh0LmcpKSlyZXR1cm5cImcuXCIrbjtpZihudWxsIT10LmZsb2F0cyYmdC5oYXNPd25Qcm9wZXJ0eShcImZsb2F0c1wiKSl7aWYoIUFycmF5LmlzQXJyYXkodC5mbG9hdHMpKXJldHVyblwiZmxvYXRzOiBhcnJheSBleHBlY3RlZFwiO2Zvcih2YXIgZT0wO2U8dC5mbG9hdHMubGVuZ3RoOysrZSlpZihcIm51bWJlclwiIT10eXBlb2YgdC5mbG9hdHNbZV0pcmV0dXJuXCJmbG9hdHM6IG51bWJlcltdIGV4cGVjdGVkXCJ9aWYobnVsbCE9dC5pbnRzJiZ0Lmhhc093blByb3BlcnR5KFwiaW50c1wiKSl7aWYoIUFycmF5LmlzQXJyYXkodC5pbnRzKSlyZXR1cm5cImludHM6IGFycmF5IGV4cGVjdGVkXCI7Zm9yKGU9MDtlPHQuaW50cy5sZW5ndGg7KytlKWlmKCEoYy5pc0ludGVnZXIodC5pbnRzW2VdKXx8dC5pbnRzW2VdJiZjLmlzSW50ZWdlcih0LmludHNbZV0ubG93KSYmYy5pc0ludGVnZXIodC5pbnRzW2VdLmhpZ2gpKSlyZXR1cm5cImludHM6IGludGVnZXJ8TG9uZ1tdIGV4cGVjdGVkXCJ9aWYobnVsbCE9dC5zdHJpbmdzJiZ0Lmhhc093blByb3BlcnR5KFwic3RyaW5nc1wiKSl7aWYoIUFycmF5LmlzQXJyYXkodC5zdHJpbmdzKSlyZXR1cm5cInN0cmluZ3M6IGFycmF5IGV4cGVjdGVkXCI7Zm9yKGU9MDtlPHQuc3RyaW5ncy5sZW5ndGg7KytlKWlmKCEodC5zdHJpbmdzW2VdJiZcIm51bWJlclwiPT10eXBlb2YgdC5zdHJpbmdzW2VdLmxlbmd0aHx8Yy5pc1N0cmluZyh0LnN0cmluZ3NbZV0pKSlyZXR1cm5cInN0cmluZ3M6IGJ1ZmZlcltdIGV4cGVjdGVkXCJ9aWYobnVsbCE9dC50ZW5zb3JzJiZ0Lmhhc093blByb3BlcnR5KFwidGVuc29yc1wiKSl7aWYoIUFycmF5LmlzQXJyYXkodC50ZW5zb3JzKSlyZXR1cm5cInRlbnNvcnM6IGFycmF5IGV4cGVjdGVkXCI7Zm9yKGU9MDtlPHQudGVuc29ycy5sZW5ndGg7KytlKWlmKG49bC5vbm54LlRlbnNvclByb3RvLnZlcmlmeSh0LnRlbnNvcnNbZV0pKXJldHVyblwidGVuc29ycy5cIitufWlmKG51bGwhPXQuZ3JhcGhzJiZ0Lmhhc093blByb3BlcnR5KFwiZ3JhcGhzXCIpKXtpZighQXJyYXkuaXNBcnJheSh0LmdyYXBocykpcmV0dXJuXCJncmFwaHM6IGFycmF5IGV4cGVjdGVkXCI7Zm9yKGU9MDtlPHQuZ3JhcGhzLmxlbmd0aDsrK2Upe3ZhciBuO2lmKG49bC5vbm54LkdyYXBoUHJvdG8udmVyaWZ5KHQuZ3JhcGhzW2VdKSlyZXR1cm5cImdyYXBocy5cIitufX1yZXR1cm4gbnVsbH0sdC5mcm9tT2JqZWN0PWZ1bmN0aW9uKHQpe2lmKHQgaW5zdGFuY2VvZiBsLm9ubnguQXR0cmlidXRlUHJvdG8pcmV0dXJuIHQ7dmFyIGU9bmV3IGwub25ueC5BdHRyaWJ1dGVQcm90bztzd2l0Y2gobnVsbCE9dC5uYW1lJiYoZS5uYW1lPVN0cmluZyh0Lm5hbWUpKSxudWxsIT10LnJlZkF0dHJOYW1lJiYoZS5yZWZBdHRyTmFtZT1TdHJpbmcodC5yZWZBdHRyTmFtZSkpLG51bGwhPXQuZG9jU3RyaW5nJiYoZS5kb2NTdHJpbmc9U3RyaW5nKHQuZG9jU3RyaW5nKSksdC50eXBlKXtjYXNlXCJVTkRFRklORURcIjpjYXNlIDA6ZS50eXBlPTA7YnJlYWs7Y2FzZVwiRkxPQVRcIjpjYXNlIDE6ZS50eXBlPTE7YnJlYWs7Y2FzZVwiSU5UXCI6Y2FzZSAyOmUudHlwZT0yO2JyZWFrO2Nhc2VcIlNUUklOR1wiOmNhc2UgMzplLnR5cGU9MzticmVhaztjYXNlXCJURU5TT1JcIjpjYXNlIDQ6ZS50eXBlPTQ7YnJlYWs7Y2FzZVwiR1JBUEhcIjpjYXNlIDU6ZS50eXBlPTU7YnJlYWs7Y2FzZVwiRkxPQVRTXCI6Y2FzZSA2OmUudHlwZT02O2JyZWFrO2Nhc2VcIklOVFNcIjpjYXNlIDc6ZS50eXBlPTc7YnJlYWs7Y2FzZVwiU1RSSU5HU1wiOmNhc2UgODplLnR5cGU9ODticmVhaztjYXNlXCJURU5TT1JTXCI6Y2FzZSA5OmUudHlwZT05O2JyZWFrO2Nhc2VcIkdSQVBIU1wiOmNhc2UgMTA6ZS50eXBlPTEwfWlmKG51bGwhPXQuZiYmKGUuZj1OdW1iZXIodC5mKSksbnVsbCE9dC5pJiYoYy5Mb25nPyhlLmk9Yy5Mb25nLmZyb21WYWx1ZSh0LmkpKS51bnNpZ25lZD0hMTpcInN0cmluZ1wiPT10eXBlb2YgdC5pP2UuaT1wYXJzZUludCh0LmksMTApOlwibnVtYmVyXCI9PXR5cGVvZiB0Lmk/ZS5pPXQuaTpcIm9iamVjdFwiPT10eXBlb2YgdC5pJiYoZS5pPW5ldyBjLkxvbmdCaXRzKHQuaS5sb3c+Pj4wLHQuaS5oaWdoPj4+MCkudG9OdW1iZXIoKSkpLG51bGwhPXQucyYmKFwic3RyaW5nXCI9PXR5cGVvZiB0LnM/Yy5iYXNlNjQuZGVjb2RlKHQucyxlLnM9Yy5uZXdCdWZmZXIoYy5iYXNlNjQubGVuZ3RoKHQucykpLDApOnQucy5sZW5ndGgmJihlLnM9dC5zKSksbnVsbCE9dC50KXtpZihcIm9iamVjdFwiIT10eXBlb2YgdC50KXRocm93IFR5cGVFcnJvcihcIi5vbm54LkF0dHJpYnV0ZVByb3RvLnQ6IG9iamVjdCBleHBlY3RlZFwiKTtlLnQ9bC5vbm54LlRlbnNvclByb3RvLmZyb21PYmplY3QodC50KX1pZihudWxsIT10Lmcpe2lmKFwib2JqZWN0XCIhPXR5cGVvZiB0LmcpdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguQXR0cmlidXRlUHJvdG8uZzogb2JqZWN0IGV4cGVjdGVkXCIpO2UuZz1sLm9ubnguR3JhcGhQcm90by5mcm9tT2JqZWN0KHQuZyl9aWYodC5mbG9hdHMpe2lmKCFBcnJheS5pc0FycmF5KHQuZmxvYXRzKSl0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5BdHRyaWJ1dGVQcm90by5mbG9hdHM6IGFycmF5IGV4cGVjdGVkXCIpO2UuZmxvYXRzPVtdO2Zvcih2YXIgbj0wO248dC5mbG9hdHMubGVuZ3RoOysrbillLmZsb2F0c1tuXT1OdW1iZXIodC5mbG9hdHNbbl0pfWlmKHQuaW50cyl7aWYoIUFycmF5LmlzQXJyYXkodC5pbnRzKSl0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5BdHRyaWJ1dGVQcm90by5pbnRzOiBhcnJheSBleHBlY3RlZFwiKTtmb3IoZS5pbnRzPVtdLG49MDtuPHQuaW50cy5sZW5ndGg7KytuKWMuTG9uZz8oZS5pbnRzW25dPWMuTG9uZy5mcm9tVmFsdWUodC5pbnRzW25dKSkudW5zaWduZWQ9ITE6XCJzdHJpbmdcIj09dHlwZW9mIHQuaW50c1tuXT9lLmludHNbbl09cGFyc2VJbnQodC5pbnRzW25dLDEwKTpcIm51bWJlclwiPT10eXBlb2YgdC5pbnRzW25dP2UuaW50c1tuXT10LmludHNbbl06XCJvYmplY3RcIj09dHlwZW9mIHQuaW50c1tuXSYmKGUuaW50c1tuXT1uZXcgYy5Mb25nQml0cyh0LmludHNbbl0ubG93Pj4+MCx0LmludHNbbl0uaGlnaD4+PjApLnRvTnVtYmVyKCkpfWlmKHQuc3RyaW5ncyl7aWYoIUFycmF5LmlzQXJyYXkodC5zdHJpbmdzKSl0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5BdHRyaWJ1dGVQcm90by5zdHJpbmdzOiBhcnJheSBleHBlY3RlZFwiKTtmb3IoZS5zdHJpbmdzPVtdLG49MDtuPHQuc3RyaW5ncy5sZW5ndGg7KytuKVwic3RyaW5nXCI9PXR5cGVvZiB0LnN0cmluZ3Nbbl0/Yy5iYXNlNjQuZGVjb2RlKHQuc3RyaW5nc1tuXSxlLnN0cmluZ3Nbbl09Yy5uZXdCdWZmZXIoYy5iYXNlNjQubGVuZ3RoKHQuc3RyaW5nc1tuXSkpLDApOnQuc3RyaW5nc1tuXS5sZW5ndGgmJihlLnN0cmluZ3Nbbl09dC5zdHJpbmdzW25dKX1pZih0LnRlbnNvcnMpe2lmKCFBcnJheS5pc0FycmF5KHQudGVuc29ycykpdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguQXR0cmlidXRlUHJvdG8udGVuc29yczogYXJyYXkgZXhwZWN0ZWRcIik7Zm9yKGUudGVuc29ycz1bXSxuPTA7bjx0LnRlbnNvcnMubGVuZ3RoOysrbil7aWYoXCJvYmplY3RcIiE9dHlwZW9mIHQudGVuc29yc1tuXSl0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5BdHRyaWJ1dGVQcm90by50ZW5zb3JzOiBvYmplY3QgZXhwZWN0ZWRcIik7ZS50ZW5zb3JzW25dPWwub25ueC5UZW5zb3JQcm90by5mcm9tT2JqZWN0KHQudGVuc29yc1tuXSl9fWlmKHQuZ3JhcGhzKXtpZighQXJyYXkuaXNBcnJheSh0LmdyYXBocykpdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguQXR0cmlidXRlUHJvdG8uZ3JhcGhzOiBhcnJheSBleHBlY3RlZFwiKTtmb3IoZS5ncmFwaHM9W10sbj0wO248dC5ncmFwaHMubGVuZ3RoOysrbil7aWYoXCJvYmplY3RcIiE9dHlwZW9mIHQuZ3JhcGhzW25dKXRocm93IFR5cGVFcnJvcihcIi5vbm54LkF0dHJpYnV0ZVByb3RvLmdyYXBoczogb2JqZWN0IGV4cGVjdGVkXCIpO2UuZ3JhcGhzW25dPWwub25ueC5HcmFwaFByb3RvLmZyb21PYmplY3QodC5ncmFwaHNbbl0pfX1yZXR1cm4gZX0sdC50b09iamVjdD1mdW5jdGlvbih0LGUpe2V8fChlPXt9KTt2YXIgbj17fTtpZigoZS5hcnJheXN8fGUuZGVmYXVsdHMpJiYobi5mbG9hdHM9W10sbi5pbnRzPVtdLG4uc3RyaW5ncz1bXSxuLnRlbnNvcnM9W10sbi5ncmFwaHM9W10pLGUuZGVmYXVsdHMpe2lmKG4ubmFtZT1cIlwiLG4uZj0wLGMuTG9uZyl7dmFyIHI9bmV3IGMuTG9uZygwLDAsITEpO24uaT1lLmxvbmdzPT09U3RyaW5nP3IudG9TdHJpbmcoKTplLmxvbmdzPT09TnVtYmVyP3IudG9OdW1iZXIoKTpyfWVsc2Ugbi5pPWUubG9uZ3M9PT1TdHJpbmc/XCIwXCI6MDtlLmJ5dGVzPT09U3RyaW5nP24ucz1cIlwiOihuLnM9W10sZS5ieXRlcyE9PUFycmF5JiYobi5zPWMubmV3QnVmZmVyKG4ucykpKSxuLnQ9bnVsbCxuLmc9bnVsbCxuLmRvY1N0cmluZz1cIlwiLG4udHlwZT1lLmVudW1zPT09U3RyaW5nP1wiVU5ERUZJTkVEXCI6MCxuLnJlZkF0dHJOYW1lPVwiXCJ9aWYobnVsbCE9dC5uYW1lJiZ0Lmhhc093blByb3BlcnR5KFwibmFtZVwiKSYmKG4ubmFtZT10Lm5hbWUpLG51bGwhPXQuZiYmdC5oYXNPd25Qcm9wZXJ0eShcImZcIikmJihuLmY9ZS5qc29uJiYhaXNGaW5pdGUodC5mKT9TdHJpbmcodC5mKTp0LmYpLG51bGwhPXQuaSYmdC5oYXNPd25Qcm9wZXJ0eShcImlcIikmJihcIm51bWJlclwiPT10eXBlb2YgdC5pP24uaT1lLmxvbmdzPT09U3RyaW5nP1N0cmluZyh0LmkpOnQuaTpuLmk9ZS5sb25ncz09PVN0cmluZz9jLkxvbmcucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodC5pKTplLmxvbmdzPT09TnVtYmVyP25ldyBjLkxvbmdCaXRzKHQuaS5sb3c+Pj4wLHQuaS5oaWdoPj4+MCkudG9OdW1iZXIoKTp0LmkpLG51bGwhPXQucyYmdC5oYXNPd25Qcm9wZXJ0eShcInNcIikmJihuLnM9ZS5ieXRlcz09PVN0cmluZz9jLmJhc2U2NC5lbmNvZGUodC5zLDAsdC5zLmxlbmd0aCk6ZS5ieXRlcz09PUFycmF5P0FycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHQucyk6dC5zKSxudWxsIT10LnQmJnQuaGFzT3duUHJvcGVydHkoXCJ0XCIpJiYobi50PWwub25ueC5UZW5zb3JQcm90by50b09iamVjdCh0LnQsZSkpLG51bGwhPXQuZyYmdC5oYXNPd25Qcm9wZXJ0eShcImdcIikmJihuLmc9bC5vbm54LkdyYXBoUHJvdG8udG9PYmplY3QodC5nLGUpKSx0LmZsb2F0cyYmdC5mbG9hdHMubGVuZ3RoKXtuLmZsb2F0cz1bXTtmb3IodmFyIGk9MDtpPHQuZmxvYXRzLmxlbmd0aDsrK2kpbi5mbG9hdHNbaV09ZS5qc29uJiYhaXNGaW5pdGUodC5mbG9hdHNbaV0pP1N0cmluZyh0LmZsb2F0c1tpXSk6dC5mbG9hdHNbaV19aWYodC5pbnRzJiZ0LmludHMubGVuZ3RoKWZvcihuLmludHM9W10saT0wO2k8dC5pbnRzLmxlbmd0aDsrK2kpXCJudW1iZXJcIj09dHlwZW9mIHQuaW50c1tpXT9uLmludHNbaV09ZS5sb25ncz09PVN0cmluZz9TdHJpbmcodC5pbnRzW2ldKTp0LmludHNbaV06bi5pbnRzW2ldPWUubG9uZ3M9PT1TdHJpbmc/Yy5Mb25nLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHQuaW50c1tpXSk6ZS5sb25ncz09PU51bWJlcj9uZXcgYy5Mb25nQml0cyh0LmludHNbaV0ubG93Pj4+MCx0LmludHNbaV0uaGlnaD4+PjApLnRvTnVtYmVyKCk6dC5pbnRzW2ldO2lmKHQuc3RyaW5ncyYmdC5zdHJpbmdzLmxlbmd0aClmb3Iobi5zdHJpbmdzPVtdLGk9MDtpPHQuc3RyaW5ncy5sZW5ndGg7KytpKW4uc3RyaW5nc1tpXT1lLmJ5dGVzPT09U3RyaW5nP2MuYmFzZTY0LmVuY29kZSh0LnN0cmluZ3NbaV0sMCx0LnN0cmluZ3NbaV0ubGVuZ3RoKTplLmJ5dGVzPT09QXJyYXk/QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodC5zdHJpbmdzW2ldKTp0LnN0cmluZ3NbaV07aWYodC50ZW5zb3JzJiZ0LnRlbnNvcnMubGVuZ3RoKWZvcihuLnRlbnNvcnM9W10saT0wO2k8dC50ZW5zb3JzLmxlbmd0aDsrK2kpbi50ZW5zb3JzW2ldPWwub25ueC5UZW5zb3JQcm90by50b09iamVjdCh0LnRlbnNvcnNbaV0sZSk7aWYodC5ncmFwaHMmJnQuZ3JhcGhzLmxlbmd0aClmb3Iobi5ncmFwaHM9W10saT0wO2k8dC5ncmFwaHMubGVuZ3RoOysraSluLmdyYXBoc1tpXT1sLm9ubnguR3JhcGhQcm90by50b09iamVjdCh0LmdyYXBoc1tpXSxlKTtyZXR1cm4gbnVsbCE9dC5kb2NTdHJpbmcmJnQuaGFzT3duUHJvcGVydHkoXCJkb2NTdHJpbmdcIikmJihuLmRvY1N0cmluZz10LmRvY1N0cmluZyksbnVsbCE9dC50eXBlJiZ0Lmhhc093blByb3BlcnR5KFwidHlwZVwiKSYmKG4udHlwZT1lLmVudW1zPT09U3RyaW5nP2wub25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlW3QudHlwZV06dC50eXBlKSxudWxsIT10LnJlZkF0dHJOYW1lJiZ0Lmhhc093blByb3BlcnR5KFwicmVmQXR0ck5hbWVcIikmJihuLnJlZkF0dHJOYW1lPXQucmVmQXR0ck5hbWUpLG59LHQucHJvdG90eXBlLnRvSlNPTj1mdW5jdGlvbigpe3JldHVybiB0aGlzLmNvbnN0cnVjdG9yLnRvT2JqZWN0KHRoaXMsYS51dGlsLnRvSlNPTk9wdGlvbnMpfSx0LkF0dHJpYnV0ZVR5cGU9ZnVuY3Rpb24oKXt2YXIgdD17fSxlPU9iamVjdC5jcmVhdGUodCk7cmV0dXJuIGVbdFswXT1cIlVOREVGSU5FRFwiXT0wLGVbdFsxXT1cIkZMT0FUXCJdPTEsZVt0WzJdPVwiSU5UXCJdPTIsZVt0WzNdPVwiU1RSSU5HXCJdPTMsZVt0WzRdPVwiVEVOU09SXCJdPTQsZVt0WzVdPVwiR1JBUEhcIl09NSxlW3RbNl09XCJGTE9BVFNcIl09NixlW3RbN109XCJJTlRTXCJdPTcsZVt0WzhdPVwiU1RSSU5HU1wiXT04LGVbdFs5XT1cIlRFTlNPUlNcIl09OSxlW3RbMTBdPVwiR1JBUEhTXCJdPTEwLGV9KCksdH0oKSxvLlZhbHVlSW5mb1Byb3RvPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0KXtpZih0KWZvcih2YXIgZT1PYmplY3Qua2V5cyh0KSxuPTA7bjxlLmxlbmd0aDsrK24pbnVsbCE9dFtlW25dXSYmKHRoaXNbZVtuXV09dFtlW25dXSl9cmV0dXJuIHQucHJvdG90eXBlLm5hbWU9XCJcIix0LnByb3RvdHlwZS50eXBlPW51bGwsdC5wcm90b3R5cGUuZG9jU3RyaW5nPVwiXCIsdC5jcmVhdGU9ZnVuY3Rpb24oZSl7cmV0dXJuIG5ldyB0KGUpfSx0LmVuY29kZT1mdW5jdGlvbih0LGUpe3JldHVybiBlfHwoZT11LmNyZWF0ZSgpKSxudWxsIT10Lm5hbWUmJnQuaGFzT3duUHJvcGVydHkoXCJuYW1lXCIpJiZlLnVpbnQzMigxMCkuc3RyaW5nKHQubmFtZSksbnVsbCE9dC50eXBlJiZ0Lmhhc093blByb3BlcnR5KFwidHlwZVwiKSYmbC5vbm54LlR5cGVQcm90by5lbmNvZGUodC50eXBlLGUudWludDMyKDE4KS5mb3JrKCkpLmxkZWxpbSgpLG51bGwhPXQuZG9jU3RyaW5nJiZ0Lmhhc093blByb3BlcnR5KFwiZG9jU3RyaW5nXCIpJiZlLnVpbnQzMigyNikuc3RyaW5nKHQuZG9jU3RyaW5nKSxlfSx0LmVuY29kZURlbGltaXRlZD1mdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLmVuY29kZSh0LGUpLmxkZWxpbSgpfSx0LmRlY29kZT1mdW5jdGlvbih0LGUpe3QgaW5zdGFuY2VvZiBzfHwodD1zLmNyZWF0ZSh0KSk7Zm9yKHZhciBuPXZvaWQgMD09PWU/dC5sZW46dC5wb3MrZSxyPW5ldyBsLm9ubnguVmFsdWVJbmZvUHJvdG87dC5wb3M8bjspe3ZhciBpPXQudWludDMyKCk7c3dpdGNoKGk+Pj4zKXtjYXNlIDE6ci5uYW1lPXQuc3RyaW5nKCk7YnJlYWs7Y2FzZSAyOnIudHlwZT1sLm9ubnguVHlwZVByb3RvLmRlY29kZSh0LHQudWludDMyKCkpO2JyZWFrO2Nhc2UgMzpyLmRvY1N0cmluZz10LnN0cmluZygpO2JyZWFrO2RlZmF1bHQ6dC5za2lwVHlwZSg3JmkpfX1yZXR1cm4gcn0sdC5kZWNvZGVEZWxpbWl0ZWQ9ZnVuY3Rpb24odCl7cmV0dXJuIHQgaW5zdGFuY2VvZiBzfHwodD1uZXcgcyh0KSksdGhpcy5kZWNvZGUodCx0LnVpbnQzMigpKX0sdC52ZXJpZnk9ZnVuY3Rpb24odCl7aWYoXCJvYmplY3RcIiE9dHlwZW9mIHR8fG51bGw9PT10KXJldHVyblwib2JqZWN0IGV4cGVjdGVkXCI7aWYobnVsbCE9dC5uYW1lJiZ0Lmhhc093blByb3BlcnR5KFwibmFtZVwiKSYmIWMuaXNTdHJpbmcodC5uYW1lKSlyZXR1cm5cIm5hbWU6IHN0cmluZyBleHBlY3RlZFwiO2lmKG51bGwhPXQudHlwZSYmdC5oYXNPd25Qcm9wZXJ0eShcInR5cGVcIikpe3ZhciBlPWwub25ueC5UeXBlUHJvdG8udmVyaWZ5KHQudHlwZSk7aWYoZSlyZXR1cm5cInR5cGUuXCIrZX1yZXR1cm4gbnVsbCE9dC5kb2NTdHJpbmcmJnQuaGFzT3duUHJvcGVydHkoXCJkb2NTdHJpbmdcIikmJiFjLmlzU3RyaW5nKHQuZG9jU3RyaW5nKT9cImRvY1N0cmluZzogc3RyaW5nIGV4cGVjdGVkXCI6bnVsbH0sdC5mcm9tT2JqZWN0PWZ1bmN0aW9uKHQpe2lmKHQgaW5zdGFuY2VvZiBsLm9ubnguVmFsdWVJbmZvUHJvdG8pcmV0dXJuIHQ7dmFyIGU9bmV3IGwub25ueC5WYWx1ZUluZm9Qcm90bztpZihudWxsIT10Lm5hbWUmJihlLm5hbWU9U3RyaW5nKHQubmFtZSkpLG51bGwhPXQudHlwZSl7aWYoXCJvYmplY3RcIiE9dHlwZW9mIHQudHlwZSl0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5WYWx1ZUluZm9Qcm90by50eXBlOiBvYmplY3QgZXhwZWN0ZWRcIik7ZS50eXBlPWwub25ueC5UeXBlUHJvdG8uZnJvbU9iamVjdCh0LnR5cGUpfXJldHVybiBudWxsIT10LmRvY1N0cmluZyYmKGUuZG9jU3RyaW5nPVN0cmluZyh0LmRvY1N0cmluZykpLGV9LHQudG9PYmplY3Q9ZnVuY3Rpb24odCxlKXtlfHwoZT17fSk7dmFyIG49e307cmV0dXJuIGUuZGVmYXVsdHMmJihuLm5hbWU9XCJcIixuLnR5cGU9bnVsbCxuLmRvY1N0cmluZz1cIlwiKSxudWxsIT10Lm5hbWUmJnQuaGFzT3duUHJvcGVydHkoXCJuYW1lXCIpJiYobi5uYW1lPXQubmFtZSksbnVsbCE9dC50eXBlJiZ0Lmhhc093blByb3BlcnR5KFwidHlwZVwiKSYmKG4udHlwZT1sLm9ubnguVHlwZVByb3RvLnRvT2JqZWN0KHQudHlwZSxlKSksbnVsbCE9dC5kb2NTdHJpbmcmJnQuaGFzT3duUHJvcGVydHkoXCJkb2NTdHJpbmdcIikmJihuLmRvY1N0cmluZz10LmRvY1N0cmluZyksbn0sdC5wcm90b3R5cGUudG9KU09OPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY29uc3RydWN0b3IudG9PYmplY3QodGhpcyxhLnV0aWwudG9KU09OT3B0aW9ucyl9LHR9KCksby5Ob2RlUHJvdG89ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQpe2lmKHRoaXMuaW5wdXQ9W10sdGhpcy5vdXRwdXQ9W10sdGhpcy5hdHRyaWJ1dGU9W10sdClmb3IodmFyIGU9T2JqZWN0LmtleXModCksbj0wO248ZS5sZW5ndGg7KytuKW51bGwhPXRbZVtuXV0mJih0aGlzW2Vbbl1dPXRbZVtuXV0pfXJldHVybiB0LnByb3RvdHlwZS5pbnB1dD1jLmVtcHR5QXJyYXksdC5wcm90b3R5cGUub3V0cHV0PWMuZW1wdHlBcnJheSx0LnByb3RvdHlwZS5uYW1lPVwiXCIsdC5wcm90b3R5cGUub3BUeXBlPVwiXCIsdC5wcm90b3R5cGUuZG9tYWluPVwiXCIsdC5wcm90b3R5cGUuYXR0cmlidXRlPWMuZW1wdHlBcnJheSx0LnByb3RvdHlwZS5kb2NTdHJpbmc9XCJcIix0LmNyZWF0ZT1mdW5jdGlvbihlKXtyZXR1cm4gbmV3IHQoZSl9LHQuZW5jb2RlPWZ1bmN0aW9uKHQsZSl7aWYoZXx8KGU9dS5jcmVhdGUoKSksbnVsbCE9dC5pbnB1dCYmdC5pbnB1dC5sZW5ndGgpZm9yKHZhciBuPTA7bjx0LmlucHV0Lmxlbmd0aDsrK24pZS51aW50MzIoMTApLnN0cmluZyh0LmlucHV0W25dKTtpZihudWxsIT10Lm91dHB1dCYmdC5vdXRwdXQubGVuZ3RoKWZvcihuPTA7bjx0Lm91dHB1dC5sZW5ndGg7KytuKWUudWludDMyKDE4KS5zdHJpbmcodC5vdXRwdXRbbl0pO2lmKG51bGwhPXQubmFtZSYmdC5oYXNPd25Qcm9wZXJ0eShcIm5hbWVcIikmJmUudWludDMyKDI2KS5zdHJpbmcodC5uYW1lKSxudWxsIT10Lm9wVHlwZSYmdC5oYXNPd25Qcm9wZXJ0eShcIm9wVHlwZVwiKSYmZS51aW50MzIoMzQpLnN0cmluZyh0Lm9wVHlwZSksbnVsbCE9dC5hdHRyaWJ1dGUmJnQuYXR0cmlidXRlLmxlbmd0aClmb3Iobj0wO248dC5hdHRyaWJ1dGUubGVuZ3RoOysrbilsLm9ubnguQXR0cmlidXRlUHJvdG8uZW5jb2RlKHQuYXR0cmlidXRlW25dLGUudWludDMyKDQyKS5mb3JrKCkpLmxkZWxpbSgpO3JldHVybiBudWxsIT10LmRvY1N0cmluZyYmdC5oYXNPd25Qcm9wZXJ0eShcImRvY1N0cmluZ1wiKSYmZS51aW50MzIoNTApLnN0cmluZyh0LmRvY1N0cmluZyksbnVsbCE9dC5kb21haW4mJnQuaGFzT3duUHJvcGVydHkoXCJkb21haW5cIikmJmUudWludDMyKDU4KS5zdHJpbmcodC5kb21haW4pLGV9LHQuZW5jb2RlRGVsaW1pdGVkPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMuZW5jb2RlKHQsZSkubGRlbGltKCl9LHQuZGVjb2RlPWZ1bmN0aW9uKHQsZSl7dCBpbnN0YW5jZW9mIHN8fCh0PXMuY3JlYXRlKHQpKTtmb3IodmFyIG49dm9pZCAwPT09ZT90Lmxlbjp0LnBvcytlLHI9bmV3IGwub25ueC5Ob2RlUHJvdG87dC5wb3M8bjspe3ZhciBpPXQudWludDMyKCk7c3dpdGNoKGk+Pj4zKXtjYXNlIDE6ci5pbnB1dCYmci5pbnB1dC5sZW5ndGh8fChyLmlucHV0PVtdKSxyLmlucHV0LnB1c2godC5zdHJpbmcoKSk7YnJlYWs7Y2FzZSAyOnIub3V0cHV0JiZyLm91dHB1dC5sZW5ndGh8fChyLm91dHB1dD1bXSksci5vdXRwdXQucHVzaCh0LnN0cmluZygpKTticmVhaztjYXNlIDM6ci5uYW1lPXQuc3RyaW5nKCk7YnJlYWs7Y2FzZSA0OnIub3BUeXBlPXQuc3RyaW5nKCk7YnJlYWs7Y2FzZSA3OnIuZG9tYWluPXQuc3RyaW5nKCk7YnJlYWs7Y2FzZSA1OnIuYXR0cmlidXRlJiZyLmF0dHJpYnV0ZS5sZW5ndGh8fChyLmF0dHJpYnV0ZT1bXSksci5hdHRyaWJ1dGUucHVzaChsLm9ubnguQXR0cmlidXRlUHJvdG8uZGVjb2RlKHQsdC51aW50MzIoKSkpO2JyZWFrO2Nhc2UgNjpyLmRvY1N0cmluZz10LnN0cmluZygpO2JyZWFrO2RlZmF1bHQ6dC5za2lwVHlwZSg3JmkpfX1yZXR1cm4gcn0sdC5kZWNvZGVEZWxpbWl0ZWQ9ZnVuY3Rpb24odCl7cmV0dXJuIHQgaW5zdGFuY2VvZiBzfHwodD1uZXcgcyh0KSksdGhpcy5kZWNvZGUodCx0LnVpbnQzMigpKX0sdC52ZXJpZnk9ZnVuY3Rpb24odCl7aWYoXCJvYmplY3RcIiE9dHlwZW9mIHR8fG51bGw9PT10KXJldHVyblwib2JqZWN0IGV4cGVjdGVkXCI7aWYobnVsbCE9dC5pbnB1dCYmdC5oYXNPd25Qcm9wZXJ0eShcImlucHV0XCIpKXtpZighQXJyYXkuaXNBcnJheSh0LmlucHV0KSlyZXR1cm5cImlucHV0OiBhcnJheSBleHBlY3RlZFwiO2Zvcih2YXIgZT0wO2U8dC5pbnB1dC5sZW5ndGg7KytlKWlmKCFjLmlzU3RyaW5nKHQuaW5wdXRbZV0pKXJldHVyblwiaW5wdXQ6IHN0cmluZ1tdIGV4cGVjdGVkXCJ9aWYobnVsbCE9dC5vdXRwdXQmJnQuaGFzT3duUHJvcGVydHkoXCJvdXRwdXRcIikpe2lmKCFBcnJheS5pc0FycmF5KHQub3V0cHV0KSlyZXR1cm5cIm91dHB1dDogYXJyYXkgZXhwZWN0ZWRcIjtmb3IoZT0wO2U8dC5vdXRwdXQubGVuZ3RoOysrZSlpZighYy5pc1N0cmluZyh0Lm91dHB1dFtlXSkpcmV0dXJuXCJvdXRwdXQ6IHN0cmluZ1tdIGV4cGVjdGVkXCJ9aWYobnVsbCE9dC5uYW1lJiZ0Lmhhc093blByb3BlcnR5KFwibmFtZVwiKSYmIWMuaXNTdHJpbmcodC5uYW1lKSlyZXR1cm5cIm5hbWU6IHN0cmluZyBleHBlY3RlZFwiO2lmKG51bGwhPXQub3BUeXBlJiZ0Lmhhc093blByb3BlcnR5KFwib3BUeXBlXCIpJiYhYy5pc1N0cmluZyh0Lm9wVHlwZSkpcmV0dXJuXCJvcFR5cGU6IHN0cmluZyBleHBlY3RlZFwiO2lmKG51bGwhPXQuZG9tYWluJiZ0Lmhhc093blByb3BlcnR5KFwiZG9tYWluXCIpJiYhYy5pc1N0cmluZyh0LmRvbWFpbikpcmV0dXJuXCJkb21haW46IHN0cmluZyBleHBlY3RlZFwiO2lmKG51bGwhPXQuYXR0cmlidXRlJiZ0Lmhhc093blByb3BlcnR5KFwiYXR0cmlidXRlXCIpKXtpZighQXJyYXkuaXNBcnJheSh0LmF0dHJpYnV0ZSkpcmV0dXJuXCJhdHRyaWJ1dGU6IGFycmF5IGV4cGVjdGVkXCI7Zm9yKGU9MDtlPHQuYXR0cmlidXRlLmxlbmd0aDsrK2Upe3ZhciBuPWwub25ueC5BdHRyaWJ1dGVQcm90by52ZXJpZnkodC5hdHRyaWJ1dGVbZV0pO2lmKG4pcmV0dXJuXCJhdHRyaWJ1dGUuXCIrbn19cmV0dXJuIG51bGwhPXQuZG9jU3RyaW5nJiZ0Lmhhc093blByb3BlcnR5KFwiZG9jU3RyaW5nXCIpJiYhYy5pc1N0cmluZyh0LmRvY1N0cmluZyk/XCJkb2NTdHJpbmc6IHN0cmluZyBleHBlY3RlZFwiOm51bGx9LHQuZnJvbU9iamVjdD1mdW5jdGlvbih0KXtpZih0IGluc3RhbmNlb2YgbC5vbm54Lk5vZGVQcm90bylyZXR1cm4gdDt2YXIgZT1uZXcgbC5vbm54Lk5vZGVQcm90bztpZih0LmlucHV0KXtpZighQXJyYXkuaXNBcnJheSh0LmlucHV0KSl0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5Ob2RlUHJvdG8uaW5wdXQ6IGFycmF5IGV4cGVjdGVkXCIpO2UuaW5wdXQ9W107Zm9yKHZhciBuPTA7bjx0LmlucHV0Lmxlbmd0aDsrK24pZS5pbnB1dFtuXT1TdHJpbmcodC5pbnB1dFtuXSl9aWYodC5vdXRwdXQpe2lmKCFBcnJheS5pc0FycmF5KHQub3V0cHV0KSl0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5Ob2RlUHJvdG8ub3V0cHV0OiBhcnJheSBleHBlY3RlZFwiKTtmb3IoZS5vdXRwdXQ9W10sbj0wO248dC5vdXRwdXQubGVuZ3RoOysrbillLm91dHB1dFtuXT1TdHJpbmcodC5vdXRwdXRbbl0pfWlmKG51bGwhPXQubmFtZSYmKGUubmFtZT1TdHJpbmcodC5uYW1lKSksbnVsbCE9dC5vcFR5cGUmJihlLm9wVHlwZT1TdHJpbmcodC5vcFR5cGUpKSxudWxsIT10LmRvbWFpbiYmKGUuZG9tYWluPVN0cmluZyh0LmRvbWFpbikpLHQuYXR0cmlidXRlKXtpZighQXJyYXkuaXNBcnJheSh0LmF0dHJpYnV0ZSkpdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguTm9kZVByb3RvLmF0dHJpYnV0ZTogYXJyYXkgZXhwZWN0ZWRcIik7Zm9yKGUuYXR0cmlidXRlPVtdLG49MDtuPHQuYXR0cmlidXRlLmxlbmd0aDsrK24pe2lmKFwib2JqZWN0XCIhPXR5cGVvZiB0LmF0dHJpYnV0ZVtuXSl0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5Ob2RlUHJvdG8uYXR0cmlidXRlOiBvYmplY3QgZXhwZWN0ZWRcIik7ZS5hdHRyaWJ1dGVbbl09bC5vbm54LkF0dHJpYnV0ZVByb3RvLmZyb21PYmplY3QodC5hdHRyaWJ1dGVbbl0pfX1yZXR1cm4gbnVsbCE9dC5kb2NTdHJpbmcmJihlLmRvY1N0cmluZz1TdHJpbmcodC5kb2NTdHJpbmcpKSxlfSx0LnRvT2JqZWN0PWZ1bmN0aW9uKHQsZSl7ZXx8KGU9e30pO3ZhciBuPXt9O2lmKChlLmFycmF5c3x8ZS5kZWZhdWx0cykmJihuLmlucHV0PVtdLG4ub3V0cHV0PVtdLG4uYXR0cmlidXRlPVtdKSxlLmRlZmF1bHRzJiYobi5uYW1lPVwiXCIsbi5vcFR5cGU9XCJcIixuLmRvY1N0cmluZz1cIlwiLG4uZG9tYWluPVwiXCIpLHQuaW5wdXQmJnQuaW5wdXQubGVuZ3RoKXtuLmlucHV0PVtdO2Zvcih2YXIgcj0wO3I8dC5pbnB1dC5sZW5ndGg7KytyKW4uaW5wdXRbcl09dC5pbnB1dFtyXX1pZih0Lm91dHB1dCYmdC5vdXRwdXQubGVuZ3RoKWZvcihuLm91dHB1dD1bXSxyPTA7cjx0Lm91dHB1dC5sZW5ndGg7KytyKW4ub3V0cHV0W3JdPXQub3V0cHV0W3JdO2lmKG51bGwhPXQubmFtZSYmdC5oYXNPd25Qcm9wZXJ0eShcIm5hbWVcIikmJihuLm5hbWU9dC5uYW1lKSxudWxsIT10Lm9wVHlwZSYmdC5oYXNPd25Qcm9wZXJ0eShcIm9wVHlwZVwiKSYmKG4ub3BUeXBlPXQub3BUeXBlKSx0LmF0dHJpYnV0ZSYmdC5hdHRyaWJ1dGUubGVuZ3RoKWZvcihuLmF0dHJpYnV0ZT1bXSxyPTA7cjx0LmF0dHJpYnV0ZS5sZW5ndGg7KytyKW4uYXR0cmlidXRlW3JdPWwub25ueC5BdHRyaWJ1dGVQcm90by50b09iamVjdCh0LmF0dHJpYnV0ZVtyXSxlKTtyZXR1cm4gbnVsbCE9dC5kb2NTdHJpbmcmJnQuaGFzT3duUHJvcGVydHkoXCJkb2NTdHJpbmdcIikmJihuLmRvY1N0cmluZz10LmRvY1N0cmluZyksbnVsbCE9dC5kb21haW4mJnQuaGFzT3duUHJvcGVydHkoXCJkb21haW5cIikmJihuLmRvbWFpbj10LmRvbWFpbiksbn0sdC5wcm90b3R5cGUudG9KU09OPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY29uc3RydWN0b3IudG9PYmplY3QodGhpcyxhLnV0aWwudG9KU09OT3B0aW9ucyl9LHR9KCksby5Nb2RlbFByb3RvPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0KXtpZih0aGlzLm9wc2V0SW1wb3J0PVtdLHRoaXMubWV0YWRhdGFQcm9wcz1bXSx0KWZvcih2YXIgZT1PYmplY3Qua2V5cyh0KSxuPTA7bjxlLmxlbmd0aDsrK24pbnVsbCE9dFtlW25dXSYmKHRoaXNbZVtuXV09dFtlW25dXSl9cmV0dXJuIHQucHJvdG90eXBlLmlyVmVyc2lvbj1jLkxvbmc/Yy5Mb25nLmZyb21CaXRzKDAsMCwhMSk6MCx0LnByb3RvdHlwZS5vcHNldEltcG9ydD1jLmVtcHR5QXJyYXksdC5wcm90b3R5cGUucHJvZHVjZXJOYW1lPVwiXCIsdC5wcm90b3R5cGUucHJvZHVjZXJWZXJzaW9uPVwiXCIsdC5wcm90b3R5cGUuZG9tYWluPVwiXCIsdC5wcm90b3R5cGUubW9kZWxWZXJzaW9uPWMuTG9uZz9jLkxvbmcuZnJvbUJpdHMoMCwwLCExKTowLHQucHJvdG90eXBlLmRvY1N0cmluZz1cIlwiLHQucHJvdG90eXBlLmdyYXBoPW51bGwsdC5wcm90b3R5cGUubWV0YWRhdGFQcm9wcz1jLmVtcHR5QXJyYXksdC5jcmVhdGU9ZnVuY3Rpb24oZSl7cmV0dXJuIG5ldyB0KGUpfSx0LmVuY29kZT1mdW5jdGlvbih0LGUpe2lmKGV8fChlPXUuY3JlYXRlKCkpLG51bGwhPXQuaXJWZXJzaW9uJiZ0Lmhhc093blByb3BlcnR5KFwiaXJWZXJzaW9uXCIpJiZlLnVpbnQzMig4KS5pbnQ2NCh0LmlyVmVyc2lvbiksbnVsbCE9dC5wcm9kdWNlck5hbWUmJnQuaGFzT3duUHJvcGVydHkoXCJwcm9kdWNlck5hbWVcIikmJmUudWludDMyKDE4KS5zdHJpbmcodC5wcm9kdWNlck5hbWUpLG51bGwhPXQucHJvZHVjZXJWZXJzaW9uJiZ0Lmhhc093blByb3BlcnR5KFwicHJvZHVjZXJWZXJzaW9uXCIpJiZlLnVpbnQzMigyNikuc3RyaW5nKHQucHJvZHVjZXJWZXJzaW9uKSxudWxsIT10LmRvbWFpbiYmdC5oYXNPd25Qcm9wZXJ0eShcImRvbWFpblwiKSYmZS51aW50MzIoMzQpLnN0cmluZyh0LmRvbWFpbiksbnVsbCE9dC5tb2RlbFZlcnNpb24mJnQuaGFzT3duUHJvcGVydHkoXCJtb2RlbFZlcnNpb25cIikmJmUudWludDMyKDQwKS5pbnQ2NCh0Lm1vZGVsVmVyc2lvbiksbnVsbCE9dC5kb2NTdHJpbmcmJnQuaGFzT3duUHJvcGVydHkoXCJkb2NTdHJpbmdcIikmJmUudWludDMyKDUwKS5zdHJpbmcodC5kb2NTdHJpbmcpLG51bGwhPXQuZ3JhcGgmJnQuaGFzT3duUHJvcGVydHkoXCJncmFwaFwiKSYmbC5vbm54LkdyYXBoUHJvdG8uZW5jb2RlKHQuZ3JhcGgsZS51aW50MzIoNTgpLmZvcmsoKSkubGRlbGltKCksbnVsbCE9dC5vcHNldEltcG9ydCYmdC5vcHNldEltcG9ydC5sZW5ndGgpZm9yKHZhciBuPTA7bjx0Lm9wc2V0SW1wb3J0Lmxlbmd0aDsrK24pbC5vbm54Lk9wZXJhdG9yU2V0SWRQcm90by5lbmNvZGUodC5vcHNldEltcG9ydFtuXSxlLnVpbnQzMig2NikuZm9yaygpKS5sZGVsaW0oKTtpZihudWxsIT10Lm1ldGFkYXRhUHJvcHMmJnQubWV0YWRhdGFQcm9wcy5sZW5ndGgpZm9yKG49MDtuPHQubWV0YWRhdGFQcm9wcy5sZW5ndGg7KytuKWwub25ueC5TdHJpbmdTdHJpbmdFbnRyeVByb3RvLmVuY29kZSh0Lm1ldGFkYXRhUHJvcHNbbl0sZS51aW50MzIoMTE0KS5mb3JrKCkpLmxkZWxpbSgpO3JldHVybiBlfSx0LmVuY29kZURlbGltaXRlZD1mdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLmVuY29kZSh0LGUpLmxkZWxpbSgpfSx0LmRlY29kZT1mdW5jdGlvbih0LGUpe3QgaW5zdGFuY2VvZiBzfHwodD1zLmNyZWF0ZSh0KSk7Zm9yKHZhciBuPXZvaWQgMD09PWU/dC5sZW46dC5wb3MrZSxyPW5ldyBsLm9ubnguTW9kZWxQcm90bzt0LnBvczxuOyl7dmFyIGk9dC51aW50MzIoKTtzd2l0Y2goaT4+PjMpe2Nhc2UgMTpyLmlyVmVyc2lvbj10LmludDY0KCk7YnJlYWs7Y2FzZSA4OnIub3BzZXRJbXBvcnQmJnIub3BzZXRJbXBvcnQubGVuZ3RofHwoci5vcHNldEltcG9ydD1bXSksci5vcHNldEltcG9ydC5wdXNoKGwub25ueC5PcGVyYXRvclNldElkUHJvdG8uZGVjb2RlKHQsdC51aW50MzIoKSkpO2JyZWFrO2Nhc2UgMjpyLnByb2R1Y2VyTmFtZT10LnN0cmluZygpO2JyZWFrO2Nhc2UgMzpyLnByb2R1Y2VyVmVyc2lvbj10LnN0cmluZygpO2JyZWFrO2Nhc2UgNDpyLmRvbWFpbj10LnN0cmluZygpO2JyZWFrO2Nhc2UgNTpyLm1vZGVsVmVyc2lvbj10LmludDY0KCk7YnJlYWs7Y2FzZSA2OnIuZG9jU3RyaW5nPXQuc3RyaW5nKCk7YnJlYWs7Y2FzZSA3OnIuZ3JhcGg9bC5vbm54LkdyYXBoUHJvdG8uZGVjb2RlKHQsdC51aW50MzIoKSk7YnJlYWs7Y2FzZSAxNDpyLm1ldGFkYXRhUHJvcHMmJnIubWV0YWRhdGFQcm9wcy5sZW5ndGh8fChyLm1ldGFkYXRhUHJvcHM9W10pLHIubWV0YWRhdGFQcm9wcy5wdXNoKGwub25ueC5TdHJpbmdTdHJpbmdFbnRyeVByb3RvLmRlY29kZSh0LHQudWludDMyKCkpKTticmVhaztkZWZhdWx0OnQuc2tpcFR5cGUoNyZpKX19cmV0dXJuIHJ9LHQuZGVjb2RlRGVsaW1pdGVkPWZ1bmN0aW9uKHQpe3JldHVybiB0IGluc3RhbmNlb2Ygc3x8KHQ9bmV3IHModCkpLHRoaXMuZGVjb2RlKHQsdC51aW50MzIoKSl9LHQudmVyaWZ5PWZ1bmN0aW9uKHQpe2lmKFwib2JqZWN0XCIhPXR5cGVvZiB0fHxudWxsPT09dClyZXR1cm5cIm9iamVjdCBleHBlY3RlZFwiO2lmKG51bGwhPXQuaXJWZXJzaW9uJiZ0Lmhhc093blByb3BlcnR5KFwiaXJWZXJzaW9uXCIpJiYhKGMuaXNJbnRlZ2VyKHQuaXJWZXJzaW9uKXx8dC5pclZlcnNpb24mJmMuaXNJbnRlZ2VyKHQuaXJWZXJzaW9uLmxvdykmJmMuaXNJbnRlZ2VyKHQuaXJWZXJzaW9uLmhpZ2gpKSlyZXR1cm5cImlyVmVyc2lvbjogaW50ZWdlcnxMb25nIGV4cGVjdGVkXCI7aWYobnVsbCE9dC5vcHNldEltcG9ydCYmdC5oYXNPd25Qcm9wZXJ0eShcIm9wc2V0SW1wb3J0XCIpKXtpZighQXJyYXkuaXNBcnJheSh0Lm9wc2V0SW1wb3J0KSlyZXR1cm5cIm9wc2V0SW1wb3J0OiBhcnJheSBleHBlY3RlZFwiO2Zvcih2YXIgZT0wO2U8dC5vcHNldEltcG9ydC5sZW5ndGg7KytlKWlmKG49bC5vbm54Lk9wZXJhdG9yU2V0SWRQcm90by52ZXJpZnkodC5vcHNldEltcG9ydFtlXSkpcmV0dXJuXCJvcHNldEltcG9ydC5cIitufWlmKG51bGwhPXQucHJvZHVjZXJOYW1lJiZ0Lmhhc093blByb3BlcnR5KFwicHJvZHVjZXJOYW1lXCIpJiYhYy5pc1N0cmluZyh0LnByb2R1Y2VyTmFtZSkpcmV0dXJuXCJwcm9kdWNlck5hbWU6IHN0cmluZyBleHBlY3RlZFwiO2lmKG51bGwhPXQucHJvZHVjZXJWZXJzaW9uJiZ0Lmhhc093blByb3BlcnR5KFwicHJvZHVjZXJWZXJzaW9uXCIpJiYhYy5pc1N0cmluZyh0LnByb2R1Y2VyVmVyc2lvbikpcmV0dXJuXCJwcm9kdWNlclZlcnNpb246IHN0cmluZyBleHBlY3RlZFwiO2lmKG51bGwhPXQuZG9tYWluJiZ0Lmhhc093blByb3BlcnR5KFwiZG9tYWluXCIpJiYhYy5pc1N0cmluZyh0LmRvbWFpbikpcmV0dXJuXCJkb21haW46IHN0cmluZyBleHBlY3RlZFwiO2lmKG51bGwhPXQubW9kZWxWZXJzaW9uJiZ0Lmhhc093blByb3BlcnR5KFwibW9kZWxWZXJzaW9uXCIpJiYhKGMuaXNJbnRlZ2VyKHQubW9kZWxWZXJzaW9uKXx8dC5tb2RlbFZlcnNpb24mJmMuaXNJbnRlZ2VyKHQubW9kZWxWZXJzaW9uLmxvdykmJmMuaXNJbnRlZ2VyKHQubW9kZWxWZXJzaW9uLmhpZ2gpKSlyZXR1cm5cIm1vZGVsVmVyc2lvbjogaW50ZWdlcnxMb25nIGV4cGVjdGVkXCI7aWYobnVsbCE9dC5kb2NTdHJpbmcmJnQuaGFzT3duUHJvcGVydHkoXCJkb2NTdHJpbmdcIikmJiFjLmlzU3RyaW5nKHQuZG9jU3RyaW5nKSlyZXR1cm5cImRvY1N0cmluZzogc3RyaW5nIGV4cGVjdGVkXCI7aWYobnVsbCE9dC5ncmFwaCYmdC5oYXNPd25Qcm9wZXJ0eShcImdyYXBoXCIpJiYobj1sLm9ubnguR3JhcGhQcm90by52ZXJpZnkodC5ncmFwaCkpKXJldHVyblwiZ3JhcGguXCIrbjtpZihudWxsIT10Lm1ldGFkYXRhUHJvcHMmJnQuaGFzT3duUHJvcGVydHkoXCJtZXRhZGF0YVByb3BzXCIpKXtpZighQXJyYXkuaXNBcnJheSh0Lm1ldGFkYXRhUHJvcHMpKXJldHVyblwibWV0YWRhdGFQcm9wczogYXJyYXkgZXhwZWN0ZWRcIjtmb3IoZT0wO2U8dC5tZXRhZGF0YVByb3BzLmxlbmd0aDsrK2Upe3ZhciBuO2lmKG49bC5vbm54LlN0cmluZ1N0cmluZ0VudHJ5UHJvdG8udmVyaWZ5KHQubWV0YWRhdGFQcm9wc1tlXSkpcmV0dXJuXCJtZXRhZGF0YVByb3BzLlwiK259fXJldHVybiBudWxsfSx0LmZyb21PYmplY3Q9ZnVuY3Rpb24odCl7aWYodCBpbnN0YW5jZW9mIGwub25ueC5Nb2RlbFByb3RvKXJldHVybiB0O3ZhciBlPW5ldyBsLm9ubnguTW9kZWxQcm90bztpZihudWxsIT10LmlyVmVyc2lvbiYmKGMuTG9uZz8oZS5pclZlcnNpb249Yy5Mb25nLmZyb21WYWx1ZSh0LmlyVmVyc2lvbikpLnVuc2lnbmVkPSExOlwic3RyaW5nXCI9PXR5cGVvZiB0LmlyVmVyc2lvbj9lLmlyVmVyc2lvbj1wYXJzZUludCh0LmlyVmVyc2lvbiwxMCk6XCJudW1iZXJcIj09dHlwZW9mIHQuaXJWZXJzaW9uP2UuaXJWZXJzaW9uPXQuaXJWZXJzaW9uOlwib2JqZWN0XCI9PXR5cGVvZiB0LmlyVmVyc2lvbiYmKGUuaXJWZXJzaW9uPW5ldyBjLkxvbmdCaXRzKHQuaXJWZXJzaW9uLmxvdz4+PjAsdC5pclZlcnNpb24uaGlnaD4+PjApLnRvTnVtYmVyKCkpKSx0Lm9wc2V0SW1wb3J0KXtpZighQXJyYXkuaXNBcnJheSh0Lm9wc2V0SW1wb3J0KSl0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5Nb2RlbFByb3RvLm9wc2V0SW1wb3J0OiBhcnJheSBleHBlY3RlZFwiKTtlLm9wc2V0SW1wb3J0PVtdO2Zvcih2YXIgbj0wO248dC5vcHNldEltcG9ydC5sZW5ndGg7KytuKXtpZihcIm9iamVjdFwiIT10eXBlb2YgdC5vcHNldEltcG9ydFtuXSl0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5Nb2RlbFByb3RvLm9wc2V0SW1wb3J0OiBvYmplY3QgZXhwZWN0ZWRcIik7ZS5vcHNldEltcG9ydFtuXT1sLm9ubnguT3BlcmF0b3JTZXRJZFByb3RvLmZyb21PYmplY3QodC5vcHNldEltcG9ydFtuXSl9fWlmKG51bGwhPXQucHJvZHVjZXJOYW1lJiYoZS5wcm9kdWNlck5hbWU9U3RyaW5nKHQucHJvZHVjZXJOYW1lKSksbnVsbCE9dC5wcm9kdWNlclZlcnNpb24mJihlLnByb2R1Y2VyVmVyc2lvbj1TdHJpbmcodC5wcm9kdWNlclZlcnNpb24pKSxudWxsIT10LmRvbWFpbiYmKGUuZG9tYWluPVN0cmluZyh0LmRvbWFpbikpLG51bGwhPXQubW9kZWxWZXJzaW9uJiYoYy5Mb25nPyhlLm1vZGVsVmVyc2lvbj1jLkxvbmcuZnJvbVZhbHVlKHQubW9kZWxWZXJzaW9uKSkudW5zaWduZWQ9ITE6XCJzdHJpbmdcIj09dHlwZW9mIHQubW9kZWxWZXJzaW9uP2UubW9kZWxWZXJzaW9uPXBhcnNlSW50KHQubW9kZWxWZXJzaW9uLDEwKTpcIm51bWJlclwiPT10eXBlb2YgdC5tb2RlbFZlcnNpb24/ZS5tb2RlbFZlcnNpb249dC5tb2RlbFZlcnNpb246XCJvYmplY3RcIj09dHlwZW9mIHQubW9kZWxWZXJzaW9uJiYoZS5tb2RlbFZlcnNpb249bmV3IGMuTG9uZ0JpdHModC5tb2RlbFZlcnNpb24ubG93Pj4+MCx0Lm1vZGVsVmVyc2lvbi5oaWdoPj4+MCkudG9OdW1iZXIoKSkpLG51bGwhPXQuZG9jU3RyaW5nJiYoZS5kb2NTdHJpbmc9U3RyaW5nKHQuZG9jU3RyaW5nKSksbnVsbCE9dC5ncmFwaCl7aWYoXCJvYmplY3RcIiE9dHlwZW9mIHQuZ3JhcGgpdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguTW9kZWxQcm90by5ncmFwaDogb2JqZWN0IGV4cGVjdGVkXCIpO2UuZ3JhcGg9bC5vbm54LkdyYXBoUHJvdG8uZnJvbU9iamVjdCh0LmdyYXBoKX1pZih0Lm1ldGFkYXRhUHJvcHMpe2lmKCFBcnJheS5pc0FycmF5KHQubWV0YWRhdGFQcm9wcykpdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguTW9kZWxQcm90by5tZXRhZGF0YVByb3BzOiBhcnJheSBleHBlY3RlZFwiKTtmb3IoZS5tZXRhZGF0YVByb3BzPVtdLG49MDtuPHQubWV0YWRhdGFQcm9wcy5sZW5ndGg7KytuKXtpZihcIm9iamVjdFwiIT10eXBlb2YgdC5tZXRhZGF0YVByb3BzW25dKXRocm93IFR5cGVFcnJvcihcIi5vbm54Lk1vZGVsUHJvdG8ubWV0YWRhdGFQcm9wczogb2JqZWN0IGV4cGVjdGVkXCIpO2UubWV0YWRhdGFQcm9wc1tuXT1sLm9ubnguU3RyaW5nU3RyaW5nRW50cnlQcm90by5mcm9tT2JqZWN0KHQubWV0YWRhdGFQcm9wc1tuXSl9fXJldHVybiBlfSx0LnRvT2JqZWN0PWZ1bmN0aW9uKHQsZSl7ZXx8KGU9e30pO3ZhciBuPXt9O2lmKChlLmFycmF5c3x8ZS5kZWZhdWx0cykmJihuLm9wc2V0SW1wb3J0PVtdLG4ubWV0YWRhdGFQcm9wcz1bXSksZS5kZWZhdWx0cyl7aWYoYy5Mb25nKXt2YXIgcj1uZXcgYy5Mb25nKDAsMCwhMSk7bi5pclZlcnNpb249ZS5sb25ncz09PVN0cmluZz9yLnRvU3RyaW5nKCk6ZS5sb25ncz09PU51bWJlcj9yLnRvTnVtYmVyKCk6cn1lbHNlIG4uaXJWZXJzaW9uPWUubG9uZ3M9PT1TdHJpbmc/XCIwXCI6MDtuLnByb2R1Y2VyTmFtZT1cIlwiLG4ucHJvZHVjZXJWZXJzaW9uPVwiXCIsbi5kb21haW49XCJcIixjLkxvbmc/KHI9bmV3IGMuTG9uZygwLDAsITEpLG4ubW9kZWxWZXJzaW9uPWUubG9uZ3M9PT1TdHJpbmc/ci50b1N0cmluZygpOmUubG9uZ3M9PT1OdW1iZXI/ci50b051bWJlcigpOnIpOm4ubW9kZWxWZXJzaW9uPWUubG9uZ3M9PT1TdHJpbmc/XCIwXCI6MCxuLmRvY1N0cmluZz1cIlwiLG4uZ3JhcGg9bnVsbH1pZihudWxsIT10LmlyVmVyc2lvbiYmdC5oYXNPd25Qcm9wZXJ0eShcImlyVmVyc2lvblwiKSYmKFwibnVtYmVyXCI9PXR5cGVvZiB0LmlyVmVyc2lvbj9uLmlyVmVyc2lvbj1lLmxvbmdzPT09U3RyaW5nP1N0cmluZyh0LmlyVmVyc2lvbik6dC5pclZlcnNpb246bi5pclZlcnNpb249ZS5sb25ncz09PVN0cmluZz9jLkxvbmcucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodC5pclZlcnNpb24pOmUubG9uZ3M9PT1OdW1iZXI/bmV3IGMuTG9uZ0JpdHModC5pclZlcnNpb24ubG93Pj4+MCx0LmlyVmVyc2lvbi5oaWdoPj4+MCkudG9OdW1iZXIoKTp0LmlyVmVyc2lvbiksbnVsbCE9dC5wcm9kdWNlck5hbWUmJnQuaGFzT3duUHJvcGVydHkoXCJwcm9kdWNlck5hbWVcIikmJihuLnByb2R1Y2VyTmFtZT10LnByb2R1Y2VyTmFtZSksbnVsbCE9dC5wcm9kdWNlclZlcnNpb24mJnQuaGFzT3duUHJvcGVydHkoXCJwcm9kdWNlclZlcnNpb25cIikmJihuLnByb2R1Y2VyVmVyc2lvbj10LnByb2R1Y2VyVmVyc2lvbiksbnVsbCE9dC5kb21haW4mJnQuaGFzT3duUHJvcGVydHkoXCJkb21haW5cIikmJihuLmRvbWFpbj10LmRvbWFpbiksbnVsbCE9dC5tb2RlbFZlcnNpb24mJnQuaGFzT3duUHJvcGVydHkoXCJtb2RlbFZlcnNpb25cIikmJihcIm51bWJlclwiPT10eXBlb2YgdC5tb2RlbFZlcnNpb24/bi5tb2RlbFZlcnNpb249ZS5sb25ncz09PVN0cmluZz9TdHJpbmcodC5tb2RlbFZlcnNpb24pOnQubW9kZWxWZXJzaW9uOm4ubW9kZWxWZXJzaW9uPWUubG9uZ3M9PT1TdHJpbmc/Yy5Mb25nLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHQubW9kZWxWZXJzaW9uKTplLmxvbmdzPT09TnVtYmVyP25ldyBjLkxvbmdCaXRzKHQubW9kZWxWZXJzaW9uLmxvdz4+PjAsdC5tb2RlbFZlcnNpb24uaGlnaD4+PjApLnRvTnVtYmVyKCk6dC5tb2RlbFZlcnNpb24pLG51bGwhPXQuZG9jU3RyaW5nJiZ0Lmhhc093blByb3BlcnR5KFwiZG9jU3RyaW5nXCIpJiYobi5kb2NTdHJpbmc9dC5kb2NTdHJpbmcpLG51bGwhPXQuZ3JhcGgmJnQuaGFzT3duUHJvcGVydHkoXCJncmFwaFwiKSYmKG4uZ3JhcGg9bC5vbm54LkdyYXBoUHJvdG8udG9PYmplY3QodC5ncmFwaCxlKSksdC5vcHNldEltcG9ydCYmdC5vcHNldEltcG9ydC5sZW5ndGgpe24ub3BzZXRJbXBvcnQ9W107Zm9yKHZhciBpPTA7aTx0Lm9wc2V0SW1wb3J0Lmxlbmd0aDsrK2kpbi5vcHNldEltcG9ydFtpXT1sLm9ubnguT3BlcmF0b3JTZXRJZFByb3RvLnRvT2JqZWN0KHQub3BzZXRJbXBvcnRbaV0sZSl9aWYodC5tZXRhZGF0YVByb3BzJiZ0Lm1ldGFkYXRhUHJvcHMubGVuZ3RoKWZvcihuLm1ldGFkYXRhUHJvcHM9W10saT0wO2k8dC5tZXRhZGF0YVByb3BzLmxlbmd0aDsrK2kpbi5tZXRhZGF0YVByb3BzW2ldPWwub25ueC5TdHJpbmdTdHJpbmdFbnRyeVByb3RvLnRvT2JqZWN0KHQubWV0YWRhdGFQcm9wc1tpXSxlKTtyZXR1cm4gbn0sdC5wcm90b3R5cGUudG9KU09OPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY29uc3RydWN0b3IudG9PYmplY3QodGhpcyxhLnV0aWwudG9KU09OT3B0aW9ucyl9LHR9KCksby5TdHJpbmdTdHJpbmdFbnRyeVByb3RvPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0KXtpZih0KWZvcih2YXIgZT1PYmplY3Qua2V5cyh0KSxuPTA7bjxlLmxlbmd0aDsrK24pbnVsbCE9dFtlW25dXSYmKHRoaXNbZVtuXV09dFtlW25dXSl9cmV0dXJuIHQucHJvdG90eXBlLmtleT1cIlwiLHQucHJvdG90eXBlLnZhbHVlPVwiXCIsdC5jcmVhdGU9ZnVuY3Rpb24oZSl7cmV0dXJuIG5ldyB0KGUpfSx0LmVuY29kZT1mdW5jdGlvbih0LGUpe3JldHVybiBlfHwoZT11LmNyZWF0ZSgpKSxudWxsIT10LmtleSYmdC5oYXNPd25Qcm9wZXJ0eShcImtleVwiKSYmZS51aW50MzIoMTApLnN0cmluZyh0LmtleSksbnVsbCE9dC52YWx1ZSYmdC5oYXNPd25Qcm9wZXJ0eShcInZhbHVlXCIpJiZlLnVpbnQzMigxOCkuc3RyaW5nKHQudmFsdWUpLGV9LHQuZW5jb2RlRGVsaW1pdGVkPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMuZW5jb2RlKHQsZSkubGRlbGltKCl9LHQuZGVjb2RlPWZ1bmN0aW9uKHQsZSl7dCBpbnN0YW5jZW9mIHN8fCh0PXMuY3JlYXRlKHQpKTtmb3IodmFyIG49dm9pZCAwPT09ZT90Lmxlbjp0LnBvcytlLHI9bmV3IGwub25ueC5TdHJpbmdTdHJpbmdFbnRyeVByb3RvO3QucG9zPG47KXt2YXIgaT10LnVpbnQzMigpO3N3aXRjaChpPj4+Myl7Y2FzZSAxOnIua2V5PXQuc3RyaW5nKCk7YnJlYWs7Y2FzZSAyOnIudmFsdWU9dC5zdHJpbmcoKTticmVhaztkZWZhdWx0OnQuc2tpcFR5cGUoNyZpKX19cmV0dXJuIHJ9LHQuZGVjb2RlRGVsaW1pdGVkPWZ1bmN0aW9uKHQpe3JldHVybiB0IGluc3RhbmNlb2Ygc3x8KHQ9bmV3IHModCkpLHRoaXMuZGVjb2RlKHQsdC51aW50MzIoKSl9LHQudmVyaWZ5PWZ1bmN0aW9uKHQpe3JldHVyblwib2JqZWN0XCIhPXR5cGVvZiB0fHxudWxsPT09dD9cIm9iamVjdCBleHBlY3RlZFwiOm51bGwhPXQua2V5JiZ0Lmhhc093blByb3BlcnR5KFwia2V5XCIpJiYhYy5pc1N0cmluZyh0LmtleSk/XCJrZXk6IHN0cmluZyBleHBlY3RlZFwiOm51bGwhPXQudmFsdWUmJnQuaGFzT3duUHJvcGVydHkoXCJ2YWx1ZVwiKSYmIWMuaXNTdHJpbmcodC52YWx1ZSk/XCJ2YWx1ZTogc3RyaW5nIGV4cGVjdGVkXCI6bnVsbH0sdC5mcm9tT2JqZWN0PWZ1bmN0aW9uKHQpe2lmKHQgaW5zdGFuY2VvZiBsLm9ubnguU3RyaW5nU3RyaW5nRW50cnlQcm90bylyZXR1cm4gdDt2YXIgZT1uZXcgbC5vbm54LlN0cmluZ1N0cmluZ0VudHJ5UHJvdG87cmV0dXJuIG51bGwhPXQua2V5JiYoZS5rZXk9U3RyaW5nKHQua2V5KSksbnVsbCE9dC52YWx1ZSYmKGUudmFsdWU9U3RyaW5nKHQudmFsdWUpKSxlfSx0LnRvT2JqZWN0PWZ1bmN0aW9uKHQsZSl7ZXx8KGU9e30pO3ZhciBuPXt9O3JldHVybiBlLmRlZmF1bHRzJiYobi5rZXk9XCJcIixuLnZhbHVlPVwiXCIpLG51bGwhPXQua2V5JiZ0Lmhhc093blByb3BlcnR5KFwia2V5XCIpJiYobi5rZXk9dC5rZXkpLG51bGwhPXQudmFsdWUmJnQuaGFzT3duUHJvcGVydHkoXCJ2YWx1ZVwiKSYmKG4udmFsdWU9dC52YWx1ZSksbn0sdC5wcm90b3R5cGUudG9KU09OPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY29uc3RydWN0b3IudG9PYmplY3QodGhpcyxhLnV0aWwudG9KU09OT3B0aW9ucyl9LHR9KCksby5UZW5zb3JBbm5vdGF0aW9uPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0KXtpZih0aGlzLnF1YW50UGFyYW1ldGVyVGVuc29yTmFtZXM9W10sdClmb3IodmFyIGU9T2JqZWN0LmtleXModCksbj0wO248ZS5sZW5ndGg7KytuKW51bGwhPXRbZVtuXV0mJih0aGlzW2Vbbl1dPXRbZVtuXV0pfXJldHVybiB0LnByb3RvdHlwZS50ZW5zb3JOYW1lPVwiXCIsdC5wcm90b3R5cGUucXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lcz1jLmVtcHR5QXJyYXksdC5jcmVhdGU9ZnVuY3Rpb24oZSl7cmV0dXJuIG5ldyB0KGUpfSx0LmVuY29kZT1mdW5jdGlvbih0LGUpe2lmKGV8fChlPXUuY3JlYXRlKCkpLG51bGwhPXQudGVuc29yTmFtZSYmdC5oYXNPd25Qcm9wZXJ0eShcInRlbnNvck5hbWVcIikmJmUudWludDMyKDEwKS5zdHJpbmcodC50ZW5zb3JOYW1lKSxudWxsIT10LnF1YW50UGFyYW1ldGVyVGVuc29yTmFtZXMmJnQucXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lcy5sZW5ndGgpZm9yKHZhciBuPTA7bjx0LnF1YW50UGFyYW1ldGVyVGVuc29yTmFtZXMubGVuZ3RoOysrbilsLm9ubnguU3RyaW5nU3RyaW5nRW50cnlQcm90by5lbmNvZGUodC5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzW25dLGUudWludDMyKDE4KS5mb3JrKCkpLmxkZWxpbSgpO3JldHVybiBlfSx0LmVuY29kZURlbGltaXRlZD1mdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLmVuY29kZSh0LGUpLmxkZWxpbSgpfSx0LmRlY29kZT1mdW5jdGlvbih0LGUpe3QgaW5zdGFuY2VvZiBzfHwodD1zLmNyZWF0ZSh0KSk7Zm9yKHZhciBuPXZvaWQgMD09PWU/dC5sZW46dC5wb3MrZSxyPW5ldyBsLm9ubnguVGVuc29yQW5ub3RhdGlvbjt0LnBvczxuOyl7dmFyIGk9dC51aW50MzIoKTtzd2l0Y2goaT4+PjMpe2Nhc2UgMTpyLnRlbnNvck5hbWU9dC5zdHJpbmcoKTticmVhaztjYXNlIDI6ci5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzJiZyLnF1YW50UGFyYW1ldGVyVGVuc29yTmFtZXMubGVuZ3RofHwoci5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzPVtdKSxyLnF1YW50UGFyYW1ldGVyVGVuc29yTmFtZXMucHVzaChsLm9ubnguU3RyaW5nU3RyaW5nRW50cnlQcm90by5kZWNvZGUodCx0LnVpbnQzMigpKSk7YnJlYWs7ZGVmYXVsdDp0LnNraXBUeXBlKDcmaSl9fXJldHVybiByfSx0LmRlY29kZURlbGltaXRlZD1mdW5jdGlvbih0KXtyZXR1cm4gdCBpbnN0YW5jZW9mIHN8fCh0PW5ldyBzKHQpKSx0aGlzLmRlY29kZSh0LHQudWludDMyKCkpfSx0LnZlcmlmeT1mdW5jdGlvbih0KXtpZihcIm9iamVjdFwiIT10eXBlb2YgdHx8bnVsbD09PXQpcmV0dXJuXCJvYmplY3QgZXhwZWN0ZWRcIjtpZihudWxsIT10LnRlbnNvck5hbWUmJnQuaGFzT3duUHJvcGVydHkoXCJ0ZW5zb3JOYW1lXCIpJiYhYy5pc1N0cmluZyh0LnRlbnNvck5hbWUpKXJldHVyblwidGVuc29yTmFtZTogc3RyaW5nIGV4cGVjdGVkXCI7aWYobnVsbCE9dC5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzJiZ0Lmhhc093blByb3BlcnR5KFwicXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lc1wiKSl7aWYoIUFycmF5LmlzQXJyYXkodC5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzKSlyZXR1cm5cInF1YW50UGFyYW1ldGVyVGVuc29yTmFtZXM6IGFycmF5IGV4cGVjdGVkXCI7Zm9yKHZhciBlPTA7ZTx0LnF1YW50UGFyYW1ldGVyVGVuc29yTmFtZXMubGVuZ3RoOysrZSl7dmFyIG49bC5vbm54LlN0cmluZ1N0cmluZ0VudHJ5UHJvdG8udmVyaWZ5KHQucXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lc1tlXSk7aWYobilyZXR1cm5cInF1YW50UGFyYW1ldGVyVGVuc29yTmFtZXMuXCIrbn19cmV0dXJuIG51bGx9LHQuZnJvbU9iamVjdD1mdW5jdGlvbih0KXtpZih0IGluc3RhbmNlb2YgbC5vbm54LlRlbnNvckFubm90YXRpb24pcmV0dXJuIHQ7dmFyIGU9bmV3IGwub25ueC5UZW5zb3JBbm5vdGF0aW9uO2lmKG51bGwhPXQudGVuc29yTmFtZSYmKGUudGVuc29yTmFtZT1TdHJpbmcodC50ZW5zb3JOYW1lKSksdC5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzKXtpZighQXJyYXkuaXNBcnJheSh0LnF1YW50UGFyYW1ldGVyVGVuc29yTmFtZXMpKXRocm93IFR5cGVFcnJvcihcIi5vbm54LlRlbnNvckFubm90YXRpb24ucXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lczogYXJyYXkgZXhwZWN0ZWRcIik7ZS5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzPVtdO2Zvcih2YXIgbj0wO248dC5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzLmxlbmd0aDsrK24pe2lmKFwib2JqZWN0XCIhPXR5cGVvZiB0LnF1YW50UGFyYW1ldGVyVGVuc29yTmFtZXNbbl0pdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguVGVuc29yQW5ub3RhdGlvbi5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzOiBvYmplY3QgZXhwZWN0ZWRcIik7ZS5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzW25dPWwub25ueC5TdHJpbmdTdHJpbmdFbnRyeVByb3RvLmZyb21PYmplY3QodC5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzW25dKX19cmV0dXJuIGV9LHQudG9PYmplY3Q9ZnVuY3Rpb24odCxlKXtlfHwoZT17fSk7dmFyIG49e307aWYoKGUuYXJyYXlzfHxlLmRlZmF1bHRzKSYmKG4ucXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lcz1bXSksZS5kZWZhdWx0cyYmKG4udGVuc29yTmFtZT1cIlwiKSxudWxsIT10LnRlbnNvck5hbWUmJnQuaGFzT3duUHJvcGVydHkoXCJ0ZW5zb3JOYW1lXCIpJiYobi50ZW5zb3JOYW1lPXQudGVuc29yTmFtZSksdC5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzJiZ0LnF1YW50UGFyYW1ldGVyVGVuc29yTmFtZXMubGVuZ3RoKXtuLnF1YW50UGFyYW1ldGVyVGVuc29yTmFtZXM9W107Zm9yKHZhciByPTA7cjx0LnF1YW50UGFyYW1ldGVyVGVuc29yTmFtZXMubGVuZ3RoOysrciluLnF1YW50UGFyYW1ldGVyVGVuc29yTmFtZXNbcl09bC5vbm54LlN0cmluZ1N0cmluZ0VudHJ5UHJvdG8udG9PYmplY3QodC5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzW3JdLGUpfXJldHVybiBufSx0LnByb3RvdHlwZS50b0pTT049ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci50b09iamVjdCh0aGlzLGEudXRpbC50b0pTT05PcHRpb25zKX0sdH0oKSxvLkdyYXBoUHJvdG89ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQpe2lmKHRoaXMubm9kZT1bXSx0aGlzLmluaXRpYWxpemVyPVtdLHRoaXMuaW5wdXQ9W10sdGhpcy5vdXRwdXQ9W10sdGhpcy52YWx1ZUluZm89W10sdGhpcy5xdWFudGl6YXRpb25Bbm5vdGF0aW9uPVtdLHQpZm9yKHZhciBlPU9iamVjdC5rZXlzKHQpLG49MDtuPGUubGVuZ3RoOysrbiludWxsIT10W2Vbbl1dJiYodGhpc1tlW25dXT10W2Vbbl1dKX1yZXR1cm4gdC5wcm90b3R5cGUubm9kZT1jLmVtcHR5QXJyYXksdC5wcm90b3R5cGUubmFtZT1cIlwiLHQucHJvdG90eXBlLmluaXRpYWxpemVyPWMuZW1wdHlBcnJheSx0LnByb3RvdHlwZS5kb2NTdHJpbmc9XCJcIix0LnByb3RvdHlwZS5pbnB1dD1jLmVtcHR5QXJyYXksdC5wcm90b3R5cGUub3V0cHV0PWMuZW1wdHlBcnJheSx0LnByb3RvdHlwZS52YWx1ZUluZm89Yy5lbXB0eUFycmF5LHQucHJvdG90eXBlLnF1YW50aXphdGlvbkFubm90YXRpb249Yy5lbXB0eUFycmF5LHQuY3JlYXRlPWZ1bmN0aW9uKGUpe3JldHVybiBuZXcgdChlKX0sdC5lbmNvZGU9ZnVuY3Rpb24odCxlKXtpZihlfHwoZT11LmNyZWF0ZSgpKSxudWxsIT10Lm5vZGUmJnQubm9kZS5sZW5ndGgpZm9yKHZhciBuPTA7bjx0Lm5vZGUubGVuZ3RoOysrbilsLm9ubnguTm9kZVByb3RvLmVuY29kZSh0Lm5vZGVbbl0sZS51aW50MzIoMTApLmZvcmsoKSkubGRlbGltKCk7aWYobnVsbCE9dC5uYW1lJiZ0Lmhhc093blByb3BlcnR5KFwibmFtZVwiKSYmZS51aW50MzIoMTgpLnN0cmluZyh0Lm5hbWUpLG51bGwhPXQuaW5pdGlhbGl6ZXImJnQuaW5pdGlhbGl6ZXIubGVuZ3RoKWZvcihuPTA7bjx0LmluaXRpYWxpemVyLmxlbmd0aDsrK24pbC5vbm54LlRlbnNvclByb3RvLmVuY29kZSh0LmluaXRpYWxpemVyW25dLGUudWludDMyKDQyKS5mb3JrKCkpLmxkZWxpbSgpO2lmKG51bGwhPXQuZG9jU3RyaW5nJiZ0Lmhhc093blByb3BlcnR5KFwiZG9jU3RyaW5nXCIpJiZlLnVpbnQzMig4Mikuc3RyaW5nKHQuZG9jU3RyaW5nKSxudWxsIT10LmlucHV0JiZ0LmlucHV0Lmxlbmd0aClmb3Iobj0wO248dC5pbnB1dC5sZW5ndGg7KytuKWwub25ueC5WYWx1ZUluZm9Qcm90by5lbmNvZGUodC5pbnB1dFtuXSxlLnVpbnQzMig5MCkuZm9yaygpKS5sZGVsaW0oKTtpZihudWxsIT10Lm91dHB1dCYmdC5vdXRwdXQubGVuZ3RoKWZvcihuPTA7bjx0Lm91dHB1dC5sZW5ndGg7KytuKWwub25ueC5WYWx1ZUluZm9Qcm90by5lbmNvZGUodC5vdXRwdXRbbl0sZS51aW50MzIoOTgpLmZvcmsoKSkubGRlbGltKCk7aWYobnVsbCE9dC52YWx1ZUluZm8mJnQudmFsdWVJbmZvLmxlbmd0aClmb3Iobj0wO248dC52YWx1ZUluZm8ubGVuZ3RoOysrbilsLm9ubnguVmFsdWVJbmZvUHJvdG8uZW5jb2RlKHQudmFsdWVJbmZvW25dLGUudWludDMyKDEwNikuZm9yaygpKS5sZGVsaW0oKTtpZihudWxsIT10LnF1YW50aXphdGlvbkFubm90YXRpb24mJnQucXVhbnRpemF0aW9uQW5ub3RhdGlvbi5sZW5ndGgpZm9yKG49MDtuPHQucXVhbnRpemF0aW9uQW5ub3RhdGlvbi5sZW5ndGg7KytuKWwub25ueC5UZW5zb3JBbm5vdGF0aW9uLmVuY29kZSh0LnF1YW50aXphdGlvbkFubm90YXRpb25bbl0sZS51aW50MzIoMTE0KS5mb3JrKCkpLmxkZWxpbSgpO3JldHVybiBlfSx0LmVuY29kZURlbGltaXRlZD1mdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLmVuY29kZSh0LGUpLmxkZWxpbSgpfSx0LmRlY29kZT1mdW5jdGlvbih0LGUpe3QgaW5zdGFuY2VvZiBzfHwodD1zLmNyZWF0ZSh0KSk7Zm9yKHZhciBuPXZvaWQgMD09PWU/dC5sZW46dC5wb3MrZSxyPW5ldyBsLm9ubnguR3JhcGhQcm90bzt0LnBvczxuOyl7dmFyIGk9dC51aW50MzIoKTtzd2l0Y2goaT4+PjMpe2Nhc2UgMTpyLm5vZGUmJnIubm9kZS5sZW5ndGh8fChyLm5vZGU9W10pLHIubm9kZS5wdXNoKGwub25ueC5Ob2RlUHJvdG8uZGVjb2RlKHQsdC51aW50MzIoKSkpO2JyZWFrO2Nhc2UgMjpyLm5hbWU9dC5zdHJpbmcoKTticmVhaztjYXNlIDU6ci5pbml0aWFsaXplciYmci5pbml0aWFsaXplci5sZW5ndGh8fChyLmluaXRpYWxpemVyPVtdKSxyLmluaXRpYWxpemVyLnB1c2gobC5vbm54LlRlbnNvclByb3RvLmRlY29kZSh0LHQudWludDMyKCkpKTticmVhaztjYXNlIDEwOnIuZG9jU3RyaW5nPXQuc3RyaW5nKCk7YnJlYWs7Y2FzZSAxMTpyLmlucHV0JiZyLmlucHV0Lmxlbmd0aHx8KHIuaW5wdXQ9W10pLHIuaW5wdXQucHVzaChsLm9ubnguVmFsdWVJbmZvUHJvdG8uZGVjb2RlKHQsdC51aW50MzIoKSkpO2JyZWFrO2Nhc2UgMTI6ci5vdXRwdXQmJnIub3V0cHV0Lmxlbmd0aHx8KHIub3V0cHV0PVtdKSxyLm91dHB1dC5wdXNoKGwub25ueC5WYWx1ZUluZm9Qcm90by5kZWNvZGUodCx0LnVpbnQzMigpKSk7YnJlYWs7Y2FzZSAxMzpyLnZhbHVlSW5mbyYmci52YWx1ZUluZm8ubGVuZ3RofHwoci52YWx1ZUluZm89W10pLHIudmFsdWVJbmZvLnB1c2gobC5vbm54LlZhbHVlSW5mb1Byb3RvLmRlY29kZSh0LHQudWludDMyKCkpKTticmVhaztjYXNlIDE0OnIucXVhbnRpemF0aW9uQW5ub3RhdGlvbiYmci5xdWFudGl6YXRpb25Bbm5vdGF0aW9uLmxlbmd0aHx8KHIucXVhbnRpemF0aW9uQW5ub3RhdGlvbj1bXSksci5xdWFudGl6YXRpb25Bbm5vdGF0aW9uLnB1c2gobC5vbm54LlRlbnNvckFubm90YXRpb24uZGVjb2RlKHQsdC51aW50MzIoKSkpO2JyZWFrO2RlZmF1bHQ6dC5za2lwVHlwZSg3JmkpfX1yZXR1cm4gcn0sdC5kZWNvZGVEZWxpbWl0ZWQ9ZnVuY3Rpb24odCl7cmV0dXJuIHQgaW5zdGFuY2VvZiBzfHwodD1uZXcgcyh0KSksdGhpcy5kZWNvZGUodCx0LnVpbnQzMigpKX0sdC52ZXJpZnk9ZnVuY3Rpb24odCl7aWYoXCJvYmplY3RcIiE9dHlwZW9mIHR8fG51bGw9PT10KXJldHVyblwib2JqZWN0IGV4cGVjdGVkXCI7aWYobnVsbCE9dC5ub2RlJiZ0Lmhhc093blByb3BlcnR5KFwibm9kZVwiKSl7aWYoIUFycmF5LmlzQXJyYXkodC5ub2RlKSlyZXR1cm5cIm5vZGU6IGFycmF5IGV4cGVjdGVkXCI7Zm9yKHZhciBlPTA7ZTx0Lm5vZGUubGVuZ3RoOysrZSlpZihuPWwub25ueC5Ob2RlUHJvdG8udmVyaWZ5KHQubm9kZVtlXSkpcmV0dXJuXCJub2RlLlwiK259aWYobnVsbCE9dC5uYW1lJiZ0Lmhhc093blByb3BlcnR5KFwibmFtZVwiKSYmIWMuaXNTdHJpbmcodC5uYW1lKSlyZXR1cm5cIm5hbWU6IHN0cmluZyBleHBlY3RlZFwiO2lmKG51bGwhPXQuaW5pdGlhbGl6ZXImJnQuaGFzT3duUHJvcGVydHkoXCJpbml0aWFsaXplclwiKSl7aWYoIUFycmF5LmlzQXJyYXkodC5pbml0aWFsaXplcikpcmV0dXJuXCJpbml0aWFsaXplcjogYXJyYXkgZXhwZWN0ZWRcIjtmb3IoZT0wO2U8dC5pbml0aWFsaXplci5sZW5ndGg7KytlKWlmKG49bC5vbm54LlRlbnNvclByb3RvLnZlcmlmeSh0LmluaXRpYWxpemVyW2VdKSlyZXR1cm5cImluaXRpYWxpemVyLlwiK259aWYobnVsbCE9dC5kb2NTdHJpbmcmJnQuaGFzT3duUHJvcGVydHkoXCJkb2NTdHJpbmdcIikmJiFjLmlzU3RyaW5nKHQuZG9jU3RyaW5nKSlyZXR1cm5cImRvY1N0cmluZzogc3RyaW5nIGV4cGVjdGVkXCI7aWYobnVsbCE9dC5pbnB1dCYmdC5oYXNPd25Qcm9wZXJ0eShcImlucHV0XCIpKXtpZighQXJyYXkuaXNBcnJheSh0LmlucHV0KSlyZXR1cm5cImlucHV0OiBhcnJheSBleHBlY3RlZFwiO2ZvcihlPTA7ZTx0LmlucHV0Lmxlbmd0aDsrK2UpaWYobj1sLm9ubnguVmFsdWVJbmZvUHJvdG8udmVyaWZ5KHQuaW5wdXRbZV0pKXJldHVyblwiaW5wdXQuXCIrbn1pZihudWxsIT10Lm91dHB1dCYmdC5oYXNPd25Qcm9wZXJ0eShcIm91dHB1dFwiKSl7aWYoIUFycmF5LmlzQXJyYXkodC5vdXRwdXQpKXJldHVyblwib3V0cHV0OiBhcnJheSBleHBlY3RlZFwiO2ZvcihlPTA7ZTx0Lm91dHB1dC5sZW5ndGg7KytlKWlmKG49bC5vbm54LlZhbHVlSW5mb1Byb3RvLnZlcmlmeSh0Lm91dHB1dFtlXSkpcmV0dXJuXCJvdXRwdXQuXCIrbn1pZihudWxsIT10LnZhbHVlSW5mbyYmdC5oYXNPd25Qcm9wZXJ0eShcInZhbHVlSW5mb1wiKSl7aWYoIUFycmF5LmlzQXJyYXkodC52YWx1ZUluZm8pKXJldHVyblwidmFsdWVJbmZvOiBhcnJheSBleHBlY3RlZFwiO2ZvcihlPTA7ZTx0LnZhbHVlSW5mby5sZW5ndGg7KytlKWlmKG49bC5vbm54LlZhbHVlSW5mb1Byb3RvLnZlcmlmeSh0LnZhbHVlSW5mb1tlXSkpcmV0dXJuXCJ2YWx1ZUluZm8uXCIrbn1pZihudWxsIT10LnF1YW50aXphdGlvbkFubm90YXRpb24mJnQuaGFzT3duUHJvcGVydHkoXCJxdWFudGl6YXRpb25Bbm5vdGF0aW9uXCIpKXtpZighQXJyYXkuaXNBcnJheSh0LnF1YW50aXphdGlvbkFubm90YXRpb24pKXJldHVyblwicXVhbnRpemF0aW9uQW5ub3RhdGlvbjogYXJyYXkgZXhwZWN0ZWRcIjtmb3IoZT0wO2U8dC5xdWFudGl6YXRpb25Bbm5vdGF0aW9uLmxlbmd0aDsrK2Upe3ZhciBuO2lmKG49bC5vbm54LlRlbnNvckFubm90YXRpb24udmVyaWZ5KHQucXVhbnRpemF0aW9uQW5ub3RhdGlvbltlXSkpcmV0dXJuXCJxdWFudGl6YXRpb25Bbm5vdGF0aW9uLlwiK259fXJldHVybiBudWxsfSx0LmZyb21PYmplY3Q9ZnVuY3Rpb24odCl7aWYodCBpbnN0YW5jZW9mIGwub25ueC5HcmFwaFByb3RvKXJldHVybiB0O3ZhciBlPW5ldyBsLm9ubnguR3JhcGhQcm90bztpZih0Lm5vZGUpe2lmKCFBcnJheS5pc0FycmF5KHQubm9kZSkpdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguR3JhcGhQcm90by5ub2RlOiBhcnJheSBleHBlY3RlZFwiKTtlLm5vZGU9W107Zm9yKHZhciBuPTA7bjx0Lm5vZGUubGVuZ3RoOysrbil7aWYoXCJvYmplY3RcIiE9dHlwZW9mIHQubm9kZVtuXSl0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5HcmFwaFByb3RvLm5vZGU6IG9iamVjdCBleHBlY3RlZFwiKTtlLm5vZGVbbl09bC5vbm54Lk5vZGVQcm90by5mcm9tT2JqZWN0KHQubm9kZVtuXSl9fWlmKG51bGwhPXQubmFtZSYmKGUubmFtZT1TdHJpbmcodC5uYW1lKSksdC5pbml0aWFsaXplcil7aWYoIUFycmF5LmlzQXJyYXkodC5pbml0aWFsaXplcikpdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguR3JhcGhQcm90by5pbml0aWFsaXplcjogYXJyYXkgZXhwZWN0ZWRcIik7Zm9yKGUuaW5pdGlhbGl6ZXI9W10sbj0wO248dC5pbml0aWFsaXplci5sZW5ndGg7KytuKXtpZihcIm9iamVjdFwiIT10eXBlb2YgdC5pbml0aWFsaXplcltuXSl0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5HcmFwaFByb3RvLmluaXRpYWxpemVyOiBvYmplY3QgZXhwZWN0ZWRcIik7ZS5pbml0aWFsaXplcltuXT1sLm9ubnguVGVuc29yUHJvdG8uZnJvbU9iamVjdCh0LmluaXRpYWxpemVyW25dKX19aWYobnVsbCE9dC5kb2NTdHJpbmcmJihlLmRvY1N0cmluZz1TdHJpbmcodC5kb2NTdHJpbmcpKSx0LmlucHV0KXtpZighQXJyYXkuaXNBcnJheSh0LmlucHV0KSl0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5HcmFwaFByb3RvLmlucHV0OiBhcnJheSBleHBlY3RlZFwiKTtmb3IoZS5pbnB1dD1bXSxuPTA7bjx0LmlucHV0Lmxlbmd0aDsrK24pe2lmKFwib2JqZWN0XCIhPXR5cGVvZiB0LmlucHV0W25dKXRocm93IFR5cGVFcnJvcihcIi5vbm54LkdyYXBoUHJvdG8uaW5wdXQ6IG9iamVjdCBleHBlY3RlZFwiKTtlLmlucHV0W25dPWwub25ueC5WYWx1ZUluZm9Qcm90by5mcm9tT2JqZWN0KHQuaW5wdXRbbl0pfX1pZih0Lm91dHB1dCl7aWYoIUFycmF5LmlzQXJyYXkodC5vdXRwdXQpKXRocm93IFR5cGVFcnJvcihcIi5vbm54LkdyYXBoUHJvdG8ub3V0cHV0OiBhcnJheSBleHBlY3RlZFwiKTtmb3IoZS5vdXRwdXQ9W10sbj0wO248dC5vdXRwdXQubGVuZ3RoOysrbil7aWYoXCJvYmplY3RcIiE9dHlwZW9mIHQub3V0cHV0W25dKXRocm93IFR5cGVFcnJvcihcIi5vbm54LkdyYXBoUHJvdG8ub3V0cHV0OiBvYmplY3QgZXhwZWN0ZWRcIik7ZS5vdXRwdXRbbl09bC5vbm54LlZhbHVlSW5mb1Byb3RvLmZyb21PYmplY3QodC5vdXRwdXRbbl0pfX1pZih0LnZhbHVlSW5mbyl7aWYoIUFycmF5LmlzQXJyYXkodC52YWx1ZUluZm8pKXRocm93IFR5cGVFcnJvcihcIi5vbm54LkdyYXBoUHJvdG8udmFsdWVJbmZvOiBhcnJheSBleHBlY3RlZFwiKTtmb3IoZS52YWx1ZUluZm89W10sbj0wO248dC52YWx1ZUluZm8ubGVuZ3RoOysrbil7aWYoXCJvYmplY3RcIiE9dHlwZW9mIHQudmFsdWVJbmZvW25dKXRocm93IFR5cGVFcnJvcihcIi5vbm54LkdyYXBoUHJvdG8udmFsdWVJbmZvOiBvYmplY3QgZXhwZWN0ZWRcIik7ZS52YWx1ZUluZm9bbl09bC5vbm54LlZhbHVlSW5mb1Byb3RvLmZyb21PYmplY3QodC52YWx1ZUluZm9bbl0pfX1pZih0LnF1YW50aXphdGlvbkFubm90YXRpb24pe2lmKCFBcnJheS5pc0FycmF5KHQucXVhbnRpemF0aW9uQW5ub3RhdGlvbikpdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguR3JhcGhQcm90by5xdWFudGl6YXRpb25Bbm5vdGF0aW9uOiBhcnJheSBleHBlY3RlZFwiKTtmb3IoZS5xdWFudGl6YXRpb25Bbm5vdGF0aW9uPVtdLG49MDtuPHQucXVhbnRpemF0aW9uQW5ub3RhdGlvbi5sZW5ndGg7KytuKXtpZihcIm9iamVjdFwiIT10eXBlb2YgdC5xdWFudGl6YXRpb25Bbm5vdGF0aW9uW25dKXRocm93IFR5cGVFcnJvcihcIi5vbm54LkdyYXBoUHJvdG8ucXVhbnRpemF0aW9uQW5ub3RhdGlvbjogb2JqZWN0IGV4cGVjdGVkXCIpO2UucXVhbnRpemF0aW9uQW5ub3RhdGlvbltuXT1sLm9ubnguVGVuc29yQW5ub3RhdGlvbi5mcm9tT2JqZWN0KHQucXVhbnRpemF0aW9uQW5ub3RhdGlvbltuXSl9fXJldHVybiBlfSx0LnRvT2JqZWN0PWZ1bmN0aW9uKHQsZSl7ZXx8KGU9e30pO3ZhciBuPXt9O2lmKChlLmFycmF5c3x8ZS5kZWZhdWx0cykmJihuLm5vZGU9W10sbi5pbml0aWFsaXplcj1bXSxuLmlucHV0PVtdLG4ub3V0cHV0PVtdLG4udmFsdWVJbmZvPVtdLG4ucXVhbnRpemF0aW9uQW5ub3RhdGlvbj1bXSksZS5kZWZhdWx0cyYmKG4ubmFtZT1cIlwiLG4uZG9jU3RyaW5nPVwiXCIpLHQubm9kZSYmdC5ub2RlLmxlbmd0aCl7bi5ub2RlPVtdO2Zvcih2YXIgcj0wO3I8dC5ub2RlLmxlbmd0aDsrK3Ipbi5ub2RlW3JdPWwub25ueC5Ob2RlUHJvdG8udG9PYmplY3QodC5ub2RlW3JdLGUpfWlmKG51bGwhPXQubmFtZSYmdC5oYXNPd25Qcm9wZXJ0eShcIm5hbWVcIikmJihuLm5hbWU9dC5uYW1lKSx0LmluaXRpYWxpemVyJiZ0LmluaXRpYWxpemVyLmxlbmd0aClmb3Iobi5pbml0aWFsaXplcj1bXSxyPTA7cjx0LmluaXRpYWxpemVyLmxlbmd0aDsrK3Ipbi5pbml0aWFsaXplcltyXT1sLm9ubnguVGVuc29yUHJvdG8udG9PYmplY3QodC5pbml0aWFsaXplcltyXSxlKTtpZihudWxsIT10LmRvY1N0cmluZyYmdC5oYXNPd25Qcm9wZXJ0eShcImRvY1N0cmluZ1wiKSYmKG4uZG9jU3RyaW5nPXQuZG9jU3RyaW5nKSx0LmlucHV0JiZ0LmlucHV0Lmxlbmd0aClmb3Iobi5pbnB1dD1bXSxyPTA7cjx0LmlucHV0Lmxlbmd0aDsrK3Ipbi5pbnB1dFtyXT1sLm9ubnguVmFsdWVJbmZvUHJvdG8udG9PYmplY3QodC5pbnB1dFtyXSxlKTtpZih0Lm91dHB1dCYmdC5vdXRwdXQubGVuZ3RoKWZvcihuLm91dHB1dD1bXSxyPTA7cjx0Lm91dHB1dC5sZW5ndGg7KytyKW4ub3V0cHV0W3JdPWwub25ueC5WYWx1ZUluZm9Qcm90by50b09iamVjdCh0Lm91dHB1dFtyXSxlKTtpZih0LnZhbHVlSW5mbyYmdC52YWx1ZUluZm8ubGVuZ3RoKWZvcihuLnZhbHVlSW5mbz1bXSxyPTA7cjx0LnZhbHVlSW5mby5sZW5ndGg7KytyKW4udmFsdWVJbmZvW3JdPWwub25ueC5WYWx1ZUluZm9Qcm90by50b09iamVjdCh0LnZhbHVlSW5mb1tyXSxlKTtpZih0LnF1YW50aXphdGlvbkFubm90YXRpb24mJnQucXVhbnRpemF0aW9uQW5ub3RhdGlvbi5sZW5ndGgpZm9yKG4ucXVhbnRpemF0aW9uQW5ub3RhdGlvbj1bXSxyPTA7cjx0LnF1YW50aXphdGlvbkFubm90YXRpb24ubGVuZ3RoOysrciluLnF1YW50aXphdGlvbkFubm90YXRpb25bcl09bC5vbm54LlRlbnNvckFubm90YXRpb24udG9PYmplY3QodC5xdWFudGl6YXRpb25Bbm5vdGF0aW9uW3JdLGUpO3JldHVybiBufSx0LnByb3RvdHlwZS50b0pTT049ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci50b09iamVjdCh0aGlzLGEudXRpbC50b0pTT05PcHRpb25zKX0sdH0oKSxvLlRlbnNvclByb3RvPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0KXtpZih0aGlzLmRpbXM9W10sdGhpcy5mbG9hdERhdGE9W10sdGhpcy5pbnQzMkRhdGE9W10sdGhpcy5zdHJpbmdEYXRhPVtdLHRoaXMuaW50NjREYXRhPVtdLHRoaXMuZXh0ZXJuYWxEYXRhPVtdLHRoaXMuZG91YmxlRGF0YT1bXSx0aGlzLnVpbnQ2NERhdGE9W10sdClmb3IodmFyIGU9T2JqZWN0LmtleXModCksbj0wO248ZS5sZW5ndGg7KytuKW51bGwhPXRbZVtuXV0mJih0aGlzW2Vbbl1dPXRbZVtuXV0pfXJldHVybiB0LnByb3RvdHlwZS5kaW1zPWMuZW1wdHlBcnJheSx0LnByb3RvdHlwZS5kYXRhVHlwZT0wLHQucHJvdG90eXBlLnNlZ21lbnQ9bnVsbCx0LnByb3RvdHlwZS5mbG9hdERhdGE9Yy5lbXB0eUFycmF5LHQucHJvdG90eXBlLmludDMyRGF0YT1jLmVtcHR5QXJyYXksdC5wcm90b3R5cGUuc3RyaW5nRGF0YT1jLmVtcHR5QXJyYXksdC5wcm90b3R5cGUuaW50NjREYXRhPWMuZW1wdHlBcnJheSx0LnByb3RvdHlwZS5uYW1lPVwiXCIsdC5wcm90b3R5cGUuZG9jU3RyaW5nPVwiXCIsdC5wcm90b3R5cGUucmF3RGF0YT1jLm5ld0J1ZmZlcihbXSksdC5wcm90b3R5cGUuZXh0ZXJuYWxEYXRhPWMuZW1wdHlBcnJheSx0LnByb3RvdHlwZS5kYXRhTG9jYXRpb249MCx0LnByb3RvdHlwZS5kb3VibGVEYXRhPWMuZW1wdHlBcnJheSx0LnByb3RvdHlwZS51aW50NjREYXRhPWMuZW1wdHlBcnJheSx0LmNyZWF0ZT1mdW5jdGlvbihlKXtyZXR1cm4gbmV3IHQoZSl9LHQuZW5jb2RlPWZ1bmN0aW9uKHQsZSl7aWYoZXx8KGU9dS5jcmVhdGUoKSksbnVsbCE9dC5kaW1zJiZ0LmRpbXMubGVuZ3RoKXtlLnVpbnQzMigxMCkuZm9yaygpO2Zvcih2YXIgbj0wO248dC5kaW1zLmxlbmd0aDsrK24pZS5pbnQ2NCh0LmRpbXNbbl0pO2UubGRlbGltKCl9aWYobnVsbCE9dC5kYXRhVHlwZSYmdC5oYXNPd25Qcm9wZXJ0eShcImRhdGFUeXBlXCIpJiZlLnVpbnQzMigxNikuaW50MzIodC5kYXRhVHlwZSksbnVsbCE9dC5zZWdtZW50JiZ0Lmhhc093blByb3BlcnR5KFwic2VnbWVudFwiKSYmbC5vbm54LlRlbnNvclByb3RvLlNlZ21lbnQuZW5jb2RlKHQuc2VnbWVudCxlLnVpbnQzMigyNikuZm9yaygpKS5sZGVsaW0oKSxudWxsIT10LmZsb2F0RGF0YSYmdC5mbG9hdERhdGEubGVuZ3RoKXtmb3IoZS51aW50MzIoMzQpLmZvcmsoKSxuPTA7bjx0LmZsb2F0RGF0YS5sZW5ndGg7KytuKWUuZmxvYXQodC5mbG9hdERhdGFbbl0pO2UubGRlbGltKCl9aWYobnVsbCE9dC5pbnQzMkRhdGEmJnQuaW50MzJEYXRhLmxlbmd0aCl7Zm9yKGUudWludDMyKDQyKS5mb3JrKCksbj0wO248dC5pbnQzMkRhdGEubGVuZ3RoOysrbillLmludDMyKHQuaW50MzJEYXRhW25dKTtlLmxkZWxpbSgpfWlmKG51bGwhPXQuc3RyaW5nRGF0YSYmdC5zdHJpbmdEYXRhLmxlbmd0aClmb3Iobj0wO248dC5zdHJpbmdEYXRhLmxlbmd0aDsrK24pZS51aW50MzIoNTApLmJ5dGVzKHQuc3RyaW5nRGF0YVtuXSk7aWYobnVsbCE9dC5pbnQ2NERhdGEmJnQuaW50NjREYXRhLmxlbmd0aCl7Zm9yKGUudWludDMyKDU4KS5mb3JrKCksbj0wO248dC5pbnQ2NERhdGEubGVuZ3RoOysrbillLmludDY0KHQuaW50NjREYXRhW25dKTtlLmxkZWxpbSgpfWlmKG51bGwhPXQubmFtZSYmdC5oYXNPd25Qcm9wZXJ0eShcIm5hbWVcIikmJmUudWludDMyKDY2KS5zdHJpbmcodC5uYW1lKSxudWxsIT10LnJhd0RhdGEmJnQuaGFzT3duUHJvcGVydHkoXCJyYXdEYXRhXCIpJiZlLnVpbnQzMig3NCkuYnl0ZXModC5yYXdEYXRhKSxudWxsIT10LmRvdWJsZURhdGEmJnQuZG91YmxlRGF0YS5sZW5ndGgpe2ZvcihlLnVpbnQzMig4MikuZm9yaygpLG49MDtuPHQuZG91YmxlRGF0YS5sZW5ndGg7KytuKWUuZG91YmxlKHQuZG91YmxlRGF0YVtuXSk7ZS5sZGVsaW0oKX1pZihudWxsIT10LnVpbnQ2NERhdGEmJnQudWludDY0RGF0YS5sZW5ndGgpe2ZvcihlLnVpbnQzMig5MCkuZm9yaygpLG49MDtuPHQudWludDY0RGF0YS5sZW5ndGg7KytuKWUudWludDY0KHQudWludDY0RGF0YVtuXSk7ZS5sZGVsaW0oKX1pZihudWxsIT10LmRvY1N0cmluZyYmdC5oYXNPd25Qcm9wZXJ0eShcImRvY1N0cmluZ1wiKSYmZS51aW50MzIoOTgpLnN0cmluZyh0LmRvY1N0cmluZyksbnVsbCE9dC5leHRlcm5hbERhdGEmJnQuZXh0ZXJuYWxEYXRhLmxlbmd0aClmb3Iobj0wO248dC5leHRlcm5hbERhdGEubGVuZ3RoOysrbilsLm9ubnguU3RyaW5nU3RyaW5nRW50cnlQcm90by5lbmNvZGUodC5leHRlcm5hbERhdGFbbl0sZS51aW50MzIoMTA2KS5mb3JrKCkpLmxkZWxpbSgpO3JldHVybiBudWxsIT10LmRhdGFMb2NhdGlvbiYmdC5oYXNPd25Qcm9wZXJ0eShcImRhdGFMb2NhdGlvblwiKSYmZS51aW50MzIoMTEyKS5pbnQzMih0LmRhdGFMb2NhdGlvbiksZX0sdC5lbmNvZGVEZWxpbWl0ZWQ9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5lbmNvZGUodCxlKS5sZGVsaW0oKX0sdC5kZWNvZGU9ZnVuY3Rpb24odCxlKXt0IGluc3RhbmNlb2Ygc3x8KHQ9cy5jcmVhdGUodCkpO2Zvcih2YXIgbj12b2lkIDA9PT1lP3QubGVuOnQucG9zK2Uscj1uZXcgbC5vbm54LlRlbnNvclByb3RvO3QucG9zPG47KXt2YXIgaT10LnVpbnQzMigpO3N3aXRjaChpPj4+Myl7Y2FzZSAxOmlmKHIuZGltcyYmci5kaW1zLmxlbmd0aHx8KHIuZGltcz1bXSksMj09KDcmaSkpZm9yKHZhciBvPXQudWludDMyKCkrdC5wb3M7dC5wb3M8bzspci5kaW1zLnB1c2godC5pbnQ2NCgpKTtlbHNlIHIuZGltcy5wdXNoKHQuaW50NjQoKSk7YnJlYWs7Y2FzZSAyOnIuZGF0YVR5cGU9dC5pbnQzMigpO2JyZWFrO2Nhc2UgMzpyLnNlZ21lbnQ9bC5vbm54LlRlbnNvclByb3RvLlNlZ21lbnQuZGVjb2RlKHQsdC51aW50MzIoKSk7YnJlYWs7Y2FzZSA0OmlmKHIuZmxvYXREYXRhJiZyLmZsb2F0RGF0YS5sZW5ndGh8fChyLmZsb2F0RGF0YT1bXSksMj09KDcmaSkpZm9yKG89dC51aW50MzIoKSt0LnBvczt0LnBvczxvOylyLmZsb2F0RGF0YS5wdXNoKHQuZmxvYXQoKSk7ZWxzZSByLmZsb2F0RGF0YS5wdXNoKHQuZmxvYXQoKSk7YnJlYWs7Y2FzZSA1OmlmKHIuaW50MzJEYXRhJiZyLmludDMyRGF0YS5sZW5ndGh8fChyLmludDMyRGF0YT1bXSksMj09KDcmaSkpZm9yKG89dC51aW50MzIoKSt0LnBvczt0LnBvczxvOylyLmludDMyRGF0YS5wdXNoKHQuaW50MzIoKSk7ZWxzZSByLmludDMyRGF0YS5wdXNoKHQuaW50MzIoKSk7YnJlYWs7Y2FzZSA2OnIuc3RyaW5nRGF0YSYmci5zdHJpbmdEYXRhLmxlbmd0aHx8KHIuc3RyaW5nRGF0YT1bXSksci5zdHJpbmdEYXRhLnB1c2godC5ieXRlcygpKTticmVhaztjYXNlIDc6aWYoci5pbnQ2NERhdGEmJnIuaW50NjREYXRhLmxlbmd0aHx8KHIuaW50NjREYXRhPVtdKSwyPT0oNyZpKSlmb3Iobz10LnVpbnQzMigpK3QucG9zO3QucG9zPG87KXIuaW50NjREYXRhLnB1c2godC5pbnQ2NCgpKTtlbHNlIHIuaW50NjREYXRhLnB1c2godC5pbnQ2NCgpKTticmVhaztjYXNlIDg6ci5uYW1lPXQuc3RyaW5nKCk7YnJlYWs7Y2FzZSAxMjpyLmRvY1N0cmluZz10LnN0cmluZygpO2JyZWFrO2Nhc2UgOTpyLnJhd0RhdGE9dC5ieXRlcygpO2JyZWFrO2Nhc2UgMTM6ci5leHRlcm5hbERhdGEmJnIuZXh0ZXJuYWxEYXRhLmxlbmd0aHx8KHIuZXh0ZXJuYWxEYXRhPVtdKSxyLmV4dGVybmFsRGF0YS5wdXNoKGwub25ueC5TdHJpbmdTdHJpbmdFbnRyeVByb3RvLmRlY29kZSh0LHQudWludDMyKCkpKTticmVhaztjYXNlIDE0OnIuZGF0YUxvY2F0aW9uPXQuaW50MzIoKTticmVhaztjYXNlIDEwOmlmKHIuZG91YmxlRGF0YSYmci5kb3VibGVEYXRhLmxlbmd0aHx8KHIuZG91YmxlRGF0YT1bXSksMj09KDcmaSkpZm9yKG89dC51aW50MzIoKSt0LnBvczt0LnBvczxvOylyLmRvdWJsZURhdGEucHVzaCh0LmRvdWJsZSgpKTtlbHNlIHIuZG91YmxlRGF0YS5wdXNoKHQuZG91YmxlKCkpO2JyZWFrO2Nhc2UgMTE6aWYoci51aW50NjREYXRhJiZyLnVpbnQ2NERhdGEubGVuZ3RofHwoci51aW50NjREYXRhPVtdKSwyPT0oNyZpKSlmb3Iobz10LnVpbnQzMigpK3QucG9zO3QucG9zPG87KXIudWludDY0RGF0YS5wdXNoKHQudWludDY0KCkpO2Vsc2Ugci51aW50NjREYXRhLnB1c2godC51aW50NjQoKSk7YnJlYWs7ZGVmYXVsdDp0LnNraXBUeXBlKDcmaSl9fXJldHVybiByfSx0LmRlY29kZURlbGltaXRlZD1mdW5jdGlvbih0KXtyZXR1cm4gdCBpbnN0YW5jZW9mIHN8fCh0PW5ldyBzKHQpKSx0aGlzLmRlY29kZSh0LHQudWludDMyKCkpfSx0LnZlcmlmeT1mdW5jdGlvbih0KXtpZihcIm9iamVjdFwiIT10eXBlb2YgdHx8bnVsbD09PXQpcmV0dXJuXCJvYmplY3QgZXhwZWN0ZWRcIjtpZihudWxsIT10LmRpbXMmJnQuaGFzT3duUHJvcGVydHkoXCJkaW1zXCIpKXtpZighQXJyYXkuaXNBcnJheSh0LmRpbXMpKXJldHVyblwiZGltczogYXJyYXkgZXhwZWN0ZWRcIjtmb3IodmFyIGU9MDtlPHQuZGltcy5sZW5ndGg7KytlKWlmKCEoYy5pc0ludGVnZXIodC5kaW1zW2VdKXx8dC5kaW1zW2VdJiZjLmlzSW50ZWdlcih0LmRpbXNbZV0ubG93KSYmYy5pc0ludGVnZXIodC5kaW1zW2VdLmhpZ2gpKSlyZXR1cm5cImRpbXM6IGludGVnZXJ8TG9uZ1tdIGV4cGVjdGVkXCJ9aWYobnVsbCE9dC5kYXRhVHlwZSYmdC5oYXNPd25Qcm9wZXJ0eShcImRhdGFUeXBlXCIpJiYhYy5pc0ludGVnZXIodC5kYXRhVHlwZSkpcmV0dXJuXCJkYXRhVHlwZTogaW50ZWdlciBleHBlY3RlZFwiO2lmKG51bGwhPXQuc2VnbWVudCYmdC5oYXNPd25Qcm9wZXJ0eShcInNlZ21lbnRcIikmJihuPWwub25ueC5UZW5zb3JQcm90by5TZWdtZW50LnZlcmlmeSh0LnNlZ21lbnQpKSlyZXR1cm5cInNlZ21lbnQuXCIrbjtpZihudWxsIT10LmZsb2F0RGF0YSYmdC5oYXNPd25Qcm9wZXJ0eShcImZsb2F0RGF0YVwiKSl7aWYoIUFycmF5LmlzQXJyYXkodC5mbG9hdERhdGEpKXJldHVyblwiZmxvYXREYXRhOiBhcnJheSBleHBlY3RlZFwiO2ZvcihlPTA7ZTx0LmZsb2F0RGF0YS5sZW5ndGg7KytlKWlmKFwibnVtYmVyXCIhPXR5cGVvZiB0LmZsb2F0RGF0YVtlXSlyZXR1cm5cImZsb2F0RGF0YTogbnVtYmVyW10gZXhwZWN0ZWRcIn1pZihudWxsIT10LmludDMyRGF0YSYmdC5oYXNPd25Qcm9wZXJ0eShcImludDMyRGF0YVwiKSl7aWYoIUFycmF5LmlzQXJyYXkodC5pbnQzMkRhdGEpKXJldHVyblwiaW50MzJEYXRhOiBhcnJheSBleHBlY3RlZFwiO2ZvcihlPTA7ZTx0LmludDMyRGF0YS5sZW5ndGg7KytlKWlmKCFjLmlzSW50ZWdlcih0LmludDMyRGF0YVtlXSkpcmV0dXJuXCJpbnQzMkRhdGE6IGludGVnZXJbXSBleHBlY3RlZFwifWlmKG51bGwhPXQuc3RyaW5nRGF0YSYmdC5oYXNPd25Qcm9wZXJ0eShcInN0cmluZ0RhdGFcIikpe2lmKCFBcnJheS5pc0FycmF5KHQuc3RyaW5nRGF0YSkpcmV0dXJuXCJzdHJpbmdEYXRhOiBhcnJheSBleHBlY3RlZFwiO2ZvcihlPTA7ZTx0LnN0cmluZ0RhdGEubGVuZ3RoOysrZSlpZighKHQuc3RyaW5nRGF0YVtlXSYmXCJudW1iZXJcIj09dHlwZW9mIHQuc3RyaW5nRGF0YVtlXS5sZW5ndGh8fGMuaXNTdHJpbmcodC5zdHJpbmdEYXRhW2VdKSkpcmV0dXJuXCJzdHJpbmdEYXRhOiBidWZmZXJbXSBleHBlY3RlZFwifWlmKG51bGwhPXQuaW50NjREYXRhJiZ0Lmhhc093blByb3BlcnR5KFwiaW50NjREYXRhXCIpKXtpZighQXJyYXkuaXNBcnJheSh0LmludDY0RGF0YSkpcmV0dXJuXCJpbnQ2NERhdGE6IGFycmF5IGV4cGVjdGVkXCI7Zm9yKGU9MDtlPHQuaW50NjREYXRhLmxlbmd0aDsrK2UpaWYoIShjLmlzSW50ZWdlcih0LmludDY0RGF0YVtlXSl8fHQuaW50NjREYXRhW2VdJiZjLmlzSW50ZWdlcih0LmludDY0RGF0YVtlXS5sb3cpJiZjLmlzSW50ZWdlcih0LmludDY0RGF0YVtlXS5oaWdoKSkpcmV0dXJuXCJpbnQ2NERhdGE6IGludGVnZXJ8TG9uZ1tdIGV4cGVjdGVkXCJ9aWYobnVsbCE9dC5uYW1lJiZ0Lmhhc093blByb3BlcnR5KFwibmFtZVwiKSYmIWMuaXNTdHJpbmcodC5uYW1lKSlyZXR1cm5cIm5hbWU6IHN0cmluZyBleHBlY3RlZFwiO2lmKG51bGwhPXQuZG9jU3RyaW5nJiZ0Lmhhc093blByb3BlcnR5KFwiZG9jU3RyaW5nXCIpJiYhYy5pc1N0cmluZyh0LmRvY1N0cmluZykpcmV0dXJuXCJkb2NTdHJpbmc6IHN0cmluZyBleHBlY3RlZFwiO2lmKG51bGwhPXQucmF3RGF0YSYmdC5oYXNPd25Qcm9wZXJ0eShcInJhd0RhdGFcIikmJiEodC5yYXdEYXRhJiZcIm51bWJlclwiPT10eXBlb2YgdC5yYXdEYXRhLmxlbmd0aHx8Yy5pc1N0cmluZyh0LnJhd0RhdGEpKSlyZXR1cm5cInJhd0RhdGE6IGJ1ZmZlciBleHBlY3RlZFwiO2lmKG51bGwhPXQuZXh0ZXJuYWxEYXRhJiZ0Lmhhc093blByb3BlcnR5KFwiZXh0ZXJuYWxEYXRhXCIpKXtpZighQXJyYXkuaXNBcnJheSh0LmV4dGVybmFsRGF0YSkpcmV0dXJuXCJleHRlcm5hbERhdGE6IGFycmF5IGV4cGVjdGVkXCI7Zm9yKGU9MDtlPHQuZXh0ZXJuYWxEYXRhLmxlbmd0aDsrK2Upe3ZhciBuO2lmKG49bC5vbm54LlN0cmluZ1N0cmluZ0VudHJ5UHJvdG8udmVyaWZ5KHQuZXh0ZXJuYWxEYXRhW2VdKSlyZXR1cm5cImV4dGVybmFsRGF0YS5cIitufX1pZihudWxsIT10LmRhdGFMb2NhdGlvbiYmdC5oYXNPd25Qcm9wZXJ0eShcImRhdGFMb2NhdGlvblwiKSlzd2l0Y2godC5kYXRhTG9jYXRpb24pe2RlZmF1bHQ6cmV0dXJuXCJkYXRhTG9jYXRpb246IGVudW0gdmFsdWUgZXhwZWN0ZWRcIjtjYXNlIDA6Y2FzZSAxOn1pZihudWxsIT10LmRvdWJsZURhdGEmJnQuaGFzT3duUHJvcGVydHkoXCJkb3VibGVEYXRhXCIpKXtpZighQXJyYXkuaXNBcnJheSh0LmRvdWJsZURhdGEpKXJldHVyblwiZG91YmxlRGF0YTogYXJyYXkgZXhwZWN0ZWRcIjtmb3IoZT0wO2U8dC5kb3VibGVEYXRhLmxlbmd0aDsrK2UpaWYoXCJudW1iZXJcIiE9dHlwZW9mIHQuZG91YmxlRGF0YVtlXSlyZXR1cm5cImRvdWJsZURhdGE6IG51bWJlcltdIGV4cGVjdGVkXCJ9aWYobnVsbCE9dC51aW50NjREYXRhJiZ0Lmhhc093blByb3BlcnR5KFwidWludDY0RGF0YVwiKSl7aWYoIUFycmF5LmlzQXJyYXkodC51aW50NjREYXRhKSlyZXR1cm5cInVpbnQ2NERhdGE6IGFycmF5IGV4cGVjdGVkXCI7Zm9yKGU9MDtlPHQudWludDY0RGF0YS5sZW5ndGg7KytlKWlmKCEoYy5pc0ludGVnZXIodC51aW50NjREYXRhW2VdKXx8dC51aW50NjREYXRhW2VdJiZjLmlzSW50ZWdlcih0LnVpbnQ2NERhdGFbZV0ubG93KSYmYy5pc0ludGVnZXIodC51aW50NjREYXRhW2VdLmhpZ2gpKSlyZXR1cm5cInVpbnQ2NERhdGE6IGludGVnZXJ8TG9uZ1tdIGV4cGVjdGVkXCJ9cmV0dXJuIG51bGx9LHQuZnJvbU9iamVjdD1mdW5jdGlvbih0KXtpZih0IGluc3RhbmNlb2YgbC5vbm54LlRlbnNvclByb3RvKXJldHVybiB0O3ZhciBlPW5ldyBsLm9ubnguVGVuc29yUHJvdG87aWYodC5kaW1zKXtpZighQXJyYXkuaXNBcnJheSh0LmRpbXMpKXRocm93IFR5cGVFcnJvcihcIi5vbm54LlRlbnNvclByb3RvLmRpbXM6IGFycmF5IGV4cGVjdGVkXCIpO2UuZGltcz1bXTtmb3IodmFyIG49MDtuPHQuZGltcy5sZW5ndGg7KytuKWMuTG9uZz8oZS5kaW1zW25dPWMuTG9uZy5mcm9tVmFsdWUodC5kaW1zW25dKSkudW5zaWduZWQ9ITE6XCJzdHJpbmdcIj09dHlwZW9mIHQuZGltc1tuXT9lLmRpbXNbbl09cGFyc2VJbnQodC5kaW1zW25dLDEwKTpcIm51bWJlclwiPT10eXBlb2YgdC5kaW1zW25dP2UuZGltc1tuXT10LmRpbXNbbl06XCJvYmplY3RcIj09dHlwZW9mIHQuZGltc1tuXSYmKGUuZGltc1tuXT1uZXcgYy5Mb25nQml0cyh0LmRpbXNbbl0ubG93Pj4+MCx0LmRpbXNbbl0uaGlnaD4+PjApLnRvTnVtYmVyKCkpfWlmKG51bGwhPXQuZGF0YVR5cGUmJihlLmRhdGFUeXBlPTB8dC5kYXRhVHlwZSksbnVsbCE9dC5zZWdtZW50KXtpZihcIm9iamVjdFwiIT10eXBlb2YgdC5zZWdtZW50KXRocm93IFR5cGVFcnJvcihcIi5vbm54LlRlbnNvclByb3RvLnNlZ21lbnQ6IG9iamVjdCBleHBlY3RlZFwiKTtlLnNlZ21lbnQ9bC5vbm54LlRlbnNvclByb3RvLlNlZ21lbnQuZnJvbU9iamVjdCh0LnNlZ21lbnQpfWlmKHQuZmxvYXREYXRhKXtpZighQXJyYXkuaXNBcnJheSh0LmZsb2F0RGF0YSkpdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguVGVuc29yUHJvdG8uZmxvYXREYXRhOiBhcnJheSBleHBlY3RlZFwiKTtmb3IoZS5mbG9hdERhdGE9W10sbj0wO248dC5mbG9hdERhdGEubGVuZ3RoOysrbillLmZsb2F0RGF0YVtuXT1OdW1iZXIodC5mbG9hdERhdGFbbl0pfWlmKHQuaW50MzJEYXRhKXtpZighQXJyYXkuaXNBcnJheSh0LmludDMyRGF0YSkpdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguVGVuc29yUHJvdG8uaW50MzJEYXRhOiBhcnJheSBleHBlY3RlZFwiKTtmb3IoZS5pbnQzMkRhdGE9W10sbj0wO248dC5pbnQzMkRhdGEubGVuZ3RoOysrbillLmludDMyRGF0YVtuXT0wfHQuaW50MzJEYXRhW25dfWlmKHQuc3RyaW5nRGF0YSl7aWYoIUFycmF5LmlzQXJyYXkodC5zdHJpbmdEYXRhKSl0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5UZW5zb3JQcm90by5zdHJpbmdEYXRhOiBhcnJheSBleHBlY3RlZFwiKTtmb3IoZS5zdHJpbmdEYXRhPVtdLG49MDtuPHQuc3RyaW5nRGF0YS5sZW5ndGg7KytuKVwic3RyaW5nXCI9PXR5cGVvZiB0LnN0cmluZ0RhdGFbbl0/Yy5iYXNlNjQuZGVjb2RlKHQuc3RyaW5nRGF0YVtuXSxlLnN0cmluZ0RhdGFbbl09Yy5uZXdCdWZmZXIoYy5iYXNlNjQubGVuZ3RoKHQuc3RyaW5nRGF0YVtuXSkpLDApOnQuc3RyaW5nRGF0YVtuXS5sZW5ndGgmJihlLnN0cmluZ0RhdGFbbl09dC5zdHJpbmdEYXRhW25dKX1pZih0LmludDY0RGF0YSl7aWYoIUFycmF5LmlzQXJyYXkodC5pbnQ2NERhdGEpKXRocm93IFR5cGVFcnJvcihcIi5vbm54LlRlbnNvclByb3RvLmludDY0RGF0YTogYXJyYXkgZXhwZWN0ZWRcIik7Zm9yKGUuaW50NjREYXRhPVtdLG49MDtuPHQuaW50NjREYXRhLmxlbmd0aDsrK24pYy5Mb25nPyhlLmludDY0RGF0YVtuXT1jLkxvbmcuZnJvbVZhbHVlKHQuaW50NjREYXRhW25dKSkudW5zaWduZWQ9ITE6XCJzdHJpbmdcIj09dHlwZW9mIHQuaW50NjREYXRhW25dP2UuaW50NjREYXRhW25dPXBhcnNlSW50KHQuaW50NjREYXRhW25dLDEwKTpcIm51bWJlclwiPT10eXBlb2YgdC5pbnQ2NERhdGFbbl0/ZS5pbnQ2NERhdGFbbl09dC5pbnQ2NERhdGFbbl06XCJvYmplY3RcIj09dHlwZW9mIHQuaW50NjREYXRhW25dJiYoZS5pbnQ2NERhdGFbbl09bmV3IGMuTG9uZ0JpdHModC5pbnQ2NERhdGFbbl0ubG93Pj4+MCx0LmludDY0RGF0YVtuXS5oaWdoPj4+MCkudG9OdW1iZXIoKSl9aWYobnVsbCE9dC5uYW1lJiYoZS5uYW1lPVN0cmluZyh0Lm5hbWUpKSxudWxsIT10LmRvY1N0cmluZyYmKGUuZG9jU3RyaW5nPVN0cmluZyh0LmRvY1N0cmluZykpLG51bGwhPXQucmF3RGF0YSYmKFwic3RyaW5nXCI9PXR5cGVvZiB0LnJhd0RhdGE/Yy5iYXNlNjQuZGVjb2RlKHQucmF3RGF0YSxlLnJhd0RhdGE9Yy5uZXdCdWZmZXIoYy5iYXNlNjQubGVuZ3RoKHQucmF3RGF0YSkpLDApOnQucmF3RGF0YS5sZW5ndGgmJihlLnJhd0RhdGE9dC5yYXdEYXRhKSksdC5leHRlcm5hbERhdGEpe2lmKCFBcnJheS5pc0FycmF5KHQuZXh0ZXJuYWxEYXRhKSl0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5UZW5zb3JQcm90by5leHRlcm5hbERhdGE6IGFycmF5IGV4cGVjdGVkXCIpO2ZvcihlLmV4dGVybmFsRGF0YT1bXSxuPTA7bjx0LmV4dGVybmFsRGF0YS5sZW5ndGg7KytuKXtpZihcIm9iamVjdFwiIT10eXBlb2YgdC5leHRlcm5hbERhdGFbbl0pdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguVGVuc29yUHJvdG8uZXh0ZXJuYWxEYXRhOiBvYmplY3QgZXhwZWN0ZWRcIik7ZS5leHRlcm5hbERhdGFbbl09bC5vbm54LlN0cmluZ1N0cmluZ0VudHJ5UHJvdG8uZnJvbU9iamVjdCh0LmV4dGVybmFsRGF0YVtuXSl9fXN3aXRjaCh0LmRhdGFMb2NhdGlvbil7Y2FzZVwiREVGQVVMVFwiOmNhc2UgMDplLmRhdGFMb2NhdGlvbj0wO2JyZWFrO2Nhc2VcIkVYVEVSTkFMXCI6Y2FzZSAxOmUuZGF0YUxvY2F0aW9uPTF9aWYodC5kb3VibGVEYXRhKXtpZighQXJyYXkuaXNBcnJheSh0LmRvdWJsZURhdGEpKXRocm93IFR5cGVFcnJvcihcIi5vbm54LlRlbnNvclByb3RvLmRvdWJsZURhdGE6IGFycmF5IGV4cGVjdGVkXCIpO2ZvcihlLmRvdWJsZURhdGE9W10sbj0wO248dC5kb3VibGVEYXRhLmxlbmd0aDsrK24pZS5kb3VibGVEYXRhW25dPU51bWJlcih0LmRvdWJsZURhdGFbbl0pfWlmKHQudWludDY0RGF0YSl7aWYoIUFycmF5LmlzQXJyYXkodC51aW50NjREYXRhKSl0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5UZW5zb3JQcm90by51aW50NjREYXRhOiBhcnJheSBleHBlY3RlZFwiKTtmb3IoZS51aW50NjREYXRhPVtdLG49MDtuPHQudWludDY0RGF0YS5sZW5ndGg7KytuKWMuTG9uZz8oZS51aW50NjREYXRhW25dPWMuTG9uZy5mcm9tVmFsdWUodC51aW50NjREYXRhW25dKSkudW5zaWduZWQ9ITA6XCJzdHJpbmdcIj09dHlwZW9mIHQudWludDY0RGF0YVtuXT9lLnVpbnQ2NERhdGFbbl09cGFyc2VJbnQodC51aW50NjREYXRhW25dLDEwKTpcIm51bWJlclwiPT10eXBlb2YgdC51aW50NjREYXRhW25dP2UudWludDY0RGF0YVtuXT10LnVpbnQ2NERhdGFbbl06XCJvYmplY3RcIj09dHlwZW9mIHQudWludDY0RGF0YVtuXSYmKGUudWludDY0RGF0YVtuXT1uZXcgYy5Mb25nQml0cyh0LnVpbnQ2NERhdGFbbl0ubG93Pj4+MCx0LnVpbnQ2NERhdGFbbl0uaGlnaD4+PjApLnRvTnVtYmVyKCEwKSl9cmV0dXJuIGV9LHQudG9PYmplY3Q9ZnVuY3Rpb24odCxlKXtlfHwoZT17fSk7dmFyIG49e307aWYoKGUuYXJyYXlzfHxlLmRlZmF1bHRzKSYmKG4uZGltcz1bXSxuLmZsb2F0RGF0YT1bXSxuLmludDMyRGF0YT1bXSxuLnN0cmluZ0RhdGE9W10sbi5pbnQ2NERhdGE9W10sbi5kb3VibGVEYXRhPVtdLG4udWludDY0RGF0YT1bXSxuLmV4dGVybmFsRGF0YT1bXSksZS5kZWZhdWx0cyYmKG4uZGF0YVR5cGU9MCxuLnNlZ21lbnQ9bnVsbCxuLm5hbWU9XCJcIixlLmJ5dGVzPT09U3RyaW5nP24ucmF3RGF0YT1cIlwiOihuLnJhd0RhdGE9W10sZS5ieXRlcyE9PUFycmF5JiYobi5yYXdEYXRhPWMubmV3QnVmZmVyKG4ucmF3RGF0YSkpKSxuLmRvY1N0cmluZz1cIlwiLG4uZGF0YUxvY2F0aW9uPWUuZW51bXM9PT1TdHJpbmc/XCJERUZBVUxUXCI6MCksdC5kaW1zJiZ0LmRpbXMubGVuZ3RoKXtuLmRpbXM9W107Zm9yKHZhciByPTA7cjx0LmRpbXMubGVuZ3RoOysrcilcIm51bWJlclwiPT10eXBlb2YgdC5kaW1zW3JdP24uZGltc1tyXT1lLmxvbmdzPT09U3RyaW5nP1N0cmluZyh0LmRpbXNbcl0pOnQuZGltc1tyXTpuLmRpbXNbcl09ZS5sb25ncz09PVN0cmluZz9jLkxvbmcucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodC5kaW1zW3JdKTplLmxvbmdzPT09TnVtYmVyP25ldyBjLkxvbmdCaXRzKHQuZGltc1tyXS5sb3c+Pj4wLHQuZGltc1tyXS5oaWdoPj4+MCkudG9OdW1iZXIoKTp0LmRpbXNbcl19aWYobnVsbCE9dC5kYXRhVHlwZSYmdC5oYXNPd25Qcm9wZXJ0eShcImRhdGFUeXBlXCIpJiYobi5kYXRhVHlwZT10LmRhdGFUeXBlKSxudWxsIT10LnNlZ21lbnQmJnQuaGFzT3duUHJvcGVydHkoXCJzZWdtZW50XCIpJiYobi5zZWdtZW50PWwub25ueC5UZW5zb3JQcm90by5TZWdtZW50LnRvT2JqZWN0KHQuc2VnbWVudCxlKSksdC5mbG9hdERhdGEmJnQuZmxvYXREYXRhLmxlbmd0aClmb3Iobi5mbG9hdERhdGE9W10scj0wO3I8dC5mbG9hdERhdGEubGVuZ3RoOysrciluLmZsb2F0RGF0YVtyXT1lLmpzb24mJiFpc0Zpbml0ZSh0LmZsb2F0RGF0YVtyXSk/U3RyaW5nKHQuZmxvYXREYXRhW3JdKTp0LmZsb2F0RGF0YVtyXTtpZih0LmludDMyRGF0YSYmdC5pbnQzMkRhdGEubGVuZ3RoKWZvcihuLmludDMyRGF0YT1bXSxyPTA7cjx0LmludDMyRGF0YS5sZW5ndGg7KytyKW4uaW50MzJEYXRhW3JdPXQuaW50MzJEYXRhW3JdO2lmKHQuc3RyaW5nRGF0YSYmdC5zdHJpbmdEYXRhLmxlbmd0aClmb3Iobi5zdHJpbmdEYXRhPVtdLHI9MDtyPHQuc3RyaW5nRGF0YS5sZW5ndGg7KytyKW4uc3RyaW5nRGF0YVtyXT1lLmJ5dGVzPT09U3RyaW5nP2MuYmFzZTY0LmVuY29kZSh0LnN0cmluZ0RhdGFbcl0sMCx0LnN0cmluZ0RhdGFbcl0ubGVuZ3RoKTplLmJ5dGVzPT09QXJyYXk/QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodC5zdHJpbmdEYXRhW3JdKTp0LnN0cmluZ0RhdGFbcl07aWYodC5pbnQ2NERhdGEmJnQuaW50NjREYXRhLmxlbmd0aClmb3Iobi5pbnQ2NERhdGE9W10scj0wO3I8dC5pbnQ2NERhdGEubGVuZ3RoOysrcilcIm51bWJlclwiPT10eXBlb2YgdC5pbnQ2NERhdGFbcl0/bi5pbnQ2NERhdGFbcl09ZS5sb25ncz09PVN0cmluZz9TdHJpbmcodC5pbnQ2NERhdGFbcl0pOnQuaW50NjREYXRhW3JdOm4uaW50NjREYXRhW3JdPWUubG9uZ3M9PT1TdHJpbmc/Yy5Mb25nLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHQuaW50NjREYXRhW3JdKTplLmxvbmdzPT09TnVtYmVyP25ldyBjLkxvbmdCaXRzKHQuaW50NjREYXRhW3JdLmxvdz4+PjAsdC5pbnQ2NERhdGFbcl0uaGlnaD4+PjApLnRvTnVtYmVyKCk6dC5pbnQ2NERhdGFbcl07aWYobnVsbCE9dC5uYW1lJiZ0Lmhhc093blByb3BlcnR5KFwibmFtZVwiKSYmKG4ubmFtZT10Lm5hbWUpLG51bGwhPXQucmF3RGF0YSYmdC5oYXNPd25Qcm9wZXJ0eShcInJhd0RhdGFcIikmJihuLnJhd0RhdGE9ZS5ieXRlcz09PVN0cmluZz9jLmJhc2U2NC5lbmNvZGUodC5yYXdEYXRhLDAsdC5yYXdEYXRhLmxlbmd0aCk6ZS5ieXRlcz09PUFycmF5P0FycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHQucmF3RGF0YSk6dC5yYXdEYXRhKSx0LmRvdWJsZURhdGEmJnQuZG91YmxlRGF0YS5sZW5ndGgpZm9yKG4uZG91YmxlRGF0YT1bXSxyPTA7cjx0LmRvdWJsZURhdGEubGVuZ3RoOysrciluLmRvdWJsZURhdGFbcl09ZS5qc29uJiYhaXNGaW5pdGUodC5kb3VibGVEYXRhW3JdKT9TdHJpbmcodC5kb3VibGVEYXRhW3JdKTp0LmRvdWJsZURhdGFbcl07aWYodC51aW50NjREYXRhJiZ0LnVpbnQ2NERhdGEubGVuZ3RoKWZvcihuLnVpbnQ2NERhdGE9W10scj0wO3I8dC51aW50NjREYXRhLmxlbmd0aDsrK3IpXCJudW1iZXJcIj09dHlwZW9mIHQudWludDY0RGF0YVtyXT9uLnVpbnQ2NERhdGFbcl09ZS5sb25ncz09PVN0cmluZz9TdHJpbmcodC51aW50NjREYXRhW3JdKTp0LnVpbnQ2NERhdGFbcl06bi51aW50NjREYXRhW3JdPWUubG9uZ3M9PT1TdHJpbmc/Yy5Mb25nLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHQudWludDY0RGF0YVtyXSk6ZS5sb25ncz09PU51bWJlcj9uZXcgYy5Mb25nQml0cyh0LnVpbnQ2NERhdGFbcl0ubG93Pj4+MCx0LnVpbnQ2NERhdGFbcl0uaGlnaD4+PjApLnRvTnVtYmVyKCEwKTp0LnVpbnQ2NERhdGFbcl07aWYobnVsbCE9dC5kb2NTdHJpbmcmJnQuaGFzT3duUHJvcGVydHkoXCJkb2NTdHJpbmdcIikmJihuLmRvY1N0cmluZz10LmRvY1N0cmluZyksdC5leHRlcm5hbERhdGEmJnQuZXh0ZXJuYWxEYXRhLmxlbmd0aClmb3Iobi5leHRlcm5hbERhdGE9W10scj0wO3I8dC5leHRlcm5hbERhdGEubGVuZ3RoOysrciluLmV4dGVybmFsRGF0YVtyXT1sLm9ubnguU3RyaW5nU3RyaW5nRW50cnlQcm90by50b09iamVjdCh0LmV4dGVybmFsRGF0YVtyXSxlKTtyZXR1cm4gbnVsbCE9dC5kYXRhTG9jYXRpb24mJnQuaGFzT3duUHJvcGVydHkoXCJkYXRhTG9jYXRpb25cIikmJihuLmRhdGFMb2NhdGlvbj1lLmVudW1zPT09U3RyaW5nP2wub25ueC5UZW5zb3JQcm90by5EYXRhTG9jYXRpb25bdC5kYXRhTG9jYXRpb25dOnQuZGF0YUxvY2F0aW9uKSxufSx0LnByb3RvdHlwZS50b0pTT049ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci50b09iamVjdCh0aGlzLGEudXRpbC50b0pTT05PcHRpb25zKX0sdC5EYXRhVHlwZT1mdW5jdGlvbigpe3ZhciB0PXt9LGU9T2JqZWN0LmNyZWF0ZSh0KTtyZXR1cm4gZVt0WzBdPVwiVU5ERUZJTkVEXCJdPTAsZVt0WzFdPVwiRkxPQVRcIl09MSxlW3RbMl09XCJVSU5UOFwiXT0yLGVbdFszXT1cIklOVDhcIl09MyxlW3RbNF09XCJVSU5UMTZcIl09NCxlW3RbNV09XCJJTlQxNlwiXT01LGVbdFs2XT1cIklOVDMyXCJdPTYsZVt0WzddPVwiSU5UNjRcIl09NyxlW3RbOF09XCJTVFJJTkdcIl09OCxlW3RbOV09XCJCT09MXCJdPTksZVt0WzEwXT1cIkZMT0FUMTZcIl09MTAsZVt0WzExXT1cIkRPVUJMRVwiXT0xMSxlW3RbMTJdPVwiVUlOVDMyXCJdPTEyLGVbdFsxM109XCJVSU5UNjRcIl09MTMsZVt0WzE0XT1cIkNPTVBMRVg2NFwiXT0xNCxlW3RbMTVdPVwiQ09NUExFWDEyOFwiXT0xNSxlW3RbMTZdPVwiQkZMT0FUMTZcIl09MTYsZX0oKSx0LlNlZ21lbnQ9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQpe2lmKHQpZm9yKHZhciBlPU9iamVjdC5rZXlzKHQpLG49MDtuPGUubGVuZ3RoOysrbiludWxsIT10W2Vbbl1dJiYodGhpc1tlW25dXT10W2Vbbl1dKX1yZXR1cm4gdC5wcm90b3R5cGUuYmVnaW49Yy5Mb25nP2MuTG9uZy5mcm9tQml0cygwLDAsITEpOjAsdC5wcm90b3R5cGUuZW5kPWMuTG9uZz9jLkxvbmcuZnJvbUJpdHMoMCwwLCExKTowLHQuY3JlYXRlPWZ1bmN0aW9uKGUpe3JldHVybiBuZXcgdChlKX0sdC5lbmNvZGU9ZnVuY3Rpb24odCxlKXtyZXR1cm4gZXx8KGU9dS5jcmVhdGUoKSksbnVsbCE9dC5iZWdpbiYmdC5oYXNPd25Qcm9wZXJ0eShcImJlZ2luXCIpJiZlLnVpbnQzMig4KS5pbnQ2NCh0LmJlZ2luKSxudWxsIT10LmVuZCYmdC5oYXNPd25Qcm9wZXJ0eShcImVuZFwiKSYmZS51aW50MzIoMTYpLmludDY0KHQuZW5kKSxlfSx0LmVuY29kZURlbGltaXRlZD1mdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLmVuY29kZSh0LGUpLmxkZWxpbSgpfSx0LmRlY29kZT1mdW5jdGlvbih0LGUpe3QgaW5zdGFuY2VvZiBzfHwodD1zLmNyZWF0ZSh0KSk7Zm9yKHZhciBuPXZvaWQgMD09PWU/dC5sZW46dC5wb3MrZSxyPW5ldyBsLm9ubnguVGVuc29yUHJvdG8uU2VnbWVudDt0LnBvczxuOyl7dmFyIGk9dC51aW50MzIoKTtzd2l0Y2goaT4+PjMpe2Nhc2UgMTpyLmJlZ2luPXQuaW50NjQoKTticmVhaztjYXNlIDI6ci5lbmQ9dC5pbnQ2NCgpO2JyZWFrO2RlZmF1bHQ6dC5za2lwVHlwZSg3JmkpfX1yZXR1cm4gcn0sdC5kZWNvZGVEZWxpbWl0ZWQ9ZnVuY3Rpb24odCl7cmV0dXJuIHQgaW5zdGFuY2VvZiBzfHwodD1uZXcgcyh0KSksdGhpcy5kZWNvZGUodCx0LnVpbnQzMigpKX0sdC52ZXJpZnk9ZnVuY3Rpb24odCl7cmV0dXJuXCJvYmplY3RcIiE9dHlwZW9mIHR8fG51bGw9PT10P1wib2JqZWN0IGV4cGVjdGVkXCI6bnVsbCE9dC5iZWdpbiYmdC5oYXNPd25Qcm9wZXJ0eShcImJlZ2luXCIpJiYhKGMuaXNJbnRlZ2VyKHQuYmVnaW4pfHx0LmJlZ2luJiZjLmlzSW50ZWdlcih0LmJlZ2luLmxvdykmJmMuaXNJbnRlZ2VyKHQuYmVnaW4uaGlnaCkpP1wiYmVnaW46IGludGVnZXJ8TG9uZyBleHBlY3RlZFwiOm51bGwhPXQuZW5kJiZ0Lmhhc093blByb3BlcnR5KFwiZW5kXCIpJiYhKGMuaXNJbnRlZ2VyKHQuZW5kKXx8dC5lbmQmJmMuaXNJbnRlZ2VyKHQuZW5kLmxvdykmJmMuaXNJbnRlZ2VyKHQuZW5kLmhpZ2gpKT9cImVuZDogaW50ZWdlcnxMb25nIGV4cGVjdGVkXCI6bnVsbH0sdC5mcm9tT2JqZWN0PWZ1bmN0aW9uKHQpe2lmKHQgaW5zdGFuY2VvZiBsLm9ubnguVGVuc29yUHJvdG8uU2VnbWVudClyZXR1cm4gdDt2YXIgZT1uZXcgbC5vbm54LlRlbnNvclByb3RvLlNlZ21lbnQ7cmV0dXJuIG51bGwhPXQuYmVnaW4mJihjLkxvbmc/KGUuYmVnaW49Yy5Mb25nLmZyb21WYWx1ZSh0LmJlZ2luKSkudW5zaWduZWQ9ITE6XCJzdHJpbmdcIj09dHlwZW9mIHQuYmVnaW4/ZS5iZWdpbj1wYXJzZUludCh0LmJlZ2luLDEwKTpcIm51bWJlclwiPT10eXBlb2YgdC5iZWdpbj9lLmJlZ2luPXQuYmVnaW46XCJvYmplY3RcIj09dHlwZW9mIHQuYmVnaW4mJihlLmJlZ2luPW5ldyBjLkxvbmdCaXRzKHQuYmVnaW4ubG93Pj4+MCx0LmJlZ2luLmhpZ2g+Pj4wKS50b051bWJlcigpKSksbnVsbCE9dC5lbmQmJihjLkxvbmc/KGUuZW5kPWMuTG9uZy5mcm9tVmFsdWUodC5lbmQpKS51bnNpZ25lZD0hMTpcInN0cmluZ1wiPT10eXBlb2YgdC5lbmQ/ZS5lbmQ9cGFyc2VJbnQodC5lbmQsMTApOlwibnVtYmVyXCI9PXR5cGVvZiB0LmVuZD9lLmVuZD10LmVuZDpcIm9iamVjdFwiPT10eXBlb2YgdC5lbmQmJihlLmVuZD1uZXcgYy5Mb25nQml0cyh0LmVuZC5sb3c+Pj4wLHQuZW5kLmhpZ2g+Pj4wKS50b051bWJlcigpKSksZX0sdC50b09iamVjdD1mdW5jdGlvbih0LGUpe2V8fChlPXt9KTt2YXIgbj17fTtpZihlLmRlZmF1bHRzKXtpZihjLkxvbmcpe3ZhciByPW5ldyBjLkxvbmcoMCwwLCExKTtuLmJlZ2luPWUubG9uZ3M9PT1TdHJpbmc/ci50b1N0cmluZygpOmUubG9uZ3M9PT1OdW1iZXI/ci50b051bWJlcigpOnJ9ZWxzZSBuLmJlZ2luPWUubG9uZ3M9PT1TdHJpbmc/XCIwXCI6MDtjLkxvbmc/KHI9bmV3IGMuTG9uZygwLDAsITEpLG4uZW5kPWUubG9uZ3M9PT1TdHJpbmc/ci50b1N0cmluZygpOmUubG9uZ3M9PT1OdW1iZXI/ci50b051bWJlcigpOnIpOm4uZW5kPWUubG9uZ3M9PT1TdHJpbmc/XCIwXCI6MH1yZXR1cm4gbnVsbCE9dC5iZWdpbiYmdC5oYXNPd25Qcm9wZXJ0eShcImJlZ2luXCIpJiYoXCJudW1iZXJcIj09dHlwZW9mIHQuYmVnaW4/bi5iZWdpbj1lLmxvbmdzPT09U3RyaW5nP1N0cmluZyh0LmJlZ2luKTp0LmJlZ2luOm4uYmVnaW49ZS5sb25ncz09PVN0cmluZz9jLkxvbmcucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodC5iZWdpbik6ZS5sb25ncz09PU51bWJlcj9uZXcgYy5Mb25nQml0cyh0LmJlZ2luLmxvdz4+PjAsdC5iZWdpbi5oaWdoPj4+MCkudG9OdW1iZXIoKTp0LmJlZ2luKSxudWxsIT10LmVuZCYmdC5oYXNPd25Qcm9wZXJ0eShcImVuZFwiKSYmKFwibnVtYmVyXCI9PXR5cGVvZiB0LmVuZD9uLmVuZD1lLmxvbmdzPT09U3RyaW5nP1N0cmluZyh0LmVuZCk6dC5lbmQ6bi5lbmQ9ZS5sb25ncz09PVN0cmluZz9jLkxvbmcucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodC5lbmQpOmUubG9uZ3M9PT1OdW1iZXI/bmV3IGMuTG9uZ0JpdHModC5lbmQubG93Pj4+MCx0LmVuZC5oaWdoPj4+MCkudG9OdW1iZXIoKTp0LmVuZCksbn0sdC5wcm90b3R5cGUudG9KU09OPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY29uc3RydWN0b3IudG9PYmplY3QodGhpcyxhLnV0aWwudG9KU09OT3B0aW9ucyl9LHR9KCksdC5EYXRhTG9jYXRpb249ZnVuY3Rpb24oKXt2YXIgdD17fSxlPU9iamVjdC5jcmVhdGUodCk7cmV0dXJuIGVbdFswXT1cIkRFRkFVTFRcIl09MCxlW3RbMV09XCJFWFRFUk5BTFwiXT0xLGV9KCksdH0oKSxvLlRlbnNvclNoYXBlUHJvdG89ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQpe2lmKHRoaXMuZGltPVtdLHQpZm9yKHZhciBlPU9iamVjdC5rZXlzKHQpLG49MDtuPGUubGVuZ3RoOysrbiludWxsIT10W2Vbbl1dJiYodGhpc1tlW25dXT10W2Vbbl1dKX1yZXR1cm4gdC5wcm90b3R5cGUuZGltPWMuZW1wdHlBcnJheSx0LmNyZWF0ZT1mdW5jdGlvbihlKXtyZXR1cm4gbmV3IHQoZSl9LHQuZW5jb2RlPWZ1bmN0aW9uKHQsZSl7aWYoZXx8KGU9dS5jcmVhdGUoKSksbnVsbCE9dC5kaW0mJnQuZGltLmxlbmd0aClmb3IodmFyIG49MDtuPHQuZGltLmxlbmd0aDsrK24pbC5vbm54LlRlbnNvclNoYXBlUHJvdG8uRGltZW5zaW9uLmVuY29kZSh0LmRpbVtuXSxlLnVpbnQzMigxMCkuZm9yaygpKS5sZGVsaW0oKTtyZXR1cm4gZX0sdC5lbmNvZGVEZWxpbWl0ZWQ9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5lbmNvZGUodCxlKS5sZGVsaW0oKX0sdC5kZWNvZGU9ZnVuY3Rpb24odCxlKXt0IGluc3RhbmNlb2Ygc3x8KHQ9cy5jcmVhdGUodCkpO2Zvcih2YXIgbj12b2lkIDA9PT1lP3QubGVuOnQucG9zK2Uscj1uZXcgbC5vbm54LlRlbnNvclNoYXBlUHJvdG87dC5wb3M8bjspe3ZhciBpPXQudWludDMyKCk7aT4+PjM9PTE/KHIuZGltJiZyLmRpbS5sZW5ndGh8fChyLmRpbT1bXSksci5kaW0ucHVzaChsLm9ubnguVGVuc29yU2hhcGVQcm90by5EaW1lbnNpb24uZGVjb2RlKHQsdC51aW50MzIoKSkpKTp0LnNraXBUeXBlKDcmaSl9cmV0dXJuIHJ9LHQuZGVjb2RlRGVsaW1pdGVkPWZ1bmN0aW9uKHQpe3JldHVybiB0IGluc3RhbmNlb2Ygc3x8KHQ9bmV3IHModCkpLHRoaXMuZGVjb2RlKHQsdC51aW50MzIoKSl9LHQudmVyaWZ5PWZ1bmN0aW9uKHQpe2lmKFwib2JqZWN0XCIhPXR5cGVvZiB0fHxudWxsPT09dClyZXR1cm5cIm9iamVjdCBleHBlY3RlZFwiO2lmKG51bGwhPXQuZGltJiZ0Lmhhc093blByb3BlcnR5KFwiZGltXCIpKXtpZighQXJyYXkuaXNBcnJheSh0LmRpbSkpcmV0dXJuXCJkaW06IGFycmF5IGV4cGVjdGVkXCI7Zm9yKHZhciBlPTA7ZTx0LmRpbS5sZW5ndGg7KytlKXt2YXIgbj1sLm9ubnguVGVuc29yU2hhcGVQcm90by5EaW1lbnNpb24udmVyaWZ5KHQuZGltW2VdKTtpZihuKXJldHVyblwiZGltLlwiK259fXJldHVybiBudWxsfSx0LmZyb21PYmplY3Q9ZnVuY3Rpb24odCl7aWYodCBpbnN0YW5jZW9mIGwub25ueC5UZW5zb3JTaGFwZVByb3RvKXJldHVybiB0O3ZhciBlPW5ldyBsLm9ubnguVGVuc29yU2hhcGVQcm90bztpZih0LmRpbSl7aWYoIUFycmF5LmlzQXJyYXkodC5kaW0pKXRocm93IFR5cGVFcnJvcihcIi5vbm54LlRlbnNvclNoYXBlUHJvdG8uZGltOiBhcnJheSBleHBlY3RlZFwiKTtlLmRpbT1bXTtmb3IodmFyIG49MDtuPHQuZGltLmxlbmd0aDsrK24pe2lmKFwib2JqZWN0XCIhPXR5cGVvZiB0LmRpbVtuXSl0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5UZW5zb3JTaGFwZVByb3RvLmRpbTogb2JqZWN0IGV4cGVjdGVkXCIpO2UuZGltW25dPWwub25ueC5UZW5zb3JTaGFwZVByb3RvLkRpbWVuc2lvbi5mcm9tT2JqZWN0KHQuZGltW25dKX19cmV0dXJuIGV9LHQudG9PYmplY3Q9ZnVuY3Rpb24odCxlKXtlfHwoZT17fSk7dmFyIG49e307aWYoKGUuYXJyYXlzfHxlLmRlZmF1bHRzKSYmKG4uZGltPVtdKSx0LmRpbSYmdC5kaW0ubGVuZ3RoKXtuLmRpbT1bXTtmb3IodmFyIHI9MDtyPHQuZGltLmxlbmd0aDsrK3Ipbi5kaW1bcl09bC5vbm54LlRlbnNvclNoYXBlUHJvdG8uRGltZW5zaW9uLnRvT2JqZWN0KHQuZGltW3JdLGUpfXJldHVybiBufSx0LnByb3RvdHlwZS50b0pTT049ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci50b09iamVjdCh0aGlzLGEudXRpbC50b0pTT05PcHRpb25zKX0sdC5EaW1lbnNpb249ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQpe2lmKHQpZm9yKHZhciBlPU9iamVjdC5rZXlzKHQpLG49MDtuPGUubGVuZ3RoOysrbiludWxsIT10W2Vbbl1dJiYodGhpc1tlW25dXT10W2Vbbl1dKX12YXIgZTtyZXR1cm4gdC5wcm90b3R5cGUuZGltVmFsdWU9Yy5Mb25nP2MuTG9uZy5mcm9tQml0cygwLDAsITEpOjAsdC5wcm90b3R5cGUuZGltUGFyYW09XCJcIix0LnByb3RvdHlwZS5kZW5vdGF0aW9uPVwiXCIsT2JqZWN0LmRlZmluZVByb3BlcnR5KHQucHJvdG90eXBlLFwidmFsdWVcIix7Z2V0OmMub25lT2ZHZXR0ZXIoZT1bXCJkaW1WYWx1ZVwiLFwiZGltUGFyYW1cIl0pLHNldDpjLm9uZU9mU2V0dGVyKGUpfSksdC5jcmVhdGU9ZnVuY3Rpb24oZSl7cmV0dXJuIG5ldyB0KGUpfSx0LmVuY29kZT1mdW5jdGlvbih0LGUpe3JldHVybiBlfHwoZT11LmNyZWF0ZSgpKSxudWxsIT10LmRpbVZhbHVlJiZ0Lmhhc093blByb3BlcnR5KFwiZGltVmFsdWVcIikmJmUudWludDMyKDgpLmludDY0KHQuZGltVmFsdWUpLG51bGwhPXQuZGltUGFyYW0mJnQuaGFzT3duUHJvcGVydHkoXCJkaW1QYXJhbVwiKSYmZS51aW50MzIoMTgpLnN0cmluZyh0LmRpbVBhcmFtKSxudWxsIT10LmRlbm90YXRpb24mJnQuaGFzT3duUHJvcGVydHkoXCJkZW5vdGF0aW9uXCIpJiZlLnVpbnQzMigyNikuc3RyaW5nKHQuZGVub3RhdGlvbiksZX0sdC5lbmNvZGVEZWxpbWl0ZWQ9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5lbmNvZGUodCxlKS5sZGVsaW0oKX0sdC5kZWNvZGU9ZnVuY3Rpb24odCxlKXt0IGluc3RhbmNlb2Ygc3x8KHQ9cy5jcmVhdGUodCkpO2Zvcih2YXIgbj12b2lkIDA9PT1lP3QubGVuOnQucG9zK2Uscj1uZXcgbC5vbm54LlRlbnNvclNoYXBlUHJvdG8uRGltZW5zaW9uO3QucG9zPG47KXt2YXIgaT10LnVpbnQzMigpO3N3aXRjaChpPj4+Myl7Y2FzZSAxOnIuZGltVmFsdWU9dC5pbnQ2NCgpO2JyZWFrO2Nhc2UgMjpyLmRpbVBhcmFtPXQuc3RyaW5nKCk7YnJlYWs7Y2FzZSAzOnIuZGVub3RhdGlvbj10LnN0cmluZygpO2JyZWFrO2RlZmF1bHQ6dC5za2lwVHlwZSg3JmkpfX1yZXR1cm4gcn0sdC5kZWNvZGVEZWxpbWl0ZWQ9ZnVuY3Rpb24odCl7cmV0dXJuIHQgaW5zdGFuY2VvZiBzfHwodD1uZXcgcyh0KSksdGhpcy5kZWNvZGUodCx0LnVpbnQzMigpKX0sdC52ZXJpZnk9ZnVuY3Rpb24odCl7aWYoXCJvYmplY3RcIiE9dHlwZW9mIHR8fG51bGw9PT10KXJldHVyblwib2JqZWN0IGV4cGVjdGVkXCI7dmFyIGU9e307aWYobnVsbCE9dC5kaW1WYWx1ZSYmdC5oYXNPd25Qcm9wZXJ0eShcImRpbVZhbHVlXCIpJiYoZS52YWx1ZT0xLCEoYy5pc0ludGVnZXIodC5kaW1WYWx1ZSl8fHQuZGltVmFsdWUmJmMuaXNJbnRlZ2VyKHQuZGltVmFsdWUubG93KSYmYy5pc0ludGVnZXIodC5kaW1WYWx1ZS5oaWdoKSkpKXJldHVyblwiZGltVmFsdWU6IGludGVnZXJ8TG9uZyBleHBlY3RlZFwiO2lmKG51bGwhPXQuZGltUGFyYW0mJnQuaGFzT3duUHJvcGVydHkoXCJkaW1QYXJhbVwiKSl7aWYoMT09PWUudmFsdWUpcmV0dXJuXCJ2YWx1ZTogbXVsdGlwbGUgdmFsdWVzXCI7aWYoZS52YWx1ZT0xLCFjLmlzU3RyaW5nKHQuZGltUGFyYW0pKXJldHVyblwiZGltUGFyYW06IHN0cmluZyBleHBlY3RlZFwifXJldHVybiBudWxsIT10LmRlbm90YXRpb24mJnQuaGFzT3duUHJvcGVydHkoXCJkZW5vdGF0aW9uXCIpJiYhYy5pc1N0cmluZyh0LmRlbm90YXRpb24pP1wiZGVub3RhdGlvbjogc3RyaW5nIGV4cGVjdGVkXCI6bnVsbH0sdC5mcm9tT2JqZWN0PWZ1bmN0aW9uKHQpe2lmKHQgaW5zdGFuY2VvZiBsLm9ubnguVGVuc29yU2hhcGVQcm90by5EaW1lbnNpb24pcmV0dXJuIHQ7dmFyIGU9bmV3IGwub25ueC5UZW5zb3JTaGFwZVByb3RvLkRpbWVuc2lvbjtyZXR1cm4gbnVsbCE9dC5kaW1WYWx1ZSYmKGMuTG9uZz8oZS5kaW1WYWx1ZT1jLkxvbmcuZnJvbVZhbHVlKHQuZGltVmFsdWUpKS51bnNpZ25lZD0hMTpcInN0cmluZ1wiPT10eXBlb2YgdC5kaW1WYWx1ZT9lLmRpbVZhbHVlPXBhcnNlSW50KHQuZGltVmFsdWUsMTApOlwibnVtYmVyXCI9PXR5cGVvZiB0LmRpbVZhbHVlP2UuZGltVmFsdWU9dC5kaW1WYWx1ZTpcIm9iamVjdFwiPT10eXBlb2YgdC5kaW1WYWx1ZSYmKGUuZGltVmFsdWU9bmV3IGMuTG9uZ0JpdHModC5kaW1WYWx1ZS5sb3c+Pj4wLHQuZGltVmFsdWUuaGlnaD4+PjApLnRvTnVtYmVyKCkpKSxudWxsIT10LmRpbVBhcmFtJiYoZS5kaW1QYXJhbT1TdHJpbmcodC5kaW1QYXJhbSkpLG51bGwhPXQuZGVub3RhdGlvbiYmKGUuZGVub3RhdGlvbj1TdHJpbmcodC5kZW5vdGF0aW9uKSksZX0sdC50b09iamVjdD1mdW5jdGlvbih0LGUpe2V8fChlPXt9KTt2YXIgbj17fTtyZXR1cm4gZS5kZWZhdWx0cyYmKG4uZGVub3RhdGlvbj1cIlwiKSxudWxsIT10LmRpbVZhbHVlJiZ0Lmhhc093blByb3BlcnR5KFwiZGltVmFsdWVcIikmJihcIm51bWJlclwiPT10eXBlb2YgdC5kaW1WYWx1ZT9uLmRpbVZhbHVlPWUubG9uZ3M9PT1TdHJpbmc/U3RyaW5nKHQuZGltVmFsdWUpOnQuZGltVmFsdWU6bi5kaW1WYWx1ZT1lLmxvbmdzPT09U3RyaW5nP2MuTG9uZy5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0LmRpbVZhbHVlKTplLmxvbmdzPT09TnVtYmVyP25ldyBjLkxvbmdCaXRzKHQuZGltVmFsdWUubG93Pj4+MCx0LmRpbVZhbHVlLmhpZ2g+Pj4wKS50b051bWJlcigpOnQuZGltVmFsdWUsZS5vbmVvZnMmJihuLnZhbHVlPVwiZGltVmFsdWVcIikpLG51bGwhPXQuZGltUGFyYW0mJnQuaGFzT3duUHJvcGVydHkoXCJkaW1QYXJhbVwiKSYmKG4uZGltUGFyYW09dC5kaW1QYXJhbSxlLm9uZW9mcyYmKG4udmFsdWU9XCJkaW1QYXJhbVwiKSksbnVsbCE9dC5kZW5vdGF0aW9uJiZ0Lmhhc093blByb3BlcnR5KFwiZGVub3RhdGlvblwiKSYmKG4uZGVub3RhdGlvbj10LmRlbm90YXRpb24pLG59LHQucHJvdG90eXBlLnRvSlNPTj1mdW5jdGlvbigpe3JldHVybiB0aGlzLmNvbnN0cnVjdG9yLnRvT2JqZWN0KHRoaXMsYS51dGlsLnRvSlNPTk9wdGlvbnMpfSx0fSgpLHR9KCksby5UeXBlUHJvdG89ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQpe2lmKHQpZm9yKHZhciBlPU9iamVjdC5rZXlzKHQpLG49MDtuPGUubGVuZ3RoOysrbiludWxsIT10W2Vbbl1dJiYodGhpc1tlW25dXT10W2Vbbl1dKX12YXIgZTtyZXR1cm4gdC5wcm90b3R5cGUudGVuc29yVHlwZT1udWxsLHQucHJvdG90eXBlLmRlbm90YXRpb249XCJcIixPYmplY3QuZGVmaW5lUHJvcGVydHkodC5wcm90b3R5cGUsXCJ2YWx1ZVwiLHtnZXQ6Yy5vbmVPZkdldHRlcihlPVtcInRlbnNvclR5cGVcIl0pLHNldDpjLm9uZU9mU2V0dGVyKGUpfSksdC5jcmVhdGU9ZnVuY3Rpb24oZSl7cmV0dXJuIG5ldyB0KGUpfSx0LmVuY29kZT1mdW5jdGlvbih0LGUpe3JldHVybiBlfHwoZT11LmNyZWF0ZSgpKSxudWxsIT10LnRlbnNvclR5cGUmJnQuaGFzT3duUHJvcGVydHkoXCJ0ZW5zb3JUeXBlXCIpJiZsLm9ubnguVHlwZVByb3RvLlRlbnNvci5lbmNvZGUodC50ZW5zb3JUeXBlLGUudWludDMyKDEwKS5mb3JrKCkpLmxkZWxpbSgpLG51bGwhPXQuZGVub3RhdGlvbiYmdC5oYXNPd25Qcm9wZXJ0eShcImRlbm90YXRpb25cIikmJmUudWludDMyKDUwKS5zdHJpbmcodC5kZW5vdGF0aW9uKSxlfSx0LmVuY29kZURlbGltaXRlZD1mdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLmVuY29kZSh0LGUpLmxkZWxpbSgpfSx0LmRlY29kZT1mdW5jdGlvbih0LGUpe3QgaW5zdGFuY2VvZiBzfHwodD1zLmNyZWF0ZSh0KSk7Zm9yKHZhciBuPXZvaWQgMD09PWU/dC5sZW46dC5wb3MrZSxyPW5ldyBsLm9ubnguVHlwZVByb3RvO3QucG9zPG47KXt2YXIgaT10LnVpbnQzMigpO3N3aXRjaChpPj4+Myl7Y2FzZSAxOnIudGVuc29yVHlwZT1sLm9ubnguVHlwZVByb3RvLlRlbnNvci5kZWNvZGUodCx0LnVpbnQzMigpKTticmVhaztjYXNlIDY6ci5kZW5vdGF0aW9uPXQuc3RyaW5nKCk7YnJlYWs7ZGVmYXVsdDp0LnNraXBUeXBlKDcmaSl9fXJldHVybiByfSx0LmRlY29kZURlbGltaXRlZD1mdW5jdGlvbih0KXtyZXR1cm4gdCBpbnN0YW5jZW9mIHN8fCh0PW5ldyBzKHQpKSx0aGlzLmRlY29kZSh0LHQudWludDMyKCkpfSx0LnZlcmlmeT1mdW5jdGlvbih0KXtpZihcIm9iamVjdFwiIT10eXBlb2YgdHx8bnVsbD09PXQpcmV0dXJuXCJvYmplY3QgZXhwZWN0ZWRcIjtpZihudWxsIT10LnRlbnNvclR5cGUmJnQuaGFzT3duUHJvcGVydHkoXCJ0ZW5zb3JUeXBlXCIpKXt2YXIgZT1sLm9ubnguVHlwZVByb3RvLlRlbnNvci52ZXJpZnkodC50ZW5zb3JUeXBlKTtpZihlKXJldHVyblwidGVuc29yVHlwZS5cIitlfXJldHVybiBudWxsIT10LmRlbm90YXRpb24mJnQuaGFzT3duUHJvcGVydHkoXCJkZW5vdGF0aW9uXCIpJiYhYy5pc1N0cmluZyh0LmRlbm90YXRpb24pP1wiZGVub3RhdGlvbjogc3RyaW5nIGV4cGVjdGVkXCI6bnVsbH0sdC5mcm9tT2JqZWN0PWZ1bmN0aW9uKHQpe2lmKHQgaW5zdGFuY2VvZiBsLm9ubnguVHlwZVByb3RvKXJldHVybiB0O3ZhciBlPW5ldyBsLm9ubnguVHlwZVByb3RvO2lmKG51bGwhPXQudGVuc29yVHlwZSl7aWYoXCJvYmplY3RcIiE9dHlwZW9mIHQudGVuc29yVHlwZSl0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5UeXBlUHJvdG8udGVuc29yVHlwZTogb2JqZWN0IGV4cGVjdGVkXCIpO2UudGVuc29yVHlwZT1sLm9ubnguVHlwZVByb3RvLlRlbnNvci5mcm9tT2JqZWN0KHQudGVuc29yVHlwZSl9cmV0dXJuIG51bGwhPXQuZGVub3RhdGlvbiYmKGUuZGVub3RhdGlvbj1TdHJpbmcodC5kZW5vdGF0aW9uKSksZX0sdC50b09iamVjdD1mdW5jdGlvbih0LGUpe2V8fChlPXt9KTt2YXIgbj17fTtyZXR1cm4gZS5kZWZhdWx0cyYmKG4uZGVub3RhdGlvbj1cIlwiKSxudWxsIT10LnRlbnNvclR5cGUmJnQuaGFzT3duUHJvcGVydHkoXCJ0ZW5zb3JUeXBlXCIpJiYobi50ZW5zb3JUeXBlPWwub25ueC5UeXBlUHJvdG8uVGVuc29yLnRvT2JqZWN0KHQudGVuc29yVHlwZSxlKSxlLm9uZW9mcyYmKG4udmFsdWU9XCJ0ZW5zb3JUeXBlXCIpKSxudWxsIT10LmRlbm90YXRpb24mJnQuaGFzT3duUHJvcGVydHkoXCJkZW5vdGF0aW9uXCIpJiYobi5kZW5vdGF0aW9uPXQuZGVub3RhdGlvbiksbn0sdC5wcm90b3R5cGUudG9KU09OPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY29uc3RydWN0b3IudG9PYmplY3QodGhpcyxhLnV0aWwudG9KU09OT3B0aW9ucyl9LHQuVGVuc29yPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0KXtpZih0KWZvcih2YXIgZT1PYmplY3Qua2V5cyh0KSxuPTA7bjxlLmxlbmd0aDsrK24pbnVsbCE9dFtlW25dXSYmKHRoaXNbZVtuXV09dFtlW25dXSl9cmV0dXJuIHQucHJvdG90eXBlLmVsZW1UeXBlPTAsdC5wcm90b3R5cGUuc2hhcGU9bnVsbCx0LmNyZWF0ZT1mdW5jdGlvbihlKXtyZXR1cm4gbmV3IHQoZSl9LHQuZW5jb2RlPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIGV8fChlPXUuY3JlYXRlKCkpLG51bGwhPXQuZWxlbVR5cGUmJnQuaGFzT3duUHJvcGVydHkoXCJlbGVtVHlwZVwiKSYmZS51aW50MzIoOCkuaW50MzIodC5lbGVtVHlwZSksbnVsbCE9dC5zaGFwZSYmdC5oYXNPd25Qcm9wZXJ0eShcInNoYXBlXCIpJiZsLm9ubnguVGVuc29yU2hhcGVQcm90by5lbmNvZGUodC5zaGFwZSxlLnVpbnQzMigxOCkuZm9yaygpKS5sZGVsaW0oKSxlfSx0LmVuY29kZURlbGltaXRlZD1mdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLmVuY29kZSh0LGUpLmxkZWxpbSgpfSx0LmRlY29kZT1mdW5jdGlvbih0LGUpe3QgaW5zdGFuY2VvZiBzfHwodD1zLmNyZWF0ZSh0KSk7Zm9yKHZhciBuPXZvaWQgMD09PWU/dC5sZW46dC5wb3MrZSxyPW5ldyBsLm9ubnguVHlwZVByb3RvLlRlbnNvcjt0LnBvczxuOyl7dmFyIGk9dC51aW50MzIoKTtzd2l0Y2goaT4+PjMpe2Nhc2UgMTpyLmVsZW1UeXBlPXQuaW50MzIoKTticmVhaztjYXNlIDI6ci5zaGFwZT1sLm9ubnguVGVuc29yU2hhcGVQcm90by5kZWNvZGUodCx0LnVpbnQzMigpKTticmVhaztkZWZhdWx0OnQuc2tpcFR5cGUoNyZpKX19cmV0dXJuIHJ9LHQuZGVjb2RlRGVsaW1pdGVkPWZ1bmN0aW9uKHQpe3JldHVybiB0IGluc3RhbmNlb2Ygc3x8KHQ9bmV3IHModCkpLHRoaXMuZGVjb2RlKHQsdC51aW50MzIoKSl9LHQudmVyaWZ5PWZ1bmN0aW9uKHQpe2lmKFwib2JqZWN0XCIhPXR5cGVvZiB0fHxudWxsPT09dClyZXR1cm5cIm9iamVjdCBleHBlY3RlZFwiO2lmKG51bGwhPXQuZWxlbVR5cGUmJnQuaGFzT3duUHJvcGVydHkoXCJlbGVtVHlwZVwiKSYmIWMuaXNJbnRlZ2VyKHQuZWxlbVR5cGUpKXJldHVyblwiZWxlbVR5cGU6IGludGVnZXIgZXhwZWN0ZWRcIjtpZihudWxsIT10LnNoYXBlJiZ0Lmhhc093blByb3BlcnR5KFwic2hhcGVcIikpe3ZhciBlPWwub25ueC5UZW5zb3JTaGFwZVByb3RvLnZlcmlmeSh0LnNoYXBlKTtpZihlKXJldHVyblwic2hhcGUuXCIrZX1yZXR1cm4gbnVsbH0sdC5mcm9tT2JqZWN0PWZ1bmN0aW9uKHQpe2lmKHQgaW5zdGFuY2VvZiBsLm9ubnguVHlwZVByb3RvLlRlbnNvcilyZXR1cm4gdDt2YXIgZT1uZXcgbC5vbm54LlR5cGVQcm90by5UZW5zb3I7aWYobnVsbCE9dC5lbGVtVHlwZSYmKGUuZWxlbVR5cGU9MHx0LmVsZW1UeXBlKSxudWxsIT10LnNoYXBlKXtpZihcIm9iamVjdFwiIT10eXBlb2YgdC5zaGFwZSl0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5UeXBlUHJvdG8uVGVuc29yLnNoYXBlOiBvYmplY3QgZXhwZWN0ZWRcIik7ZS5zaGFwZT1sLm9ubnguVGVuc29yU2hhcGVQcm90by5mcm9tT2JqZWN0KHQuc2hhcGUpfXJldHVybiBlfSx0LnRvT2JqZWN0PWZ1bmN0aW9uKHQsZSl7ZXx8KGU9e30pO3ZhciBuPXt9O3JldHVybiBlLmRlZmF1bHRzJiYobi5lbGVtVHlwZT0wLG4uc2hhcGU9bnVsbCksbnVsbCE9dC5lbGVtVHlwZSYmdC5oYXNPd25Qcm9wZXJ0eShcImVsZW1UeXBlXCIpJiYobi5lbGVtVHlwZT10LmVsZW1UeXBlKSxudWxsIT10LnNoYXBlJiZ0Lmhhc093blByb3BlcnR5KFwic2hhcGVcIikmJihuLnNoYXBlPWwub25ueC5UZW5zb3JTaGFwZVByb3RvLnRvT2JqZWN0KHQuc2hhcGUsZSkpLG59LHQucHJvdG90eXBlLnRvSlNPTj1mdW5jdGlvbigpe3JldHVybiB0aGlzLmNvbnN0cnVjdG9yLnRvT2JqZWN0KHRoaXMsYS51dGlsLnRvSlNPTk9wdGlvbnMpfSx0fSgpLHR9KCksby5PcGVyYXRvclNldElkUHJvdG89ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQpe2lmKHQpZm9yKHZhciBlPU9iamVjdC5rZXlzKHQpLG49MDtuPGUubGVuZ3RoOysrbiludWxsIT10W2Vbbl1dJiYodGhpc1tlW25dXT10W2Vbbl1dKX1yZXR1cm4gdC5wcm90b3R5cGUuZG9tYWluPVwiXCIsdC5wcm90b3R5cGUudmVyc2lvbj1jLkxvbmc/Yy5Mb25nLmZyb21CaXRzKDAsMCwhMSk6MCx0LmNyZWF0ZT1mdW5jdGlvbihlKXtyZXR1cm4gbmV3IHQoZSl9LHQuZW5jb2RlPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIGV8fChlPXUuY3JlYXRlKCkpLG51bGwhPXQuZG9tYWluJiZ0Lmhhc093blByb3BlcnR5KFwiZG9tYWluXCIpJiZlLnVpbnQzMigxMCkuc3RyaW5nKHQuZG9tYWluKSxudWxsIT10LnZlcnNpb24mJnQuaGFzT3duUHJvcGVydHkoXCJ2ZXJzaW9uXCIpJiZlLnVpbnQzMigxNikuaW50NjQodC52ZXJzaW9uKSxlfSx0LmVuY29kZURlbGltaXRlZD1mdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLmVuY29kZSh0LGUpLmxkZWxpbSgpfSx0LmRlY29kZT1mdW5jdGlvbih0LGUpe3QgaW5zdGFuY2VvZiBzfHwodD1zLmNyZWF0ZSh0KSk7Zm9yKHZhciBuPXZvaWQgMD09PWU/dC5sZW46dC5wb3MrZSxyPW5ldyBsLm9ubnguT3BlcmF0b3JTZXRJZFByb3RvO3QucG9zPG47KXt2YXIgaT10LnVpbnQzMigpO3N3aXRjaChpPj4+Myl7Y2FzZSAxOnIuZG9tYWluPXQuc3RyaW5nKCk7YnJlYWs7Y2FzZSAyOnIudmVyc2lvbj10LmludDY0KCk7YnJlYWs7ZGVmYXVsdDp0LnNraXBUeXBlKDcmaSl9fXJldHVybiByfSx0LmRlY29kZURlbGltaXRlZD1mdW5jdGlvbih0KXtyZXR1cm4gdCBpbnN0YW5jZW9mIHN8fCh0PW5ldyBzKHQpKSx0aGlzLmRlY29kZSh0LHQudWludDMyKCkpfSx0LnZlcmlmeT1mdW5jdGlvbih0KXtyZXR1cm5cIm9iamVjdFwiIT10eXBlb2YgdHx8bnVsbD09PXQ/XCJvYmplY3QgZXhwZWN0ZWRcIjpudWxsIT10LmRvbWFpbiYmdC5oYXNPd25Qcm9wZXJ0eShcImRvbWFpblwiKSYmIWMuaXNTdHJpbmcodC5kb21haW4pP1wiZG9tYWluOiBzdHJpbmcgZXhwZWN0ZWRcIjpudWxsIT10LnZlcnNpb24mJnQuaGFzT3duUHJvcGVydHkoXCJ2ZXJzaW9uXCIpJiYhKGMuaXNJbnRlZ2VyKHQudmVyc2lvbil8fHQudmVyc2lvbiYmYy5pc0ludGVnZXIodC52ZXJzaW9uLmxvdykmJmMuaXNJbnRlZ2VyKHQudmVyc2lvbi5oaWdoKSk/XCJ2ZXJzaW9uOiBpbnRlZ2VyfExvbmcgZXhwZWN0ZWRcIjpudWxsfSx0LmZyb21PYmplY3Q9ZnVuY3Rpb24odCl7aWYodCBpbnN0YW5jZW9mIGwub25ueC5PcGVyYXRvclNldElkUHJvdG8pcmV0dXJuIHQ7dmFyIGU9bmV3IGwub25ueC5PcGVyYXRvclNldElkUHJvdG87cmV0dXJuIG51bGwhPXQuZG9tYWluJiYoZS5kb21haW49U3RyaW5nKHQuZG9tYWluKSksbnVsbCE9dC52ZXJzaW9uJiYoYy5Mb25nPyhlLnZlcnNpb249Yy5Mb25nLmZyb21WYWx1ZSh0LnZlcnNpb24pKS51bnNpZ25lZD0hMTpcInN0cmluZ1wiPT10eXBlb2YgdC52ZXJzaW9uP2UudmVyc2lvbj1wYXJzZUludCh0LnZlcnNpb24sMTApOlwibnVtYmVyXCI9PXR5cGVvZiB0LnZlcnNpb24/ZS52ZXJzaW9uPXQudmVyc2lvbjpcIm9iamVjdFwiPT10eXBlb2YgdC52ZXJzaW9uJiYoZS52ZXJzaW9uPW5ldyBjLkxvbmdCaXRzKHQudmVyc2lvbi5sb3c+Pj4wLHQudmVyc2lvbi5oaWdoPj4+MCkudG9OdW1iZXIoKSkpLGV9LHQudG9PYmplY3Q9ZnVuY3Rpb24odCxlKXtlfHwoZT17fSk7dmFyIG49e307aWYoZS5kZWZhdWx0cylpZihuLmRvbWFpbj1cIlwiLGMuTG9uZyl7dmFyIHI9bmV3IGMuTG9uZygwLDAsITEpO24udmVyc2lvbj1lLmxvbmdzPT09U3RyaW5nP3IudG9TdHJpbmcoKTplLmxvbmdzPT09TnVtYmVyP3IudG9OdW1iZXIoKTpyfWVsc2Ugbi52ZXJzaW9uPWUubG9uZ3M9PT1TdHJpbmc/XCIwXCI6MDtyZXR1cm4gbnVsbCE9dC5kb21haW4mJnQuaGFzT3duUHJvcGVydHkoXCJkb21haW5cIikmJihuLmRvbWFpbj10LmRvbWFpbiksbnVsbCE9dC52ZXJzaW9uJiZ0Lmhhc093blByb3BlcnR5KFwidmVyc2lvblwiKSYmKFwibnVtYmVyXCI9PXR5cGVvZiB0LnZlcnNpb24/bi52ZXJzaW9uPWUubG9uZ3M9PT1TdHJpbmc/U3RyaW5nKHQudmVyc2lvbik6dC52ZXJzaW9uOm4udmVyc2lvbj1lLmxvbmdzPT09U3RyaW5nP2MuTG9uZy5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0LnZlcnNpb24pOmUubG9uZ3M9PT1OdW1iZXI/bmV3IGMuTG9uZ0JpdHModC52ZXJzaW9uLmxvdz4+PjAsdC52ZXJzaW9uLmhpZ2g+Pj4wKS50b051bWJlcigpOnQudmVyc2lvbiksbn0sdC5wcm90b3R5cGUudG9KU09OPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY29uc3RydWN0b3IudG9PYmplY3QodGhpcyxhLnV0aWwudG9KU09OT3B0aW9ucyl9LHR9KCksbyksdC5leHBvcnRzPWx9LDIxMDA6KHQsZSxuKT0+e1widXNlIHN0cmljdFwiO3QuZXhwb3J0cz1uKDk0ODIpfSw5NDgyOih0LGUsbik9PntcInVzZSBzdHJpY3RcIjt2YXIgcj1lO2Z1bmN0aW9uIGkoKXtyLnV0aWwuX2NvbmZpZ3VyZSgpLHIuV3JpdGVyLl9jb25maWd1cmUoci5CdWZmZXJXcml0ZXIpLHIuUmVhZGVyLl9jb25maWd1cmUoci5CdWZmZXJSZWFkZXIpfXIuYnVpbGQ9XCJtaW5pbWFsXCIsci5Xcml0ZXI9bigxMTczKSxyLkJ1ZmZlcldyaXRlcj1uKDMxNTUpLHIuUmVhZGVyPW4oMTQwOCksci5CdWZmZXJSZWFkZXI9big1OTMpLHIudXRpbD1uKDk2OTMpLHIucnBjPW4oNTk5NCksci5yb290cz1uKDUwNTQpLHIuY29uZmlndXJlPWksaSgpfSwxNDA4Oih0LGUsbik9PntcInVzZSBzdHJpY3RcIjt0LmV4cG9ydHM9dTt2YXIgcixpPW4oOTY5Myksbz1pLkxvbmdCaXRzLGE9aS51dGY4O2Z1bmN0aW9uIHModCxlKXtyZXR1cm4gUmFuZ2VFcnJvcihcImluZGV4IG91dCBvZiByYW5nZTogXCIrdC5wb3MrXCIgKyBcIisoZXx8MSkrXCIgPiBcIit0Lmxlbil9ZnVuY3Rpb24gdSh0KXt0aGlzLmJ1Zj10LHRoaXMucG9zPTAsdGhpcy5sZW49dC5sZW5ndGh9dmFyIGMsbD1cInVuZGVmaW5lZFwiIT10eXBlb2YgVWludDhBcnJheT9mdW5jdGlvbih0KXtpZih0IGluc3RhbmNlb2YgVWludDhBcnJheXx8QXJyYXkuaXNBcnJheSh0KSlyZXR1cm4gbmV3IHUodCk7dGhyb3cgRXJyb3IoXCJpbGxlZ2FsIGJ1ZmZlclwiKX06ZnVuY3Rpb24odCl7aWYoQXJyYXkuaXNBcnJheSh0KSlyZXR1cm4gbmV3IHUodCk7dGhyb3cgRXJyb3IoXCJpbGxlZ2FsIGJ1ZmZlclwiKX0scD1mdW5jdGlvbigpe3JldHVybiBpLkJ1ZmZlcj9mdW5jdGlvbih0KXtyZXR1cm4odS5jcmVhdGU9ZnVuY3Rpb24odCl7cmV0dXJuIGkuQnVmZmVyLmlzQnVmZmVyKHQpP25ldyByKHQpOmwodCl9KSh0KX06bH07ZnVuY3Rpb24gZigpe3ZhciB0PW5ldyBvKDAsMCksZT0wO2lmKCEodGhpcy5sZW4tdGhpcy5wb3M+NCkpe2Zvcig7ZTwzOysrZSl7aWYodGhpcy5wb3M+PXRoaXMubGVuKXRocm93IHModGhpcyk7aWYodC5sbz0odC5sb3woMTI3JnRoaXMuYnVmW3RoaXMucG9zXSk8PDcqZSk+Pj4wLHRoaXMuYnVmW3RoaXMucG9zKytdPDEyOClyZXR1cm4gdH1yZXR1cm4gdC5sbz0odC5sb3woMTI3JnRoaXMuYnVmW3RoaXMucG9zKytdKTw8NyplKT4+PjAsdH1mb3IoO2U8NDsrK2UpaWYodC5sbz0odC5sb3woMTI3JnRoaXMuYnVmW3RoaXMucG9zXSk8PDcqZSk+Pj4wLHRoaXMuYnVmW3RoaXMucG9zKytdPDEyOClyZXR1cm4gdDtpZih0LmxvPSh0LmxvfCgxMjcmdGhpcy5idWZbdGhpcy5wb3NdKTw8MjgpPj4+MCx0LmhpPSh0LmhpfCgxMjcmdGhpcy5idWZbdGhpcy5wb3NdKT4+NCk+Pj4wLHRoaXMuYnVmW3RoaXMucG9zKytdPDEyOClyZXR1cm4gdDtpZihlPTAsdGhpcy5sZW4tdGhpcy5wb3M+NCl7Zm9yKDtlPDU7KytlKWlmKHQuaGk9KHQuaGl8KDEyNyZ0aGlzLmJ1Zlt0aGlzLnBvc10pPDw3KmUrMyk+Pj4wLHRoaXMuYnVmW3RoaXMucG9zKytdPDEyOClyZXR1cm4gdH1lbHNlIGZvcig7ZTw1OysrZSl7aWYodGhpcy5wb3M+PXRoaXMubGVuKXRocm93IHModGhpcyk7aWYodC5oaT0odC5oaXwoMTI3JnRoaXMuYnVmW3RoaXMucG9zXSk8PDcqZSszKT4+PjAsdGhpcy5idWZbdGhpcy5wb3MrK108MTI4KXJldHVybiB0fXRocm93IEVycm9yKFwiaW52YWxpZCB2YXJpbnQgZW5jb2RpbmdcIil9ZnVuY3Rpb24gZCh0LGUpe3JldHVybih0W2UtNF18dFtlLTNdPDw4fHRbZS0yXTw8MTZ8dFtlLTFdPDwyNCk+Pj4wfWZ1bmN0aW9uIGgoKXtpZih0aGlzLnBvcys4PnRoaXMubGVuKXRocm93IHModGhpcyw4KTtyZXR1cm4gbmV3IG8oZCh0aGlzLmJ1Zix0aGlzLnBvcys9NCksZCh0aGlzLmJ1Zix0aGlzLnBvcys9NCkpfXUuY3JlYXRlPXAoKSx1LnByb3RvdHlwZS5fc2xpY2U9aS5BcnJheS5wcm90b3R5cGUuc3ViYXJyYXl8fGkuQXJyYXkucHJvdG90eXBlLnNsaWNlLHUucHJvdG90eXBlLnVpbnQzMj0oYz00Mjk0OTY3Mjk1LGZ1bmN0aW9uKCl7aWYoYz0oMTI3JnRoaXMuYnVmW3RoaXMucG9zXSk+Pj4wLHRoaXMuYnVmW3RoaXMucG9zKytdPDEyOClyZXR1cm4gYztpZihjPShjfCgxMjcmdGhpcy5idWZbdGhpcy5wb3NdKTw8Nyk+Pj4wLHRoaXMuYnVmW3RoaXMucG9zKytdPDEyOClyZXR1cm4gYztpZihjPShjfCgxMjcmdGhpcy5idWZbdGhpcy5wb3NdKTw8MTQpPj4+MCx0aGlzLmJ1Zlt0aGlzLnBvcysrXTwxMjgpcmV0dXJuIGM7aWYoYz0oY3woMTI3JnRoaXMuYnVmW3RoaXMucG9zXSk8PDIxKT4+PjAsdGhpcy5idWZbdGhpcy5wb3MrK108MTI4KXJldHVybiBjO2lmKGM9KGN8KDE1JnRoaXMuYnVmW3RoaXMucG9zXSk8PDI4KT4+PjAsdGhpcy5idWZbdGhpcy5wb3MrK108MTI4KXJldHVybiBjO2lmKCh0aGlzLnBvcys9NSk+dGhpcy5sZW4pdGhyb3cgdGhpcy5wb3M9dGhpcy5sZW4scyh0aGlzLDEwKTtyZXR1cm4gY30pLHUucHJvdG90eXBlLmludDMyPWZ1bmN0aW9uKCl7cmV0dXJuIDB8dGhpcy51aW50MzIoKX0sdS5wcm90b3R5cGUuc2ludDMyPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy51aW50MzIoKTtyZXR1cm4gdD4+PjFeLSgxJnQpfDB9LHUucHJvdG90eXBlLmJvb2w9ZnVuY3Rpb24oKXtyZXR1cm4gMCE9PXRoaXMudWludDMyKCl9LHUucHJvdG90eXBlLmZpeGVkMzI9ZnVuY3Rpb24oKXtpZih0aGlzLnBvcys0PnRoaXMubGVuKXRocm93IHModGhpcyw0KTtyZXR1cm4gZCh0aGlzLmJ1Zix0aGlzLnBvcys9NCl9LHUucHJvdG90eXBlLnNmaXhlZDMyPWZ1bmN0aW9uKCl7aWYodGhpcy5wb3MrND50aGlzLmxlbil0aHJvdyBzKHRoaXMsNCk7cmV0dXJuIDB8ZCh0aGlzLmJ1Zix0aGlzLnBvcys9NCl9LHUucHJvdG90eXBlLmZsb2F0PWZ1bmN0aW9uKCl7aWYodGhpcy5wb3MrND50aGlzLmxlbil0aHJvdyBzKHRoaXMsNCk7dmFyIHQ9aS5mbG9hdC5yZWFkRmxvYXRMRSh0aGlzLmJ1Zix0aGlzLnBvcyk7cmV0dXJuIHRoaXMucG9zKz00LHR9LHUucHJvdG90eXBlLmRvdWJsZT1mdW5jdGlvbigpe2lmKHRoaXMucG9zKzg+dGhpcy5sZW4pdGhyb3cgcyh0aGlzLDQpO3ZhciB0PWkuZmxvYXQucmVhZERvdWJsZUxFKHRoaXMuYnVmLHRoaXMucG9zKTtyZXR1cm4gdGhpcy5wb3MrPTgsdH0sdS5wcm90b3R5cGUuYnl0ZXM9ZnVuY3Rpb24oKXt2YXIgdD10aGlzLnVpbnQzMigpLGU9dGhpcy5wb3Msbj10aGlzLnBvcyt0O2lmKG4+dGhpcy5sZW4pdGhyb3cgcyh0aGlzLHQpO3JldHVybiB0aGlzLnBvcys9dCxBcnJheS5pc0FycmF5KHRoaXMuYnVmKT90aGlzLmJ1Zi5zbGljZShlLG4pOmU9PT1uP25ldyB0aGlzLmJ1Zi5jb25zdHJ1Y3RvcigwKTp0aGlzLl9zbGljZS5jYWxsKHRoaXMuYnVmLGUsbil9LHUucHJvdG90eXBlLnN0cmluZz1mdW5jdGlvbigpe3ZhciB0PXRoaXMuYnl0ZXMoKTtyZXR1cm4gYS5yZWFkKHQsMCx0Lmxlbmd0aCl9LHUucHJvdG90eXBlLnNraXA9ZnVuY3Rpb24odCl7aWYoXCJudW1iZXJcIj09dHlwZW9mIHQpe2lmKHRoaXMucG9zK3Q+dGhpcy5sZW4pdGhyb3cgcyh0aGlzLHQpO3RoaXMucG9zKz10fWVsc2UgZG97aWYodGhpcy5wb3M+PXRoaXMubGVuKXRocm93IHModGhpcyl9d2hpbGUoMTI4JnRoaXMuYnVmW3RoaXMucG9zKytdKTtyZXR1cm4gdGhpc30sdS5wcm90b3R5cGUuc2tpcFR5cGU9ZnVuY3Rpb24odCl7c3dpdGNoKHQpe2Nhc2UgMDp0aGlzLnNraXAoKTticmVhaztjYXNlIDE6dGhpcy5za2lwKDgpO2JyZWFrO2Nhc2UgMjp0aGlzLnNraXAodGhpcy51aW50MzIoKSk7YnJlYWs7Y2FzZSAzOmZvcig7NCE9KHQ9NyZ0aGlzLnVpbnQzMigpKTspdGhpcy5za2lwVHlwZSh0KTticmVhaztjYXNlIDU6dGhpcy5za2lwKDQpO2JyZWFrO2RlZmF1bHQ6dGhyb3cgRXJyb3IoXCJpbnZhbGlkIHdpcmUgdHlwZSBcIit0K1wiIGF0IG9mZnNldCBcIit0aGlzLnBvcyl9cmV0dXJuIHRoaXN9LHUuX2NvbmZpZ3VyZT1mdW5jdGlvbih0KXtyPXQsdS5jcmVhdGU9cCgpLHIuX2NvbmZpZ3VyZSgpO3ZhciBlPWkuTG9uZz9cInRvTG9uZ1wiOlwidG9OdW1iZXJcIjtpLm1lcmdlKHUucHJvdG90eXBlLHtpbnQ2NDpmdW5jdGlvbigpe3JldHVybiBmLmNhbGwodGhpcylbZV0oITEpfSx1aW50NjQ6ZnVuY3Rpb24oKXtyZXR1cm4gZi5jYWxsKHRoaXMpW2VdKCEwKX0sc2ludDY0OmZ1bmN0aW9uKCl7cmV0dXJuIGYuY2FsbCh0aGlzKS56ekRlY29kZSgpW2VdKCExKX0sZml4ZWQ2NDpmdW5jdGlvbigpe3JldHVybiBoLmNhbGwodGhpcylbZV0oITApfSxzZml4ZWQ2NDpmdW5jdGlvbigpe3JldHVybiBoLmNhbGwodGhpcylbZV0oITEpfX0pfX0sNTkzOih0LGUsbik9PntcInVzZSBzdHJpY3RcIjt0LmV4cG9ydHM9bzt2YXIgcj1uKDE0MDgpOyhvLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKHIucHJvdG90eXBlKSkuY29uc3RydWN0b3I9bzt2YXIgaT1uKDk2OTMpO2Z1bmN0aW9uIG8odCl7ci5jYWxsKHRoaXMsdCl9by5fY29uZmlndXJlPWZ1bmN0aW9uKCl7aS5CdWZmZXImJihvLnByb3RvdHlwZS5fc2xpY2U9aS5CdWZmZXIucHJvdG90eXBlLnNsaWNlKX0sby5wcm90b3R5cGUuc3RyaW5nPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy51aW50MzIoKTtyZXR1cm4gdGhpcy5idWYudXRmOFNsaWNlP3RoaXMuYnVmLnV0ZjhTbGljZSh0aGlzLnBvcyx0aGlzLnBvcz1NYXRoLm1pbih0aGlzLnBvcyt0LHRoaXMubGVuKSk6dGhpcy5idWYudG9TdHJpbmcoXCJ1dGYtOFwiLHRoaXMucG9zLHRoaXMucG9zPU1hdGgubWluKHRoaXMucG9zK3QsdGhpcy5sZW4pKX0sby5fY29uZmlndXJlKCl9LDUwNTQ6dD0+e1widXNlIHN0cmljdFwiO3QuZXhwb3J0cz17fX0sNTk5NDoodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7ZS5TZXJ2aWNlPW4oNzk0OCl9LDc5NDg6KHQsZSxuKT0+e1widXNlIHN0cmljdFwiO3QuZXhwb3J0cz1pO3ZhciByPW4oOTY5Myk7ZnVuY3Rpb24gaSh0LGUsbil7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgdCl0aHJvdyBUeXBlRXJyb3IoXCJycGNJbXBsIG11c3QgYmUgYSBmdW5jdGlvblwiKTtyLkV2ZW50RW1pdHRlci5jYWxsKHRoaXMpLHRoaXMucnBjSW1wbD10LHRoaXMucmVxdWVzdERlbGltaXRlZD1Cb29sZWFuKGUpLHRoaXMucmVzcG9uc2VEZWxpbWl0ZWQ9Qm9vbGVhbihuKX0oaS5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShyLkV2ZW50RW1pdHRlci5wcm90b3R5cGUpKS5jb25zdHJ1Y3Rvcj1pLGkucHJvdG90eXBlLnJwY0NhbGw9ZnVuY3Rpb24gdChlLG4saSxvLGEpe2lmKCFvKXRocm93IFR5cGVFcnJvcihcInJlcXVlc3QgbXVzdCBiZSBzcGVjaWZpZWRcIik7dmFyIHM9dGhpcztpZighYSlyZXR1cm4gci5hc1Byb21pc2UodCxzLGUsbixpLG8pO2lmKHMucnBjSW1wbCl0cnl7cmV0dXJuIHMucnBjSW1wbChlLG5bcy5yZXF1ZXN0RGVsaW1pdGVkP1wiZW5jb2RlRGVsaW1pdGVkXCI6XCJlbmNvZGVcIl0obykuZmluaXNoKCksKGZ1bmN0aW9uKHQsbil7aWYodClyZXR1cm4gcy5lbWl0KFwiZXJyb3JcIix0LGUpLGEodCk7aWYobnVsbCE9PW4pe2lmKCEobiBpbnN0YW5jZW9mIGkpKXRyeXtuPWlbcy5yZXNwb25zZURlbGltaXRlZD9cImRlY29kZURlbGltaXRlZFwiOlwiZGVjb2RlXCJdKG4pfWNhdGNoKHQpe3JldHVybiBzLmVtaXQoXCJlcnJvclwiLHQsZSksYSh0KX1yZXR1cm4gcy5lbWl0KFwiZGF0YVwiLG4sZSksYShudWxsLG4pfXMuZW5kKCEwKX0pKX1jYXRjaCh0KXtyZXR1cm4gcy5lbWl0KFwiZXJyb3JcIix0LGUpLHZvaWQgc2V0VGltZW91dCgoZnVuY3Rpb24oKXthKHQpfSksMCl9ZWxzZSBzZXRUaW1lb3V0KChmdW5jdGlvbigpe2EoRXJyb3IoXCJhbHJlYWR5IGVuZGVkXCIpKX0pLDApfSxpLnByb3RvdHlwZS5lbmQ9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMucnBjSW1wbCYmKHR8fHRoaXMucnBjSW1wbChudWxsLG51bGwsbnVsbCksdGhpcy5ycGNJbXBsPW51bGwsdGhpcy5lbWl0KFwiZW5kXCIpLm9mZigpKSx0aGlzfX0sMTk0NToodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7dC5leHBvcnRzPWk7dmFyIHI9big5NjkzKTtmdW5jdGlvbiBpKHQsZSl7dGhpcy5sbz10Pj4+MCx0aGlzLmhpPWU+Pj4wfXZhciBvPWkuemVybz1uZXcgaSgwLDApO28udG9OdW1iZXI9ZnVuY3Rpb24oKXtyZXR1cm4gMH0sby56ekVuY29kZT1vLnp6RGVjb2RlPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXN9LG8ubGVuZ3RoPWZ1bmN0aW9uKCl7cmV0dXJuIDF9O3ZhciBhPWkuemVyb0hhc2g9XCJcXDBcXDBcXDBcXDBcXDBcXDBcXDBcXDBcIjtpLmZyb21OdW1iZXI9ZnVuY3Rpb24odCl7aWYoMD09PXQpcmV0dXJuIG87dmFyIGU9dDwwO2UmJih0PS10KTt2YXIgbj10Pj4+MCxyPSh0LW4pLzQyOTQ5NjcyOTY+Pj4wO3JldHVybiBlJiYocj1+cj4+PjAsbj1+bj4+PjAsKytuPjQyOTQ5NjcyOTUmJihuPTAsKytyPjQyOTQ5NjcyOTUmJihyPTApKSksbmV3IGkobixyKX0saS5mcm9tPWZ1bmN0aW9uKHQpe2lmKFwibnVtYmVyXCI9PXR5cGVvZiB0KXJldHVybiBpLmZyb21OdW1iZXIodCk7aWYoci5pc1N0cmluZyh0KSl7aWYoIXIuTG9uZylyZXR1cm4gaS5mcm9tTnVtYmVyKHBhcnNlSW50KHQsMTApKTt0PXIuTG9uZy5mcm9tU3RyaW5nKHQpfXJldHVybiB0Lmxvd3x8dC5oaWdoP25ldyBpKHQubG93Pj4+MCx0LmhpZ2g+Pj4wKTpvfSxpLnByb3RvdHlwZS50b051bWJlcj1mdW5jdGlvbih0KXtpZighdCYmdGhpcy5oaT4+PjMxKXt2YXIgZT0xK350aGlzLmxvPj4+MCxuPX50aGlzLmhpPj4+MDtyZXR1cm4gZXx8KG49bisxPj4+MCksLShlKzQyOTQ5NjcyOTYqbil9cmV0dXJuIHRoaXMubG8rNDI5NDk2NzI5Nip0aGlzLmhpfSxpLnByb3RvdHlwZS50b0xvbmc9ZnVuY3Rpb24odCl7cmV0dXJuIHIuTG9uZz9uZXcgci5Mb25nKDB8dGhpcy5sbywwfHRoaXMuaGksQm9vbGVhbih0KSk6e2xvdzowfHRoaXMubG8saGlnaDowfHRoaXMuaGksdW5zaWduZWQ6Qm9vbGVhbih0KX19O3ZhciBzPVN0cmluZy5wcm90b3R5cGUuY2hhckNvZGVBdDtpLmZyb21IYXNoPWZ1bmN0aW9uKHQpe3JldHVybiB0PT09YT9vOm5ldyBpKChzLmNhbGwodCwwKXxzLmNhbGwodCwxKTw8OHxzLmNhbGwodCwyKTw8MTZ8cy5jYWxsKHQsMyk8PDI0KT4+PjAsKHMuY2FsbCh0LDQpfHMuY2FsbCh0LDUpPDw4fHMuY2FsbCh0LDYpPDwxNnxzLmNhbGwodCw3KTw8MjQpPj4+MCl9LGkucHJvdG90eXBlLnRvSGFzaD1mdW5jdGlvbigpe3JldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKDI1NSZ0aGlzLmxvLHRoaXMubG8+Pj44JjI1NSx0aGlzLmxvPj4+MTYmMjU1LHRoaXMubG8+Pj4yNCwyNTUmdGhpcy5oaSx0aGlzLmhpPj4+OCYyNTUsdGhpcy5oaT4+PjE2JjI1NSx0aGlzLmhpPj4+MjQpfSxpLnByb3RvdHlwZS56ekVuY29kZT1mdW5jdGlvbigpe3ZhciB0PXRoaXMuaGk+PjMxO3JldHVybiB0aGlzLmhpPSgodGhpcy5oaTw8MXx0aGlzLmxvPj4+MzEpXnQpPj4+MCx0aGlzLmxvPSh0aGlzLmxvPDwxXnQpPj4+MCx0aGlzfSxpLnByb3RvdHlwZS56ekRlY29kZT1mdW5jdGlvbigpe3ZhciB0PS0oMSZ0aGlzLmxvKTtyZXR1cm4gdGhpcy5sbz0oKHRoaXMubG8+Pj4xfHRoaXMuaGk8PDMxKV50KT4+PjAsdGhpcy5oaT0odGhpcy5oaT4+PjFedCk+Pj4wLHRoaXN9LGkucHJvdG90eXBlLmxlbmd0aD1mdW5jdGlvbigpe3ZhciB0PXRoaXMubG8sZT0odGhpcy5sbz4+PjI4fHRoaXMuaGk8PDQpPj4+MCxuPXRoaXMuaGk+Pj4yNDtyZXR1cm4gMD09PW4/MD09PWU/dDwxNjM4ND90PDEyOD8xOjI6dDwyMDk3MTUyPzM6NDplPDE2Mzg0P2U8MTI4PzU6NjplPDIwOTcxNTI/Nzo4Om48MTI4Pzk6MTB9fSw5NjkzOmZ1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjt2YXIgcj1lO2Z1bmN0aW9uIGkodCxlLG4pe2Zvcih2YXIgcj1PYmplY3Qua2V5cyhlKSxpPTA7aTxyLmxlbmd0aDsrK2kpdm9pZCAwIT09dFtyW2ldXSYmbnx8KHRbcltpXV09ZVtyW2ldXSk7cmV0dXJuIHR9ZnVuY3Rpb24gbyh0KXtmdW5jdGlvbiBlKHQsbil7aWYoISh0aGlzIGluc3RhbmNlb2YgZSkpcmV0dXJuIG5ldyBlKHQsbik7T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsXCJtZXNzYWdlXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0fX0pLEVycm9yLmNhcHR1cmVTdGFja1RyYWNlP0Vycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsZSk6T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsXCJzdGFja1wiLHt2YWx1ZToobmV3IEVycm9yKS5zdGFja3x8XCJcIn0pLG4mJmkodGhpcyxuKX1yZXR1cm4oZS5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUpKS5jb25zdHJ1Y3Rvcj1lLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLnByb3RvdHlwZSxcIm5hbWVcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHR9fSksZS5wcm90b3R5cGUudG9TdHJpbmc9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5uYW1lK1wiOiBcIit0aGlzLm1lc3NhZ2V9LGV9ci5hc1Byb21pc2U9big0NTM3KSxyLmJhc2U2ND1uKDc0MTkpLHIuRXZlbnRFbWl0dGVyPW4oOTIxMSksci5mbG9hdD1uKDk0NSksci5pbnF1aXJlPW4oNzE5OSksci51dGY4PW4oNDk5Nyksci5wb29sPW4oNjY2Miksci5Mb25nQml0cz1uKDE5NDUpLHIuaXNOb2RlPUJvb2xlYW4oXCJ1bmRlZmluZWRcIiE9dHlwZW9mIGdsb2JhbCYmZ2xvYmFsJiZnbG9iYWwucHJvY2VzcyYmZ2xvYmFsLnByb2Nlc3MudmVyc2lvbnMmJmdsb2JhbC5wcm9jZXNzLnZlcnNpb25zLm5vZGUpLHIuZ2xvYmFsPXIuaXNOb2RlJiZnbG9iYWx8fFwidW5kZWZpbmVkXCIhPXR5cGVvZiB3aW5kb3cmJndpbmRvd3x8XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHNlbGYmJnNlbGZ8fHRoaXMsci5lbXB0eUFycmF5PU9iamVjdC5mcmVlemU/T2JqZWN0LmZyZWV6ZShbXSk6W10sci5lbXB0eU9iamVjdD1PYmplY3QuZnJlZXplP09iamVjdC5mcmVlemUoe30pOnt9LHIuaXNJbnRlZ2VyPU51bWJlci5pc0ludGVnZXJ8fGZ1bmN0aW9uKHQpe3JldHVyblwibnVtYmVyXCI9PXR5cGVvZiB0JiZpc0Zpbml0ZSh0KSYmTWF0aC5mbG9vcih0KT09PXR9LHIuaXNTdHJpbmc9ZnVuY3Rpb24odCl7cmV0dXJuXCJzdHJpbmdcIj09dHlwZW9mIHR8fHQgaW5zdGFuY2VvZiBTdHJpbmd9LHIuaXNPYmplY3Q9ZnVuY3Rpb24odCl7cmV0dXJuIHQmJlwib2JqZWN0XCI9PXR5cGVvZiB0fSxyLmlzc2V0PXIuaXNTZXQ9ZnVuY3Rpb24odCxlKXt2YXIgbj10W2VdO3JldHVybiEobnVsbD09bnx8IXQuaGFzT3duUHJvcGVydHkoZSkpJiYoXCJvYmplY3RcIiE9dHlwZW9mIG58fChBcnJheS5pc0FycmF5KG4pP24ubGVuZ3RoOk9iamVjdC5rZXlzKG4pLmxlbmd0aCk+MCl9LHIuQnVmZmVyPWZ1bmN0aW9uKCl7dHJ5e3ZhciB0PXIuaW5xdWlyZShcImJ1ZmZlclwiKS5CdWZmZXI7cmV0dXJuIHQucHJvdG90eXBlLnV0ZjhXcml0ZT90Om51bGx9Y2F0Y2godCl7cmV0dXJuIG51bGx9fSgpLHIuX0J1ZmZlcl9mcm9tPW51bGwsci5fQnVmZmVyX2FsbG9jVW5zYWZlPW51bGwsci5uZXdCdWZmZXI9ZnVuY3Rpb24odCl7cmV0dXJuXCJudW1iZXJcIj09dHlwZW9mIHQ/ci5CdWZmZXI/ci5fQnVmZmVyX2FsbG9jVW5zYWZlKHQpOm5ldyByLkFycmF5KHQpOnIuQnVmZmVyP3IuX0J1ZmZlcl9mcm9tKHQpOlwidW5kZWZpbmVkXCI9PXR5cGVvZiBVaW50OEFycmF5P3Q6bmV3IFVpbnQ4QXJyYXkodCl9LHIuQXJyYXk9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIFVpbnQ4QXJyYXk/VWludDhBcnJheTpBcnJheSxyLkxvbmc9ci5nbG9iYWwuZGNvZGVJTyYmci5nbG9iYWwuZGNvZGVJTy5Mb25nfHxyLmdsb2JhbC5Mb25nfHxyLmlucXVpcmUoXCJsb25nXCIpLHIua2V5MlJlPS9edHJ1ZXxmYWxzZXwwfDEkLyxyLmtleTMyUmU9L14tPyg/OjB8WzEtOV1bMC05XSopJC8sci5rZXk2NFJlPS9eKD86W1xcXFx4MDAtXFxcXHhmZl17OH18LT8oPzowfFsxLTldWzAtOV0qKSkkLyxyLmxvbmdUb0hhc2g9ZnVuY3Rpb24odCl7cmV0dXJuIHQ/ci5Mb25nQml0cy5mcm9tKHQpLnRvSGFzaCgpOnIuTG9uZ0JpdHMuemVyb0hhc2h9LHIubG9uZ0Zyb21IYXNoPWZ1bmN0aW9uKHQsZSl7dmFyIG49ci5Mb25nQml0cy5mcm9tSGFzaCh0KTtyZXR1cm4gci5Mb25nP3IuTG9uZy5mcm9tQml0cyhuLmxvLG4uaGksZSk6bi50b051bWJlcihCb29sZWFuKGUpKX0sci5tZXJnZT1pLHIubGNGaXJzdD1mdW5jdGlvbih0KXtyZXR1cm4gdC5jaGFyQXQoMCkudG9Mb3dlckNhc2UoKSt0LnN1YnN0cmluZygxKX0sci5uZXdFcnJvcj1vLHIuUHJvdG9jb2xFcnJvcj1vKFwiUHJvdG9jb2xFcnJvclwiKSxyLm9uZU9mR2V0dGVyPWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT17fSxuPTA7bjx0Lmxlbmd0aDsrK24pZVt0W25dXT0xO3JldHVybiBmdW5jdGlvbigpe2Zvcih2YXIgdD1PYmplY3Qua2V5cyh0aGlzKSxuPXQubGVuZ3RoLTE7bj4tMTstLW4paWYoMT09PWVbdFtuXV0mJnZvaWQgMCE9PXRoaXNbdFtuXV0mJm51bGwhPT10aGlzW3Rbbl1dKXJldHVybiB0W25dfX0sci5vbmVPZlNldHRlcj1mdW5jdGlvbih0KXtyZXR1cm4gZnVuY3Rpb24oZSl7Zm9yKHZhciBuPTA7bjx0Lmxlbmd0aDsrK24pdFtuXSE9PWUmJmRlbGV0ZSB0aGlzW3Rbbl1dfX0sci50b0pTT05PcHRpb25zPXtsb25nczpTdHJpbmcsZW51bXM6U3RyaW5nLGJ5dGVzOlN0cmluZyxqc29uOiEwfSxyLl9jb25maWd1cmU9ZnVuY3Rpb24oKXt2YXIgdD1yLkJ1ZmZlcjt0PyhyLl9CdWZmZXJfZnJvbT10LmZyb20hPT1VaW50OEFycmF5LmZyb20mJnQuZnJvbXx8ZnVuY3Rpb24oZSxuKXtyZXR1cm4gbmV3IHQoZSxuKX0sci5fQnVmZmVyX2FsbG9jVW5zYWZlPXQuYWxsb2NVbnNhZmV8fGZ1bmN0aW9uKGUpe3JldHVybiBuZXcgdChlKX0pOnIuX0J1ZmZlcl9mcm9tPXIuX0J1ZmZlcl9hbGxvY1Vuc2FmZT1udWxsfX0sMTE3MzoodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7dC5leHBvcnRzPXA7dmFyIHIsaT1uKDk2OTMpLG89aS5Mb25nQml0cyxhPWkuYmFzZTY0LHM9aS51dGY4O2Z1bmN0aW9uIHUodCxlLG4pe3RoaXMuZm49dCx0aGlzLmxlbj1lLHRoaXMubmV4dD12b2lkIDAsdGhpcy52YWw9bn1mdW5jdGlvbiBjKCl7fWZ1bmN0aW9uIGwodCl7dGhpcy5oZWFkPXQuaGVhZCx0aGlzLnRhaWw9dC50YWlsLHRoaXMubGVuPXQubGVuLHRoaXMubmV4dD10LnN0YXRlc31mdW5jdGlvbiBwKCl7dGhpcy5sZW49MCx0aGlzLmhlYWQ9bmV3IHUoYywwLDApLHRoaXMudGFpbD10aGlzLmhlYWQsdGhpcy5zdGF0ZXM9bnVsbH12YXIgZj1mdW5jdGlvbigpe3JldHVybiBpLkJ1ZmZlcj9mdW5jdGlvbigpe3JldHVybihwLmNyZWF0ZT1mdW5jdGlvbigpe3JldHVybiBuZXcgcn0pKCl9OmZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBwfX07ZnVuY3Rpb24gZCh0LGUsbil7ZVtuXT0yNTUmdH1mdW5jdGlvbiBoKHQsZSl7dGhpcy5sZW49dCx0aGlzLm5leHQ9dm9pZCAwLHRoaXMudmFsPWV9ZnVuY3Rpb24gZyh0LGUsbil7Zm9yKDt0LmhpOyllW24rK109MTI3JnQubG98MTI4LHQubG89KHQubG8+Pj43fHQuaGk8PDI1KT4+PjAsdC5oaT4+Pj03O2Zvcig7dC5sbz4xMjc7KWVbbisrXT0xMjcmdC5sb3wxMjgsdC5sbz10LmxvPj4+NztlW24rK109dC5sb31mdW5jdGlvbiBiKHQsZSxuKXtlW25dPTI1NSZ0LGVbbisxXT10Pj4+OCYyNTUsZVtuKzJdPXQ+Pj4xNiYyNTUsZVtuKzNdPXQ+Pj4yNH1wLmNyZWF0ZT1mKCkscC5hbGxvYz1mdW5jdGlvbih0KXtyZXR1cm4gbmV3IGkuQXJyYXkodCl9LGkuQXJyYXkhPT1BcnJheSYmKHAuYWxsb2M9aS5wb29sKHAuYWxsb2MsaS5BcnJheS5wcm90b3R5cGUuc3ViYXJyYXkpKSxwLnByb3RvdHlwZS5fcHVzaD1mdW5jdGlvbih0LGUsbil7cmV0dXJuIHRoaXMudGFpbD10aGlzLnRhaWwubmV4dD1uZXcgdSh0LGUsbiksdGhpcy5sZW4rPWUsdGhpc30saC5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZSh1LnByb3RvdHlwZSksaC5wcm90b3R5cGUuZm49ZnVuY3Rpb24odCxlLG4pe2Zvcig7dD4xMjc7KWVbbisrXT0xMjcmdHwxMjgsdD4+Pj03O2Vbbl09dH0scC5wcm90b3R5cGUudWludDMyPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmxlbis9KHRoaXMudGFpbD10aGlzLnRhaWwubmV4dD1uZXcgaCgodD4+Pj0wKTwxMjg/MTp0PDE2Mzg0PzI6dDwyMDk3MTUyPzM6dDwyNjg0MzU0NTY/NDo1LHQpKS5sZW4sdGhpc30scC5wcm90b3R5cGUuaW50MzI9ZnVuY3Rpb24odCl7cmV0dXJuIHQ8MD90aGlzLl9wdXNoKGcsMTAsby5mcm9tTnVtYmVyKHQpKTp0aGlzLnVpbnQzMih0KX0scC5wcm90b3R5cGUuc2ludDMyPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnVpbnQzMigodDw8MV50Pj4zMSk+Pj4wKX0scC5wcm90b3R5cGUudWludDY0PWZ1bmN0aW9uKHQpe3ZhciBlPW8uZnJvbSh0KTtyZXR1cm4gdGhpcy5fcHVzaChnLGUubGVuZ3RoKCksZSl9LHAucHJvdG90eXBlLmludDY0PXAucHJvdG90eXBlLnVpbnQ2NCxwLnByb3RvdHlwZS5zaW50NjQ9ZnVuY3Rpb24odCl7dmFyIGU9by5mcm9tKHQpLnp6RW5jb2RlKCk7cmV0dXJuIHRoaXMuX3B1c2goZyxlLmxlbmd0aCgpLGUpfSxwLnByb3RvdHlwZS5ib29sPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLl9wdXNoKGQsMSx0PzE6MCl9LHAucHJvdG90eXBlLmZpeGVkMzI9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuX3B1c2goYiw0LHQ+Pj4wKX0scC5wcm90b3R5cGUuc2ZpeGVkMzI9cC5wcm90b3R5cGUuZml4ZWQzMixwLnByb3RvdHlwZS5maXhlZDY0PWZ1bmN0aW9uKHQpe3ZhciBlPW8uZnJvbSh0KTtyZXR1cm4gdGhpcy5fcHVzaChiLDQsZS5sbykuX3B1c2goYiw0LGUuaGkpfSxwLnByb3RvdHlwZS5zZml4ZWQ2ND1wLnByb3RvdHlwZS5maXhlZDY0LHAucHJvdG90eXBlLmZsb2F0PWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLl9wdXNoKGkuZmxvYXQud3JpdGVGbG9hdExFLDQsdCl9LHAucHJvdG90eXBlLmRvdWJsZT1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5fcHVzaChpLmZsb2F0LndyaXRlRG91YmxlTEUsOCx0KX07dmFyIG09aS5BcnJheS5wcm90b3R5cGUuc2V0P2Z1bmN0aW9uKHQsZSxuKXtlLnNldCh0LG4pfTpmdW5jdGlvbih0LGUsbil7Zm9yKHZhciByPTA7cjx0Lmxlbmd0aDsrK3IpZVtuK3JdPXRbcl19O3AucHJvdG90eXBlLmJ5dGVzPWZ1bmN0aW9uKHQpe3ZhciBlPXQubGVuZ3RoPj4+MDtpZighZSlyZXR1cm4gdGhpcy5fcHVzaChkLDEsMCk7aWYoaS5pc1N0cmluZyh0KSl7dmFyIG49cC5hbGxvYyhlPWEubGVuZ3RoKHQpKTthLmRlY29kZSh0LG4sMCksdD1ufXJldHVybiB0aGlzLnVpbnQzMihlKS5fcHVzaChtLGUsdCl9LHAucHJvdG90eXBlLnN0cmluZz1mdW5jdGlvbih0KXt2YXIgZT1zLmxlbmd0aCh0KTtyZXR1cm4gZT90aGlzLnVpbnQzMihlKS5fcHVzaChzLndyaXRlLGUsdCk6dGhpcy5fcHVzaChkLDEsMCl9LHAucHJvdG90eXBlLmZvcms9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zdGF0ZXM9bmV3IGwodGhpcyksdGhpcy5oZWFkPXRoaXMudGFpbD1uZXcgdShjLDAsMCksdGhpcy5sZW49MCx0aGlzfSxwLnByb3RvdHlwZS5yZXNldD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnN0YXRlcz8odGhpcy5oZWFkPXRoaXMuc3RhdGVzLmhlYWQsdGhpcy50YWlsPXRoaXMuc3RhdGVzLnRhaWwsdGhpcy5sZW49dGhpcy5zdGF0ZXMubGVuLHRoaXMuc3RhdGVzPXRoaXMuc3RhdGVzLm5leHQpOih0aGlzLmhlYWQ9dGhpcy50YWlsPW5ldyB1KGMsMCwwKSx0aGlzLmxlbj0wKSx0aGlzfSxwLnByb3RvdHlwZS5sZGVsaW09ZnVuY3Rpb24oKXt2YXIgdD10aGlzLmhlYWQsZT10aGlzLnRhaWwsbj10aGlzLmxlbjtyZXR1cm4gdGhpcy5yZXNldCgpLnVpbnQzMihuKSxuJiYodGhpcy50YWlsLm5leHQ9dC5uZXh0LHRoaXMudGFpbD1lLHRoaXMubGVuKz1uKSx0aGlzfSxwLnByb3RvdHlwZS5maW5pc2g9ZnVuY3Rpb24oKXtmb3IodmFyIHQ9dGhpcy5oZWFkLm5leHQsZT10aGlzLmNvbnN0cnVjdG9yLmFsbG9jKHRoaXMubGVuKSxuPTA7dDspdC5mbih0LnZhbCxlLG4pLG4rPXQubGVuLHQ9dC5uZXh0O3JldHVybiBlfSxwLl9jb25maWd1cmU9ZnVuY3Rpb24odCl7cj10LHAuY3JlYXRlPWYoKSxyLl9jb25maWd1cmUoKX19LDMxNTU6KHQsZSxuKT0+e1widXNlIHN0cmljdFwiO3QuZXhwb3J0cz1vO3ZhciByPW4oMTE3Myk7KG8ucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoci5wcm90b3R5cGUpKS5jb25zdHJ1Y3Rvcj1vO3ZhciBpPW4oOTY5Myk7ZnVuY3Rpb24gbygpe3IuY2FsbCh0aGlzKX1mdW5jdGlvbiBhKHQsZSxuKXt0Lmxlbmd0aDw0MD9pLnV0Zjgud3JpdGUodCxlLG4pOmUudXRmOFdyaXRlP2UudXRmOFdyaXRlKHQsbik6ZS53cml0ZSh0LG4pfW8uX2NvbmZpZ3VyZT1mdW5jdGlvbigpe28uYWxsb2M9aS5fQnVmZmVyX2FsbG9jVW5zYWZlLG8ud3JpdGVCeXRlc0J1ZmZlcj1pLkJ1ZmZlciYmaS5CdWZmZXIucHJvdG90eXBlIGluc3RhbmNlb2YgVWludDhBcnJheSYmXCJzZXRcIj09PWkuQnVmZmVyLnByb3RvdHlwZS5zZXQubmFtZT9mdW5jdGlvbih0LGUsbil7ZS5zZXQodCxuKX06ZnVuY3Rpb24odCxlLG4pe2lmKHQuY29weSl0LmNvcHkoZSxuLDAsdC5sZW5ndGgpO2Vsc2UgZm9yKHZhciByPTA7cjx0Lmxlbmd0aDspZVtuKytdPXRbcisrXX19LG8ucHJvdG90eXBlLmJ5dGVzPWZ1bmN0aW9uKHQpe2kuaXNTdHJpbmcodCkmJih0PWkuX0J1ZmZlcl9mcm9tKHQsXCJiYXNlNjRcIikpO3ZhciBlPXQubGVuZ3RoPj4+MDtyZXR1cm4gdGhpcy51aW50MzIoZSksZSYmdGhpcy5fcHVzaChvLndyaXRlQnl0ZXNCdWZmZXIsZSx0KSx0aGlzfSxvLnByb3RvdHlwZS5zdHJpbmc9ZnVuY3Rpb24odCl7dmFyIGU9aS5CdWZmZXIuYnl0ZUxlbmd0aCh0KTtyZXR1cm4gdGhpcy51aW50MzIoZSksZSYmdGhpcy5fcHVzaChhLGUsdCksdGhpc30sby5fY29uZmlndXJlKCl9LDc3MTQ6KHQsZSxuKT0+e1widXNlIHN0cmljdFwiO2UuUj12b2lkIDA7Y29uc3Qgcj1uKDY5MTkpLGk9big3NDQ4KTtlLlI9bmV3IGNsYXNze2FzeW5jIGluaXQoKXt9YXN5bmMgY3JlYXRlU2Vzc2lvbkhhbmRsZXIodCxlKXtjb25zdCBuPW5ldyByLlNlc3Npb24oZSk7cmV0dXJuIGF3YWl0IG4ubG9hZE1vZGVsKHQpLG5ldyBpLk9ubnhqc1Nlc3Npb25IYW5kbGVyKG4pfX19LDQyMDA6KHQsZSxuKT0+e1widXNlIHN0cmljdFwiO2UuYzg9ZS5yWD12b2lkIDA7Y29uc3Qgcj1uKDYyMDcpLGk9big5NzE5KSxvPW4oMjE1NyksYT1uKDIzMDYpO2Uuclg9KCk9PntpZigoXCJudW1iZXJcIiE9dHlwZW9mIHIuZW52Lndhc20uaW5pdFRpbWVvdXR8fHIuZW52Lndhc20uaW5pdFRpbWVvdXQ8MCkmJihyLmVudi53YXNtLmluaXRUaW1lb3V0PTApLFwiYm9vbGVhblwiIT10eXBlb2Ygci5lbnYud2FzbS5zaW1kJiYoci5lbnYud2FzbS5zaW1kPSEwKSxcImJvb2xlYW5cIiE9dHlwZW9mIHIuZW52Lndhc20ucHJveHkmJihyLmVudi53YXNtLnByb3h5PSExKSxcIm51bWJlclwiIT10eXBlb2Ygci5lbnYud2FzbS5udW1UaHJlYWRzfHwhTnVtYmVyLmlzSW50ZWdlcihyLmVudi53YXNtLm51bVRocmVhZHMpfHxyLmVudi53YXNtLm51bVRocmVhZHM8PTApe2NvbnN0IHQ9XCJ1bmRlZmluZWRcIj09dHlwZW9mIG5hdmlnYXRvcj8oMCxpLmNwdXMpKCkubGVuZ3RoOm5hdmlnYXRvci5oYXJkd2FyZUNvbmN1cnJlbmN5O3IuZW52Lndhc20ubnVtVGhyZWFkcz1NYXRoLm1pbig0LE1hdGguY2VpbCgodHx8MSkvMikpfX0sZS5jOD1uZXcgY2xhc3N7YXN5bmMgaW5pdCgpeygwLGUuclgpKCksYXdhaXQoMCxvLmluaXRXYXNtKSgpfWFzeW5jIGNyZWF0ZVNlc3Npb25IYW5kbGVyKHQsZSl7Y29uc3Qgbj1uZXcgYS5Pbm54cnVudGltZVdlYkFzc2VtYmx5U2Vzc2lvbkhhbmRsZXI7cmV0dXJuIGF3YWl0IG4ubG9hZE1vZGVsKHQsZSksUHJvbWlzZS5yZXNvbHZlKG4pfX19LDYwMTg6ZnVuY3Rpb24odCxlLG4pe1widXNlIHN0cmljdFwiO3ZhciByPXRoaXMmJnRoaXMuX19jcmVhdGVCaW5kaW5nfHwoT2JqZWN0LmNyZWF0ZT9mdW5jdGlvbih0LGUsbixyKXt2b2lkIDA9PT1yJiYocj1uKTt2YXIgaT1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsbik7aSYmIShcImdldFwiaW4gaT8hZS5fX2VzTW9kdWxlOmkud3JpdGFibGV8fGkuY29uZmlndXJhYmxlKXx8KGk9e2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGVbbl19fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQscixpKX06ZnVuY3Rpb24odCxlLG4scil7dm9pZCAwPT09ciYmKHI9biksdFtyXT1lW25dfSksaT10aGlzJiZ0aGlzLl9fZXhwb3J0U3Rhcnx8ZnVuY3Rpb24odCxlKXtmb3IodmFyIG4gaW4gdClcImRlZmF1bHRcIj09PW58fE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLG4pfHxyKGUsdCxuKX07T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksaShuKDYyMDcpLGUpO2NvbnN0IG89big2MjA3KTt7Y29uc3QgdD1uKDc3MTQpLlI7KDAsby5yZWdpc3RlckJhY2tlbmQpKFwid2ViZ2xcIix0LC0xMCl9e2NvbnN0IHQ9big0MjAwKS5jODsoMCxvLnJlZ2lzdGVyQmFja2VuZCkoXCJjcHVcIix0LDEwKSwoMCxvLnJlZ2lzdGVyQmFja2VuZCkoXCJ3YXNtXCIsdCwxMCksKDAsby5yZWdpc3RlckJhY2tlbmQpKFwieG5ucGFja1wiLHQsOSl9fSwyNDY6KHQsZSk9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLmNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleT12b2lkIDA7Y2xhc3Mgbntjb25zdHJ1Y3Rvcih0KXtPYmplY3QuYXNzaWduKHRoaXMsdCl9Z2V0IGNhY2hlS2V5KCl7cmV0dXJuIHRoaXMuX2NhY2hlS2V5fHwodGhpcy5fY2FjaGVLZXk9T2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGhpcykuc29ydCgpLm1hcCgodD0+YCR7dGhpc1t0XX1gKSkuam9pbihcIjtcIikpLHRoaXMuX2NhY2hlS2V5fX1lLmNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleT10PT5uZXcgbih0KX0sNzc3ODoodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5BdHRyaWJ1dGU9dm9pZCAwO2NvbnN0IHI9bigxNDQ2KSxpPW4oOTM5NSksbz1uKDkxNjIpLGE9bigyNTE3KTt2YXIgcz1pLm9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnM7Y2xhc3MgdXtjb25zdHJ1Y3Rvcih0KXtpZih0aGlzLl9hdHRyaWJ1dGVzPW5ldyBNYXAsbnVsbCE9dCl7Zm9yKGNvbnN0IGUgb2YgdCllIGluc3RhbmNlb2Ygci5vbm54LkF0dHJpYnV0ZVByb3RvP3RoaXMuX2F0dHJpYnV0ZXMuc2V0KGUubmFtZSxbdS5nZXRWYWx1ZShlKSx1LmdldFR5cGUoZSldKTplIGluc3RhbmNlb2Ygcy5BdHRyaWJ1dGUmJnRoaXMuX2F0dHJpYnV0ZXMuc2V0KGUubmFtZSgpLFt1LmdldFZhbHVlKGUpLHUuZ2V0VHlwZShlKV0pO2lmKHRoaXMuX2F0dHJpYnV0ZXMuc2l6ZTx0Lmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJkdXBsaWNhdGVkIGF0dHJpYnV0ZSBuYW1lc1wiKX19c2V0KHQsZSxuKXt0aGlzLl9hdHRyaWJ1dGVzLnNldCh0LFtuLGVdKX1kZWxldGUodCl7dGhpcy5fYXR0cmlidXRlcy5kZWxldGUodCl9Z2V0RmxvYXQodCxlKXtyZXR1cm4gdGhpcy5nZXQodCxcImZsb2F0XCIsZSl9Z2V0SW50KHQsZSl7cmV0dXJuIHRoaXMuZ2V0KHQsXCJpbnRcIixlKX1nZXRTdHJpbmcodCxlKXtyZXR1cm4gdGhpcy5nZXQodCxcInN0cmluZ1wiLGUpfWdldFRlbnNvcih0LGUpe3JldHVybiB0aGlzLmdldCh0LFwidGVuc29yXCIsZSl9Z2V0RmxvYXRzKHQsZSl7cmV0dXJuIHRoaXMuZ2V0KHQsXCJmbG9hdHNcIixlKX1nZXRJbnRzKHQsZSl7cmV0dXJuIHRoaXMuZ2V0KHQsXCJpbnRzXCIsZSl9Z2V0U3RyaW5ncyh0LGUpe3JldHVybiB0aGlzLmdldCh0LFwic3RyaW5nc1wiLGUpfWdldFRlbnNvcnModCxlKXtyZXR1cm4gdGhpcy5nZXQodCxcInRlbnNvcnNcIixlKX1nZXQodCxlLG4pe2NvbnN0IHI9dGhpcy5fYXR0cmlidXRlcy5nZXQodCk7aWYodm9pZCAwPT09cil7aWYodm9pZCAwIT09bilyZXR1cm4gbjt0aHJvdyBuZXcgRXJyb3IoYHJlcXVpcmVkIGF0dHJpYnV0ZSBub3QgZm91bmQ6ICR7dH1gKX1pZihyWzFdIT09ZSl0aHJvdyBuZXcgRXJyb3IoYHR5cGUgbWlzbWF0Y2g6IGV4cGVjdGVkICR7ZX0gYnV0IGdvdCAke3JbMV19YCk7cmV0dXJuIHJbMF19c3RhdGljIGdldFR5cGUodCl7Y29uc3QgZT10IGluc3RhbmNlb2Ygci5vbm54LkF0dHJpYnV0ZVByb3RvP3QudHlwZTp0LnR5cGUoKTtzd2l0Y2goZSl7Y2FzZSByLm9ubnguQXR0cmlidXRlUHJvdG8uQXR0cmlidXRlVHlwZS5GTE9BVDpyZXR1cm5cImZsb2F0XCI7Y2FzZSByLm9ubnguQXR0cmlidXRlUHJvdG8uQXR0cmlidXRlVHlwZS5JTlQ6cmV0dXJuXCJpbnRcIjtjYXNlIHIub25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlLlNUUklORzpyZXR1cm5cInN0cmluZ1wiO2Nhc2Ugci5vbm54LkF0dHJpYnV0ZVByb3RvLkF0dHJpYnV0ZVR5cGUuVEVOU09SOnJldHVyblwidGVuc29yXCI7Y2FzZSByLm9ubnguQXR0cmlidXRlUHJvdG8uQXR0cmlidXRlVHlwZS5GTE9BVFM6cmV0dXJuXCJmbG9hdHNcIjtjYXNlIHIub25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlLklOVFM6cmV0dXJuXCJpbnRzXCI7Y2FzZSByLm9ubnguQXR0cmlidXRlUHJvdG8uQXR0cmlidXRlVHlwZS5TVFJJTkdTOnJldHVyblwic3RyaW5nc1wiO2Nhc2Ugci5vbm54LkF0dHJpYnV0ZVByb3RvLkF0dHJpYnV0ZVR5cGUuVEVOU09SUzpyZXR1cm5cInRlbnNvcnNcIjtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgYXR0cmlidXRlIHR5cGUgaXMgbm90IHN1cHBvcnRlZCB5ZXQ6ICR7ci5vbm54LkF0dHJpYnV0ZVByb3RvLkF0dHJpYnV0ZVR5cGVbZV19YCl9fXN0YXRpYyBnZXRWYWx1ZSh0KXtjb25zdCBlPXQgaW5zdGFuY2VvZiByLm9ubnguQXR0cmlidXRlUHJvdG8/dC50eXBlOnQudHlwZSgpO2lmKGU9PT1yLm9ubnguQXR0cmlidXRlUHJvdG8uQXR0cmlidXRlVHlwZS5HUkFQSHx8ZT09PXIub25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlLkdSQVBIUyl0aHJvdyBuZXcgRXJyb3IoXCJncmFwaCBhdHRyaWJ1dGUgaXMgbm90IHN1cHBvcnRlZCB5ZXRcIik7Y29uc3Qgbj10aGlzLmdldFZhbHVlTm9DaGVjayh0KTtpZihlPT09ci5vbm54LkF0dHJpYnV0ZVByb3RvLkF0dHJpYnV0ZVR5cGUuSU5UJiZhLkxvbmdVdGlsLmlzTG9uZyhuKSlyZXR1cm4gYS5Mb25nVXRpbC5sb25nVG9OdW1iZXIobik7aWYoZT09PXIub25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlLklOVFMpe2NvbnN0IHQ9bixlPW5ldyBBcnJheSh0Lmxlbmd0aCk7Zm9yKGxldCBuPTA7bjx0Lmxlbmd0aDtuKyspe2NvbnN0IHI9dFtuXTtlW25dPWEuTG9uZ1V0aWwubG9uZ1RvTnVtYmVyKHIpfXJldHVybiBlfWlmKGU9PT1yLm9ubnguQXR0cmlidXRlUHJvdG8uQXR0cmlidXRlVHlwZS5URU5TT1IpcmV0dXJuIHQgaW5zdGFuY2VvZiByLm9ubnguQXR0cmlidXRlUHJvdG8/by5UZW5zb3IuZnJvbVByb3RvKG4pOm8uVGVuc29yLmZyb21PcnRUZW5zb3Iobik7aWYoZT09PXIub25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlLlRFTlNPUlMpe2lmKHQgaW5zdGFuY2VvZiByLm9ubnguQXR0cmlidXRlUHJvdG8pcmV0dXJuIG4ubWFwKCh0PT5vLlRlbnNvci5mcm9tUHJvdG8odCkpKTtpZih0IGluc3RhbmNlb2Ygcy5BdHRyaWJ1dGUpcmV0dXJuIG4ubWFwKCh0PT5vLlRlbnNvci5mcm9tT3J0VGVuc29yKHQpKSl9aWYoZT09PXIub25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlLlNUUklORyYmdCBpbnN0YW5jZW9mIHIub25ueC5BdHRyaWJ1dGVQcm90byl7Y29uc3QgdD1uO3JldHVybigwLGEuZGVjb2RlVXRmOFN0cmluZykodCl9cmV0dXJuIGU9PT1yLm9ubnguQXR0cmlidXRlUHJvdG8uQXR0cmlidXRlVHlwZS5TVFJJTkdTJiZ0IGluc3RhbmNlb2Ygci5vbm54LkF0dHJpYnV0ZVByb3RvP24ubWFwKGEuZGVjb2RlVXRmOFN0cmluZyk6bn1zdGF0aWMgZ2V0VmFsdWVOb0NoZWNrKHQpe3JldHVybiB0IGluc3RhbmNlb2Ygci5vbm54LkF0dHJpYnV0ZVByb3RvP3RoaXMuZ2V0VmFsdWVOb0NoZWNrRnJvbU9ubnhGb3JtYXQodCk6dGhpcy5nZXRWYWx1ZU5vQ2hlY2tGcm9tT3J0Rm9ybWF0KHQpfXN0YXRpYyBnZXRWYWx1ZU5vQ2hlY2tGcm9tT25ueEZvcm1hdCh0KXtzd2l0Y2godC50eXBlKXtjYXNlIHIub25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlLkZMT0FUOnJldHVybiB0LmY7Y2FzZSByLm9ubnguQXR0cmlidXRlUHJvdG8uQXR0cmlidXRlVHlwZS5JTlQ6cmV0dXJuIHQuaTtjYXNlIHIub25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlLlNUUklORzpyZXR1cm4gdC5zO2Nhc2Ugci5vbm54LkF0dHJpYnV0ZVByb3RvLkF0dHJpYnV0ZVR5cGUuVEVOU09SOnJldHVybiB0LnQ7Y2FzZSByLm9ubnguQXR0cmlidXRlUHJvdG8uQXR0cmlidXRlVHlwZS5HUkFQSDpyZXR1cm4gdC5nO2Nhc2Ugci5vbm54LkF0dHJpYnV0ZVByb3RvLkF0dHJpYnV0ZVR5cGUuRkxPQVRTOnJldHVybiB0LmZsb2F0cztjYXNlIHIub25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlLklOVFM6cmV0dXJuIHQuaW50cztjYXNlIHIub25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlLlNUUklOR1M6cmV0dXJuIHQuc3RyaW5ncztjYXNlIHIub25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlLlRFTlNPUlM6cmV0dXJuIHQudGVuc29ycztjYXNlIHIub25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlLkdSQVBIUzpyZXR1cm4gdC5ncmFwaHM7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIGF0dHJpYnV0ZSB0eXBlOiAke3Iub25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlW3QudHlwZV19YCl9fXN0YXRpYyBnZXRWYWx1ZU5vQ2hlY2tGcm9tT3J0Rm9ybWF0KHQpe3N3aXRjaCh0LnR5cGUoKSl7Y2FzZSBzLkF0dHJpYnV0ZVR5cGUuRkxPQVQ6cmV0dXJuIHQuZigpO2Nhc2Ugcy5BdHRyaWJ1dGVUeXBlLklOVDpyZXR1cm4gdC5pKCk7Y2FzZSBzLkF0dHJpYnV0ZVR5cGUuU1RSSU5HOnJldHVybiB0LnMoKTtjYXNlIHMuQXR0cmlidXRlVHlwZS5URU5TT1I6cmV0dXJuIHQudCgpO2Nhc2Ugcy5BdHRyaWJ1dGVUeXBlLkdSQVBIOnJldHVybiB0LmcoKTtjYXNlIHMuQXR0cmlidXRlVHlwZS5GTE9BVFM6cmV0dXJuIHQuZmxvYXRzQXJyYXkoKTtjYXNlIHMuQXR0cmlidXRlVHlwZS5JTlRTOntjb25zdCBlPVtdO2ZvcihsZXQgbj0wO248dC5pbnRzTGVuZ3RoKCk7bisrKWUucHVzaCh0LmludHMobikpO3JldHVybiBlfWNhc2Ugcy5BdHRyaWJ1dGVUeXBlLlNUUklOR1M6e2NvbnN0IGU9W107Zm9yKGxldCBuPTA7bjx0LnN0cmluZ3NMZW5ndGgoKTtuKyspZS5wdXNoKHQuc3RyaW5ncyhuKSk7cmV0dXJuIGV9Y2FzZSBzLkF0dHJpYnV0ZVR5cGUuVEVOU09SUzp7Y29uc3QgZT1bXTtmb3IobGV0IG49MDtuPHQudGVuc29yc0xlbmd0aCgpO24rKyllLnB1c2godC50ZW5zb3JzKG4pKTtyZXR1cm4gZX1kZWZhdWx0OnRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgYXR0cmlidXRlIHR5cGU6ICR7cy5BdHRyaWJ1dGVUeXBlW3QudHlwZSgpXX1gKX19fWUuQXR0cmlidXRlPXV9LDcwOTE6KHQsZSxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUucmVzb2x2ZUJhY2tlbmQ9ZS5iYWNrZW5kPXZvaWQgMDtjb25zdCByPW4oNTAzOCksaT1uZXcgTWFwO2FzeW5jIGZ1bmN0aW9uIG8odCl7Y29uc3Qgbj1lLmJhY2tlbmQ7aWYodm9pZCAwIT09blt0XSYmZnVuY3Rpb24odCl7Y29uc3QgZT10O3JldHVyblwiaW5pdGlhbGl6ZVwiaW4gZSYmXCJmdW5jdGlvblwiPT10eXBlb2YgZS5pbml0aWFsaXplJiZcImNyZWF0ZVNlc3Npb25IYW5kbGVyXCJpbiBlJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBlLmNyZWF0ZVNlc3Npb25IYW5kbGVyJiZcImRpc3Bvc2VcImluIGUmJlwiZnVuY3Rpb25cIj09dHlwZW9mIGUuZGlzcG9zZX0oblt0XSkpe2NvbnN0IGU9blt0XTtsZXQgcj1lLmluaXRpYWxpemUoKTtpZihcIm9iamVjdFwiPT10eXBlb2YgciYmXCJ0aGVuXCJpbiByJiYocj1hd2FpdCByKSxyKXJldHVybiBpLnNldCh0LGUpLGV9fWUuYmFja2VuZD17d2ViZ2w6bmV3IHIuV2ViR0xCYWNrZW5kfSxlLnJlc29sdmVCYWNrZW5kPWFzeW5jIGZ1bmN0aW9uIHQoZSl7aWYoIWUpcmV0dXJuIHQoW1wid2ViZ2xcIl0pO3tjb25zdCB0PVwic3RyaW5nXCI9PXR5cGVvZiBlP1tlXTplO2Zvcihjb25zdCBlIG9mIHQpe2NvbnN0IHQ9aS5nZXQoZSk7aWYodClyZXR1cm4gdDtjb25zdCBuPWF3YWl0IG8oZSk7aWYobilyZXR1cm4gbn19dGhyb3cgbmV3IEVycm9yKFwibm8gYXZhaWxhYmxlIGJhY2tlbmQgdG8gdXNlXCIpfX0sNTAzODoodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5XZWJHTEJhY2tlbmQ9dm9pZCAwO2NvbnN0IHI9big2MjA3KSxpPW4oMzY5NCksbz1uKDY0MTYpLGE9big3MzA1KTtlLldlYkdMQmFja2VuZD1jbGFzc3tnZXQgY29udGV4dElkKCl7cmV0dXJuIHIuZW52LndlYmdsLmNvbnRleHRJZH1zZXQgY29udGV4dElkKHQpe3IuZW52LndlYmdsLmNvbnRleHRJZD10fWdldCBtYXRtdWxNYXhCYXRjaFNpemUoKXtyZXR1cm4gci5lbnYud2ViZ2wubWF0bXVsTWF4QmF0Y2hTaXplfXNldCBtYXRtdWxNYXhCYXRjaFNpemUodCl7ci5lbnYud2ViZ2wubWF0bXVsTWF4QmF0Y2hTaXplPXR9Z2V0IHRleHR1cmVDYWNoZU1vZGUoKXtyZXR1cm4gci5lbnYud2ViZ2wudGV4dHVyZUNhY2hlTW9kZX1zZXQgdGV4dHVyZUNhY2hlTW9kZSh0KXtyLmVudi53ZWJnbC50ZXh0dXJlQ2FjaGVNb2RlPXR9Z2V0IHBhY2soKXtyZXR1cm4gci5lbnYud2ViZ2wucGFja31zZXQgcGFjayh0KXtyLmVudi53ZWJnbC5wYWNrPXR9Z2V0IGFzeW5jKCl7cmV0dXJuIHIuZW52LndlYmdsLmFzeW5jfXNldCBhc3luYyh0KXtyLmVudi53ZWJnbC5hc3luYz10fWluaXRpYWxpemUoKXt0cnl7cmV0dXJuIHRoaXMuZ2xDb250ZXh0PSgwLGEuY3JlYXRlV2ViR0xDb250ZXh0KSh0aGlzLmNvbnRleHRJZCksXCJudW1iZXJcIiE9dHlwZW9mIHRoaXMubWF0bXVsTWF4QmF0Y2hTaXplJiYodGhpcy5tYXRtdWxNYXhCYXRjaFNpemU9MTYpLFwic3RyaW5nXCIhPXR5cGVvZiB0aGlzLnRleHR1cmVDYWNoZU1vZGUmJih0aGlzLnRleHR1cmVDYWNoZU1vZGU9XCJmdWxsXCIpLFwiYm9vbGVhblwiIT10eXBlb2YgdGhpcy5wYWNrJiYodGhpcy5wYWNrPSExKSxcImJvb2xlYW5cIiE9dHlwZW9mIHRoaXMuYXN5bmMmJih0aGlzLmFzeW5jPSExKSxpLkxvZ2dlci5zZXRXaXRoRW52KHIuZW52KSxpLkxvZ2dlci52ZXJib3NlKFwiV2ViR0xCYWNrZW5kXCIsYENyZWF0ZWQgV2ViR0xDb250ZXh0OiAke3R5cGVvZiB0aGlzLmdsQ29udGV4dH0gd2l0aCBtYXRtdWxNYXhCYXRjaFNpemU6ICR7dGhpcy5tYXRtdWxNYXhCYXRjaFNpemV9OyB0ZXh0dXJlQ2FjaGVNb2RlOiAke3RoaXMudGV4dHVyZUNhY2hlTW9kZX07IHBhY2s6ICR7dGhpcy5wYWNrfTsgYXN5bmM6ICR7dGhpcy5hc3luY30uYCksITB9Y2F0Y2godCl7cmV0dXJuIGkuTG9nZ2VyLndhcm5pbmcoXCJXZWJHTEJhY2tlbmRcIixgVW5hYmxlIHRvIGluaXRpYWxpemUgV2ViR0xCYWNrZW5kLiAke3R9YCksITF9fWNyZWF0ZVNlc3Npb25IYW5kbGVyKHQpe3JldHVybiBuZXcgby5XZWJHTFNlc3Npb25IYW5kbGVyKHRoaXMsdCl9ZGlzcG9zZSgpe3RoaXMuZ2xDb250ZXh0LmRpc3Bvc2UoKX19fSw1MTA3Oih0LGUsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLkNvb3Jkc0dsc2xMaWI9dm9pZCAwO2NvbnN0IHI9bigyNTE3KSxpPW4oODUyMCksbz1uKDUwNjApLGE9big3ODU5KSxzPW4oOTM5MCk7Y2xhc3MgdSBleHRlbmRzIGkuR2xzbExpYntjb25zdHJ1Y3Rvcih0KXtzdXBlcih0KX1nZXRGdW5jdGlvbnMoKXtyZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSx0aGlzLm9mZnNldFRvQ29vcmRzKCkpLHRoaXMuY29vcmRzVG9PZmZzZXQoKSksdGhpcy50b1ZlYygpKSx0aGlzLnZhbHVlRnJvbSgpKSx0aGlzLmdldENvbW1vblV0aWxGdW5jcygpKSx0aGlzLmdldElucHV0c1NhbXBsaW5nU25pcHBldHMoKSksdGhpcy5nZXRPdXRwdXRTYW1wbGluZ1NuaXBwZXQoKSl9Z2V0Q3VzdG9tVHlwZXMoKXtyZXR1cm57fX1vZmZzZXRUb0Nvb3Jkcygpe3JldHVybntvZmZzZXRUb0Nvb3JkczpuZXcgaS5HbHNsTGliUm91dGluZShcIlxcbiAgICAgIHZlYzIgb2Zmc2V0VG9Db29yZHMoaW50IG9mZnNldCwgaW50IHdpZHRoLCBpbnQgaGVpZ2h0KSB7XFxuICAgICAgICBpbnQgdCA9IG9mZnNldCAvIHdpZHRoO1xcbiAgICAgICAgaW50IHMgPSBvZmZzZXQgLSB0KndpZHRoO1xcbiAgICAgICAgdmVjMiBjb29yZHMgPSAodmVjMihzLHQpICsgdmVjMigwLjUsMC41KSkgLyB2ZWMyKHdpZHRoLCBoZWlnaHQpO1xcbiAgICAgICAgcmV0dXJuIGNvb3JkcztcXG4gICAgICB9XFxuICAgICAgXCIpfX1jb29yZHNUb09mZnNldCgpe3JldHVybntjb29yZHNUb09mZnNldDpuZXcgaS5HbHNsTGliUm91dGluZShcIlxcbiAgICAgIGludCBjb29yZHNUb09mZnNldCh2ZWMyIGNvb3JkcywgaW50IHdpZHRoLCBpbnQgaGVpZ2h0KSB7XFxuICAgICAgICBmbG9hdCBzID0gY29vcmRzLnMgKiBmbG9hdCh3aWR0aCk7XFxuICAgICAgICBmbG9hdCB0ID0gY29vcmRzLnQgKiBmbG9hdChoZWlnaHQpO1xcbiAgICAgICAgaW50IG9mZnNldCA9IGludCh0KSAqIHdpZHRoICsgaW50KHMpO1xcbiAgICAgICAgcmV0dXJuIG9mZnNldDtcXG4gICAgICB9XFxuICAgICAgXCIpfX1nZXRPdXRwdXRTYW1wbGluZ1NuaXBwZXQoKXtjb25zdCB0PXRoaXMuY29udGV4dC5vdXRwdXRUZXh0dXJlTGF5b3V0O3JldHVybiB0LmlzUGFja2VkP3RoaXMuZ2V0UGFja2VkT3V0cHV0U2FtcGxpbmdTbmlwcGV0KHQpOnRoaXMuZ2V0VW5wYWNrZWRPdXRwdXRTYW1wbGluZ1NuaXBwZXQodCl9Z2V0UGFja2VkT3V0cHV0U2FtcGxpbmdTbmlwcGV0KHQpe2NvbnN0IGU9dC51bnBhY2tlZFNoYXBlLG49W3Qud2lkdGgsdC5oZWlnaHRdLHI9e30sYT1cImdldE91dHB1dENvb3Jkc1wiO3N3aXRjaChlLmxlbmd0aCl7Y2FzZSAwOnJbYV09dGhpcy5nZXRPdXRwdXRTY2FsYXJDb29yZHMoKTticmVhaztjYXNlIDE6clthXT10aGlzLmdldE91dHB1dFBhY2tlZDFEQ29vcmRzKGUsbik7YnJlYWs7Y2FzZSAyOnJbYV09dGhpcy5nZXRPdXRwdXRQYWNrZWQyRENvb3JkcyhlLG4pO2JyZWFrO2Nhc2UgMzpyW2FdPXRoaXMuZ2V0T3V0cHV0UGFja2VkM0RDb29yZHMoZSxuKTticmVhaztkZWZhdWx0OnJbYV09dGhpcy5nZXRPdXRwdXRQYWNrZWRORENvb3JkcyhlLG4pfWNvbnN0IHM9YFxcbiAgICAgIHZvaWQgc2V0T3V0cHV0KHZlYzQgdmFsKSB7XFxuICAgICAgICAkeygwLG8uZ2V0R2xzbCkodGhpcy5jb250ZXh0LmdsQ29udGV4dC52ZXJzaW9uKS5vdXRwdXR9ID0gdmFsO1xcbiAgICAgIH1cXG4gICAgYDtyZXR1cm4gci5mbG9hdFRleHR1cmVTZXRSR0JBPW5ldyBpLkdsc2xMaWJSb3V0aW5lKHMpLHJ9Z2V0VW5wYWNrZWRPdXRwdXRTYW1wbGluZ1NuaXBwZXQodCl7Y29uc3QgZT10LnVucGFja2VkU2hhcGUsbj1bdC53aWR0aCx0LmhlaWdodF0scj17fSxhPVwiZ2V0T3V0cHV0Q29vcmRzXCI7c3dpdGNoKGUubGVuZ3RoKXtjYXNlIDA6clthXT10aGlzLmdldE91dHB1dFNjYWxhckNvb3JkcygpO2JyZWFrO2Nhc2UgMTpyW2FdPXRoaXMuZ2V0T3V0cHV0VW5wYWNrZWQxRENvb3JkcyhlLG4pO2JyZWFrO2Nhc2UgMjpyW2FdPXRoaXMuZ2V0T3V0cHV0VW5wYWNrZWQyRENvb3JkcyhlLG4pO2JyZWFrO2Nhc2UgMzpyW2FdPXRoaXMuZ2V0T3V0cHV0VW5wYWNrZWQzRENvb3JkcyhlLG4pO2JyZWFrO2Nhc2UgNDpyW2FdPXRoaXMuZ2V0T3V0cHV0VW5wYWNrZWQ0RENvb3JkcyhlLG4pO2JyZWFrO2Nhc2UgNTpyW2FdPXRoaXMuZ2V0T3V0cHV0VW5wYWNrZWQ1RENvb3JkcyhlLG4pO2JyZWFrO2Nhc2UgNjpyW2FdPXRoaXMuZ2V0T3V0cHV0VW5wYWNrZWQ2RENvb3JkcyhlLG4pO2JyZWFrO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBvdXRwdXQgZGltZW5zaW9uYWxpdHk6ICR7ZS5sZW5ndGh9YCl9Y29uc3Qgcz1gXFxuICAgICAgICB2b2lkIHNldE91dHB1dChmbG9hdCB2YWwpIHtcXG4gICAgICAgICAgJHsoMCxvLmdldEdsc2wpKHRoaXMuY29udGV4dC5nbENvbnRleHQudmVyc2lvbikub3V0cHV0fSA9IHZlYzQodmFsLCAwLCAwLCAwKTtcXG4gICAgICAgIH1cXG4gICAgYDtyZXR1cm4gci5mbG9hdFRleHR1cmVTZXRSPW5ldyBpLkdsc2xMaWJSb3V0aW5lKHMpLHJ9Z2V0T3V0cHV0U2NhbGFyQ29vcmRzKCl7cmV0dXJuIG5ldyBpLkdsc2xMaWJSb3V0aW5lKFwiXFxuICAgICAgaW50IGdldE91dHB1dENvb3JkcygpIHtcXG4gICAgICAgIHJldHVybiAwO1xcbiAgICAgIH1cXG4gICAgXCIpfWdldE91dHB1dFBhY2tlZDFEQ29vcmRzKHQsZSl7Y29uc3Qgbj1lO2xldCByPVwiXCI7cmV0dXJuIDE9PT1uWzBdPyhyPWBcXG4gICAgICAgICAgaW50IGdldE91dHB1dENvb3JkcygpIHtcXG4gICAgICAgICAgICByZXR1cm4gMiAqIGludChUZXhDb29yZHMueSAqICR7blsxXX0uMCk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIGAsbmV3IGkuR2xzbExpYlJvdXRpbmUocikpOjE9PT1uWzFdPyhyPWBcXG4gICAgICAgICAgaW50IGdldE91dHB1dENvb3JkcygpIHtcXG4gICAgICAgICAgICByZXR1cm4gMiAqIGludChUZXhDb29yZHMueCAqICR7blswXX0uMCk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIGAsbmV3IGkuR2xzbExpYlJvdXRpbmUocikpOihyPWBcXG4gICAgICAgIGludCBnZXRPdXRwdXRDb29yZHMoKSB7XFxuICAgICAgICAgIGl2ZWMyIHJlc1RleFJDID0gaXZlYzIoVGV4Q29vcmRzLnh5ICpcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZWMyKCR7blswXX0sICR7blsxXX0pKTtcXG4gICAgICAgICAgcmV0dXJuIDIgKiAocmVzVGV4UkMueSAqICR7blswXX0gKyByZXNUZXhSQy54KTtcXG4gICAgICAgIH1cXG4gICAgICBgLG5ldyBpLkdsc2xMaWJSb3V0aW5lKHIpKX1nZXRPdXRwdXRQYWNrZWQyRENvb3Jkcyh0LGUpe2xldCBuPVwiXCI7aWYoci5BcnJheVV0aWwuYXJyYXlzRXF1YWwodCxlKSlyZXR1cm4gbj1gXFxuICAgICAgICBpdmVjMiBnZXRPdXRwdXRDb29yZHMoKSB7XFxuICAgICAgICAgIHJldHVybiAyICogaXZlYzIoVGV4Q29vcmRzLnh5ICogdmVjMigke2VbMF19LCAke2VbMV19KSk7XFxuICAgICAgICB9XFxuICAgICAgYCxuZXcgaS5HbHNsTGliUm91dGluZShuKTtjb25zdCBvPWUsYT1NYXRoLmNlaWwodFsxXS8yKTtyZXR1cm4gbj1gXFxuICAgICAgICBpdmVjMiBnZXRPdXRwdXRDb29yZHMoKSB7XFxuICAgICAgICAgIGl2ZWMyIHJlc1RleFJDID0gaXZlYzIoVGV4Q29vcmRzLnh5ICpcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIoJHtvWzBdfSwgJHtvWzFdfSkpO1xcblxcbiAgICAgICAgICBpbnQgaW5kZXggPSByZXNUZXhSQy55ICogJHtvWzBdfSArIHJlc1RleFJDLng7XFxuXFxuICAgICAgICAgIC8vIHJldmVyc2UgciBhbmQgYyBvcmRlciBmb3IgcGFja2VkIHRleHR1cmVcXG4gICAgICAgICAgaW50IHIgPSBpbW9kKGluZGV4LCAke2F9KSAqIDI7XFxuICAgICAgICAgIGludCBjID0gMiAqIChpbmRleCAvICR7YX0pO1xcblxcbiAgICAgICAgICByZXR1cm4gaXZlYzIociwgYyk7XFxuICAgICAgICB9XFxuICAgICAgYCxuZXcgaS5HbHNsTGliUm91dGluZShuKX1nZXRPdXRwdXRQYWNrZWQzRENvb3Jkcyh0LGUpe2NvbnN0IG49W2VbMF0sZVsxXV0scj1NYXRoLmNlaWwodFsyXS8yKSxvPXIqTWF0aC5jZWlsKHRbMV0vMiksYT1gXFxuICAgICAgICBpdmVjMyBnZXRPdXRwdXRDb29yZHMoKSB7XFxuICAgICAgICAgIGl2ZWMyIHJlc1RleFJDID0gaXZlYzIoVGV4Q29vcmRzLnh5ICpcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIoJHtuWzBdfSwgJHtuWzFdfSkpO1xcbiAgICAgICAgICBpbnQgaW5kZXggPSByZXNUZXhSQy55ICogJHtuWzBdfSArIHJlc1RleFJDLng7XFxuXFxuICAgICAgICAgIGludCBiID0gaW5kZXggLyAke299O1xcbiAgICAgICAgICBpbmRleCAtPSBiICogJHtvfTtcXG5cXG4gICAgICAgICAgLy8gcmV2ZXJzZSByIGFuZCBjIG9yZGVyIGZvciBwYWNrZWQgdGV4dHVyZVxcbiAgICAgICAgICBpbnQgciA9IGltb2QoaW5kZXgsICR7cn0pICogMjtcXG4gICAgICAgICAgaW50IGMgPSAyICogKGluZGV4IC8gJHtyfSk7XFxuXFxuICAgICAgICAgIHJldHVybiBpdmVjMyhiLCByLCBjKTtcXG4gICAgICAgIH1cXG4gICAgICBgO3JldHVybiBuZXcgaS5HbHNsTGliUm91dGluZShhKX1nZXRPdXRwdXRQYWNrZWRORENvb3Jkcyh0LGUpe2NvbnN0IG49W2VbMF0sZVsxXV0scj1NYXRoLmNlaWwodFt0Lmxlbmd0aC0xXS8yKSxvPXIqTWF0aC5jZWlsKHRbdC5sZW5ndGgtMl0vMik7bGV0IGE9byxzPVwiXCIsdT1cImIsIHIsIGNcIjtmb3IobGV0IGU9MjtlPHQubGVuZ3RoLTE7ZSsrKWEqPXRbdC5sZW5ndGgtZS0xXSxzPWBcXG4gICAgICBpbnQgYiR7ZX0gPSBpbmRleCAvICR7YX07XFxuICAgICAgaW5kZXggLT0gYiR7ZX0gKiAke2F9O1xcbiAgICBgK3MsdT1gYiR7ZX0sIGArdTtjb25zdCBjPWBcXG4gICAgICBpdmVjJHt0Lmxlbmd0aH0gZ2V0T3V0cHV0Q29vcmRzKCkge1xcbiAgICAgICAgaXZlYzIgcmVzVGV4UkMgPSBpdmVjMihUZXhDb29yZHMueHkgKlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIoJHtuWzBdfSwgJHtuWzFdfSkpO1xcbiAgICAgICAgaW50IGluZGV4ID0gcmVzVGV4UkMueSAqICR7blswXX0gKyByZXNUZXhSQy54O1xcblxcbiAgICAgICAgJHtzfVxcblxcbiAgICAgICAgaW50IGIgPSBpbmRleCAvICR7b307XFxuICAgICAgICBpbmRleCAtPSBiICogJHtvfTtcXG5cXG4gICAgICAgIC8vIHJldmVyc2UgciBhbmQgYyBvcmRlciBmb3IgcGFja2VkIHRleHR1cmVcXG4gICAgICAgIGludCByID0gaW1vZChpbmRleCwgJHtyfSkgKiAyO1xcbiAgICAgICAgaW50IGMgPSAyICogKGluZGV4IC8gJHtyfSk7XFxuXFxuICAgICAgICByZXR1cm4gaXZlYyR7dC5sZW5ndGh9KCR7dX0pO1xcbiAgICAgIH1cXG4gICAgYDtyZXR1cm4gbmV3IGkuR2xzbExpYlJvdXRpbmUoYyl9Z2V0T3V0cHV0VW5wYWNrZWQxRENvb3Jkcyh0LGUpe2NvbnN0IG49YFxcbiAgICAgICAgaW50IGdldE91dHB1dENvb3JkcygpIHtcXG4gICAgICAgICAgaXZlYzIgcmVzVGV4UkMgPSBpdmVjMihUZXhDb29yZHMueHkgKlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVjMigke2VbMF19LCAke2VbMV19KSk7XFxuICAgICAgICAgIHJldHVybiByZXNUZXhSQy55ICogJHtlWzBdfSArIHJlc1RleFJDLng7XFxuICAgICAgICB9XFxuICAgICAgYDtyZXR1cm4gbmV3IGkuR2xzbExpYlJvdXRpbmUobil9Z2V0T3V0cHV0VW5wYWNrZWQyRENvb3Jkcyh0LGUpe2NvbnN0IG49YFxcbiAgICAgICAgaXZlYzIgZ2V0T3V0cHV0Q29vcmRzKCkge1xcbiAgICAgICAgICBpdmVjMiByZXNUZXhSQyA9IGl2ZWMyKFRleENvb3Jkcy54eSAqXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZWMyKCR7ZVswXX0sICR7ZVsxXX0pKTtcXG4gICAgICAgICAgaW50IGluZGV4ID0gcmVzVGV4UkMueSAqICR7ZVswXX0gKyByZXNUZXhSQy54O1xcbiAgICAgICAgICBpbnQgciA9IGluZGV4IC8gJHt0WzFdfTtcXG4gICAgICAgICAgaW50IGMgPSBpbmRleCAtIHIgKiAke3RbMV19O1xcbiAgICAgICAgICByZXR1cm4gaXZlYzIociwgYyk7XFxuICAgICAgICB9XFxuICAgICAgYDtyZXR1cm4gbmV3IGkuR2xzbExpYlJvdXRpbmUobil9Z2V0T3V0cHV0VW5wYWNrZWQzRENvb3Jkcyh0LGUpe2xldCBuPVwiXCI7Y29uc3Qgcj10Lmxlbmd0aDtsZXQgbz1udWxsO3I8MiYmKG89W10pLG89bmV3IEFycmF5KHItMSksb1tyLTJdPXRbci0xXTtmb3IobGV0IGU9ci0zO2U+PTA7LS1lKW9bZV09b1tlKzFdKnRbZSsxXTtjb25zdCBhPVtcInJcIixcImNcIixcImRcIl0scz1vLm1hcCgoKHQsZSk9PmBpbnQgJHthW2VdfSA9IGluZGV4IC8gJHt0fTsgJHtlPT09by5sZW5ndGgtMT9gaW50ICR7YVtlKzFdfSA9IGluZGV4IC0gJHthW2VdfSAqICR7dH1gOmBpbmRleCAtPSAke2FbZV19ICogJHt0fWB9O2ApKS5qb2luKFwiXCIpO3JldHVybiBuPWBcXG4gICAgICAgIGl2ZWMzIGdldE91dHB1dENvb3JkcygpIHtcXG4gICAgICAgICAgaXZlYzIgcmVzVGV4UkMgPSBpdmVjMihUZXhDb29yZHMueHkgKlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVjMigke2VbMF19LCAke2VbMV19KSk7XFxuICAgICAgICAgIGludCBpbmRleCA9IHJlc1RleFJDLnkgKiAke2VbMF19ICsgcmVzVGV4UkMueDtcXG4gICAgICAgICAgJHtzfVxcbiAgICAgICAgICByZXR1cm4gaXZlYzMociwgYywgZCk7XFxuICAgICAgICB9XFxuICAgICAgYCxuZXcgaS5HbHNsTGliUm91dGluZShuKX1nZXRPdXRwdXRVbnBhY2tlZDREQ29vcmRzKHQsZSl7bGV0IG49XCJcIjtjb25zdCByPXQubGVuZ3RoO2xldCBvPW51bGw7cjwyJiYobz1bXSksbz1uZXcgQXJyYXkoci0xKSxvW3ItMl09dFtyLTFdO2ZvcihsZXQgZT1yLTM7ZT49MDstLWUpb1tlXT1vW2UrMV0qdFtlKzFdO2NvbnN0IGE9W1wiclwiLFwiY1wiLFwiZFwiLFwiZDJcIl0scz1vLm1hcCgoKHQsZSk9PmBpbnQgJHthW2VdfSA9IGluZGV4IC8gJHt0fTsgJHtlPT09by5sZW5ndGgtMT9gaW50ICR7YVtlKzFdfSA9IGluZGV4IC0gJHthW2VdfSAqICR7dH1gOmBpbmRleCAtPSAke2FbZV19ICogJHt0fWB9O2ApKS5qb2luKFwiXCIpO3JldHVybiBuPWBcXG4gICAgICBpdmVjNCBnZXRPdXRwdXRDb29yZHMoKSB7XFxuICAgICAgICAgIGl2ZWMyIHJlc1RleFJDID0gaXZlYzIoVGV4Q29vcmRzLnh5ICpcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIoJHtlWzBdfSwgJHtlWzFdfSkpO1xcbiAgICAgICAgICBpbnQgaW5kZXggPSByZXNUZXhSQy55ICogJHtlWzBdfSArIHJlc1RleFJDLng7XFxuICAgICAgICAgICR7c31cXG4gICAgICAgICAgcmV0dXJuIGl2ZWM0KHIsIGMsIGQsIGQyKTtcXG4gICAgICAgIH1cXG4gICAgICBgLG5ldyBpLkdsc2xMaWJSb3V0aW5lKG4pfWdldE91dHB1dFVucGFja2VkNURDb29yZHModCxlKXtsZXQgbj1cIlwiO2NvbnN0IHI9dC5sZW5ndGg7bGV0IG89bnVsbDtyPDImJihvPVtdKSxvPW5ldyBBcnJheShyLTEpLG9bci0yXT10W3ItMV07Zm9yKGxldCBlPXItMztlPj0wOy0tZSlvW2VdPW9bZSsxXSp0W2UrMV07Y29uc3QgYT1bXCJyXCIsXCJjXCIsXCJkXCIsXCJkMlwiLFwiZDNcIl0scz1vLm1hcCgoKHQsZSk9PmBpbnQgJHthW2VdfSA9IGluZGV4IC8gJHt0fTsgJHtlPT09by5sZW5ndGgtMT9gaW50ICR7YVtlKzFdfSA9IGluZGV4IC0gJHthW2VdfSAqICR7dH1gOmBpbmRleCAtPSAke2FbZV19ICogJHt0fWB9O2ApKS5qb2luKFwiXCIpO3JldHVybiBuPWBcXG4gICAgICBpdmVjNSBnZXRPdXRwdXRDb29yZHMoKSB7XFxuICAgICAgICAgIGl2ZWMyIHJlc1RleFJDID0gaXZlYzIoVGV4Q29vcmRzLnh5ICpcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIoJHtlWzBdfSwgJHtlWzFdfSkpO1xcbiAgICAgICAgICBpbnQgaW5kZXggPSByZXNUZXhSQy55ICogJHtlWzBdfSArIHJlc1RleFJDLng7XFxuICAgICAgICAgICR7c31cXG4gICAgICAgICAgcmV0dXJuIGl2ZWM1KHIsIGMsIGQsIGQyLCBkMyk7XFxuICAgICAgICB9XFxuICAgICAgYCxuZXcgaS5HbHNsTGliUm91dGluZShuKX1nZXRPdXRwdXRVbnBhY2tlZDZEQ29vcmRzKHQsZSl7bGV0IG49XCJcIjtjb25zdCByPXQubGVuZ3RoO2xldCBvPW51bGw7cjwyJiYobz1bXSksbz1uZXcgQXJyYXkoci0xKSxvW3ItMl09dFtyLTFdO2ZvcihsZXQgZT1yLTM7ZT49MDstLWUpb1tlXT1vW2UrMV0qdFtlKzFdO2NvbnN0IGE9W1wiclwiLFwiY1wiLFwiZFwiLFwiZDJcIixcImQzXCIsXCJkNFwiXSxzPW8ubWFwKCgodCxlKT0+YGludCAke2FbZV19ID0gaW5kZXggLyAke3R9OyAke2U9PT1vLmxlbmd0aC0xP2BpbnQgJHthW2UrMV19ID0gaW5kZXggLSAke2FbZV19ICogJHt0fWA6YGluZGV4IC09ICR7YVtlXX0gKiAke3R9YH07YCkpLmpvaW4oXCJcIik7cmV0dXJuIG49YFxcbiAgICAgaXZlYzYgZ2V0T3V0cHV0Q29vcmRzKCkge1xcbiAgICAgICAgIGl2ZWMyIHJlc1RleFJDID0gaXZlYzIoVGV4Q29vcmRzLnh5ICpcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVjMigke2VbMF19LCAke2VbMV19KSk7XFxuICAgICAgICAgaW50IGluZGV4ID0gcmVzVGV4UkMueSAqICR7ZVswXX0gKyByZXNUZXhSQy54O1xcbiAgICAgICAgICR7c31cXG4gICAgICAgICByZXR1cm4gaXZlYzYociwgYywgZCwgZDIsIGQzLCBkNCk7XFxuICAgICAgIH1cXG4gICAgIGAsbmV3IGkuR2xzbExpYlJvdXRpbmUobil9Z2V0Q29tbW9uVXRpbEZ1bmNzKCl7Y29uc3QgdD17fTtsZXQgZT1cInV2RnJvbUZsYXRcIjt0W2VdPW5ldyBpLkdsc2xMaWJSb3V0aW5lKFwiXFxuICAgIHZlYzIgdXZGcm9tRmxhdChpbnQgdGV4TnVtUiwgaW50IHRleE51bUMsIGludCBpbmRleCkge1xcbiAgICAgIGludCB0ZXhDID0gaW5kZXggLyB0ZXhOdW1SO1xcbiAgICAgIGludCB0ZXhSID0gaW5kZXggLSB0ZXhDICogdGV4TnVtUjtcXG4gICAgICAvLyBUT0RPOiBzd2FwIHRleFIsIHRleEMgb3JkZXIgaW4gZm9sbG93aW5nIGZ1bmN0aW9uIHNvIHJvdyBpcyBjb3JyZXNwb25kaW5nIHRvIHUgYW5kIGNvbHVtbiBpcyBjb3JyZXNwb25kaW5nIHRvXFxuICAgICAgLy8gICAgICAgdi5cXG4gICAgICByZXR1cm4gKHZlYzIodGV4UiwgdGV4QykgKyBoYWxmQ1IpIC8gdmVjMih0ZXhOdW1SLCB0ZXhOdW1DKTtcXG4gICAgfVxcbiAgICBcIiksZT1cInBhY2tlZFVWZnJvbTFEXCIsdFtlXT1uZXcgaS5HbHNsTGliUm91dGluZShcIlxcbiAgICAgIHZlYzIgcGFja2VkVVZmcm9tMUQoaW50IHRleE51bVIsIGludCB0ZXhOdW1DLCBpbnQgaW5kZXgpIHtcXG4gICAgICAgIGludCB0ZXhlbEluZGV4ID0gaW5kZXggLyAyO1xcbiAgICAgICAgaW50IHRleFIgPSB0ZXhlbEluZGV4IC8gdGV4TnVtQztcXG4gICAgICAgIGludCB0ZXhDID0gdGV4ZWxJbmRleCAtIHRleFIgKiB0ZXhOdW1DO1xcbiAgICAgICAgcmV0dXJuICh2ZWMyKHRleEMsIHRleFIpICsgaGFsZkNSKSAvIHZlYzIodGV4TnVtQywgdGV4TnVtUik7XFxuICAgICAgfVxcbiAgICAgIFwiKSxlPVwicGFja2VkVVZmcm9tMkRcIix0W2VdPW5ldyBpLkdsc2xMaWJSb3V0aW5lKFwiXFxuICAgICAgdmVjMiBwYWNrZWRVVmZyb20yRChpbnQgdGV4TnVtUiwgaW50IHRleE51bUMsIGludCB0ZXhlbHNJbkxvZ2ljYWxSb3csIGludCByb3csIGludCBjb2wpIHtcXG4gICAgICAgIGludCB0ZXhlbEluZGV4ID0gKHJvdyAvIDIpICogdGV4ZWxzSW5Mb2dpY2FsUm93ICsgKGNvbCAvIDIpO1xcbiAgICAgICAgaW50IHRleFIgPSB0ZXhlbEluZGV4IC8gdGV4TnVtQztcXG4gICAgICAgIGludCB0ZXhDID0gdGV4ZWxJbmRleCAtIHRleFIgKiB0ZXhOdW1DO1xcbiAgICAgICAgcmV0dXJuICh2ZWMyKHRleEMsIHRleFIpICsgaGFsZkNSKSAvIHZlYzIodGV4TnVtQywgdGV4TnVtUik7XFxuICAgICAgfVxcbiAgICAgIFwiKSxlPVwicGFja2VkVVZmcm9tM0RcIix0W2VdPW5ldyBpLkdsc2xMaWJSb3V0aW5lKFwiXFxuICAgICAgdmVjMiBwYWNrZWRVVmZyb20zRChpbnQgdGV4TnVtUiwgaW50IHRleE51bUMsXFxuICAgICAgICAgIGludCB0ZXhlbHNJbkJhdGNoLCBpbnQgdGV4ZWxzSW5Mb2dpY2FsUm93LCBpbnQgYixcXG4gICAgICAgICAgaW50IHJvdywgaW50IGNvbCkge1xcbiAgICAgICAgaW50IGluZGV4ID0gYiAqIHRleGVsc0luQmF0Y2ggKyAocm93IC8gMikgKiB0ZXhlbHNJbkxvZ2ljYWxSb3cgKyAoY29sIC8gMik7XFxuICAgICAgICBpbnQgdGV4UiA9IGluZGV4IC8gdGV4TnVtQztcXG4gICAgICAgIGludCB0ZXhDID0gaW5kZXggLSB0ZXhSICogdGV4TnVtQztcXG4gICAgICAgIHJldHVybiAodmVjMih0ZXhDLCB0ZXhSKSArIGhhbGZDUikgLyB2ZWMyKHRleE51bUMsIHRleE51bVIpO1xcbiAgICAgIH1cXG4gICAgICBcIiksZT1cInNhbXBsZVRleHR1cmVcIjtjb25zdCBuPSgwLG8uZ2V0R2xzbCkodGhpcy5jb250ZXh0LmdsQ29udGV4dC52ZXJzaW9uKTtyZXR1cm4gdFtlXT1uZXcgaS5HbHNsTGliUm91dGluZShgXFxuICAgICAgICBmbG9hdCBzYW1wbGVUZXh0dXJlKHNhbXBsZXIyRCB0ZXh0dXJlU2FtcGxlciwgdmVjMiB1dikge1xcbiAgICAgICAgICAgIHJldHVybiAke24udGV4dHVyZTJEfSh0ZXh0dXJlU2FtcGxlciwgdXYpLnI7XFxuICAgICAgICB9YCksdH1nZXRJbnB1dHNTYW1wbGluZ1NuaXBwZXRzKCl7Y29uc3QgdD17fSxlPXRoaXMuY29udGV4dC5vdXRwdXRUZXh0dXJlTGF5b3V0O3JldHVybiB0aGlzLmNvbnRleHQucHJvZ3JhbUluZm8uaW5wdXROYW1lcy5mb3JFYWNoKCgobixyKT0+e2NvbnN0IGk9dGhpcy5jb250ZXh0LmlucHV0VGV4dHVyZUxheW91dHNbcl0sbz0oMCxzLmdlbmVyYXRlU2hhZGVyRnVuY05hbWVGcm9tSW5wdXRTYW1wbGVyTmFtZSkobik7aS5pc1BhY2tlZD90W29dPXRoaXMuZ2V0UGFja2VkU2FtcGxlckZyb21JbnB1dChvLG4saSk6dFtvXT10aGlzLmdldFVucGFja2VkU2FtcGxlckZyb21JbnB1dChvLG4saSk7Y29uc3QgYT0oMCxzLmdlbmVyYXRlU2hhZGVyRnVuY05hbWVGcm9tSW5wdXRTYW1wbGVyTmFtZUF0T3V0Q29vcmRzKShuKTtpLnVucGFja2VkU2hhcGUubGVuZ3RoPD1lLnVucGFja2VkU2hhcGUubGVuZ3RoJiYoaS5pc1BhY2tlZD90W2FdPXRoaXMuZ2V0UGFja2VkU2FtcGxlckF0T3V0cHV0Q29vcmRzKGEsaSxlLG4pOnRbYV09dGhpcy5nZXRVbnBhY2tlZFNhbXBsZXJBdE91dHB1dENvb3JkcyhhLGksZSxuKSl9KSksdH1nZXRQYWNrZWRTYW1wbGVyQXRPdXRwdXRDb29yZHModCxlLG4sbyl7Y29uc3QgYT1lLnVucGFja2VkU2hhcGUsdT1uLnVucGFja2VkU2hhcGUsYz1vLGw9KDAscy5nZW5lcmF0ZVNoYWRlckZ1bmNOYW1lRnJvbUlucHV0U2FtcGxlck5hbWUpKGMpLHA9YS5sZW5ndGgsZj11Lmxlbmd0aCxkPXIuQnJvYWRjYXN0VXRpbC5nZXRCcm9hZGNhc3REaW1zKGEsdSksaD0oMCxzLmdldENvb3Jkc0RhdGFUeXBlKShmKSxnPWYtcDtsZXQgYjtjb25zdCBtPSgwLHMuZ2V0R2xDaGFubmVscykoKTtiPTA9PT1wP1wiXCI6ZjwyJiZkLmxlbmd0aD49MT9cImNvb3JkcyA9IDA7XCI6ZC5tYXAoKHQ9PmBjb29yZHMuJHttW3QrZ119ID0gMDtgKSkuam9pbihcIlxcblwiKTtsZXQgeT1cIlwiO3k9ZjwyJiZwPjA/XCJjb29yZHNcIjphLm1hcCgoKHQsZSk9PmBjb29yZHMuJHttW2UrZ119YCkpLmpvaW4oXCIsIFwiKTtsZXQgXz1cInJldHVybiBvdXRwdXRWYWx1ZTtcIjtjb25zdCB2PTE9PT1yLlNoYXBlVXRpbC5zaXplKGEpLHc9MT09PXIuU2hhcGVVdGlsLnNpemUodSk7aWYoMSE9PXB8fHZ8fHcpe2lmKHYmJiF3KV89MT09PWY/XCJcXG4gICAgICAgICAgcmV0dXJuIHZlYzQob3V0cHV0VmFsdWUueCwgb3V0cHV0VmFsdWUueCwgMC4sIDAuKTtcXG4gICAgICAgIFwiOlwiXFxuICAgICAgICAgIHJldHVybiB2ZWM0KG91dHB1dFZhbHVlLngpO1xcbiAgICAgICAgXCI7ZWxzZSBpZihkLmxlbmd0aCl7Y29uc3QgdD1wLTIsZT1wLTE7ZC5pbmRleE9mKHQpPi0xJiZkLmluZGV4T2YoZSk+LTE/Xz1cInJldHVybiB2ZWM0KG91dHB1dFZhbHVlLngpO1wiOmQuaW5kZXhPZih0KT4tMT9fPVwicmV0dXJuIHZlYzQob3V0cHV0VmFsdWUueCwgb3V0cHV0VmFsdWUueSwgb3V0cHV0VmFsdWUueCwgb3V0cHV0VmFsdWUueSk7XCI6ZC5pbmRleE9mKGUpPi0xJiYoXz1cInJldHVybiB2ZWM0KG91dHB1dFZhbHVlLnh4LCBvdXRwdXRWYWx1ZS56eik7XCIpfX1lbHNlIF89XCJcXG4gICAgICAgIHJldHVybiB2ZWM0KG91dHB1dFZhbHVlLnh5LCBvdXRwdXRWYWx1ZS54eSk7XFxuICAgICAgXCI7Y29uc3QgeD1gXFxuICAgICAgdmVjNCAke3R9KCkge1xcbiAgICAgICAgJHtofSBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIFxcbiAgICAgICAgaW50IGxhc3REaW0gPSBjb29yZHMuJHttW2YtMV19O1xcbiAgICAgICAgY29vcmRzLiR7bVtmLTFdfSA9IGNvb3Jkcy4ke21bZi0yXX07XFxuICAgICAgICBjb29yZHMuJHttW2YtMl19ID0gbGFzdERpbTtcXG4gICAgICBcXG4gICAgICAgICR7Yn1cXG4gICAgICAgIHZlYzQgb3V0cHV0VmFsdWUgPSAke2x9KCR7eX0pO1xcbiAgICAgICAgJHtffVxcbiAgICAgIH1cXG4gICAgYDtyZXR1cm4gbmV3IGkuR2xzbExpYlJvdXRpbmUoeCxbXCJjb29yZGluYXRlcy5nZXRPdXRwdXRDb29yZHNcIl0pfWdldFVucGFja2VkU2FtcGxlckF0T3V0cHV0Q29vcmRzKHQsZSxuLG8pe2NvbnN0IGE9W24ud2lkdGgsbi5oZWlnaHRdLHU9W2Uud2lkdGgsZS5oZWlnaHRdLGM9ZS51bnBhY2tlZFNoYXBlLmxlbmd0aCxsPW4udW5wYWNrZWRTaGFwZS5sZW5ndGgscD1lLnVucGFja2VkU2hhcGUsZj1uLnVucGFja2VkU2hhcGUsZD0oMCxzLmdlbmVyYXRlU2hhZGVyRnVuY05hbWVGcm9tSW5wdXRTYW1wbGVyTmFtZSkobyk7aWYoYz09PWwmJnIuQXJyYXlVdGlsLmFycmF5c0VxdWFsKHUsYSkpe2NvbnN0IGU9YFxcbiAgICAgICAgICBmbG9hdCAke3R9KCkge1xcbiAgICAgICAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKCR7b30sIFRleENvb3Jkcyk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIGA7cmV0dXJuIG5ldyBpLkdsc2xMaWJSb3V0aW5lKGUsW1wiY29vcmRpbmF0ZXMuc2FtcGxlVGV4dHVyZVwiXSl9Y29uc3QgaD0oMCxzLmdldENvb3Jkc0RhdGFUeXBlKShsKSxnPXIuQnJvYWRjYXN0VXRpbC5nZXRCcm9hZGNhc3REaW1zKHAsZiksYj1sLWM7bGV0IG07Y29uc3QgeT0oMCxzLmdldEdsQ2hhbm5lbHMpKCk7bT0wPT09Yz9cIlwiOmw8MiYmZy5sZW5ndGg+PTE/XCJjb29yZHMgPSAwO1wiOmcubWFwKCh0PT5gY29vcmRzLiR7eVt0K2JdfSA9IDA7YCkpLmpvaW4oXCJcXG5cIik7bGV0IF89XCJcIjtfPWw8MiYmYz4wP1wiY29vcmRzXCI6ZS51bnBhY2tlZFNoYXBlLm1hcCgoKHQsZSk9PmBjb29yZHMuJHt5W2UrYl19YCkpLmpvaW4oXCIsIFwiKTtjb25zdCB2PWBcXG4gICAgICAgIGZsb2F0ICR7dH0oKSB7XFxuICAgICAgICAgICR7aH0gY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICAgICR7bX1cXG4gICAgICAgICAgcmV0dXJuICR7ZH0oJHtffSk7XFxuICAgICAgICB9XFxuICAgICAgYDtyZXR1cm4gbmV3IGkuR2xzbExpYlJvdXRpbmUodixbXCJjb29yZGluYXRlcy5nZXRPdXRwdXRDb29yZHNcIl0pfWdldFBhY2tlZFNhbXBsZXJGcm9tSW5wdXQodCxlLG4pe3N3aXRjaChuLnVucGFja2VkU2hhcGUubGVuZ3RoKXtjYXNlIDA6cmV0dXJuIHRoaXMuZ2V0UGFja2VkU2FtcGxlclNjYWxhcih0LGUpO2Nhc2UgMTpyZXR1cm4gdGhpcy5nZXRQYWNrZWRTYW1wbGVyMUQodCxlLG4pO2Nhc2UgMjpyZXR1cm4gdGhpcy5nZXRQYWNrZWRTYW1wbGVyMkQodCxlLG4pO2Nhc2UgMzpyZXR1cm4gdGhpcy5nZXRQYWNrZWRTYW1wbGVyM0QodCxlLG4pO2RlZmF1bHQ6cmV0dXJuIHRoaXMuZ2V0UGFja2VkU2FtcGxlck5EKHQsZSxuKX19Z2V0VW5wYWNrZWRTYW1wbGVyRnJvbUlucHV0KHQsZSxuKXtjb25zdCByPW4udW5wYWNrZWRTaGFwZTtzd2l0Y2goci5sZW5ndGgpe2Nhc2UgMDpyZXR1cm4gdGhpcy5nZXRVbnBhY2tlZFNhbXBsZXJTY2FsYXIodCxlLG4pO2Nhc2UgMTpyZXR1cm4gdGhpcy5nZXRVbnBhY2tlZFNhbXBsZXIxRCh0LGUsbik7Y2FzZSAyOnJldHVybiB0aGlzLmdldFVucGFja2VkU2FtcGxlcjJEKHQsZSxuKTtjYXNlIDM6cmV0dXJuIHRoaXMuZ2V0VW5wYWNrZWRTYW1wbGVyM0QodCxlLG4pO2Nhc2UgNDpyZXR1cm4gdGhpcy5nZXRVbnBhY2tlZFNhbXBsZXI0RCh0LGUsbik7Y2FzZSA1OnJldHVybiB0aGlzLmdldFVucGFja2VkU2FtcGxlcjVEKHQsZSxuKTtjYXNlIDY6cmV0dXJuIHRoaXMuZ2V0VW5wYWNrZWRTYW1wbGVyNkQodCxlLG4pO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBkaW1lbnNpb24gJHtyLmxlbmd0aH0tRGApfX1nZXRQYWNrZWRTYW1wbGVyU2NhbGFyKHQsZSl7Y29uc3Qgbj1gXFxuICAgICAgICAgIHZlYzQgJHt0fSgpIHtcXG4gICAgICAgICAgICByZXR1cm4gJHsoMCxvLmdldEdsc2wpKHRoaXMuY29udGV4dC5nbENvbnRleHQudmVyc2lvbikudGV4dHVyZTJEfSgke2V9LCBoYWxmQ1IpO1xcbiAgICAgICAgICB9XFxuICAgICAgICBgO3JldHVybiBuZXcgaS5HbHNsTGliUm91dGluZShuKX1nZXRQYWNrZWRTYW1wbGVyMUQodCxlLG4pe2NvbnN0IHI9W24ud2lkdGgsbi5oZWlnaHRdLGE9W3JbMV0sclswXV0scz0oMCxvLmdldEdsc2wpKHRoaXMuY29udGV4dC5nbENvbnRleHQudmVyc2lvbiksdT1gdmVjNCAke3R9KGludCBpbmRleCkge1xcbiAgICAgIHZlYzIgdXYgPSBwYWNrZWRVVmZyb20xRChcXG4gICAgICAke2FbMF19LCAke2FbMV19LCBpbmRleCk7XFxuICAgICAgcmV0dXJuICR7cy50ZXh0dXJlMkR9KCR7ZX0sIHV2KTtcXG4gICAgfWA7cmV0dXJuIG5ldyBpLkdsc2xMaWJSb3V0aW5lKHUsW1wiY29vcmRpbmF0ZXMucGFja2VkVVZmcm9tMURcIl0pfWdldFBhY2tlZFNhbXBsZXIyRCh0LGUsbil7Y29uc3QgYT1uLnVucGFja2VkU2hhcGUscz1bbi53aWR0aCxuLmhlaWdodF0sdT0oMCxvLmdldEdsc2wpKHRoaXMuY29udGV4dC5nbENvbnRleHQudmVyc2lvbiksYz1zWzBdLGw9c1sxXTtpZihudWxsIT1zJiZyLkFycmF5VXRpbC5hcnJheXNFcXVhbChhLHMpKXtjb25zdCBuPWB2ZWM0ICR7dH0oaW50IHJvdywgaW50IGNvbCkge1xcbiAgICAgICAgdmVjMiB1diA9ICh2ZWMyKGNvbCwgcm93KSArIGhhbGZDUikgLyB2ZWMyKCR7bH0uMCwgJHtjfS4wKTtcXG4gICAgICAgIHJldHVybiAke3UudGV4dHVyZTJEfSgke2V9LCB1dik7XFxuICAgICAgfWA7cmV0dXJuIG5ldyBpLkdsc2xMaWJSb3V0aW5lKG4pfWNvbnN0IHA9cyxmPU1hdGguY2VpbChhWzFdLzIpLGQ9YHZlYzQgJHt0fShpbnQgcm93LCBpbnQgY29sKSB7XFxuICAgICAgdmVjMiB1diA9IHBhY2tlZFVWZnJvbTJEKCR7cFsxXX0sICR7cFswXX0sICR7Zn0sIHJvdywgY29sKTtcXG4gICAgICByZXR1cm4gJHt1LnRleHR1cmUyRH0oJHtlfSwgdXYpO1xcbiAgICB9YDtyZXR1cm4gbmV3IGkuR2xzbExpYlJvdXRpbmUoZCxbXCJjb29yZGluYXRlcy5wYWNrZWRVVmZyb20yRFwiXSl9Z2V0UGFja2VkU2FtcGxlcjNEKHQsZSxuKXtjb25zdCByPW4udW5wYWNrZWRTaGFwZSxhPVtuLndpZHRoLG4uaGVpZ2h0XSx1PVthWzBdLGFbMV1dLGM9KDAsby5nZXRHbHNsKSh0aGlzLmNvbnRleHQuZ2xDb250ZXh0LnZlcnNpb24pO2lmKDE9PT1yWzBdKXtjb25zdCBvPXIuc2xpY2UoMSksYT1bMSwyXSx1PSgwLHMuc3F1ZWV6ZUlucHV0U2hhcGUpKHIsbyksYz1bXCJiXCIsXCJyb3dcIixcImNvbFwiXSxsPUpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkobikpO2wudW5wYWNrZWRTaGFwZT11O2NvbnN0IHA9dGhpcy5nZXRQYWNrZWRTYW1wbGVyRnJvbUlucHV0KHQsZSxsKSxmPWAke3Aucm91dGluZUJvZHl9XFxuICAgICAgdmVjNCAke3R9KGludCBiLCBpbnQgcm93LCBpbnQgY29sKSB7XFxuICAgICAgICByZXR1cm4gJHt0fSgkeygwLHMuZ2V0U3F1ZWV6ZWRQYXJhbXMpKGMsYSl9KTtcXG4gICAgICB9IGA7cmV0dXJuIG5ldyBpLkdsc2xMaWJSb3V0aW5lKGYscC5kZXBlbmRlbmNpZXMpfWNvbnN0IGw9dVswXSxwPXVbMV0sZj1NYXRoLmNlaWwoclsyXS8yKSxkPWB2ZWM0ICR7dH0oaW50IGIsIGludCByb3csIGludCBjb2wpIHtcXG4gICAgICB2ZWMyIHV2ID0gcGFja2VkVVZmcm9tM0QoXFxuICAgICAgICAke3B9LCAke2x9LCAke2YqTWF0aC5jZWlsKHJbMV0vMil9LCAke2Z9LCBiLCByb3csIGNvbCk7XFxuICAgICAgcmV0dXJuICR7Yy50ZXh0dXJlMkR9KCR7ZX0sIHV2KTt9YDtyZXR1cm4gbmV3IGkuR2xzbExpYlJvdXRpbmUoZCxbXCJjb29yZGluYXRlcy5wYWNrZWRVVmZyb20zRFwiXSl9Z2V0UGFja2VkU2FtcGxlck5EKHQsZSxuKXtjb25zdCByPW4udW5wYWNrZWRTaGFwZSxhPXIubGVuZ3RoLHM9W24ud2lkdGgsbi5oZWlnaHRdLHU9KDAsby5nZXRHbHNsKSh0aGlzLmNvbnRleHQuZ2xDb250ZXh0LnZlcnNpb24pLGM9W3NbMF0sc1sxXV0sbD1jWzFdLHA9Y1swXSxmPU1hdGguY2VpbChyW2EtMV0vMik7bGV0IGQ9ZipNYXRoLmNlaWwoclthLTJdLzIpLGg9XCJpbnQgYiwgaW50IHJvdywgaW50IGNvbFwiLGc9YGIgKiAke2R9ICsgKHJvdyAvIDIpICogJHtmfSArIChjb2wgLyAyKWA7Zm9yKGxldCB0PTI7dDxhLTE7dCsrKWg9YGludCBiJHt0fSwgYCtoLGQqPXJbYS10LTFdLGc9YGIke3R9ICogJHtkfSArIGArZztjb25zdCBiPWB2ZWM0ICR7dH0oJHtofSkge1xcbiAgICAgIGludCBpbmRleCA9ICR7Z307XFxuICAgICAgaW50IHRleFIgPSBpbmRleCAvICR7cH07XFxuICAgICAgaW50IHRleEMgPSBpbmRleCAtIHRleFIgKiAke3B9O1xcbiAgICAgIHZlYzIgdXYgPSAodmVjMih0ZXhDLCB0ZXhSKSArIGhhbGZDUikgLyB2ZWMyKCR7cH0sICR7bH0pO1xcbiAgICAgIHJldHVybiAke3UudGV4dHVyZTJEfSgke2V9LCB1dik7XFxuICAgIH1gO3JldHVybiBuZXcgaS5HbHNsTGliUm91dGluZShiKX1nZXRVbnBhY2tlZFNhbXBsZXJTY2FsYXIodCxlLG4pe2NvbnN0W3Isb109W24ud2lkdGgsbi5oZWlnaHRdO2lmKDE9PT1yJiYxPT09byl7Y29uc3Qgbj1gXFxuICAgICAgICAgIGZsb2F0ICR7dH0oKSB7XFxuICAgICAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoJHtlfSwgaGFsZkNSKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgYDtyZXR1cm4gbmV3IGkuR2xzbExpYlJvdXRpbmUobixbXCJjb29yZGluYXRlcy5zYW1wbGVUZXh0dXJlXCJdKX1jb25zdCBhPWBcXG4gICAgICAgIGZsb2F0ICR7dH0oKSB7XFxuICAgICAgICAgIGludCBvZmZzZXRfJHtlfSA9IGNvb3Jkc1RvT2Zmc2V0KFRleENvb3JkcywgJHtyfSwgJHtvfSk7XFxuICAgICAgICAgIHZlYzIgdXYgPSB1dkZyb21GbGF0KCR7cn0sICR7b30sIG9mZnNldF8ke2V9KTtcXG4gICAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoJHtlfSwgdXYpO1xcbiAgICAgICAgfVxcbiAgICAgIGA7cmV0dXJuIG5ldyBpLkdsc2xMaWJSb3V0aW5lKGEsW1wiY29vcmRpbmF0ZXMudXZGcm9tRmxhdFwiLFwiY29vcmRpbmF0ZXMuc2FtcGxlVGV4dHVyZVwiLFwiY29vcmRpbmF0ZXMuY29vcmRzVG9PZmZzZXRcIl0pfWdldFVucGFja2VkU2FtcGxlcjFEKHQsZSxuKXtjb25zdCByPW4ud2lkdGgsbz1uLmhlaWdodDtpZigxPT09byYmMT09PXIpe2NvbnN0IG49YFxcbiAgICAgICAgZmxvYXQgJHt0fShpbnQgaW5kZXgpIHtcXG4gICAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoJHtlfSwgaGFsZkNSKTtcXG4gICAgICAgIH1cXG4gICAgICBgO3JldHVybiBuZXcgaS5HbHNsTGliUm91dGluZShuLFtcImNvb3JkaW5hdGVzLnNhbXBsZVRleHR1cmVcIl0pfWlmKDE9PT1vKXtjb25zdCBuPWBcXG4gICAgICAgICAgZmxvYXQgJHt0fShpbnQgaW5kZXgpIHtcXG4gICAgICAgICAgICB2ZWMyIHV2ID0gdmVjMigoZmxvYXQoaW5kZXgpICsgMC41KSAvICR7cn0uMCwgMC41KTtcXG4gICAgICAgICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZSgke2V9LCB1dik7XFxuICAgICAgICAgIH1cXG4gICAgICAgIGA7cmV0dXJuIG5ldyBpLkdsc2xMaWJSb3V0aW5lKG4sW1wiY29vcmRpbmF0ZXMuc2FtcGxlVGV4dHVyZVwiXSl9aWYoMT09PXIpe2NvbnN0IG49YFxcbiAgICAgICAgICBmbG9hdCAke3R9KGludCBpbmRleCkge1xcbiAgICAgICAgICAgIHZlYzIgdXYgPSB2ZWMyKDAuNSwgKGZsb2F0KGluZGV4KSArIDAuNSkgLyAke299LjApO1xcbiAgICAgICAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKCR7ZX0sIHV2KTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgYDtyZXR1cm4gbmV3IGkuR2xzbExpYlJvdXRpbmUobixbXCJjb29yZGluYXRlcy5zYW1wbGVUZXh0dXJlXCJdKX1jb25zdCBhPWBcXG4gICAgICAgIGZsb2F0ICR7dH0oaW50IGluZGV4KSB7XFxuICAgICAgICAgIHZlYzIgdXYgPSB1dkZyb21GbGF0KCR7cn0sICR7b30sIGluZGV4KTtcXG4gICAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoJHtlfSwgdXYpO1xcbiAgICAgICAgfVxcbiAgICAgIGA7cmV0dXJuIG5ldyBpLkdsc2xMaWJSb3V0aW5lKGEsW1wiY29vcmRpbmF0ZXMudXZGcm9tRmxhdFwiLFwiY29vcmRpbmF0ZXMuc2FtcGxlVGV4dHVyZVwiXSl9Z2V0VW5wYWNrZWRTYW1wbGVyMkQodCxlLG4pe2NvbnN0IG89bi51bnBhY2tlZFNoYXBlLHU9W24uaGVpZ2h0LG4ud2lkdGhdO2lmKG51bGwhPXUmJnIuQXJyYXlVdGlsLmFycmF5c0VxdWFsKG8sdSkpe2NvbnN0IG49YFxcbiAgICAgICAgICBmbG9hdCAke3R9KGludCByb3csIGludCBjb2wpIHtcXG4gICAgICAgICAgICB2ZWMyIHV2ID0gKHZlYzIocm93LCBjb2wpICsgaGFsZkNSKSAvIHZlYzIoJHt1WzFdfS4wLCAke3VbMF19LjApO1xcbiAgICAgICAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKCR7ZX0sIHV2KTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgYDtyZXR1cm4gbmV3IGkuR2xzbExpYlJvdXRpbmUobixbXCJjb29yZGluYXRlcy5zYW1wbGVUZXh0dXJlXCJdKX1jb25zdHtuZXdTaGFwZTpjLGtlcHREaW1zOmx9PSgwLGEuc3F1ZWV6ZVNoYXBlKShvKSxwPWM7aWYocC5sZW5ndGg8by5sZW5ndGgpe2NvbnN0IHI9KDAscy5zcXVlZXplSW5wdXRTaGFwZSkobyxwKSxhPUpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkobikpO2EudW5wYWNrZWRTaGFwZT1yO2NvbnN0IHU9W1wiY29sXCIsXCJyb3dcIl0sYz1gXFxuICAgICAgICAgICR7dGhpcy5nZXRVbnBhY2tlZFNhbXBsZXJGcm9tSW5wdXQodCxlLGEpLnJvdXRpbmVCb2R5fVxcbiAgICAgICAgICBmbG9hdCAke3R9KGludCByb3csIGludCBjb2wpIHtcXG4gICAgICAgICAgICByZXR1cm4gJHt0fSgkeygwLHMuZ2V0U3F1ZWV6ZWRQYXJhbXMpKHUsbCl9KTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgYDtyZXR1cm4gbmV3IGkuR2xzbExpYlJvdXRpbmUoYyxbXCJjb29yZGluYXRlcy5zYW1wbGVUZXh0dXJlXCJdKX1jb25zdCBmPXVbMV0sZD11WzBdO2lmKDE9PT1kKXtjb25zdCBuPWBcXG4gICAgICAgICAgZmxvYXQgJHt0fShpbnQgcm93LCBpbnQgY29sKSB7XFxuICAgICAgICAgICAgaW50IG9mZnNldF8ke2V9ID0gY29vcmRzVG9PZmZzZXQoVGV4Q29vcmRzLCAke2Z9LCAke2R9KTtcXG4gICAgICAgICAgICBmbG9hdCBpbmRleCA9IGRvdCh2ZWMzKHJvdywgY29sLCBvZmZzZXRfJHtlfSksIHZlYzMoJHtvWzFdfSwgMSwgMSkpO1xcbiAgICAgICAgICAgIHZlYzIgdXYgPSB2ZWMyKDAuNSwgKGluZGV4ICsgMC41KSAvICR7Zn0uMCk7XFxuICAgICAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoJHtlfSwgdXYpO1xcbiAgICAgICAgICB9XFxuICAgICAgICBgO3JldHVybiBuZXcgaS5HbHNsTGliUm91dGluZShuLFtcImNvb3JkaW5hdGVzLnNhbXBsZVRleHR1cmVcIixcImNvb3JkaW5hdGVzLmNvb3Jkc1RvT2Zmc2V0XCJdKX1pZigxPT09Zil7Y29uc3Qgbj1gXFxuICAgICAgICAgIGZsb2F0ICR7dH0oaW50IHJvdywgaW50IGNvbCkge1xcbiAgICAgICAgICAgIGludCBvZmZzZXRfJHtlfSA9IGNvb3Jkc1RvT2Zmc2V0KFRleENvb3JkcywgJHtmfSwgJHtkfSk7XFxuICAgICAgICAgICAgZmxvYXQgaW5kZXggPSBkb3QodmVjMyhyb3csIGNvbCwgb2Zmc2V0XyR7ZX0pLCB2ZWMzKCR7b1sxXX0sIDEsIDEpKTtcXG4gICAgICAgICAgICB2ZWMyIHV2ID0gdmVjMigoaW5kZXggKyAwLjUpIC8gJHtkfS4wLCAwLjUpO1xcbiAgICAgICAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKCR7ZX0sIHV2KTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgYDtyZXR1cm4gbmV3IGkuR2xzbExpYlJvdXRpbmUobixbXCJjb29yZGluYXRlcy5zYW1wbGVUZXh0dXJlXCIsXCJjb29yZGluYXRlcy5jb29yZHNUb09mZnNldFwiXSl9Y29uc3QgaD1gXFxuICAgICAgICBmbG9hdCAke3R9KGludCByb3csIGludCBjb2wpIHtcXG4gICAgICAgICAgaW50IGluZGV4ID0gY29sICogJHtvWzFdfSArIHJvdztcXG4gICAgICAgICAgdmVjMiB1diA9IHV2RnJvbUZsYXQoJHtmfSwgJHtkfSwgaW5kZXgpO1xcbiAgICAgICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZSgke2V9LCB1dik7XFxuICAgICAgICB9XFxuICAgICAgYDtyZXR1cm4gbmV3IGkuR2xzbExpYlJvdXRpbmUoaCxbXCJjb29yZGluYXRlcy51dkZyb21GbGF0XCIsXCJjb29yZGluYXRlcy5zYW1wbGVUZXh0dXJlXCIsXCJjb29yZGluYXRlcy5jb29yZHNUb09mZnNldFwiXSl9Z2V0VW5wYWNrZWRTYW1wbGVyM0QodCxlLG4pe2NvbnN0IHI9bi51bnBhY2tlZFNoYXBlLG89clsxXSpyWzJdLHU9clsyXSx7bmV3U2hhcGU6YyxrZXB0RGltczpsfT0oMCxhLnNxdWVlemVTaGFwZSkocikscD1jO2lmKHAubGVuZ3RoPHIubGVuZ3RoKXtjb25zdCBvPSgwLHMuc3F1ZWV6ZUlucHV0U2hhcGUpKHIscCksYT1bXCJiYXRjaFwiLFwiY29sXCIsXCJyb3dcIl0sdT1KU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG4pKTt1LnVucGFja2VkU2hhcGU9bztjb25zdCBjPXRoaXMuZ2V0VW5wYWNrZWRTYW1wbGVyRnJvbUlucHV0KHQsZSx1KSxmPWwucmV2ZXJzZSgpLGQ9YFxcbiAgICAgICAgICAke2Mucm91dGluZUJvZHl9XFxuICAgICAgICAgIGZsb2F0ICR7dH0oaW50IGJhdGNoLCBpbnQgcm93LCBpbnQgY29sKSB7XFxuICAgICAgICAgICAgcmV0dXJuICR7dH0oJHsoMCxzLmdldFNxdWVlemVkUGFyYW1zKShhLGYpfSk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIGA7cmV0dXJuIG5ldyBpLkdsc2xMaWJSb3V0aW5lKGQsYy5kZXBlbmRlbmNpZXMpfWNvbnN0IGY9YFxcbiAgICAgICAgICBmbG9hdCAke3R9KGludCBkZXB0aCwgaW50IHJvdywgaW50IGNvbCkge1xcbiAgICAgICAgICAgIC8vIEV4cGxpY2l0bHkgdXNlIGludGVnZXIgb3BlcmF0aW9ucyBhcyBkb3QoKSBvbmx5IHdvcmtzIG9uIGZsb2F0cy5cXG4gICAgICAgICAgICBpbnQgaW5kZXggPSBkZXB0aCAqICR7b30gKyBjb2wgKiAke3V9ICsgcm93O1xcbiAgICAgICAgICAgIHZlYzIgdXYgPSB1dkZyb21GbGF0KCR7bi53aWR0aH0sICR7bi5oZWlnaHR9LCBpbmRleCk7XFxuICAgICAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoJHtlfSwgdXYpO1xcbiAgICAgICAgICB9XFxuICAgICAgYDtyZXR1cm4gbmV3IGkuR2xzbExpYlJvdXRpbmUoZixbXCJjb29yZGluYXRlcy51dkZyb21GbGF0XCIsXCJjb29yZGluYXRlcy5zYW1wbGVUZXh0dXJlXCIsXCJjb29yZGluYXRlcy5jb29yZHNUb09mZnNldFwiXSl9Z2V0VW5wYWNrZWRTYW1wbGVyNEQodCxlLG4pe2NvbnN0IHI9bi51bnBhY2tlZFNoYXBlLG89clszXSxhPXJbMl0qbyxzPWBcXG4gICAgICAgIGZsb2F0ICR7dH0oaW50IHJvdywgaW50IGNvbCwgaW50IGRlcHRoLCBpbnQgZGVwdGgyKSB7XFxuICAgICAgICAgIGludCBpbmRleCA9IHJvdyAqICR7clsxXSphfSArIGNvbCAqICR7YX0gK1xcbiAgICAgICAgICAgICAgZGVwdGgyICogJHtvfSArIGRlcHRoO1xcbiAgICAgICAgICB2ZWMyIHV2ID0gdXZGcm9tRmxhdCgke24ud2lkdGh9LCAke24uaGVpZ2h0fSwgaW5kZXgpO1xcbiAgICAgICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZSgke2V9LCB1dik7XFxuICAgICAgICB9XFxuICAgICAgYDtyZXR1cm4gbmV3IGkuR2xzbExpYlJvdXRpbmUocyxbXCJjb29yZGluYXRlcy51dkZyb21GbGF0XCIsXCJjb29yZGluYXRlcy5zYW1wbGVUZXh0dXJlXCJdKX1nZXRVbnBhY2tlZFNhbXBsZXI1RCh0LGUsbil7Y29uc3Qgcj1uLnVucGFja2VkU2hhcGUsbz1yWzRdLHU9clszXSpvLGM9clsyXSp1LGw9clsxXSpjLHtuZXdTaGFwZTpwLGtlcHREaW1zOmZ9PSgwLGEuc3F1ZWV6ZVNoYXBlKShyKTtpZihwLmxlbmd0aDxyLmxlbmd0aCl7Y29uc3Qgbz0oMCxzLnNxdWVlemVJbnB1dFNoYXBlKShyLHApLGE9W1wicm93XCIsXCJjb2xcIixcImRlcHRoXCIsXCJkZXB0aDJcIixcImRlcHRoM1wiXSx1PUpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkobikpO3UudW5wYWNrZWRTaGFwZT1vO2NvbnN0IGM9YFxcbiAgICAgICAgICAke3RoaXMuZ2V0VW5wYWNrZWRTYW1wbGVyRnJvbUlucHV0KHQsZSx1KS5yb3V0aW5lQm9keX1cXG4gICAgICAgICAgZmxvYXQgJHt0fShpbnQgcm93LCBpbnQgY29sLCBpbnQgZGVwdGgsIGludCBkZXB0aDIsIGludCBkZXB0aDMpIHtcXG4gICAgICAgICAgICByZXR1cm4gJHt0fSgkeygwLHMuZ2V0U3F1ZWV6ZWRQYXJhbXMpKGEsZil9KTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgYDtyZXR1cm4gbmV3IGkuR2xzbExpYlJvdXRpbmUoYyxbXCJjb29yZGluYXRlcy5zYW1wbGVUZXh0dXJlXCIsXCJjb29yZGluYXRlcy51dkZyb21GbGF0XCJdKX1jb25zdCBkPWBcXG4gICAgICAgIGZsb2F0ICR7dH0oaW50IHJvdywgaW50IGNvbCwgaW50IGRlcHRoLCBpbnQgZGVwdGgyLCBpbnQgZGVwdGgzKSB7XFxuICAgICAgICAgIGludCBpbmRleCA9IHJvdyAqICR7bH0gKyBjb2wgKiAke2N9ICsgZGVwdGggKiAke3V9ICtcXG4gICAgICAgICAgZGVwdGgzICogJHtvfSArIGRlcHRoMjtcXG4gICAgICAgICAgdmVjMiB1diA9IHV2RnJvbUZsYXQoJHtuLndpZHRofSwgJHtuLmhlaWdodH0sIGluZGV4KTtcXG4gICAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoJHtlfSwgdXYpO1xcbiAgICAgICAgfVxcbiAgICAgIGA7cmV0dXJuIG5ldyBpLkdsc2xMaWJSb3V0aW5lKGQsW1wiY29vcmRpbmF0ZXMuc2FtcGxlVGV4dHVyZVwiLFwiY29vcmRpbmF0ZXMudXZGcm9tRmxhdFwiXSl9Z2V0VW5wYWNrZWRTYW1wbGVyNkQodCxlLG4pe2NvbnN0IHI9bi51bnBhY2tlZFNoYXBlLG89cls1XSx1PXJbNF0qbyxjPXJbM10qdSxsPXJbMl0qYyxwPXJbMV0qbCx7bmV3U2hhcGU6ZixrZXB0RGltczpkfT0oMCxhLnNxdWVlemVTaGFwZSkocik7aWYoZi5sZW5ndGg8ci5sZW5ndGgpe2NvbnN0IG89KDAscy5zcXVlZXplSW5wdXRTaGFwZSkocixmKSxhPVtcInJvd1wiLFwiY29sXCIsXCJkZXB0aFwiLFwiZGVwdGgyXCIsXCJkZXB0aDNcIixcImRlcHRoNFwiXSx1PUpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkobikpO3UudW5wYWNrZWRTaGFwZT1vO2NvbnN0IGM9YFxcbiAgICAgICAgICAgICR7dGhpcy5nZXRVbnBhY2tlZFNhbXBsZXJGcm9tSW5wdXQodCxlLHUpLnJvdXRpbmVCb2R5fVxcbiAgICAgICAgICAgIGZsb2F0ICR7dH0oaW50IHJvdywgaW50IGNvbCwgaW50IGRlcHRoLFxcbiAgICAgICAgICAgICAgaW50IGRlcHRoMiwgaW50IGRlcHRoMywgaW50IGRlcHRoNCkge1xcbiAgICAgICAgICAgICAgcmV0dXJuICR7dH0oJHsoMCxzLmdldFNxdWVlemVkUGFyYW1zKShhLGQpfSk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICBgO3JldHVybiBuZXcgaS5HbHNsTGliUm91dGluZShjLFtcImNvb3JkaW5hdGVzLnNhbXBsZVRleHR1cmVcIixcImNvb3JkaW5hdGVzLnV2RnJvbUZsYXRcIl0pfWNvbnN0IGg9YFxcbiAgICAgICAgICBmbG9hdCAke3R9KGludCByb3csIGludCBjb2wsIGludCBkZXB0aCxcXG4gICAgICAgICAgICBpbnQgZGVwdGgyLCBpbnQgZGVwdGgzLCBpbnQgZGVwdGg0KSB7XFxuICAgICAgICAgICAgaW50IGluZGV4ID0gcm93ICogJHtwfSArIGNvbCAqICR7bH0gKyBkZXB0aCAqICR7Y30gK1xcbiAgICAgICAgICAgIGRlcHRoMiAqICR7dX0gKyBkZXB0aDMgKiAke299ICsgZGVwdGg0O1xcbiAgICAgICAgICAgIHZlYzIgdXYgPSB1dkZyb21GbGF0KCR7bi53aWR0aH0sICR7bi5oZWlnaHR9LCBpbmRleCk7XFxuICAgICAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoJHtlfSwgdXYpO1xcbiAgICAgICAgICB9XFxuICAgICAgICBgO3JldHVybiBuZXcgaS5HbHNsTGliUm91dGluZShoLFtcImNvb3JkaW5hdGVzLnV2RnJvbUZsYXRcIixcImNvb3JkaW5hdGVzLnNhbXBsZVRleHR1cmVcIixcImNvb3JkaW5hdGVzLmNvb3Jkc1RvT2Zmc2V0XCJdKX10b1ZlYygpe2NvbnN0IHQ9dGhpcy5jb250ZXh0Lm91dHB1dFRleHR1cmVMYXlvdXQsZT10LnNoYXBlLmxlbmd0aCxuPXQuc3RyaWRlcyxyPXQud2lkdGgsbz10LmhlaWdodCxhPVtdO2ZvcihsZXQgdD0wO3Q8ZS0xOysrdClhLnB1c2goYFxcbiAgICAgICAgY1ske3R9XSA9IG9mZnNldCAvICR7blt0XX07YCksYS5wdXNoKGBcXG4gICAgICAgIG9mZnNldCAtPSBjWyR7dH1dICogJHtuW3RdfTtgKTthLnB1c2goYFxcbiAgICAgICAgY1ske2UtMX1dID0gb2Zmc2V0O2ApO2NvbnN0IHM9YFxcbiAgICAgIHZvaWQgdG9WZWModmVjMiB0ZXhDb29yZHMsIG91dCBpbnQgY1ske2V9XSkge1xcbiAgICAgICAgaW50IG9mZnNldCA9IGNvb3Jkc1RvT2Zmc2V0KHRleENvb3JkcywgJHtyfSwgJHtvfSk7XFxuICAgICAgICAke2Euam9pbihcIlwiKX1cXG4gICAgICB9XFxuICAgICAgdm9pZCB0b1ZlYyhpbnQgb2Zmc2V0LCBvdXQgaW50IGNbJHtlfV0pIHtcXG4gICAgICAgICR7YS5qb2luKFwiXCIpfVxcbiAgICAgIH1cXG4gICAgYDtyZXR1cm57dG9WZWM6bmV3IGkuR2xzbExpYlJvdXRpbmUocyxbXCJjb29yZGluYXRlcy5jb29yZHNUb09mZnNldFwiXSl9fXZhbHVlRnJvbSgpe2NvbnN0IHQ9e307cmV0dXJuIHRoaXMuY29udGV4dC5wcm9ncmFtSW5mby5pbnB1dE5hbWVzLmZvckVhY2goKChlLG4pPT57Y29uc3Qgcj10aGlzLmNvbnRleHQuaW5wdXRUZXh0dXJlTGF5b3V0c1tuXSxvPShyLnVucGFja2VkU2hhcGUubGVuZ3RoPjA/ci51bnBhY2tlZFNoYXBlOnIuc2hhcGUpLmxlbmd0aDtsZXQgYT1gXyR7ZX1gO3RbYV09bmV3IGkuR2xzbExpYlJvdXRpbmUodGhpcy5nZXRWYWx1ZUZyb21TaW5nbGUoZSxvLHIud2lkdGgsci5oZWlnaHQsITEpLFtgc2hhcGVVdGlscy5pbmRpY2VzVG9PZmZzZXQke2F9YCxcImNvb3JkaW5hdGVzLm9mZnNldFRvQ29vcmRzXCIsXCJmcmFnY29sb3IuZ2V0Q29sb3JBc0Zsb2F0XCJdKSxhKz1cIl9UXCIsdFthXT1uZXcgaS5HbHNsTGliUm91dGluZSh0aGlzLmdldFZhbHVlRnJvbVNpbmdsZShlLG8sci53aWR0aCxyLmhlaWdodCwhMCksW2BzaGFwZVV0aWxzLmluZGljZXNUb09mZnNldCR7YX1gLFwiY29vcmRpbmF0ZXMub2Zmc2V0VG9Db29yZHNcIixcImZyYWdjb2xvci5nZXRDb2xvckFzRmxvYXRcIl0pfSkpLHR9Z2V0VmFsdWVGcm9tU2luZ2xlKHQsZSxuLHIsaSl7bGV0IGE9YF8ke3R9YDtyZXR1cm4gaSYmKGErPVwiX1RcIiksYFxcbiAgICAgICAgZmxvYXQgJHthfShpbnQgbVske2V9XSkge1xcbiAgICAgICAgICBpbnQgb2Zmc2V0ID0gaW5kaWNlc1RvT2Zmc2V0JHthfShtKTtcXG4gICAgICAgICAgdmVjMiBjb29yZHMgPSBvZmZzZXRUb0Nvb3JkcyhvZmZzZXQsICR7bn0sICR7cn0pO1xcbiAgICAgICAgICBmbG9hdCB2YWx1ZSA9IGdldENvbG9yQXNGbG9hdCgkeygwLG8uZ2V0R2xzbCkodGhpcy5jb250ZXh0LmdsQ29udGV4dC52ZXJzaW9uKS50ZXh0dXJlMkR9KCR7dH0sIGNvb3JkcykpO1xcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XFxuICAgICAgICB9XFxuICAgICAgICBgfWdldFBhY2tlZFZhbHVlRnJvbSh0LGUsbixyLGkpe2xldCBhPWBfJHt0fV9QYWNrYDtyZXR1cm4gaSYmKGErPVwiX1RcIiksYFxcbiAgICAgICAgdmVjNCAke2F9KGludCBtWyR7ZX1dKSB7XFxuICAgICAgICAgIGludCBvZmZzZXQgPSBpbmRpY2VzVG9PZmZzZXRfJHt0fShtKTtcXG4gICAgICAgICAgdmVjMiBjb29yZHMgPSBvZmZzZXRUb0Nvb3JkcyhvZmZzZXQsICR7bn0sICR7cn0pO1xcbiAgICAgICAgICByZXR1cm4gJHsoMCxvLmdldEdsc2wpKHRoaXMuY29udGV4dC5nbENvbnRleHQudmVyc2lvbikudGV4dHVyZTJEfSgke3R9LCBjb29yZHMpO1xcbiAgICAgICAgfVxcbiAgICAgICAgYH19ZS5Db29yZHNHbHNsTGliPXV9LDg1MjA6KHQsZSk9PntcInVzZSBzdHJpY3RcIjt2YXIgbjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLlRvcG9sb2dpY2FsU29ydEdsc2xSb3V0aW5lcz1lLkdsc2xMaWJSb3V0aW5lTm9kZT1lLkdsc2xMaWJSb3V0aW5lPWUuR2xzbExpYj1lLkdsc2xDb250ZXh0PWUuRnVuY3Rpb25UeXBlPXZvaWQgMCwobj1lLkZ1bmN0aW9uVHlwZXx8KGUuRnVuY3Rpb25UeXBlPXt9KSlbbi5WYWx1ZUJhc2VkPTBdPVwiVmFsdWVCYXNlZFwiLG5bbi5Qb3NpdGlvbmFsPTFdPVwiUG9zaXRpb25hbFwiLGUuR2xzbENvbnRleHQ9Y2xhc3N7Y29uc3RydWN0b3IodCxlLG4scil7dGhpcy5nbENvbnRleHQ9dCx0aGlzLnByb2dyYW1JbmZvPWUsdGhpcy5pbnB1dFRleHR1cmVMYXlvdXRzPW4sdGhpcy5vdXRwdXRUZXh0dXJlTGF5b3V0PXJ9fSxlLkdsc2xMaWI9Y2xhc3N7Y29uc3RydWN0b3IodCl7dGhpcy5jb250ZXh0PXR9fSxlLkdsc2xMaWJSb3V0aW5lPWNsYXNze2NvbnN0cnVjdG9yKHQsZSl7dGhpcy5yb3V0aW5lQm9keT10LHRoaXMuZGVwZW5kZW5jaWVzPWV9fSxlLkdsc2xMaWJSb3V0aW5lTm9kZT1jbGFzc3tjb25zdHJ1Y3Rvcih0LGUsbil7dGhpcy5uYW1lPXQsdGhpcy5kZXBlbmRlbmNpZXM9bnx8W10sZSYmKHRoaXMucm91dGluZUJvZHk9ZSl9YWRkRGVwZW5kZW5jeSh0KXt0JiZ0aGlzLmRlcGVuZGVuY2llcy5wdXNoKHQpfX0sZS5Ub3BvbG9naWNhbFNvcnRHbHNsUm91dGluZXM9Y2xhc3N7c3RhdGljIHJldHVybk9yZGVyZWROb2Rlcyh0KXtpZighdHx8MD09PXQubGVuZ3RoKXJldHVybltdO2lmKDE9PT10Lmxlbmd0aClyZXR1cm4gdDtjb25zdCBlPW5ldyBTZXQsbj1uZXcgU2V0LHI9bmV3IEFycmF5O3JldHVybiB0aGlzLmNyZWF0ZU9yZGVyZWROb2Rlcyh0LGUsbixyKSxyfXN0YXRpYyBjcmVhdGVPcmRlcmVkTm9kZXModCxlLG4scil7Zm9yKGxldCBpPTA7aTx0Lmxlbmd0aDsrK2kpdGhpcy5kZnNUcmF2ZXJzZSh0W2ldLGUsbixyKX1zdGF0aWMgZGZzVHJhdmVyc2UodCxlLG4scil7aWYoIXR8fG4uaGFzKHQubmFtZSkpcmV0dXJuO2lmKGUuaGFzKHQubmFtZSkpdGhyb3cgbmV3IEVycm9yKFwiQ3ljbGljIGRlcGVuZGVuY3kgZGV0ZWN0ZWQuIENhbid0IHRvcG9sb2dpY2FsbHkgc29ydCByb3V0aW5lcyBuZWVkZWQgZm9yIHNoYWRlci5cIik7ZS5hZGQodC5uYW1lKTtjb25zdCBpPXQuZGVwZW5kZW5jaWVzO2lmKGkmJmkubGVuZ3RoPjApZm9yKGxldCB0PTA7dDxpLmxlbmd0aDsrK3QpdGhpcy5kZnNUcmF2ZXJzZShpW3RdLGUsbixyKTtyLnB1c2godCksbi5hZGQodC5uYW1lKSxlLmRlbGV0ZSh0Lm5hbWUpfX19LDczNDE6KHQsZSxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUuRW5jb2RpbmdHbHNsTGliPXZvaWQgMDtjb25zdCByPW4oODUyMCk7Y2xhc3MgaSBleHRlbmRzIHIuR2xzbExpYntjb25zdHJ1Y3Rvcih0KXtzdXBlcih0KX1nZXRGdW5jdGlvbnMoKXtyZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LHRoaXMuZW5jb2RlRmxvYXQzMigpKSx0aGlzLmRlY29kZUZsb2F0MzIoKSl9Z2V0Q3VzdG9tVHlwZXMoKXtyZXR1cm57fX1lbmNvZGVGbG9hdDMyKCl7cmV0dXJue2VuY29kZTpuZXcgci5HbHNsTGliUm91dGluZShcImhpZ2hwIHZlYzQgZW5jb2RlKGhpZ2hwIGZsb2F0IGYpIHtcXG4gICAgICAgIHJldHVybiB2ZWM0KGYsIDAuMCwgMC4wLCAwLjApO1xcbiAgICAgIH1cXG4gICAgICAgIFwiKX19ZGVjb2RlRmxvYXQzMigpe3JldHVybntkZWNvZGU6bmV3IHIuR2xzbExpYlJvdXRpbmUoXCJoaWdocCBmbG9hdCBkZWNvZGUoaGlnaHAgdmVjNCByZ2JhKSB7XFxuICAgICAgICByZXR1cm4gcmdiYS5yO1xcbiAgICAgIH1cXG4gICAgICAgIFwiKX19ZW5jb2RlVWludDgoKXtjb25zdCB0PWkuaXNMaXR0bGVFbmRpYW4oKT9cInJnYmEucmdiYT1yZ2JhLmFiZ3I7XCI6XCJcIjtyZXR1cm57ZW5jb2RlOm5ldyByLkdsc2xMaWJSb3V0aW5lKGBcXG4gICAgICBoaWdocCB2ZWM0IGVuY29kZShoaWdocCBmbG9hdCBmKSB7XFxuICAgICAgICBoaWdocCBmbG9hdCBGID0gYWJzKGYpO1xcbiAgICAgICAgaGlnaHAgZmxvYXQgU2lnbiA9IHN0ZXAoMC4wLC1mKTtcXG4gICAgICAgIGhpZ2hwIGZsb2F0IEV4cG9uZW50ID0gZmxvb3IobG9nMihGKSk7XFxuICAgICAgICBoaWdocCBmbG9hdCBNYW50aXNzYSA9IChleHAyKC0gRXhwb25lbnQpICogRik7XFxuICAgICAgICBFeHBvbmVudCA9IGZsb29yKGxvZzIoRikgKyAxMjcuMCkgKyBmbG9vcihsb2cyKE1hbnRpc3NhKSk7XFxuICAgICAgICBoaWdocCB2ZWM0IHJnYmE7XFxuICAgICAgICByZ2JhWzBdID0gMTI4LjAgKiBTaWduICArIGZsb29yKEV4cG9uZW50KmV4cDIoLTEuMCkpO1xcbiAgICAgICAgcmdiYVsxXSA9IDEyOC4wICogbW9kKEV4cG9uZW50LDIuMCkgKyBtb2QoZmxvb3IoTWFudGlzc2EqMTI4LjApLDEyOC4wKTtcXG4gICAgICAgIHJnYmFbMl0gPSBmbG9vcihtb2QoZmxvb3IoTWFudGlzc2EqZXhwMigyMy4wIC04LjApKSxleHAyKDguMCkpKTtcXG4gICAgICAgIHJnYmFbM10gPSBmbG9vcihleHAyKDIzLjApKm1vZChNYW50aXNzYSxleHAyKC0xNS4wKSkpO1xcbiAgICAgICAgJHt0fVxcbiAgICAgICAgcmdiYSA9IHJnYmEgLyAyNTUuMDsgLy8gdmFsdWVzIG5lZWQgdG8gYmUgbm9ybWFsaXplZCB0byBbMCwxXVxcbiAgICAgICAgcmV0dXJuIHJnYmE7XFxuICAgIH1cXG4gICAgICAgIGApfX1kZWNvZGVVaW50OCgpe2NvbnN0IHQ9aS5pc0xpdHRsZUVuZGlhbigpP1wicmdiYS5yZ2JhPXJnYmEuYWJncjtcIjpcIlwiO3JldHVybntkZWNvZGU6bmV3IHIuR2xzbExpYlJvdXRpbmUoYFxcbiAgICAgICAgaGlnaHAgZmxvYXQgZGVjb2RlKGhpZ2hwIHZlYzQgcmdiYSkge1xcbiAgICAgICAgICByZ2JhID0gcmdiYSAqIDI1NS4wOyAvLyB2YWx1ZXMgbmVlZCB0byBiZSBkZS1ub3JtYWxpemVkIGZyb20gWzAsMV0gdG8gWzAsMjU1XVxcbiAgICAgICAgICAke3R9XFxuICAgICAgICAgIGhpZ2hwIGZsb2F0IFNpZ24gPSAxLjAgLSBzdGVwKDEyOC4wLHJnYmFbMF0pKjIuMDtcXG4gICAgICAgICAgaGlnaHAgZmxvYXQgRXhwb25lbnQgPSAyLjAgKiBtb2QocmdiYVswXSwxMjguMCkgKyBzdGVwKDEyOC4wLHJnYmFbMV0pIC0gMTI3LjA7XFxuICAgICAgICAgIGhpZ2hwIGZsb2F0IE1hbnRpc3NhID0gbW9kKHJnYmFbMV0sMTI4LjApKjY1NTM2LjAgKyByZ2JhWzJdKjI1Ni4wICtyZ2JhWzNdICsgZmxvYXQoMHg4MDAwMDApO1xcbiAgICAgICAgICBoaWdocCBmbG9hdCBSZXN1bHQgPSAgU2lnbiAqIGV4cDIoRXhwb25lbnQpICogKE1hbnRpc3NhICogZXhwMigtMjMuMCApKTtcXG4gICAgICAgICAgcmV0dXJuIFJlc3VsdDtcXG4gICAgICB9XFxuICAgICAgICBgKX19c3RhdGljIGlzTGl0dGxlRW5kaWFuKCl7Y29uc3QgdD1uZXcgQXJyYXlCdWZmZXIoNCksZT1uZXcgVWludDMyQXJyYXkodCksbj1uZXcgVWludDhBcnJheSh0KTtpZihlWzBdPTM3MzU5Mjg1NTksMjM5PT09blswXSlyZXR1cm4hMDtpZigyMjI9PT1uWzBdKXJldHVybiExO3Rocm93IG5ldyBFcnJvcihcInVua25vd24gZW5kaWFubmVzc1wiKX19ZS5FbmNvZGluZ0dsc2xMaWI9aX0sOTg5NDoodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5GcmFnQ29sb3JHbHNsTGliPXZvaWQgMDtjb25zdCByPW4oODUyMCksaT1uKDUwNjApO2NsYXNzIG8gZXh0ZW5kcyByLkdsc2xMaWJ7Y29uc3RydWN0b3IodCl7c3VwZXIodCl9Z2V0RnVuY3Rpb25zKCl7cmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSx0aGlzLnNldEZyYWdDb2xvcigpKSx0aGlzLmdldENvbG9yQXNGbG9hdCgpKX1nZXRDdXN0b21UeXBlcygpe3JldHVybnt9fXNldEZyYWdDb2xvcigpe2NvbnN0IHQ9KDAsaS5nZXRHbHNsKSh0aGlzLmNvbnRleHQuZ2xDb250ZXh0LnZlcnNpb24pO3JldHVybntzZXRGcmFnQ29sb3I6bmV3IHIuR2xzbExpYlJvdXRpbmUoYFxcbiAgICAgICAgdm9pZCBzZXRGcmFnQ29sb3IoZmxvYXQgdmFsdWUpIHtcXG4gICAgICAgICAgICAke3Qub3V0cHV0fSA9IGVuY29kZSh2YWx1ZSk7XFxuICAgICAgICB9XFxuICAgICAgICBgLFtcImVuY29kaW5nLmVuY29kZVwiXSl9fWdldENvbG9yQXNGbG9hdCgpe3JldHVybntnZXRDb2xvckFzRmxvYXQ6bmV3IHIuR2xzbExpYlJvdXRpbmUoXCJcXG4gICAgICAgIGZsb2F0IGdldENvbG9yQXNGbG9hdCh2ZWM0IGNvbG9yKSB7XFxuICAgICAgICAgICAgcmV0dXJuIGRlY29kZShjb2xvcik7XFxuICAgICAgICB9XFxuICAgICAgICBcIixbXCJlbmNvZGluZy5kZWNvZGVcIl0pfX19ZS5GcmFnQ29sb3JHbHNsTGliPW99LDI4NDg6KHQsZSk9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLnJlcGxhY2VJbmxpbmVzPXZvaWQgMDtjb25zdCBuPS9AaW5saW5lW1xcc1xcblxccl0rKFxcdyspW1xcc1xcblxccl0rKFswLTlhLXpBLVpfXSspXFxzKlxcKChbXildKilcXClcXHMqeygoW159XXxbXFxuXFxyXSkqKX0vZ207ZS5yZXBsYWNlSW5saW5lcz1mdW5jdGlvbih0KXtjb25zdCBlPXt9O2xldCByO2Zvcig7bnVsbCE9PShyPW4uZXhlYyh0KSk7KXtjb25zdCB0PXJbM10uc3BsaXQoXCIsXCIpLm1hcCgodD0+e2NvbnN0IGU9dC50cmltKCkuc3BsaXQoXCIgXCIpO3JldHVybiBlJiYyPT09ZS5sZW5ndGg/e3R5cGU6ZVswXSxuYW1lOmVbMV19Om51bGx9KSkuZmlsdGVyKCh0PT5udWxsIT09dCkpO2VbclsyXV09e3BhcmFtczp0LGJvZHk6cls0XX19Zm9yKGNvbnN0IG4gaW4gZSl7Y29uc3QgaT1cIihcXFxcdyspP1xcXFxzKyhbXzAtOWEtekEtWl0rKVxcXFxzKz1cXFxccytfX0ZVTkNfX1xcXFwoKC4qKVxcXFwpXFxcXHMqO1wiLnJlcGxhY2UoXCJfX0ZVTkNfX1wiLG4pLG89bmV3IFJlZ0V4cChpLFwiZ21cIik7Zm9yKDtudWxsIT09KHI9by5leGVjKHQpKTspe2NvbnN0IGk9clsxXSxvPXJbMl0sYT1yWzNdLnNwbGl0KFwiLFwiKSxzPWk/YCR7aX0gJHtvfTtgOlwiXCI7bGV0IHU9ZVtuXS5ib2R5LGM9XCJcIjtlW25dLnBhcmFtcy5mb3JFYWNoKCgodCxlKT0+e3QmJihjKz1gJHt0LnR5cGV9ICR7dC5uYW1lfSA9ICR7YVtlXX07XFxuYCl9KSksdT1gJHtjfVxcbiAke3V9YCx1PXUucmVwbGFjZShcInJldHVyblwiLGAke299ID0gYCk7Y29uc3QgbD1gXFxuICAgICAgJHtzfVxcbiAgICAgIHtcXG4gICAgICAgICR7dX1cXG4gICAgICB9XFxuICAgICAgYDt0PXQucmVwbGFjZShyWzBdLGwpfX1yZXR1cm4gdC5yZXBsYWNlKG4sXCJcIil9fSw4ODc5Oih0LGUsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLkdsc2xQcmVwcm9jZXNzb3I9dm9pZCAwO2NvbnN0IHI9big4NTIwKSxpPW4oMjg0OCksbz1uKDU0ODMpLGE9big1MDYwKTtlLkdsc2xQcmVwcm9jZXNzb3I9Y2xhc3N7Y29uc3RydWN0b3IodCxlLG4saSl7dGhpcy5saWJzPXt9LHRoaXMuZ2xzbExpYlJvdXRpbmVEZXBlbmRlbmN5R3JhcGg9e30sdGhpcy5jb250ZXh0PW5ldyByLkdsc2xDb250ZXh0KHQsZSxuLGkpLE9iamVjdC5rZXlzKG8uZ2xzbFJlZ2lzdHJ5KS5mb3JFYWNoKCh0PT57Y29uc3QgZT1uZXcgby5nbHNsUmVnaXN0cnlbdF0odGhpcy5jb250ZXh0KTt0aGlzLmxpYnNbdF09ZX0pKTtjb25zdCBhPXRoaXMuZ2xzbExpYlJvdXRpbmVEZXBlbmRlbmN5R3JhcGg7Zm9yKGNvbnN0IHQgaW4gdGhpcy5saWJzKXtjb25zdCBlPXRoaXMubGlic1t0XS5nZXRGdW5jdGlvbnMoKTtmb3IoY29uc3QgbiBpbiBlKXtjb25zdCBpPXQrXCIuXCIrbjtsZXQgbzthW2ldPyhvPWFbaV0sby5yb3V0aW5lQm9keT1lW25dLnJvdXRpbmVCb2R5KToobz1uZXcgci5HbHNsTGliUm91dGluZU5vZGUoaSxlW25dLnJvdXRpbmVCb2R5KSxhW2ldPW8pO2NvbnN0IHM9ZVtuXS5kZXBlbmRlbmNpZXM7aWYocylmb3IobGV0IHQ9MDt0PHMubGVuZ3RoOysrdClpZihhW3NbdF1dKW8uYWRkRGVwZW5kZW5jeShhW3NbdF1dKTtlbHNle2NvbnN0IGU9bmV3IHIuR2xzbExpYlJvdXRpbmVOb2RlKHNbdF0pO2Fbc1t0XV09ZSxvLmFkZERlcGVuZGVuY3koZSl9fX19cHJlcHJvY2Vzcygpe2NvbnN0IHQ9dGhpcy5jb250ZXh0LnByb2dyYW1JbmZvO2xldCBlPXQuc2hhZGVyU291cmNlO3JldHVybiB0aGlzLmNvbnRleHQucHJvZ3JhbUluZm8uaGFzTWFpbnx8KGU9YCR7ZX1cXG4gICAgICAkeygwLGEuZ2V0RGVmYXVsdEZyYWdTaGFkZXJNYWluKSh0aGlzLmNvbnRleHQuZ2xDb250ZXh0LnZlcnNpb24sdGhpcy5jb250ZXh0Lm91dHB1dFRleHR1cmVMYXlvdXQuc2hhcGUubGVuZ3RoKX1gKSxlPSgwLGkucmVwbGFjZUlubGluZXMpKGUpLGAkeygwLGEuZ2V0RnJhZ1NoYWRlclByZWFtYmxlKSh0aGlzLmNvbnRleHQuZ2xDb250ZXh0LnZlcnNpb24pfVxcbiAgICAke3RoaXMuZ2V0VW5pZm9ybXModC5pbnB1dE5hbWVzLHQudmFyaWFibGVzKX1cXG4gICAgJHt0aGlzLmdldEltcG9ydHMoZSl9XFxuICAgICR7ZX1gfWdldEltcG9ydHModCl7Y29uc3QgZT10aGlzLnNlbGVjdEdsc2xMaWJSb3V0aW5lc1RvQmVJbmNsdWRlZCh0KTtpZigwPT09ZS5sZW5ndGgpcmV0dXJuXCJcIjtsZXQgbj1cIlwiO2ZvcihsZXQgdD0wO3Q8ZS5sZW5ndGg7Kyt0KXtpZighZVt0XS5yb3V0aW5lQm9keSl0aHJvdyBuZXcgRXJyb3IoYE1pc3NpbmcgYm9keSBmb3IgdGhlIEdsc2wgTGlicmFyeSByb3V0aW5lOiAke2VbdF0ubmFtZX1gKTtuKz1lW3RdLnJvdXRpbmVCb2R5K1wiXFxuXCJ9cmV0dXJuIG59c2VsZWN0R2xzbExpYlJvdXRpbmVzVG9CZUluY2x1ZGVkKHQpe2NvbnN0IGU9W107cmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuZ2xzbExpYlJvdXRpbmVEZXBlbmRlbmN5R3JhcGgpLmZvckVhY2goKG49Pntjb25zdCByPW4uc3BsaXQoXCIuXCIpWzFdOy0xIT09dC5pbmRleE9mKHIpJiZlLnB1c2godGhpcy5nbHNsTGliUm91dGluZURlcGVuZGVuY3lHcmFwaFtuXSl9KSksci5Ub3BvbG9naWNhbFNvcnRHbHNsUm91dGluZXMucmV0dXJuT3JkZXJlZE5vZGVzKGUpfWdldFVuaWZvcm1zKHQsZSl7Y29uc3Qgbj1bXTtpZih0KWZvcihjb25zdCBlIG9mIHQpbi5wdXNoKGB1bmlmb3JtIHNhbXBsZXIyRCAke2V9O2ApO2lmKGUpZm9yKGNvbnN0IHQgb2YgZSluLnB1c2goYHVuaWZvcm0gJHt0LnR5cGV9ICR7dC5uYW1lfSR7dC5hcnJheUxlbmd0aD9gWyR7dC5hcnJheUxlbmd0aH1dYDpcIlwifTtgKTtyZXR1cm4gbi5qb2luKFwiXFxuXCIpfX19LDU0ODM6KHQsZSxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUuZ2xzbFJlZ2lzdHJ5PXZvaWQgMDtjb25zdCByPW4oNTEwNyksaT1uKDczNDEpLG89big5ODk0KSxhPW4oMjY1NSkscz1uKDM4OTEpO2UuZ2xzbFJlZ2lzdHJ5PXtlbmNvZGluZzppLkVuY29kaW5nR2xzbExpYixmcmFnY29sb3I6by5GcmFnQ29sb3JHbHNsTGliLHZlYzpzLlZlY0dsc2xMaWIsc2hhcGVVdGlsczphLlNoYXBlVXRpbHNHbHNsTGliLGNvb3JkaW5hdGVzOnIuQ29vcmRzR2xzbExpYn19LDI2NTU6KHQsZSxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUuU2hhcGVVdGlsc0dsc2xMaWI9dm9pZCAwO2NvbnN0IHI9big4NTIwKTtjbGFzcyBpIGV4dGVuZHMgci5HbHNsTGlie2NvbnN0cnVjdG9yKHQpe3N1cGVyKHQpfWdldEZ1bmN0aW9ucygpe3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sdGhpcy5iY2FzdEluZGV4KCkpLHRoaXMuYmNhc3RNYXRtdWxJbmRleCgpKSx0aGlzLm9mZnNldFRvSW5kaWNlcygpKSx0aGlzLmluZGljZXNUb09mZnNldCgpKSx0aGlzLmluY3JlbWVudEluZGljZXMoKSl9Z2V0Q3VzdG9tVHlwZXMoKXtyZXR1cm57fX1iY2FzdEluZGV4KCl7Y29uc3QgdD10aGlzLmNvbnRleHQub3V0cHV0VGV4dHVyZUxheW91dC5zaGFwZS5sZW5ndGgsZT17fTtyZXR1cm4gdGhpcy5jb250ZXh0LnByb2dyYW1JbmZvLmlucHV0TmFtZXMuZm9yRWFjaCgoKG4saSk9Pntjb25zdCBvPXRoaXMuY29udGV4dC5pbnB1dFRleHR1cmVMYXlvdXRzW2ldLnVucGFja2VkU2hhcGU7aWYoby5sZW5ndGg8PXQpe2NvbnN0IGk9by5sZW5ndGgsYT10LWkscz1gYmNhc3RJbmRpY2VzXyR7bn1gO2xldCB1PVwiXCI7Zm9yKGxldCB0PTA7dDxpOysrdCl1Kz1gXFxuICAgICAgICAgIHJlYWxJbmRpY2VzWyR7dH1dID0gaW50KCBtb2QoZmxvYXQoYmNhc3RlZEluZGljZXNbJHthK3R9XSksICR7b1t0XX0uMCkgKTtcXG4gICAgICAgICAgYDtjb25zdCBjPWBcXG4gICAgICAgIHZvaWQgJHtzfSAoaW50IGJjYXN0ZWRJbmRpY2VzWyR7dH1dLCBvdXQgaW50IHJlYWxJbmRpY2VzWyR7aX1dKSB7XFxuICAgICAgICAgICR7dX1cXG4gICAgICAgIH1cXG4gICAgICAgIGA7ZVtzXT1uZXcgci5HbHNsTGliUm91dGluZShjKX19KSksZX1iY2FzdE1hdG11bEluZGV4KCl7Y29uc3QgdD10aGlzLmNvbnRleHQub3V0cHV0VGV4dHVyZUxheW91dC5zaGFwZS5sZW5ndGgsZT17fTtyZXR1cm4gdGhpcy5jb250ZXh0LnByb2dyYW1JbmZvLmlucHV0TmFtZXMuZm9yRWFjaCgoKG4saSk9Pntjb25zdCBvPXRoaXMuY29udGV4dC5pbnB1dFRleHR1cmVMYXlvdXRzW2ldLnNoYXBlO2lmKCEoby5sZW5ndGg8Mnx8by5sZW5ndGg+dCkpe2NvbnN0IGk9by5sZW5ndGgsYT10LWkscz1gYmNhc3RNYXRtdWxJbmRpY2VzXyR7bn1gO2xldCB1PVwiXCI7Zm9yKGxldCB0PTA7dDxpLTI7Kyt0KXUrPWBcXG4gICAgICAgICAgcmVhbEluZGljZXNbJHt0fV0gPSBpbnQoIG1vZChmbG9hdChiY2FzdGVkSW5kaWNlc1ske2ErdH1dKSwgJHtvW3RdfS4wKSApO1xcbiAgICAgICAgICBgO2NvbnN0IGM9YFxcbiAgICAgICAgdm9pZCAke3N9KGludCBiY2FzdGVkSW5kaWNlc1ske3R9XSwgb3V0IGludCByZWFsSW5kaWNlc1ske2l9XSkge1xcbiAgICAgICAgICAke3V9XFxuICAgICAgICAgIHJlYWxJbmRpY2VzWyR7aS0xfV0gPSBiY2FzdGVkSW5kaWNlc1ske3QtMX1dO1xcbiAgICAgICAgICByZWFsSW5kaWNlc1ske2ktMn1dID0gYmNhc3RlZEluZGljZXNbJHt0LTJ9XTtcXG4gICAgICAgIH1cXG4gICAgICAgIGA7ZVtzXT1uZXcgci5HbHNsTGliUm91dGluZShjKX19KSksZX1pbmRpY2VzVG9PZmZzZXQoKXtjb25zdCB0PXt9O3JldHVybiB0aGlzLmNvbnRleHQucHJvZ3JhbUluZm8uaW5wdXROYW1lcy5mb3JFYWNoKCgoZSxuKT0+e2NvbnN0IG89dGhpcy5jb250ZXh0LmlucHV0VGV4dHVyZUxheW91dHNbbl0uc2hhcGUsYT10aGlzLmNvbnRleHQuaW5wdXRUZXh0dXJlTGF5b3V0c1tuXS5zdHJpZGVzLHM9by5sZW5ndGg7bGV0IHU9YGluZGljZXNUb09mZnNldF8ke2V9YDt0W3VdPW5ldyByLkdsc2xMaWJSb3V0aW5lKGkuaW5kZXhUb09mZnNldFNpbmdsZSh1LHMsYSkpLHU9YGluZGljZXNUb09mZnNldF8ke2V9X1RgLHRbdV09bmV3IHIuR2xzbExpYlJvdXRpbmUoaS5pbmRleFRvT2Zmc2V0U2luZ2xlKHUscyxhLnNsaWNlKCkucmV2ZXJzZSgpKSl9KSksdH1zdGF0aWMgaW5kZXhUb09mZnNldFNpbmdsZSh0LGUsbil7bGV0IHI9XCJcIjtmb3IobGV0IHQ9ZS0xO3Q+PTA7LS10KXIrPWBcXG4gICAgICAgIG9mZnNldCArPSBpbmRpY2VzWyR7dH1dICogJHtuW3RdfTtcXG4gICAgICAgIGA7cmV0dXJuYFxcbiAgICAgIGludCAke3R9KGludCBpbmRpY2VzWyR7ZX1dKSB7XFxuICAgICAgICBpbnQgb2Zmc2V0ID0gMDtcXG4gICAgICAgICR7cn1cXG4gICAgICAgIHJldHVybiBvZmZzZXQ7XFxuICAgICAgfVxcbiAgICAgIGB9b2Zmc2V0VG9JbmRpY2VzKCl7Y29uc3QgdD17fTtyZXR1cm4gdGhpcy5jb250ZXh0LnByb2dyYW1JbmZvLmlucHV0TmFtZXMuZm9yRWFjaCgoKGUsbik9Pntjb25zdCBvPXRoaXMuY29udGV4dC5pbnB1dFRleHR1cmVMYXlvdXRzW25dLnNoYXBlLGE9dGhpcy5jb250ZXh0LmlucHV0VGV4dHVyZUxheW91dHNbbl0uc3RyaWRlcyxzPW8ubGVuZ3RoO2xldCB1PWBvZmZzZXRUb0luZGljZXNfJHtlfWA7dFt1XT1uZXcgci5HbHNsTGliUm91dGluZShpLm9mZnNldFRvSW5kaWNlc1NpbmdsZSh1LHMsYSkpLHU9YG9mZnNldFRvSW5kaWNlc18ke2V9X1RgLHRbdV09bmV3IHIuR2xzbExpYlJvdXRpbmUoaS5vZmZzZXRUb0luZGljZXNTaW5nbGUodSxzLGEuc2xpY2UoKS5yZXZlcnNlKCkpKX0pKSx0fXN0YXRpYyBvZmZzZXRUb0luZGljZXNTaW5nbGUodCxlLG4pe2NvbnN0IHI9W107Zm9yKGxldCB0PTA7dDxlLTE7Kyt0KXIucHVzaChgXFxuICAgICAgaW5kaWNlc1ske3R9XSA9IG9mZnNldCAvICR7blt0XX07YCksci5wdXNoKGBcXG4gICAgICAgIG9mZnNldCAtPSBpbmRpY2VzWyR7dH1dICogJHtuW3RdfTtgKTtyZXR1cm4gci5wdXNoKGBcXG4gICAgICBpbmRpY2VzWyR7ZS0xfV0gPSBvZmZzZXQ7YCksYFxcbiAgICAgIHZvaWQgJHt0fShpbnQgb2Zmc2V0LCBvdXQgaW50IGluZGljZXNbJHtlfV0pIHtcXG4gICAgICAgICR7ci5qb2luKFwiXCIpfVxcbiAgICAgIH1cXG4gICAgICBgfWluY3JlbWVudEluZGljZXMoKXtjb25zdCB0PXt9O3JldHVybiB0aGlzLmNvbnRleHQucHJvZ3JhbUluZm8uaW5wdXROYW1lcy5mb3JFYWNoKCgoZSxuKT0+e2NvbnN0IGk9dGhpcy5jb250ZXh0LmlucHV0VGV4dHVyZUxheW91dHNbbl0uc2hhcGUsbz1pLmxlbmd0aCxhPWBpbmNyZW1lbnRJbmRpY2VzXyR7ZX1gO2xldCBzPVwiXCI7Zm9yKGxldCB0PTA7dDxvOysrdClzKz1gXFxuICAgICAgICBzaGFwZVske3R9XSA9ICR7aVt0XX07YDtjb25zdCB1PWBcXG4gICAgICAgIHZvaWQgJHthfShpbnQgYXhpcywgb3V0IGludCBpbmRpY2VzWyR7b31dKSB7XFxuICAgICAgICAgIGludCBzaGFwZVske299XTtcXG4gICAgICAgICAgJHtzfTtcXG4gICAgICAgICAgZm9yKGludCBpID0gJHtvfSAtMSA7IGkgPj0gMDsgLS1pKSB7XFxuICAgICAgICAgICAgaWYoaSA+IGF4aXMpIGNvbnRpbnVlO1xcbiAgICAgICAgICAgIGluZGljZXNbaV0gKz0gMTtcXG4gICAgICAgICAgICBpZihpbmRpY2VzW2ldIDwgc2hhcGVbaV0pIHtcXG4gICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBpbmRpY2VzW2ldID0gMDtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgYDt0W2FdPW5ldyByLkdsc2xMaWJSb3V0aW5lKHUpfSkpLHR9fWUuU2hhcGVVdGlsc0dsc2xMaWI9aX0sNTA2MDoodCxlKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUuZ2V0RGVmYXVsdEZyYWdTaGFkZXJNYWluPWUuZ2V0RnJhZ1NoYWRlclByZWFtYmxlPWUuZ2V0VmVydGV4U2hhZGVyU291cmNlPWUuZ2V0R2xzbD12b2lkIDA7Y29uc3Qgbj17dmVyc2lvbjpcIlwiLGF0dHJpYnV0ZTpcImF0dHJpYnV0ZVwiLHZhcnlpbmdWZXJ0ZXg6XCJ2YXJ5aW5nXCIsdmFyeWluZ0ZyYWc6XCJ2YXJ5aW5nXCIsdGV4dHVyZTJEOlwidGV4dHVyZTJEXCIsb3V0cHV0OlwiZ2xfRnJhZ0NvbG9yXCIsb3V0cHV0RGVjbGFyYXRpb246XCJcIn0scj17dmVyc2lvbjpcIiN2ZXJzaW9uIDMwMCBlc1wiLGF0dHJpYnV0ZTpcImluXCIsdmFyeWluZ1ZlcnRleDpcIm91dFwiLHZhcnlpbmdGcmFnOlwiaW5cIix0ZXh0dXJlMkQ6XCJ0ZXh0dXJlXCIsb3V0cHV0Olwib3V0cHV0Q29sb3JcIixvdXRwdXREZWNsYXJhdGlvbjpcIm91dCB2ZWM0IG91dHB1dENvbG9yO1wifTtmdW5jdGlvbiBpKHQpe3JldHVybiAxPT09dD9uOnJ9ZS5nZXRHbHNsPWksZS5nZXRWZXJ0ZXhTaGFkZXJTb3VyY2U9ZnVuY3Rpb24odCl7Y29uc3QgZT1pKHQpO3JldHVybmAke2UudmVyc2lvbn1cXG4gICAgICBwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuICAgICAgJHtlLmF0dHJpYnV0ZX0gdmVjMyBwb3NpdGlvbjtcXG4gICAgICAke2UuYXR0cmlidXRlfSB2ZWMyIHRleHR1cmVDb29yZDtcXG5cXG4gICAgICAke2UudmFyeWluZ1ZlcnRleH0gdmVjMiBUZXhDb29yZHM7XFxuXFxuICAgICAgdm9pZCBtYWluKClcXG4gICAgICB7XFxuICAgICAgICAgIGdsX1Bvc2l0aW9uID0gdmVjNChwb3NpdGlvbiwgMS4wKTtcXG4gICAgICAgICAgVGV4Q29vcmRzID0gdGV4dHVyZUNvb3JkO1xcbiAgICAgIH1gfSxlLmdldEZyYWdTaGFkZXJQcmVhbWJsZT1mdW5jdGlvbih0KXtjb25zdCBlPWkodCk7cmV0dXJuYCR7ZS52ZXJzaW9ufVxcbiAgICBwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuICAgIHByZWNpc2lvbiBoaWdocCBpbnQ7XFxuICAgIHByZWNpc2lvbiBoaWdocCBzYW1wbGVyMkQ7XFxuICAgICR7ZS52YXJ5aW5nRnJhZ30gdmVjMiBUZXhDb29yZHM7XFxuICAgICR7ZS5vdXRwdXREZWNsYXJhdGlvbn1cXG4gICAgY29uc3QgdmVjMiBoYWxmQ1IgPSB2ZWMyKDAuNSwgMC41KTtcXG5cXG4gICAgLy8gQ3VzdG9tIHZlY3RvciB0eXBlcyB0byBoYW5kbGUgaGlnaGVyIGRpbWVuYWxpdGllcy5cXG4gICAgc3RydWN0IGl2ZWM1XFxuICAgIHtcXG4gICAgICBpbnQgeDtcXG4gICAgICBpbnQgeTtcXG4gICAgICBpbnQgejtcXG4gICAgICBpbnQgdztcXG4gICAgICBpbnQgdTtcXG4gICAgfTtcXG5cXG4gICAgc3RydWN0IGl2ZWM2XFxuICAgIHtcXG4gICAgICBpbnQgeDtcXG4gICAgICBpbnQgeTtcXG4gICAgICBpbnQgejtcXG4gICAgICBpbnQgdztcXG4gICAgICBpbnQgdTtcXG4gICAgICBpbnQgdjtcXG4gICAgfTtcXG5cXG4gICAgaW50IGltb2QoaW50IHgsIGludCB5KSB7XFxuICAgICAgcmV0dXJuIHggLSB5ICogKHggLyB5KTtcXG4gICAgfVxcblxcbiAgICBgfSxlLmdldERlZmF1bHRGcmFnU2hhZGVyTWFpbj1mdW5jdGlvbih0LGUpe3JldHVybmBcXG4gIHZvaWQgbWFpbigpIHtcXG4gICAgaW50IGluZGljZXNbJHtlfV07XFxuICAgIHRvVmVjKFRleENvb3JkcywgaW5kaWNlcyk7XFxuICAgIHZlYzQgcmVzdWx0ID0gdmVjNChwcm9jZXNzKGluZGljZXMpKTtcXG4gICAgJHtpKHQpLm91dHB1dH0gPSByZXN1bHQ7XFxuICB9XFxuICBgfX0sMzg5MToodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5WZWNHbHNsTGliPXZvaWQgMDtjb25zdCByPW4oODUyMCk7Y2xhc3MgaSBleHRlbmRzIHIuR2xzbExpYntjb25zdHJ1Y3Rvcih0KXtzdXBlcih0KX1nZXRDdXN0b21UeXBlcygpe3JldHVybnt9fWdldEZ1bmN0aW9ucygpe3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LHRoaXMuYmluYXJ5VmVjRnVuY3Rpb25zKCkpLHRoaXMuY29weVZlYygpKSx0aGlzLnNldFZlY0l0ZW0oKSksdGhpcy5nZXRWZWNJdGVtKCkpfWJpbmFyeVZlY0Z1bmN0aW9ucygpe2NvbnN0IHQ9dGhpcy5jb250ZXh0Lm91dHB1dFRleHR1cmVMYXlvdXQuc2hhcGUubGVuZ3RoLGU9e2FkZDpcIis9XCIsc3ViOlwiLT1cIixtdWw6XCIqPVwiLGRpdjpcIi89XCJ9LG49e307Zm9yKGNvbnN0IGkgaW4gZSl7Y29uc3Qgbz1gJHtpfVZlY2A7bGV0IGE9XCJcIjtmb3IobGV0IG49MDtuPHQ7KytuKWErPWBcXG4gICAgICAgICAgZGVzdFske259XSAke2VbaV19IHNyY1ske259XTtcXG4gICAgICAgICAgYDtjb25zdCBzPWBcXG4gICAgICAgIHZvaWQgJHtvfShpbnQgc3JjWyR7dH1dLCBvdXQgaW50IGRlc3RbJHt0fV0pIHtcXG4gICAgICAgICAgJHthfVxcbiAgICAgICAgfVxcbiAgICAgICAgYDtuW29dPW5ldyByLkdsc2xMaWJSb3V0aW5lKHMpfXJldHVybiBufWNvcHlWZWMoKXtjb25zdCB0PXRoaXMuY29udGV4dC5vdXRwdXRUZXh0dXJlTGF5b3V0LnNoYXBlLmxlbmd0aDtsZXQgZT1cIlwiO2ZvcihsZXQgbj0wO248dDsrK24pZSs9YFxcbiAgICAgICAgZGVzdFske259XSA9IHNyY1ske259XTtcXG4gICAgICAgIGA7Y29uc3Qgbj1gXFxuICAgICAgdm9pZCBjb3B5VmVjKGludCBzcmNbJHt0fV0sIG91dCBpbnQgZGVzdFske3R9XSkge1xcbiAgICAgICAgJHtlfVxcbiAgICAgIH1cXG4gICAgICBgO3JldHVybntjb3B5VmVjOm5ldyByLkdsc2xMaWJSb3V0aW5lKG4pfX1zZXRWZWNJdGVtKCl7Y29uc3QgdD10aGlzLmNvbnRleHQub3V0cHV0VGV4dHVyZUxheW91dC5zaGFwZS5sZW5ndGg7bGV0IGU9YFxcbiAgICAgICAgaWYoaW5kZXggPCAwKVxcbiAgICAgICAgICAgIGluZGV4ID0ke3R9ICsgaW5kZXg7XFxuICAgICAgICBpZiAoaW5kZXggPT0gMClcXG4gICAgICAgICAgICBtWzBdID0gdmFsdWU7XFxuICAgICAgICBgO2ZvcihsZXQgbj0xO248dC0xOysrbillKz1gXFxuICAgICAgICBlbHNlIGlmIChpbmRleCA9PSAke259KVxcbiAgICAgICAgICAgIG1bJHtufV0gPSB2YWx1ZTtcXG4gICAgICAgICAgICBgO2UrPWBcXG4gICAgICAgIGVsc2VcXG4gICAgICAgICAgICBtWyR7dC0xfV0gPSB2YWx1ZTtcXG4gICAgICAgIGA7Y29uc3Qgbj1gXFxuICAgICAgdm9pZCBzZXRWZWNJdGVtKG91dCBpbnQgbVske3R9XSwgaW50IGluZGV4LCBpbnQgdmFsdWUpIHtcXG4gICAgICAgICR7ZX1cXG4gICAgICB9XFxuICAgICAgICBgO3JldHVybntzZXRWZWNJdGVtOm5ldyByLkdsc2xMaWJSb3V0aW5lKG4pfX1nZXRWZWNJdGVtKCl7Y29uc3QgdD10aGlzLmNvbnRleHQub3V0cHV0VGV4dHVyZUxheW91dC5zaGFwZS5sZW5ndGg7bGV0IGU9YFxcbiAgICAgICAgaWYoaW5kZXggPCAwKVxcbiAgICAgICAgICAgIGluZGV4ID0gJHt0fSArIGluZGV4O1xcbiAgICAgICAgaWYgKGluZGV4ID09IDApXFxuICAgICAgICAgICAgcmV0dXJuIG1bMF07XFxuICAgICAgYDtmb3IobGV0IG49MTtuPHQtMTsrK24pZSs9YFxcbiAgICAgICAgZWxzZSBpZiAoaW5kZXggPT0gJHtufSlcXG4gICAgICAgICAgICByZXR1cm4gbVske259XTtcXG4gICAgICBgO2UrPWBcXG4gICAgICAgIGVsc2VcXG4gICAgICAgICAgICByZXR1cm4gbVske3QtMX1dO1xcbiAgICAgICAgYDtjb25zdCBuPWBcXG4gICAgICBpbnQgZ2V0VmVjSXRlbShpbnQgbVske3R9XSwgaW50IGluZGV4KSB7XFxuICAgICAgICAke2V9XFxuICAgICAgfVxcbiAgICBgO3JldHVybntnZXRWZWNJdGVtOm5ldyByLkdsc2xMaWJSb3V0aW5lKG4pfX19ZS5WZWNHbHNsTGliPWl9LDgzMTY6KHQsZSxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUuV2ViR0xJbmZlcmVuY2VIYW5kbGVyPXZvaWQgMDtjb25zdCByPW4oMzY5NCksaT1uKDkxNjIpLG89bigyNTE3KSxhPW4oMjQwMykscz1uKDcwMTkpLHU9big4NzEwKSxjPW4oNTYxMSksbD1uKDQwNTcpLHA9bigyMDM5KTtlLldlYkdMSW5mZXJlbmNlSGFuZGxlcj1jbGFzc3tjb25zdHJ1Y3Rvcih0KXt0aGlzLnNlc3Npb249dCx0aGlzLnBhY2tlZFRleHR1cmVEYXRhQ2FjaGU9bmV3IE1hcCx0aGlzLnVucGFja2VkVGV4dHVyZURhdGFDYWNoZT1uZXcgTWFwfWNhbGN1bGF0ZVRleHR1cmVXaWR0aEFuZEhlaWdodCh0LGUpe3JldHVybigwLGwuY2FsY3VsYXRlVGV4dHVyZVdpZHRoQW5kSGVpZ2h0KSh0aGlzLnNlc3Npb24ubGF5b3V0U3RyYXRlZ3ksdCxlKX1leGVjdXRlUHJvZ3JhbSh0LGUpe2lmKGUubGVuZ3RoPHQuaW5wdXROYW1lcy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKGBJbnB1dCBzaXplIG11c3RuJ3QgYmUgbGVzcyB0aGFuICR7dC5pbnB1dE5hbWVzLmxlbmd0aH0uYCk7aWYodC5pbnB1dE5hbWVzLmxlbmd0aCE9PXQuaW5wdXRUeXBlcy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiaW5wdXQgbmFtZXMgc2l6ZSBkb2VzIG5vdCBtYXRjaCBpbnB1dCB0eXBlc1wiKTtjb25zdCBuPVtdO2ZvcihsZXQgcj0wO3I8dC5pbnB1dE5hbWVzLmxlbmd0aDsrK3IpbltyXT10aGlzLmdldE9yQ3JlYXRlVGV4dHVyZURhdGEoZVtyXSx0LmlucHV0VHlwZXNbcl0pO2NvbnN0IHI9KCh0LGUpPT57Y29uc3Qgbj1lLm1hcCgodD0+YCR7dC51bnBhY2tlZFNoYXBlLmpvaW4oXCIsXCIpfTske3Qud2lkdGh9eCR7dC5oZWlnaHR9YCkpLmpvaW4oXCJfXCIpO2xldCByPXQubmFtZTtyZXR1cm4gdC5jYWNoZUhpbnQmJihyKz1cIltcIit0LmNhY2hlSGludCtcIl1cIikscis9XCI6XCIrbixyfSkodCxuKTtsZXQgaT10aGlzLnNlc3Npb24ucHJvZ3JhbU1hbmFnZXIuZ2V0QXJ0aWZhY3Qocik7Y29uc3Qgbz1pP2kucHJvZ3JhbUluZm86XCJmdW5jdGlvblwiPT10eXBlb2YgdC5nZXQ/dC5nZXQoKTp0LGE9KDAsbC5jcmVhdGVUZXh0dXJlTGF5b3V0RnJvbVRleHR1cmVUeXBlKSh0aGlzLnNlc3Npb24ubGF5b3V0U3RyYXRlZ3ksby5vdXRwdXQuZGltcyxvLm91dHB1dC50ZXh0dXJlVHlwZSkscz10aGlzLmNyZWF0ZVRleHR1cmVEYXRhKGEsby5vdXRwdXQudHlwZSk7cmV0dXJuIGl8fChpPXRoaXMuc2Vzc2lvbi5wcm9ncmFtTWFuYWdlci5idWlsZChvLG4scyksdGhpcy5zZXNzaW9uLnByb2dyYW1NYW5hZ2VyLnNldEFydGlmYWN0KHIsaSkpLHRoaXMucnVuUHJvZ3JhbShpLG4scyksc31ydW4odCxlKXtyZXR1cm4gdGhpcy5leGVjdXRlUHJvZ3JhbSh0LGUpLnRlbnNvcn1ydW5Qcm9ncmFtKHQsZSxuKXtmb3IobGV0IG49MDtuPGUubGVuZ3RoOysrbilpZighIWVbbl0uaXNQYWNrZWQhPSh0LnByb2dyYW1JbmZvLmlucHV0VHlwZXNbbl09PT1wLlRleHR1cmVUeXBlLnBhY2tlZCkpdGhyb3cgbmV3IEVycm9yKGBpbnB1dFske259XSBwcm9wZXJ0eSBwYWNrZWQgaW5jb25zaXN0ZW50YCk7aWYoISFuLmlzUGFja2VkIT0odC5wcm9ncmFtSW5mby5vdXRwdXQudGV4dHVyZVR5cGU9PT1wLlRleHR1cmVUeXBlLnBhY2tlZCkpdGhyb3cgbmV3IEVycm9yKFwib3V0cHV0IHByb3BlcnR5IHBhY2tlZCBpbmNvbnNpc3RlbnRcIik7dGhpcy5zZXNzaW9uLnByb2dyYW1NYW5hZ2VyLnJ1bih0LGUsbil9Z2V0T3JDcmVhdGVUZXh0dXJlRGF0YSh0LGUpe2xldCBuPXRoaXMuZ2V0VGV4dHVyZURhdGEodC5kYXRhSWQsZT09PXAuVGV4dHVyZVR5cGUucGFja2VkKTtpZighbiYmKG49dGhpcy5nZXRUZXh0dXJlRGF0YSh0LmRhdGFJZCxlIT09cC5UZXh0dXJlVHlwZS5wYWNrZWQpLG4pKXJldHVybiBlPT09cC5UZXh0dXJlVHlwZS5wYWNrZWQ/dGhpcy5wYWNrKG4pOnRoaXMudW5wYWNrKG4pO2lmKCFuKXtjb25zdCByPSgwLGwuY3JlYXRlVGV4dHVyZUxheW91dEZyb21UZXh0dXJlVHlwZSkodGhpcy5zZXNzaW9uLmxheW91dFN0cmF0ZWd5LHQuZGltcyxlKTtpZihlPT09cC5UZXh0dXJlVHlwZS5wYWNrZWRMYXN0RGltZW5zaW9uKXtjb25zdCBuPTEscj00LGk9dC5kaW1zO2lmKDQ9PT1pLmxlbmd0aCl7Y29uc3Qgbz1baVswXSxNYXRoLmNlaWwoaVsxXSppWzJdKmlbM10vcildLGE9KDAsbC5jcmVhdGVUZXh0dXJlTGF5b3V0RnJvbVRleHR1cmVUeXBlKSh0aGlzLnNlc3Npb24ubGF5b3V0U3RyYXRlZ3ksbyxlKTtsZXQgcz10Lm51bWJlckRhdGE7aWYoaVsxXSppWzJdKmlbM10lciE9MCl7Y29uc3QgZT1pWzBdLG89aVsxXSppWzJdKmlbM10sYT1NYXRoLmNlaWwobypuL3IpKnI7cz1uZXcgRmxvYXQzMkFycmF5KGUqYSk7Zm9yKGxldCByPTA7cjxlOysrcil7Y29uc3QgZT1yKm8saT1yKmErciVuKm87cy5zZXQodC5udW1iZXJEYXRhLnN1YmFycmF5KGUsZStvKSxpKX19cmV0dXJuIHRoaXMuY3JlYXRlVGV4dHVyZURhdGEoYSx0LnR5cGUscyx0LDEpfX1pZihlPT09cC5UZXh0dXJlVHlwZS5wYWNrZWQpe2NvbnN0IGU9KDAsbC5jcmVhdGVUZXh0dXJlTGF5b3V0RnJvbVNoYXBlKSh0aGlzLnNlc3Npb24ubGF5b3V0U3RyYXRlZ3ksdC5kaW1zLDEsW10se3JldmVyc2VXSDohMH0pLHI9dGhpcy5jcmVhdGVUZXh0dXJlRGF0YShlLHQudHlwZSx0Lm51bWJlckRhdGEsdCwxKTtuPXRoaXMucGFjayhyKX1lbHNlIG49dGhpcy5jcmVhdGVUZXh0dXJlRGF0YShyLHQudHlwZSx0Lm51bWJlckRhdGEsdCwxKX1yZXR1cm4gbn1jcmVhdGVUZXh0dXJlRGF0YUZyb21MYXlvdXRCaW5kVGVuc29yKHQsZSxuLHIpe3JldHVybiB0aGlzLmNyZWF0ZVRleHR1cmVEYXRhKHQsZSxuLHIsMSl9Y3JlYXRlVGV4dHVyZURhdGEodCxlLG4saSxvKXtyLkxvZ2dlci52ZXJib3NlKFwiSW5mZXJlbmNlSGFuZGxlclwiLGBDcmVhdGluZyBUZXh0dXJlRGF0YTogbGF5b3V0Olske0pTT04uc3RyaW5naWZ5KHQpfV1gKTtjb25zdCBhPXRoaXMuc2Vzc2lvbi50ZXh0dXJlTWFuYWdlci5jcmVhdGVUZXh0dXJlRnJvbUxheW91dChlLHQsbixvKTtyZXR1cm4gdGhpcy5jcmVhdGVUZXh0dXJlRGF0YUZyb21UZXh0dXJlKHQsZSxhLGkpfXJlc2hhcGVVbnBhY2tlZCh0LGUpe2NvbnN0IG49dGhpcy5nZXRPckNyZWF0ZVRleHR1cmVEYXRhKHQscC5UZXh0dXJlVHlwZS51bnBhY2tlZCkscj17Y2hhbm5lbHM6bi5jaGFubmVscyxoZWlnaHQ6bi5oZWlnaHQsd2lkdGg6bi53aWR0aCxzaGFwZTowIT09ZS5sZW5ndGg/ZTpbMV0sc3RyaWRlczpvLlNoYXBlVXRpbC5jb21wdXRlU3RyaWRlcyhlKSx1bnBhY2tlZFNoYXBlOmV9O3JldHVybiB0aGlzLmNyZWF0ZVRleHR1cmVEYXRhRnJvbVRleHR1cmUocix0LnR5cGUsbi50ZXh0dXJlKS50ZW5zb3J9cmVzaGFwZVBhY2tlZCh0LGUpe2NvbnN0IG49dGhpcy5nZXRPckNyZWF0ZVRleHR1cmVEYXRhKHQscC5UZXh0dXJlVHlwZS5wYWNrZWQpO2lmKCgwLHMuaXNSZXNoYXBlQ2hlYXApKHQuZGltcyxlKSl7Y29uc3Qgcj17Y2hhbm5lbHM6bi5jaGFubmVscyxoZWlnaHQ6bi5oZWlnaHQsd2lkdGg6bi53aWR0aCxzaGFwZTowIT09ZS5sZW5ndGg/ZTpbMV0sc3RyaWRlczpvLlNoYXBlVXRpbC5jb21wdXRlU3RyaWRlcyhlKSx1bnBhY2tlZFNoYXBlOmUsaXNQYWNrZWQ6ITB9O3JldHVybiB0aGlzLmNyZWF0ZVRleHR1cmVEYXRhRnJvbVRleHR1cmUocix0LnR5cGUsbi50ZXh0dXJlKS50ZW5zb3J9Y29uc3Qgcj0oMCxzLnByb2Nlc3NEaW1zM0QpKHQuZGltcyksaT0oMCxzLnByb2Nlc3NEaW1zM0QpKGUpLGE9dGhpcy5yZXNoYXBlUGFja2VkKHQsciksdT10aGlzLnJ1bigoMCxzLmNyZWF0ZVBhY2tlZFJlc2hhcGUzRFByb2dyYW1JbmZvTG9hZGVyKSh0aGlzLGEsaSksW2FdKTtyZXR1cm4gdGhpcy5yZXNoYXBlUGFja2VkKHUsZSl9Y2FzdCh0LGUpe2NvbnN0IG49dGhpcy5nZXRPckNyZWF0ZVRleHR1cmVEYXRhKHQscC5UZXh0dXJlVHlwZS51bnBhY2tlZCk7cmV0dXJuIHRoaXMuY3JlYXRlVGV4dHVyZURhdGFGcm9tVGV4dHVyZShuLGUsbi50ZXh0dXJlKS50ZW5zb3J9Y3JlYXRlVGV4dHVyZURhdGFGcm9tVGV4dHVyZSh0LGUsbixyLG8pe2NvbnN0IGE9T2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LHQpLHt0ZW5zb3I6cnx8bmV3IGkuVGVuc29yKHQudW5wYWNrZWRTaGFwZSxlLCh0PT50aGlzLnJlYWRUZXh0dXJlKGEpKSwoYXN5bmMgdD0+dGhpcy5yZWFkVGV4dHVyZUFzeW5jKGEpKSx2b2lkIDAsbyksdGV4dHVyZTpufSk7cmV0dXJuIHRoaXMuc2V0VGV4dHVyZURhdGEoYS50ZW5zb3IuZGF0YUlkLGEsdC5pc1BhY2tlZCksYX1nZXRUZXh0dXJlRGF0YSh0LGU9ITEpe3JldHVybiB0aGlzLnNlc3Npb24uaXNJbml0aWFsaXplcih0KT90aGlzLnNlc3Npb24uZ2V0VGV4dHVyZURhdGEodCxlKTplP3RoaXMucGFja2VkVGV4dHVyZURhdGFDYWNoZS5nZXQodCk6dGhpcy51bnBhY2tlZFRleHR1cmVEYXRhQ2FjaGUuZ2V0KHQpfXNldFRleHR1cmVEYXRhKHQsZSxuPSExKXt0aGlzLnNlc3Npb24uaXNJbml0aWFsaXplcih0KT90aGlzLnNlc3Npb24uc2V0VGV4dHVyZURhdGEodCxlLG4pOihuP3RoaXMucGFja2VkVGV4dHVyZURhdGFDYWNoZTp0aGlzLnVucGFja2VkVGV4dHVyZURhdGFDYWNoZSkuc2V0KHQsZSl9aXNUZXh0dXJlTGF5b3V0Q2FjaGVkKHQsZT0hMSl7cmV0dXJuISF0aGlzLmdldFRleHR1cmVEYXRhKHQuZGF0YUlkLGUpfWRpc3Bvc2UoKXt0aGlzLnNlc3Npb24udGV4dHVyZU1hbmFnZXIuY2xlYXJBY3RpdmVUZXh0dXJlcygpLHRoaXMucGFja2VkVGV4dHVyZURhdGFDYWNoZS5mb3JFYWNoKCh0PT50aGlzLnNlc3Npb24udGV4dHVyZU1hbmFnZXIucmVsZWFzZVRleHR1cmUodCkpKSx0aGlzLnBhY2tlZFRleHR1cmVEYXRhQ2FjaGU9bmV3IE1hcCx0aGlzLnVucGFja2VkVGV4dHVyZURhdGFDYWNoZS5mb3JFYWNoKCh0PT50aGlzLnNlc3Npb24udGV4dHVyZU1hbmFnZXIucmVsZWFzZVRleHR1cmUodCkpKSx0aGlzLnVucGFja2VkVGV4dHVyZURhdGFDYWNoZT1uZXcgTWFwfXJlYWRUZXh0dXJlKHQpe3JldHVybiB0LmlzUGFja2VkP3RoaXMucmVhZFRleHR1cmUodGhpcy51bnBhY2sodCkpOnRoaXMuc2Vzc2lvbi5iYWNrZW5kLmdsQ29udGV4dC5pc0Zsb2F0MzJEb3dubG9hZFN1cHBvcnRlZD90aGlzLnNlc3Npb24udGV4dHVyZU1hbmFnZXIucmVhZFRleHR1cmUodCx0LnRlbnNvci50eXBlLHQuY2hhbm5lbHMpOnRoaXMuc2Vzc2lvbi50ZXh0dXJlTWFuYWdlci5yZWFkVWludDhUZXh0dXJlQXNGbG9hdCgoMCx1LmVuY29kZUFzVWludDgpKHRoaXMsdCkpfWFzeW5jIHJlYWRUZXh0dXJlQXN5bmModCl7cmV0dXJuIHQuaXNQYWNrZWQ/dGhpcy5yZWFkVGV4dHVyZUFzeW5jKHRoaXMudW5wYWNrKHQpKTp0aGlzLnNlc3Npb24uYmFja2VuZC5nbENvbnRleHQuaXNGbG9hdDMyRG93bmxvYWRTdXBwb3J0ZWQ/dGhpcy5zZXNzaW9uLnRleHR1cmVNYW5hZ2VyLnJlYWRUZXh0dXJlQXN5bmModCx0LnRlbnNvci50eXBlLHQuY2hhbm5lbHMpOnRoaXMuc2Vzc2lvbi50ZXh0dXJlTWFuYWdlci5yZWFkVWludDhUZXh0dXJlQXNGbG9hdCgoMCx1LmVuY29kZUFzVWludDgpKHRoaXMsdCkpfXBhY2sodCl7cmV0dXJuIHRoaXMuZXhlY3V0ZVByb2dyYW0oKDAsYS5jcmVhdGVQYWNrUHJvZ3JhbUluZm9Mb2FkZXIpKHRoaXMsdC50ZW5zb3IpLFt0LnRlbnNvcl0pfXVucGFjayh0KXtyZXR1cm4gdGhpcy5leGVjdXRlUHJvZ3JhbSgoMCxjLmNyZWF0ZVVucGFja1Byb2dyYW1JbmZvTG9hZGVyKSh0aGlzLHQudGVuc29yKSxbdC50ZW5zb3JdKX19fSwxNjQwOmZ1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjt2YXIgcj10aGlzJiZ0aGlzLl9fY3JlYXRlQmluZGluZ3x8KE9iamVjdC5jcmVhdGU/ZnVuY3Rpb24odCxlLG4scil7dm9pZCAwPT09ciYmKHI9bik7dmFyIGk9T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLG4pO2kmJiEoXCJnZXRcImluIGk/IWUuX19lc01vZHVsZTppLndyaXRhYmxlfHxpLmNvbmZpZ3VyYWJsZSl8fChpPXtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBlW25dfX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LHIsaSl9OmZ1bmN0aW9uKHQsZSxuLHIpe3ZvaWQgMD09PXImJihyPW4pLHRbcl09ZVtuXX0pLGk9dGhpcyYmdGhpcy5fX3NldE1vZHVsZURlZmF1bHR8fChPYmplY3QuY3JlYXRlP2Z1bmN0aW9uKHQsZSl7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJkZWZhdWx0XCIse2VudW1lcmFibGU6ITAsdmFsdWU6ZX0pfTpmdW5jdGlvbih0LGUpe3QuZGVmYXVsdD1lfSksbz10aGlzJiZ0aGlzLl9faW1wb3J0U3Rhcnx8ZnVuY3Rpb24odCl7aWYodCYmdC5fX2VzTW9kdWxlKXJldHVybiB0O3ZhciBlPXt9O2lmKG51bGwhPXQpZm9yKHZhciBuIGluIHQpXCJkZWZhdWx0XCIhPT1uJiZPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCxuKSYmcihlLHQsbik7cmV0dXJuIGkoZSx0KSxlfTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLldFQkdMX09QX1JFU09MVkVfUlVMRVM9dm9pZCAwO2NvbnN0IGE9bigyODk4KSxzPW8obig3ODM5KSksdT1uKDQxOTYpLGM9bigyMDY5KSxsPW4oODEzOCkscD1uKDk2NjMpLGY9big1MTkzKSxkPW4oNzk5MiksaD1uKDEyNTMpLGc9big0Nzc2KSxiPW4oNjU3MiksbT1uKDMzNDYpLHk9big1NjIzKSxfPW4oMjg3MCksdj1uKDIxNDMpLHc9big0OTM5KSx4PW4oNzE4KSxUPW4oMjI2OCksUz1uKDgxMTcpLE89bigyMjc4KSxBPW4oNTUyNCksRT1uKDU5NzUpLEk9bigzOTMzKSxQPW4oNjU1OCksRD1uKDU3MjMpLCQ9bigzNzM4KSxrPW8obig0OTA5KSksQz1uKDg0MjgpLEY9big5NzkzKTtlLldFQkdMX09QX1JFU09MVkVfUlVMRVM9W1tcIkFic1wiLFwiXCIsXCI2K1wiLGsuYWJzXSxbXCJBY29zXCIsXCJcIixcIjcrXCIsay5hY29zXSxbXCJBZGRcIixcIlwiLFwiNytcIixzLmFkZF0sW1wiQW5kXCIsXCJcIixcIjcrXCIscy5hbmRdLFtcIkFzaW5cIixcIlwiLFwiNytcIixrLmFzaW5dLFtcIkF0YW5cIixcIlwiLFwiNytcIixrLmF0YW5dLFtcIkF2ZXJhZ2VQb29sXCIsXCJcIixcIjcrXCIsdi5hdmVyYWdlUG9vbCx2LnBhcnNlQXZlcmFnZVBvb2xBdHRyaWJ1dGVzXSxbXCJCYXRjaE5vcm1hbGl6YXRpb25cIixcIlwiLFwiNytcIixhLmJhdGNoTm9ybWFsaXphdGlvbixhLnBhcnNlQmF0Y2hOb3JtYWxpemF0aW9uQXR0cmlidXRlc10sW1wiQ2FzdFwiLFwiXCIsXCI2K1wiLHUuY2FzdCx1LnBhcnNlQ2FzdEF0dHJpYnV0ZXNdLFtcIkNlaWxcIixcIlwiLFwiNitcIixrLmNlaWxdLFtcIkNsaXBcIixcIlwiLFwiNi0xMFwiLGsuY2xpcCxrLnBhcnNlQ2xpcEF0dHJpYnV0ZXNdLFtcIkNsaXBcIixcIlwiLFwiMTErXCIsay5jbGlwVjExXSxbXCJDb25jYXRcIixcIlwiLFwiNCtcIixjLmNvbmNhdCxjLnBhcnNlQ29uY2F0QXR0cmlidXRlc10sW1wiQ29udlwiLFwiXCIsXCIxK1wiLGwuY29udixsLnBhcnNlQ29udkF0dHJpYnV0ZXNdLFtcIkNvbnZUcmFuc3Bvc2VcIixcIlwiLFwiMStcIixwLmNvbnZUcmFuc3Bvc2UscC5wYXJzZUNvbnZUcmFuc3Bvc2VBdHRyaWJ1dGVzXSxbXCJDb3NcIixcIlwiLFwiNytcIixrLmNvc10sW1wiRGl2XCIsXCJcIixcIjcrXCIscy5kaXZdLFtcIkRyb3BvdXRcIixcIlwiLFwiNytcIixrLmlkZW50aXR5XSxbXCJEZXB0aFRvU3BhY2VcIixcIlwiLFwiMStcIixmLmRlcHRoVG9TcGFjZSxmLnBhcnNlRGVwdGhUb1NwYWNlQXR0cmlidXRlc10sW1wiRXF1YWxcIixcIlwiLFwiNytcIixzLmVxdWFsXSxbXCJFbHVcIixcIlwiLFwiNitcIixrLmVsdSxrLnBhcnNlRWx1QXR0cmlidXRlc10sW1wiRXhwXCIsXCJcIixcIjYrXCIsay5leHBdLFtcIkZsYXR0ZW5cIixcIlwiLFwiMStcIixkLmZsYXR0ZW4sZC5wYXJzZUZsYXR0ZW5BdHRyaWJ1dGVzXSxbXCJGbG9vclwiLFwiXCIsXCI2K1wiLGsuZmxvb3JdLFtcIkZ1c2VkQ29udlwiLFwiY29tLm1pY3Jvc29mdFwiLFwiMStcIixsLmNvbnYsbC5wYXJzZUNvbnZBdHRyaWJ1dGVzXSxbXCJHYXRoZXJcIixcIlwiLFwiMStcIixoLmdhdGhlcixoLnBhcnNlR2F0aGVyQXR0cmlidXRlc10sW1wiR2VtbVwiLFwiXCIsXCI3LTEwXCIsZy5nZW1tLGcucGFyc2VHZW1tQXR0cmlidXRlc1Y3XSxbXCJHZW1tXCIsXCJcIixcIjExK1wiLGcuZ2VtbSxnLnBhcnNlR2VtbUF0dHJpYnV0ZXNWMTFdLFtcIkdsb2JhbEF2ZXJhZ2VQb29sXCIsXCJcIixcIjErXCIsdi5nbG9iYWxBdmVyYWdlUG9vbCx2LnBhcnNlR2xvYmFsQXZlcmFnZVBvb2xBdHRyaWJ1dGVzXSxbXCJHbG9iYWxNYXhQb29sXCIsXCJcIixcIjErXCIsdi5nbG9iYWxNYXhQb29sXSxbXCJHcmVhdGVyXCIsXCJcIixcIjcrXCIscy5ncmVhdGVyXSxbXCJJZGVudGl0eVwiLFwiXCIsXCIxK1wiLGsuaWRlbnRpdHldLFtcIkltYWdlU2NhbGVyXCIsXCJcIixcIjErXCIsYi5pbWFnZVNjYWxlcixiLnBhcnNlSW1hZ2VTY2FsZXJBdHRyaWJ1dGVzXSxbXCJJbnN0YW5jZU5vcm1hbGl6YXRpb25cIixcIlwiLFwiNitcIixtLmluc3RhbmNlTm9ybWFsaXphdGlvbixtLnBhcnNlSW5zdGFuY2VOb3JtYWxpemF0aW9uQXR0cmlidXRlc10sW1wiTGVha3lSZWx1XCIsXCJcIixcIjYrXCIsay5sZWFreVJlbHUsay5wYXJzZUxlYWt5UmVsdUF0dHJpYnV0ZXNdLFtcIkxlc3NcIixcIlwiLFwiNytcIixzLmxlc3NdLFtcIkxvZ1wiLFwiXCIsXCI2K1wiLGsubG9nXSxbXCJNYXRNdWxcIixcIlwiLFwiMStcIix5Lm1hdE11bCx5LnBhcnNlTWF0TXVsQXR0cmlidXRlc10sW1wiTWF4UG9vbFwiLFwiXCIsXCIxK1wiLHYubWF4UG9vbCx2LnBhcnNlTWF4UG9vbEF0dHJpYnV0ZXNdLFtcIk11bFwiLFwiXCIsXCI3K1wiLHMubXVsXSxbXCJOZWdcIixcIlwiLFwiNitcIixrLm5lZ10sW1wiTm90XCIsXCJcIixcIjErXCIsay5ub3RdLFtcIk9yXCIsXCJcIixcIjcrXCIscy5vcl0sW1wiUGFkXCIsXCJcIixcIjItMTBcIixfLnBhZFYyLF8ucGFyc2VQYWRBdHRyaWJ1dGVzVjJdLFtcIlBhZFwiLFwiXCIsXCIxMStcIixfLnBhZFYxMSxfLnBhcnNlUGFkQXR0cmlidXRlc1YxMV0sW1wiUG93XCIsXCJcIixcIjcrXCIscy5wb3ddLFtcIlBSZWx1XCIsXCJcIixcIjcrXCIscy5wUmVsdV0sW1wiUmVkdWNlTG9nU3VtXCIsXCJcIixcIjErXCIsdy5yZWR1Y2VMb2dTdW0sdy5wYXJzZVJlZHVjZUF0dHJpYnV0ZXNdLFtcIlJlZHVjZU1heFwiLFwiXCIsXCIxK1wiLHcucmVkdWNlTWF4LHcucGFyc2VSZWR1Y2VBdHRyaWJ1dGVzXSxbXCJSZWR1Y2VNZWFuXCIsXCJcIixcIjErXCIsdy5yZWR1Y2VNZWFuLHcucGFyc2VSZWR1Y2VBdHRyaWJ1dGVzXSxbXCJSZWR1Y2VNaW5cIixcIlwiLFwiMStcIix3LnJlZHVjZU1pbix3LnBhcnNlUmVkdWNlQXR0cmlidXRlc10sW1wiUmVkdWNlUHJvZFwiLFwiXCIsXCIxK1wiLHcucmVkdWNlUHJvZCx3LnBhcnNlUmVkdWNlQXR0cmlidXRlc10sW1wiUmVkdWNlU3VtXCIsXCJcIixcIjEtMTJcIix3LnJlZHVjZVN1bSx3LnBhcnNlUmVkdWNlQXR0cmlidXRlc10sW1wiUmVkdWNlU3VtU3F1YXJlXCIsXCJcIixcIjErXCIsdy5yZWR1Y2VMb2dTdW1TcXVhcmUsdy5wYXJzZVJlZHVjZUF0dHJpYnV0ZXNdLFtcIlJlbHVcIixcIlwiLFwiNitcIixrLnJlbHVdLFtcIlJlc2hhcGVcIixcIlwiLFwiNStcIix4LnJlc2hhcGVdLFtcIlJlc2l6ZVwiLFwiXCIsXCIxMFwiLFQucmVzaXplLFQucGFyc2VSZXNpemVBdHRyaWJ1dGVzVjEwXSxbXCJSZXNpemVcIixcIlwiLFwiMTErXCIsVC5yZXNpemUsVC5wYXJzZVJlc2l6ZUF0dHJpYnV0ZXNWMTFdLFtcIlNoYXBlXCIsXCJcIixcIjErXCIsUy5zaGFwZV0sW1wiU2lnbW9pZFwiLFwiXCIsXCI2K1wiLGsuc2lnbW9pZF0sW1wiU2luXCIsXCJcIixcIjcrXCIsay5zaW5dLFtcIlNsaWNlXCIsXCJcIixcIjEwK1wiLE8uc2xpY2VWMTBdLFtcIlNsaWNlXCIsXCJcIixcIjEtOVwiLE8uc2xpY2UsTy5wYXJzZVNsaWNlQXR0cmlidXRlc10sW1wiU29mdG1heFwiLFwiXCIsXCIxLTEyXCIsQS5zb2Z0bWF4LEEucGFyc2VTb2Z0bWF4QXR0cmlidXRlc10sW1wiU29mdG1heFwiLFwiXCIsXCIxMytcIixBLnNvZnRtYXhWMTMsQS5wYXJzZVNvZnRtYXhBdHRyaWJ1dGVzVjEzXSxbXCJTcGxpdFwiLFwiXCIsXCIyLTEyXCIsRS5zcGxpdCxFLnBhcnNlU3BsaXRBdHRyaWJ1dGVzXSxbXCJTcXJ0XCIsXCJcIixcIjYrXCIsay5zcXJ0XSxbXCJTcXVlZXplXCIsXCJcIixcIjEtMTJcIixJLnNxdWVlemUsSS5wYXJzZVNxdWVlemVBdHRyaWJ1dGVzXSxbXCJTcXVlZXplXCIsXCJcIixcIjEzK1wiLEkuc3F1ZWV6ZVYxM10sW1wiU3ViXCIsXCJcIixcIjcrXCIscy5zdWJdLFtcIlN1bVwiLFwiXCIsXCI2K1wiLFAuc3VtXSxbXCJUYW5cIixcIlwiLFwiNytcIixrLnRhbl0sW1wiVGFuaFwiLFwiXCIsXCI2K1wiLGsudGFuaF0sW1wiVGlsZVwiLFwiXCIsXCI2K1wiLEQudGlsZV0sW1wiVHJhbnNwb3NlXCIsXCJcIixcIjErXCIsJC50cmFuc3Bvc2UsJC5wYXJzZVRyYW5zcG9zZUF0dHJpYnV0ZXNdLFtcIlVwc2FtcGxlXCIsXCJcIixcIjctOFwiLEYudXBzYW1wbGUsRi5wYXJzZVVwc2FtcGxlQXR0cmlidXRlc1Y3XSxbXCJVcHNhbXBsZVwiLFwiXCIsXCI5XCIsRi51cHNhbXBsZSxGLnBhcnNlVXBzYW1wbGVBdHRyaWJ1dGVzVjldLFtcIlVuc3F1ZWV6ZVwiLFwiXCIsXCIxLTEyXCIsQy51bnNxdWVlemUsQy5wYXJzZVVuc3F1ZWV6ZUF0dHJpYnV0ZXNdLFtcIlVuc3F1ZWV6ZVwiLFwiXCIsXCIxMytcIixDLnVuc3F1ZWV6ZVYxM10sW1wiWG9yXCIsXCJcIixcIjcrXCIscy54b3JdXX0sMjg5ODoodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5wYXJzZUJhdGNoTm9ybWFsaXphdGlvbkF0dHJpYnV0ZXM9ZS5iYXRjaE5vcm1hbGl6YXRpb249dm9pZCAwO2NvbnN0IHI9bigyNDYpLGk9big1MDYwKSxvPW4oMjAzOSksYT17bmFtZTpcIkJhdGNoTm9ybWFsaXphdGlvblwiLGlucHV0TmFtZXM6W1wiQVwiLFwiU2NhbGVcIixcIkJcIixcIk1lYW5cIixcIlZhcmlhbmNlXCJdLGlucHV0VHlwZXM6W28uVGV4dHVyZVR5cGUudW5wYWNrZWQsby5UZXh0dXJlVHlwZS51bnBhY2tlZCxvLlRleHR1cmVUeXBlLnVucGFja2VkLG8uVGV4dHVyZVR5cGUudW5wYWNrZWQsby5UZXh0dXJlVHlwZS51bnBhY2tlZF19O2UuYmF0Y2hOb3JtYWxpemF0aW9uPSh0LGUsbik9Pih1KGUpLFt0LnJ1bihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sYSkse2NhY2hlSGludDpuLmNhY2hlS2V5LGdldDooKT0+cyh0LGUsbil9KSxlKV0pLGUucGFyc2VCYXRjaE5vcm1hbGl6YXRpb25BdHRyaWJ1dGVzPXQ9Pntjb25zdCBlPXQuYXR0cmlidXRlcy5nZXRGbG9hdChcImVwc2lsb25cIiwxZS01KSxuPXQuYXR0cmlidXRlcy5nZXRGbG9hdChcIm1vbWVudHVtXCIsLjkpLGk9dC5hdHRyaWJ1dGVzLmdldEludChcInNwYXRpYWxcIiwxKTtyZXR1cm4oMCxyLmNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSkoe2Vwc2lsb246ZSxtb21lbnR1bTpuLHNwYXRpYWw6aX0pfTtjb25zdCBzPSh0LGUsbik9Pntjb25zdCByPSgwLGkuZ2V0R2xzbCkodC5zZXNzaW9uLmJhY2tlbmQuZ2xDb250ZXh0LnZlcnNpb24pLHM9ZVswXS5kaW1zLmxlbmd0aCxbdSxjXT10LmNhbGN1bGF0ZVRleHR1cmVXaWR0aEFuZEhlaWdodChlWzFdLmRpbXMsby5UZXh0dXJlVHlwZS51bnBhY2tlZCksbD1gXFxuICBmbG9hdCBwcm9jZXNzKGludFske3N9XSBpbmRpY2VzKSB7XFxuICAgIHZlYzIgcG9zaXRpb24gPSBvZmZzZXRUb0Nvb3JkcyhpbmRpY2VzWzFdLCAke3V9LCAke2N9KTtcXG4gICAgZmxvYXQgc2NhbGUgPSBnZXRDb2xvckFzRmxvYXQoJHtyLnRleHR1cmUyRH0oU2NhbGUsIHBvc2l0aW9uKSk7XFxuICAgIGZsb2F0IG1lYW4gPSBnZXRDb2xvckFzRmxvYXQoJHtyLnRleHR1cmUyRH0oTWVhbiwgcG9zaXRpb24pKTtcXG4gICAgZmxvYXQgdmFyaWFuY2UgPSBnZXRDb2xvckFzRmxvYXQoJHtyLnRleHR1cmUyRH0oVmFyaWFuY2UsIHBvc2l0aW9uKSk7XFxuICAgIGZsb2F0IGIgPSBnZXRDb2xvckFzRmxvYXQoJHtyLnRleHR1cmUyRH0oQiwgcG9zaXRpb24pKTtcXG5cXG4gICAgcmV0dXJuIHNjYWxlICogKCAoX0EoaW5kaWNlcykgLSBtZWFuKSAvIHNxcnQodmFyaWFuY2UgKyBmbG9hdCgke24uZXBzaWxvbn0pKSApICsgYjtcXG4gIH1gO3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sYSkse291dHB1dDp7ZGltczplWzBdLmRpbXMsdHlwZTplWzBdLnR5cGUsdGV4dHVyZVR5cGU6by5UZXh0dXJlVHlwZS51bnBhY2tlZH0sc2hhZGVyU291cmNlOmx9KX0sdT10PT57aWYoIXR8fDUhPT10Lmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJCYXRjaE5vcm1hbGl6YXRpb24gcmVxdWlyZXMgNSBpbnB1dHMuXCIpO2NvbnN0IGU9dFswXSxuPXRbMV0scj10WzJdLGk9dFszXSxvPXRbNF07aWYoZS5kaW1zLmxlbmd0aDwzfHwxIT09bi5kaW1zLmxlbmd0aHx8MSE9PXIuZGltcy5sZW5ndGh8fDEhPT1pLmRpbXMubGVuZ3RofHwxIT09by5kaW1zLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGlucHV0IHNoYXBlLlwiKTtpZihuLmRpbXNbMF0hPT1lLmRpbXNbMV18fHIuZGltc1swXSE9PWUuZGltc1sxXXx8aS5kaW1zWzBdIT09ZS5kaW1zWzFdfHxvLmRpbXNbMF0hPT1lLmRpbXNbMV0pdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBpbnB1dCBzaGFwZS5cIik7aWYoXCJmbG9hdDMyXCIhPT1lLnR5cGUmJlwiZmxvYXQ2NFwiIT09ZS50eXBlfHxcImZsb2F0MzJcIiE9PW4udHlwZSYmXCJmbG9hdDY0XCIhPT1uLnR5cGV8fFwiZmxvYXQzMlwiIT09ci50eXBlJiZcImZsb2F0NjRcIiE9PXIudHlwZXx8XCJmbG9hdDMyXCIhPT1pLnR5cGUmJlwiZmxvYXQ2NFwiIT09aS50eXBlfHxcImZsb2F0MzJcIiE9PW8udHlwZSYmXCJmbG9hdDY0XCIhPT1vLnR5cGUpdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBpbnB1dCB0ZW5zb3IgdHlwZXMuXCIpfX0sNzgzOToodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS54b3I9ZS5zdWI9ZS5wUmVsdT1lLnBvdz1lLm9yPWUubXVsPWUubGVzcz1lLmdyZWF0ZXI9ZS5lcXVhbD1lLmRpdj1lLmFuZD1lLmFkZD1lLmdsc2xQUmVsdT1lLmdsc2xQb3c9ZS5nbHNsWG9yPWUuZ2xzbE9yPWUuZ2xzbEFuZD1lLmdsc2xMZXNzPWUuZ2xzbEdyZWF0ZXI9ZS5nbHNsRXF1YWw9ZS5nbHNsU3ViPWUuZ2xzbE11bD1lLmdsc2xEaXY9ZS5nbHNsQWRkPXZvaWQgMDtjb25zdCByPW4oMjUxNyksaT1uKDg1MjApLG89big1MDYwKSxhPW4oMjAzOSk7ZnVuY3Rpb24gcygpe2NvbnN0IHQ9XCJhZGRfXCI7cmV0dXJue2JvZHk6YFxcbiAgZmxvYXQgJHt0fShmbG9hdCBhLCBmbG9hdCBiKSB7XFxuICAgIHJldHVybiBhICsgYjtcXG4gIH1cXG4gIHZlYzQgJHt0fSh2ZWM0IHYxLCB2ZWM0IHYyKSB7XFxuICAgIHJldHVybiB2MSArIHYyO1xcbiAgfVxcbiAgYCxuYW1lOnQsdHlwZTppLkZ1bmN0aW9uVHlwZS5WYWx1ZUJhc2VkfX1mdW5jdGlvbiB1KCl7Y29uc3QgdD1cImRpdl9cIjtyZXR1cm57Ym9keTpgXFxuICBmbG9hdCAke3R9KGZsb2F0IGEsIGZsb2F0IGIpIHtcXG4gICAgcmV0dXJuIGEgLyBiO1xcbiAgfVxcbiAgdmVjNCAke3R9KHZlYzQgdjEsIHZlYzQgdjIpIHtcXG4gICAgcmV0dXJuIHYxIC8gdjI7XFxuICB9XFxuICBgLG5hbWU6dCx0eXBlOmkuRnVuY3Rpb25UeXBlLlZhbHVlQmFzZWR9fWZ1bmN0aW9uIGMoKXtjb25zdCB0PVwibXVsX1wiO3JldHVybntib2R5OmBcXG4gIGZsb2F0ICR7dH0oZmxvYXQgYSwgZmxvYXQgYikge1xcbiAgICByZXR1cm4gYSAqIGI7XFxuICB9XFxuICB2ZWM0ICR7dH0odmVjNCB2MSwgdmVjNCB2Mikge1xcbiAgICByZXR1cm4gdjEgKiB2MjtcXG4gIH1cXG4gIGAsbmFtZTp0LHR5cGU6aS5GdW5jdGlvblR5cGUuVmFsdWVCYXNlZH19ZnVuY3Rpb24gbCgpe2NvbnN0IHQ9XCJzdWJfXCI7cmV0dXJue2JvZHk6YFxcbiAgZmxvYXQgJHt0fShmbG9hdCBhLCBmbG9hdCBiKSB7XFxuICAgIHJldHVybiBhIC0gYjtcXG4gIH1cXG4gIHZlYzQgJHt0fSh2ZWM0IHYxLCB2ZWM0IHYyKSB7XFxuICAgIHJldHVybiB2MSAtIHYyO1xcbiAgfVxcbiAgYCxuYW1lOnQsdHlwZTppLkZ1bmN0aW9uVHlwZS5WYWx1ZUJhc2VkfX1mdW5jdGlvbiBwKCl7Y29uc3QgdD1cImVxdWFsX1wiO3JldHVybntib2R5OmBcXG4gIGZsb2F0ICR7dH0oZmxvYXQgYSwgZmxvYXQgYikge1xcbiAgICByZXR1cm4gZmxvYXQoYSA9PSBiKTtcXG4gIH1cXG4gIHZlYzQgJHt0fSh2ZWM0IHYxLCB2ZWM0IHYyKSB7XFxuICAgIHJldHVybiB2ZWM0KGVxdWFsKHYxLCB2MikpO1xcbiAgfVxcbiAgYCxuYW1lOnQsdHlwZTppLkZ1bmN0aW9uVHlwZS5WYWx1ZUJhc2VkfX1mdW5jdGlvbiBmKCl7Y29uc3QgdD1cImdyZWF0ZXJfXCI7cmV0dXJue2JvZHk6YFxcbiAgZmxvYXQgJHt0fShmbG9hdCBhLCBmbG9hdCBiKSB7XFxuICAgIHJldHVybiBmbG9hdChhID4gYik7XFxuICB9XFxuICB2ZWM0ICR7dH0odmVjNCB2MSwgdmVjNCB2Mikge1xcbiAgICByZXR1cm4gdmVjNCggdjEuciA+IHYyLnIgLFxcbiAgICAgIHYxLmcgPiB2Mi5nLFxcbiAgICAgIHYxLmIgPiB2Mi5iLFxcbiAgICAgIHYxLmEgPiB2Mi5hICk7XFxuICB9XFxuICBgLG5hbWU6dCx0eXBlOmkuRnVuY3Rpb25UeXBlLlZhbHVlQmFzZWR9fWZ1bmN0aW9uIGQoKXtjb25zdCB0PVwibGVzc19cIjtyZXR1cm57Ym9keTpgXFxuICBmbG9hdCAke3R9KGZsb2F0IGEsIGZsb2F0IGIpIHtcXG4gICAgcmV0dXJuIGZsb2F0KGEgPCBiKTtcXG4gIH1cXG4gIHZlYzQgJHt0fSh2ZWM0IHYxLCB2ZWM0IHYyKSB7XFxuICAgIHJldHVybiB2ZWM0KCB2MS5yIDwgdjIuciAsXFxuICAgICAgICAgICAgICAgIHYxLmcgPCB2Mi5nLFxcbiAgICAgICAgICAgICAgICB2MS5iIDwgdjIuYixcXG4gICAgICAgICAgICAgICAgdjEuYSA8IHYyLmEgKTtcXG4gIH1cXG4gIGAsbmFtZTp0LHR5cGU6aS5GdW5jdGlvblR5cGUuVmFsdWVCYXNlZH19ZnVuY3Rpb24gaCgpe2NvbnN0IHQ9XCJhbmRfXCI7cmV0dXJue2JvZHk6YFxcbiAgZmxvYXQgJHt0fShmbG9hdCBhLCBmbG9hdCBiKSB7XFxuICAgIHJldHVybiBmbG9hdCggYm9vbChhKSAmJiBib29sKGIpICk7XFxuICB9XFxuICB2ZWM0ICR7dH0odmVjNCB2MSwgdmVjNCB2Mikge1xcbiAgICBidmVjNCBiMSA9IGJ2ZWM0KHYxKTtcXG4gICAgYnZlYzQgYjIgPSBidmVjNCh2Mik7XFxuICAgIHJldHVybiB2ZWM0KCBiMS5yICYmIGIyLnIgLFxcbiAgICAgICAgICAgICAgICBiMS5nICYmIGIyLmcsXFxuICAgICAgICAgICAgICAgIGIxLmIgJiYgYjIuYixcXG4gICAgICAgICAgICAgICAgYjEuYSAmJiBiMi5hICk7XFxuICB9XFxuICBgLG5hbWU6dCx0eXBlOmkuRnVuY3Rpb25UeXBlLlZhbHVlQmFzZWR9fWZ1bmN0aW9uIGcoKXtjb25zdCB0PVwib3JfXCI7cmV0dXJue2JvZHk6YFxcbiAgZmxvYXQgJHt0fShmbG9hdCBhLCBmbG9hdCBiKSB7XFxuICAgIHJldHVybiBmbG9hdCggYm9vbChhKSB8fCBib29sKGIpICk7XFxuICB9XFxuICB2ZWM0ICR7dH0odmVjNCB2MSwgdmVjNCB2Mikge1xcbiAgICBidmVjNCBiMSA9IGJ2ZWM0KHYxKTtcXG4gICAgYnZlYzQgYjIgPSBidmVjNCh2Mik7XFxuICAgIHJldHVybiB2ZWM0KCBiMS5yIHx8IGIyLnIgLFxcbiAgICAgICAgICAgICAgICBiMS5nIHx8IGIyLmcsXFxuICAgICAgICAgICAgICAgIGIxLmIgfHwgYjIuYixcXG4gICAgICAgICAgICAgICAgYjEuYSB8fCBiMi5hICk7XFxuICB9XFxuICBgLG5hbWU6dCx0eXBlOmkuRnVuY3Rpb25UeXBlLlZhbHVlQmFzZWR9fWZ1bmN0aW9uIGIoKXtjb25zdCB0PVwieG9yX1wiO3JldHVybntib2R5OmBcXG4gIGZsb2F0ICR7dH0oZmxvYXQgYSwgZmxvYXQgYikge1xcbiAgICByZXR1cm4gZmxvYXQoIGJvb2woYSkgXl4gYm9vbChiKSApO1xcbiAgfVxcbiAgdmVjNCAke3R9KHZlYzQgdjEsIHZlYzQgdjIpIHtcXG4gICAgYnZlYzQgYjEgPSBidmVjNCh2MSk7XFxuICAgIGJ2ZWM0IGIyID0gYnZlYzQodjIpO1xcbiAgICByZXR1cm4gdmVjNCggYjEuciBeXiBiMi5yICxcXG4gICAgICAgICAgICAgICAgYjEuZyBeXiBiMi5nLFxcbiAgICAgICAgICAgICAgICBiMS5iIF5eIGIyLmIsXFxuICAgICAgICAgICAgICAgIGIxLmEgXl4gYjIuYSApO1xcbiAgfVxcbiAgYCxuYW1lOnQsdHlwZTppLkZ1bmN0aW9uVHlwZS5WYWx1ZUJhc2VkfX1mdW5jdGlvbiBtKCl7cmV0dXJuIGZ1bmN0aW9uKHQpe2NvbnN0IGU9YCR7dH1fYDtyZXR1cm57Ym9keTpgXFxuICBmbG9hdCAke2V9KGZsb2F0IGEsIGZsb2F0IGIpIHtcXG4gICAgcmV0dXJuICR7dH0oYSwgYik7XFxuICB9XFxuICB2ZWM0ICR7ZX0odmVjNCB2MSwgdmVjNCB2Mikge1xcbiAgICByZXR1cm4gJHt0fSh2MSwgdjIpO1xcbiAgfVxcbiAgYCxuYW1lOmUsdHlwZTppLkZ1bmN0aW9uVHlwZS5WYWx1ZUJhc2VkfX0oXCJwb3dcIil9ZnVuY3Rpb24geSgpe2NvbnN0IHQ9XCJwcmVsdV9cIjtyZXR1cm57Ym9keTpgXFxuICBmbG9hdCAke3R9KGZsb2F0IGEsIGZsb2F0IGIpIHtcXG4gICAgcmV0dXJuIGEgPCAwLjAgPyBhICogYjogYTtcXG4gIH1cXG4gIHZlYzQgJHt0fSh2ZWM0IHYxLCB2ZWM0IHYyKSB7XFxuICAgIHJldHVybiB2ZWM0KFxcbiAgICAgIHYxLnIgPCAwLjAgPyB2MS5yICogdjIucjogdjEucixcXG4gICAgICB2MS5nIDwgMC4wID8gdjEuZyAqIHYyLmc6IHYxLmcsXFxuICAgICAgdjEuYiA8IDAuMCA/IHYxLmIgKiB2Mi5iOiB2MS5iLFxcbiAgICAgIHYxLmEgPCAwLjAgPyB2MS5hICogdjIuYTogdjEuYVxcbiAgICAgICk7XFxuICB9XFxuICBgLG5hbWU6dCx0eXBlOmkuRnVuY3Rpb25UeXBlLlZhbHVlQmFzZWR9fWUuZ2xzbEFkZD1zLGUuZ2xzbERpdj11LGUuZ2xzbE11bD1jLGUuZ2xzbFN1Yj1sLGUuZ2xzbEVxdWFsPXAsZS5nbHNsR3JlYXRlcj1mLGUuZ2xzbExlc3M9ZCxlLmdsc2xBbmQ9aCxlLmdsc2xPcj1nLGUuZ2xzbFhvcj1iLGUuZ2xzbFBvdz1tLGUuZ2xzbFBSZWx1PXk7Y29uc3QgXz0odCxlLG4scj1lWzBdLnR5cGUsaSk9Pntjb25zdCBvPXQuc2Vzc2lvbi5wYWNrP2EuVGV4dHVyZVR5cGUucGFja2VkOmEuVGV4dHVyZVR5cGUudW5wYWNrZWQ7cmV0dXJue25hbWU6bi5uYW1lLGlucHV0TmFtZXM6W1wiQVwiLFwiQlwiXSxpbnB1dFR5cGVzOltvLG9dLGNhY2hlSGludDppLGdldDooKT0+dih0LGUsbixyKX19LHY9KHQsZSxuLGk9ZVswXS50eXBlKT0+e2NvbnN0IHM9dC5zZXNzaW9uLnBhY2s/YS5UZXh0dXJlVHlwZS5wYWNrZWQ6YS5UZXh0dXJlVHlwZS51bnBhY2tlZCx1PSFyLlNoYXBlVXRpbC5hcmVFcXVhbChlWzBdLmRpbXMsZVsxXS5kaW1zKTtsZXQgYz1lWzBdLmRpbXM7Y29uc3QgbD10LnNlc3Npb24ucGFjaztpZih1KXtjb25zdCBhPXIuQnJvYWRjYXN0VXRpbC5jYWxjU2hhcGUoZVswXS5kaW1zLGVbMV0uZGltcywhMSk7aWYoIWEpdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgcGVyZm9ybSBiaW5hcnkgb3Agb24gdGhlIGdpdmVuIHRlbnNvcnNcIik7Yz1hO2NvbnN0IHU9Yy5sZW5ndGgscD0wIT09ZVswXS5kaW1zLmxlbmd0aD9lWzBdLmRpbXMubGVuZ3RoOjEsZj0wIT09ZVsxXS5kaW1zLmxlbmd0aD9lWzFdLmRpbXMubGVuZ3RoOjEsZD0wIT09ZVswXS5kaW1zLmxlbmd0aD9cImJjYXN0SW5kaWNlc19BKGluZGljZXMsIGFpbmRpY2VzKTtcIjpcImFpbmRpY2VzWzBdID0gMDtcIixoPTAhPT1lWzFdLmRpbXMubGVuZ3RoP1wiYmNhc3RJbmRpY2VzX0IoaW5kaWNlcywgYmluZGljZXMpO1wiOlwiYmluZGljZXNbMF0gPSAwO1wiLGc9KDAsby5nZXRHbHNsKSh0LnNlc3Npb24uYmFja2VuZC5nbENvbnRleHQudmVyc2lvbiksYj1sP2BcXG4gICAgICAke24uYm9keX1cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICB2ZWM0IGEgPSBnZXRBQXRPdXRDb29yZHMoKTtcXG4gICAgICAgIHZlYzQgYiA9IGdldEJBdE91dENvb3JkcygpO1xcbiAgICAgICAgdmVjNCByZXN1bHQgPSAke24ubmFtZX0oYSwgYik7XFxuICAgICAgICAke2cub3V0cHV0fSA9IHJlc3VsdDtcXG4gICAgICB9YDpgXFxuICAgICAgJHtuLmJvZHl9XFxuICAgICAgZmxvYXQgcHJvY2VzcyhpbnQgaW5kaWNlc1ske3V9XSkge1xcbiAgICAgICAgaW50IGFpbmRpY2VzWyR7cH1dO1xcbiAgICAgICAgaW50IGJpbmRpY2VzWyR7Zn1dO1xcbiAgICAgICAgJHtkfVxcbiAgICAgICAgJHtofVxcbiAgICAgICAgcmV0dXJuICR7bi5uYW1lfShfQShhaW5kaWNlcyksIF9CKGJpbmRpY2VzKSk7XFxuICAgICAgfWA7cmV0dXJue25hbWU6bi5uYW1lLGlucHV0TmFtZXM6W1wiQVwiLFwiQlwiXSxpbnB1dFR5cGVzOltzLHNdLG91dHB1dDp7ZGltczpjLHR5cGU6aSx0ZXh0dXJlVHlwZTpzfSxzaGFkZXJTb3VyY2U6YixoYXNNYWluOmx9fWNvbnN0IHA9KDAsby5nZXRHbHNsKSh0LnNlc3Npb24uYmFja2VuZC5nbENvbnRleHQudmVyc2lvbiksZj1gXFxuICAgICR7bi5ib2R5fVxcbiAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgdmVjNCB2MSA9ICR7cC50ZXh0dXJlMkR9KEEsIFRleENvb3Jkcyk7XFxuICAgICAgdmVjNCB2MiA9ICR7cC50ZXh0dXJlMkR9KEIsIFRleENvb3Jkcyk7XFxuICAgICAgdmVjNCByZXN1bHQgPSAke24ubmFtZX0odjEsIHYyKTtcXG4gICAgICAke3Aub3V0cHV0fSA9IHJlc3VsdDtcXG4gICAgfVxcbiAgICBgO3JldHVybntuYW1lOm4ubmFtZSxpbnB1dE5hbWVzOltcIkFcIixcIkJcIl0saW5wdXRUeXBlczpbcyxzXSxvdXRwdXQ6e2RpbXM6ZVswXS5kaW1zLHR5cGU6aSx0ZXh0dXJlVHlwZTpzfSxzaGFkZXJTb3VyY2U6ZixoYXNNYWluOiEwfX07ZS5hZGQ9KHQsZSk9Plt0LnJ1bihfKHQsZSxzKCkpLGUpXSxlLmFuZD0odCxlKT0+W3QucnVuKF8odCxlLGgoKSxcImJvb2xcIiksZSldLGUuZGl2PSh0LGUpPT5bdC5ydW4oXyh0LGUsdSgpKSxlKV0sZS5lcXVhbD0odCxlKT0+W3QucnVuKF8odCxlLHAoKSxcImJvb2xcIiksZSldLGUuZ3JlYXRlcj0odCxlKT0+W3QucnVuKF8odCxlLGYoKSxcImJvb2xcIiksZSldLGUubGVzcz0odCxlKT0+W3QucnVuKF8odCxlLGQoKSxcImJvb2xcIiksZSldLGUubXVsPSh0LGUpPT5bdC5ydW4oXyh0LGUsYygpKSxlKV0sZS5vcj0odCxlKT0+W3QucnVuKF8odCxlLGcoKSxcImJvb2xcIiksZSldLGUucG93PSh0LGUpPT5bdC5ydW4oXyh0LGUsbSgpKSxlKV0sZS5wUmVsdT0odCxlKT0+W3QucnVuKF8odCxlLHkoKSksZSldLGUuc3ViPSh0LGUpPT5bdC5ydW4oXyh0LGUsbCgpKSxlKV0sZS54b3I9KHQsZSk9Plt0LnJ1bihfKHQsZSxiKCksXCJib29sXCIpLGUpXX0sNDE5NjoodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5wYXJzZUNhc3RBdHRyaWJ1dGVzPWUuY2FzdD12b2lkIDA7Y29uc3Qgcj1uKDI1MTcpO2UuY2FzdD0odCxlLG4pPT4oaShlKSxbdC5jYXN0KGVbMF0sbildKSxlLnBhcnNlQ2FzdEF0dHJpYnV0ZXM9dD0+ci5Qcm90b1V0aWwudGVuc29yRGF0YVR5cGVGcm9tUHJvdG8odC5hdHRyaWJ1dGVzLmdldEludChcInRvXCIpKTtjb25zdCBpPXQ9PntpZighdHx8MSE9PXQubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIkNhc3QgcmVxdWlyZXMgMSBpbnB1dC5cIik7aWYoXCJzdHJpbmdcIj09PXRbMF0udHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGlucHV0IHR5cGUuXCIpfX0sMTE2MzoodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5jcmVhdGVQYWNrZWRDb25jYXRQcm9ncmFtSW5mb0xvYWRlcj12b2lkIDA7Y29uc3Qgcj1uKDUwNjApLGk9bigyMDM5KSxvPW4oOTM5MCksYT1uKDI4MjcpO2UuY3JlYXRlUGFja2VkQ29uY2F0UHJvZ3JhbUluZm9Mb2FkZXI9KHQsZSxuKT0+e2NvbnN0IHU9KGM9ZS5sZW5ndGgsbD1uLmNhY2hlS2V5LHtuYW1lOlwiQ29uY2F0IChwYWNrZWQpXCIsaW5wdXROYW1lczpBcnJheS5mcm9tKHtsZW5ndGg6Y30sKCh0LGUpPT5gWCR7ZX1gKSksaW5wdXRUeXBlczpBcnJheShjKS5maWxsKGkuVGV4dHVyZVR5cGUucGFja2VkKSxjYWNoZUhpbnQ6bH0pO3ZhciBjLGw7cmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSx1KSx7Z2V0OigpPT4oKHQsZSxuLHUpPT57Y29uc3QgYz1uWzBdLmRpbXMuc2xpY2UoKTtpZih1Pj1jLmxlbmd0aHx8dTwtMSpjLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJheGlzIHNwZWNpZmllZCBmb3IgY29uY2F0IGRvZXNuJ3QgbWF0Y2ggaW5wdXQgZGltZW5zaW9uYWxpdHlcIik7dTwwJiYodT1jLmxlbmd0aCt1KTtjb25zdCBsPWMuc2xpY2UoMCk7Zm9yKGxldCB0PTE7dDxuLmxlbmd0aDt0Kyspe2NvbnN0IGU9blt0XS5kaW1zLnNsaWNlKCk7Zm9yKGxldCB0PTA7dDxjLmxlbmd0aDt0KyspaWYodD09PXUpbFt1XSs9ZVt0XTtlbHNlIGlmKGNbdF0hPT1lW3RdKXRocm93IG5ldyBFcnJvcihcIm5vbiBjb25jYXQgZGltZW5zaW9ucyBtdXN0IG1hdGNoXCIpfWNvbnN0IHA9bC5sZW5ndGgsZj0oMCxhLmdldENoYW5uZWxzKShcImNvb3Jkc1wiLHApLGQ9KDAsby5nZXRDb29yZHNEYXRhVHlwZSkocCksaD0oMCxhLnVucGFja0Zyb21DaGFubmVsKSgpLGc9bi5tYXAoKHQ9PnQuZGltcykpLGI9KDAsby5nZXRHbENoYW5uZWxzKShwKSxtPW5ldyBBcnJheShnLmxlbmd0aC0xKTttWzBdPWdbMF1bdV07Zm9yKGxldCB0PTE7dDxtLmxlbmd0aDt0KyspbVt0XT1tW3QtMV0rZ1t0XVt1XTtjb25zdCB5PWJbdV0sXz1iLnNsaWNlKC0yKSx2PWIuam9pbigpO2xldCB3PWBpZiAoJHt5fSA8ICR7bVswXX0pIHtcXG4gICAgICAgIHJldHVybiBnZXRDaGFubmVsKFxcbiAgICAgICAgICAgIGdldFgwKCR7dn0pLCB2ZWMyKCR7Xy5qb2luKCl9KSk7XFxuICAgICAgICB9YDtmb3IobGV0IHQ9MTt0PG0ubGVuZ3RoO3QrKyl7Y29uc3QgZT1tW3QtMV07dys9YFxcbiAgICAgICAgICAgIGlmICgke3l9IDwgJHttW3RdfSAgJiYgJHt5fSA+PSAke21bdC0xXX0pIHtcXG4gICAgICAgICAgICAgIHJldHVybiBnZXRDaGFubmVsKFxcbiAgICAgICAgICAgICAgICBnZXRYJHt0fSgke3MoYix5LGUpfSksXFxuICAgICAgICAgICAgICAgIHZlYzIoJHtzKF8seSxlKX0pKTtcXG4gICAgICAgICAgICB9YH1jb25zdCB4PW0ubGVuZ3RoLFQ9bVttLmxlbmd0aC0xXTt3Kz1gXFxuICAgICAgICAgICAgcmV0dXJuIGdldENoYW5uZWwoXFxuICAgICAgICAgICAgICBnZXRYJHt4fSgke3MoYix5LFQpfSksXFxuICAgICAgICAgICAgICB2ZWMyKCR7cyhfLHksVCl9KSk7YDtjb25zdCBTPSgwLHIuZ2V0R2xzbCkodC5zZXNzaW9uLmJhY2tlbmQuZ2xDb250ZXh0LnZlcnNpb24pLE89YFxcbiAgICAgICAgICAke2h9XFxuICAgICAgICAgIGZsb2F0IGdldFZhbHVlKCR7Yi5tYXAoKHQ9PlwiaW50IFwiK3QpKX0pIHtcXG4gICAgICAgICAgICAke3d9XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgICAgICR7ZH0gY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICAgICAgaW50IGxhc3REaW0gPSBjb29yZHMuJHtiW3AtMV19O1xcbiAgICAgICAgICAgIGNvb3Jkcy4ke2JbcC0xXX0gPSBjb29yZHMuJHtiW3AtMl19O1xcbiAgICAgICAgICAgIGNvb3Jkcy4ke2JbcC0yXX0gPSBsYXN0RGltO1xcblxcbiAgICAgICAgICAgIHZlYzQgcmVzdWx0ID0gdmVjNChnZXRWYWx1ZSgke2Z9KSwgMC4sIDAuLCAwLik7XFxuXFxuICAgICAgICAgICAgJHtmW3AtMV19ID0gJHtmW3AtMV19ICsgMTtcXG4gICAgICAgICAgICBpZiAoJHtmW3AtMV19IDwgJHtsW3AtMV19KSB7XFxuICAgICAgICAgICAgICByZXN1bHQuZyA9IGdldFZhbHVlKCR7Zn0pO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAke2ZbcC0yXX0gPSAke2ZbcC0yXX0gKyAxO1xcbiAgICAgICAgICAgIGlmICgke2ZbcC0yXX0gPCAke2xbcC0yXX0pIHtcXG4gICAgICAgICAgICAgIHJlc3VsdC5hID0gZ2V0VmFsdWUoJHtmfSk7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICR7ZltwLTFdfSA9ICR7ZltwLTFdfSAtIDE7XFxuICAgICAgICAgICAgaWYgKCR7ZltwLTJdfSA8ICR7bFtwLTJdfSAmJlxcbiAgICAgICAgICAgICAgICAke2ZbcC0xXX0gPCAke2xbcC0xXX0pIHtcXG4gICAgICAgICAgICAgIHJlc3VsdC5iID0gZ2V0VmFsdWUoJHtmfSk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICR7Uy5vdXRwdXR9ID0gcmVzdWx0O1xcbiAgICAgICAgICB9XFxuICAgICAgICBgO3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sZSkse291dHB1dDp7ZGltczpsLHR5cGU6blswXS50eXBlLHRleHR1cmVUeXBlOmkuVGV4dHVyZVR5cGUucGFja2VkfSxzaGFkZXJTb3VyY2U6TyxoYXNNYWluOiEwfSl9KSh0LHUsZSxuLmF4aXMpfSl9O2NvbnN0IHM9KHQsZSxuKT0+e2NvbnN0IHI9dC5pbmRleE9mKGUpO3JldHVybiB0Lm1hcCgoKHQsZSk9PmU9PT1yP2Ake3R9IC0gJHtufWA6dCkpLmpvaW4oKX19LDIwNjk6KHQsZSxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUucGFyc2VDb25jYXRBdHRyaWJ1dGVzPWUuY29uY2F0PXZvaWQgMDtjb25zdCByPW4oMjQ2KSxpPW4oMjAzOSksbz1uKDExNjMpO2UuY29uY2F0PSh0LGUsbik9PihwKGUpLHQuc2Vzc2lvbi5wYWNrJiZlWzBdLmRpbXMubGVuZ3RoPjE/W3QucnVuKCgwLG8uY3JlYXRlUGFja2VkQ29uY2F0UHJvZ3JhbUluZm9Mb2FkZXIpKHQsZSxuKSxlKV06W3QucnVuKGEodCxlLG4pLGUpXSk7Y29uc3QgYT0odCxlLG4pPT57Y29uc3Qgcj0obz1lLmxlbmd0aCxhPW4uY2FjaGVLZXkse25hbWU6XCJDb25jYXRcIixpbnB1dE5hbWVzOkFycmF5LmZyb20oe2xlbmd0aDpvfSwoKHQsZSk9PmBYJHtlfWApKSxpbnB1dFR5cGVzOkFycmF5KG8pLmZpbGwoaS5UZXh0dXJlVHlwZS51bnBhY2tlZCksY2FjaGVIaW50OmF9KTt2YXIgbyxhO3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30scikse2dldDooKT0+KCh0LGUsbixyKT0+e2NvbnN0IG89blswXS5kaW1zLnNsaWNlKCk7aWYocj49by5sZW5ndGh8fHI8LTEqby5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiYXhpcyBzcGVjaWZpZWQgZm9yIGNvbmNhdCBkb2Vzbid0IG1hdGNoIGlucHV0IGRpbWVuc2lvbmFsaXR5XCIpO3I8MCYmKHI9by5sZW5ndGgrcik7Y29uc3QgYT1vLnNsaWNlKDApO2ZvcihsZXQgdD0xO3Q8bi5sZW5ndGg7dCsrKXtjb25zdCBlPW5bdF0uZGltcy5zbGljZSgpO2ZvcihsZXQgdD0wO3Q8by5sZW5ndGg7dCsrKWlmKHQ9PT1yKWFbcl0rPWVbdF07ZWxzZSBpZihvW3RdIT09ZVt0XSl0aHJvdyBuZXcgRXJyb3IoXCJub24gY29uY2F0IGRpbWVuc2lvbnMgbXVzdCBtYXRjaFwiKX1jb25zdCBwPWEubGVuZ3RoLGY9bmV3IEFycmF5KG4ubGVuZ3RoKTtsZXQgZD0wO2ZvcihsZXQgdD0wO3Q8Zi5sZW5ndGg7Kyt0KWQrPW5bdF0uZGltc1tyXSxmW3RdPWQ7bGV0IGg9XCJcIjtoPW4ubGVuZ3RoPDU/cyhmKTp1KGYpO2NvbnN0IGc9YFxcbiAgICAgICAgJHtjKG4ubGVuZ3RoLHApfVxcbiAgICAgICAgJHtsKGYpfVxcbiAgICAgICAgJHtofVxcbiAgICAgICAgZmxvYXQgcHJvY2VzcyhpbnQgaW5kaWNlc1ske3B9XSkge1xcbiAgICAgICAgICBpbnQgdGV4dHVyZUluZGV4ID0gZ2V0VGV4dHVyZVdoZXJlRGF0YVJlc2lkZXMgKGluZGljZXNbJHtyfV0pO1xcblxcbiAgICAgICAgICBpZih0ZXh0dXJlSW5kZXggIT0gMCkge1xcbiAgICAgICAgICAgIGluZGljZXNbJHtyfV0gPSBpbmRpY2VzWyR7cn1dIC0gaW50KGdldFNpemVJbkNvbmNhdEF4aXNWYWx1ZUZyb21JbmRleCh0ZXh0dXJlSW5kZXgtaW50KDEpKSk7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgcmV0dXJuIGZldGNoRGF0YUZyb21Db3JyZWN0VGV4dHVyZSh0ZXh0dXJlSW5kZXgsIGluZGljZXMpO1xcbiAgICAgICAgfWA7cmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxlKSx7b3V0cHV0OntkaW1zOmEsdHlwZTpuWzBdLnR5cGUsdGV4dHVyZVR5cGU6aS5UZXh0dXJlVHlwZS51bnBhY2tlZH0sc2hhZGVyU291cmNlOmd9KX0pKDAscixlLG4uYXhpcyl9KX0scz10PT57Y29uc3QgZT10Lm1hcCgoKHQsZSk9PmBpZihpbmRleDwke3R9KSB7cmV0dXJuICR7ZX07fVxcbmApKTtyZXR1cm5gaW50IGdldFRleHR1cmVXaGVyZURhdGFSZXNpZGVzKGludCBpbmRleCkge1xcbiAgICAgICR7ZS5qb2luKFwiXCIpfVxcbiAgICB9YH0sdT10PT5zKHQpLGM9KHQsZSk9Pntjb25zdCBuPVtgZmxvYXQgZmV0Y2hEYXRhRnJvbUNvcnJlY3RUZXh0dXJlKGludCB0ZXh0dXJlSW5kZXgsIGludCBpbmRpY2VzWyR7ZX1dKSB7YF07Zm9yKGxldCBlPTA7ZTx0OysrZSkwPT09ZT9uLnB1c2goYFxcdGlmICh0ZXh0dXJlSW5kZXggPT0gJHtlfSkgeyByZXR1cm4gX1gke2V9KGluZGljZXMpOyB9YCk6ZT09PXQtMT9uLnB1c2goYFxcdGVsc2UgeyByZXR1cm4gX1gke2V9KGluZGljZXMpOyB9YCk6bi5wdXNoKGBcXHRlbHNlIGlmICh0ZXh0dXJlSW5kZXggPT0gJHtlfSkgeyByZXR1cm4gX1gke2V9KGluZGljZXMpOyB9YCk7cmV0dXJuIG4ucHVzaChcIlxcdH1cIiksbi5qb2luKFwiXFxuXCIpfSxsPXQ9Pntjb25zdCBlPVtcImludCBnZXRTaXplSW5Db25jYXRBeGlzVmFsdWVGcm9tSW5kZXgoaW50IGluZGV4KSB7XCJdO2ZvcihsZXQgbj0wO248dC5sZW5ndGg7KytuKTA9PT1uP2UucHVzaChgXFx0aWYgKGluZGV4ID09ICR7bn0pIHsgcmV0dXJuICR7dFtuXX07IH1gKTpuPT09dC5sZW5ndGgtMT9lLnB1c2goYFxcdGVsc2UgeyByZXR1cm4gJHt0W25dfTsgfWApOmUucHVzaChgXFx0ZWxzZSBpZiAoaW5kZXggPT0gJHtufSkgeyByZXR1cm4gJHt0W25dfTsgfWApO3JldHVybiBlLnB1c2goXCJcXHR9XCIpLGUuam9pbihcIlxcblwiKX07ZS5wYXJzZUNvbmNhdEF0dHJpYnV0ZXM9dD0+KDAsci5jcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkpKHtheGlzOnQuYXR0cmlidXRlcy5nZXRJbnQoXCJheGlzXCIpfSk7Y29uc3QgcD10PT57aWYoIXR8fHQubGVuZ3RoPDEpdGhyb3cgbmV3IEVycm9yKFwidG9vIGZldyBpbnB1dHNcIik7Y29uc3QgZT10WzBdLnR5cGUsbj10WzBdLmRpbXMubGVuZ3RoO2lmKFwic3RyaW5nXCI9PT1lKXRocm93IG5ldyBFcnJvcihcInN0cmluZyB0ZW5zb3IgaXMgbm90IHN1cHBvcnRlZCB5ZXRcIik7Zm9yKGNvbnN0IHIgb2YgdCl7aWYoci50eXBlIT09ZSl0aHJvdyBuZXcgRXJyb3IoXCJpbnB1dCB0ZW5zb3JzIHNob3VsZCBiZSBvbmUgdHlwZVwiKTtpZihyLmRpbXMubGVuZ3RoIT09bil0aHJvdyBuZXcgRXJyb3IoXCJpbnB1dCB0ZW5zb3JzIHNob3VsZCBoYXZlIHRoZSBzYW1lIHNoYXBlXCIpfX19LDQ3NzA6KHQsZSxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUuY3JlYXRlVW5wYWNrZWRHcm91cGVkQ29udlByb2dyYW1JbmZvTG9hZGVyPXZvaWQgMDtjb25zdCByPW4oMzY5NCksaT1uKDUwNjApLG89bigyMDM5KSxhPW4oODEzOCkscz1uKDI4MjMpO2UuY3JlYXRlVW5wYWNrZWRHcm91cGVkQ29udlByb2dyYW1JbmZvTG9hZGVyPSh0LGUsbik9Pntjb25zdCB1PShjPWUubGVuZ3RoPjIsbD1uLmNhY2hlS2V5LHtuYW1lOlwiR3JvdXBlZENvbnZcIixpbnB1dE5hbWVzOmM/W1wiWFwiLFwiV1wiLFwiQmlhc1wiXTpbXCJYXCIsXCJXXCJdLGlucHV0VHlwZXM6Yz9bby5UZXh0dXJlVHlwZS51bnBhY2tlZCxvLlRleHR1cmVUeXBlLnVucGFja2VkLG8uVGV4dHVyZVR5cGUudW5wYWNrZWRdOltvLlRleHR1cmVUeXBlLnVucGFja2VkLG8uVGV4dHVyZVR5cGUudW5wYWNrZWRdLGNhY2hlSGludDpsfSk7dmFyIGMsbDtyZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LHUpLHtnZXQ6KCk9PigodCxlLG4sdSk9Pntjb25zdCBjPWUubGVuZ3RoPjI/XCJ2YWx1ZSArPSBnZXRCaWFzKG91dHB1dF9jaGFubmVsKTtcIjpcIlwiLGw9ZVswXS5kaW1zLnNsaWNlKCkscD1lWzFdLmRpbXMuc2xpY2UoKSxmPXBbMF0vdS5ncm91cDtyLkxvZ2dlci52ZXJib3NlKFwiR3JvdXBlZENvbnZcIixgYXV0cFBhZDoke3UuYXV0b1BhZH0sIGRpbGF0aW9uczoke3UuZGlsYXRpb25zfSwgZ3JvdXA6JHt1Lmdyb3VwfSwga2VybmVsU2hhcGU6JHt1Lmtlcm5lbFNoYXBlfSwgcGFkczoke3UucGFkc30sIHN0cmlkZXM6JHt1LnN0cmlkZXN9YCk7Y29uc3QgZD0oMCxhLmNhbGN1bGF0ZU91dHB1dFNoYXBlKShsLHAsdS5kaWxhdGlvbnMsdS5wYWRzLHUuc3RyaWRlcyksaD0oMCxpLmdldEdsc2wpKHQuc2Vzc2lvbi5iYWNrZW5kLmdsQ29udGV4dC52ZXJzaW9uKSx7YWN0aXZhdGlvbkZ1bmN0aW9uOmcsYXBwbHlBY3RpdmF0aW9uOmJ9PSgwLHMuZ2V0QWN0aXZhdGlvblNuaXBwZXQpKHUpLG09YFxcbiAgY29uc3QgaXZlYzIgc3RyaWRlcyA9IGl2ZWMyKCR7dS5zdHJpZGVzWzBdfSwgJHt1LnN0cmlkZXNbMV19KTtcXG4gIGNvbnN0IGl2ZWMyIHBhZHMgPSBpdmVjMigke3UucGFkc1swXX0sICR7dS5wYWRzWzFdfSk7XFxuICAke2d9XFxuICB2b2lkIG1haW4oKSB7XFxuICAgIGl2ZWM0IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICBpbnQgYmF0Y2ggPSBjb29yZHMueDtcXG4gICAgaW50IG91dHB1dF9jaGFubmVsID0gY29vcmRzLnk7XFxuICAgIGl2ZWMyIHhSQ0Nvcm5lciA9IGNvb3Jkcy56dyAqIHN0cmlkZXMgLSBwYWRzO1xcbiAgICBpbnQgZ3JvdXBfaWQgPSBvdXRwdXRfY2hhbm5lbCAvICR7Zn07XFxuXFxuICAgIGZsb2F0IHZhbHVlID0gMC4wO1xcbiAgICBmb3IgKGludCB3SW5DaGFubmVsID0gMDsgd0luQ2hhbm5lbCA8ICR7cFsxXX07IHdJbkNoYW5uZWwrKykge1xcbiAgICAgIGludCBpbnB1dF9jaGFubmVsID0gZ3JvdXBfaWQgKiAke3BbMV19ICsgd0luQ2hhbm5lbDtcXG4gICAgICBmb3IgKGludCB3SGVpZ2h0ID0gMDsgd0hlaWdodCA8ICR7cFsyXX07IHdIZWlnaHQrKykge1xcbiAgICAgICAgaW50IHhIZWlnaHQgPSB4UkNDb3JuZXIueCArIHdIZWlnaHQgKiAke3UuZGlsYXRpb25zWzBdfTtcXG5cXG4gICAgICAgIGlmICh4SGVpZ2h0IDwgMCB8fCB4SGVpZ2h0ID49ICR7bFsyXX0pIHtcXG4gICAgICAgICAgY29udGludWU7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBmb3IgKGludCB3V2lkdGggPSAwOyB3V2lkdGggPCAke3BbM119OyB3V2lkdGgrKykge1xcbiAgICAgICAgICBpbnQgeFdpZHRoID0geFJDQ29ybmVyLnkgKyB3V2lkdGggKiAke3UuZGlsYXRpb25zWzFdfTtcXG4gICAgICAgICAgaWYgKHhXaWR0aCA8IDAgfHwgeFdpZHRoID49ICR7bFszXX0pIHtcXG4gICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBmbG9hdCB4VmFsID0gZ2V0WChiYXRjaCwgaW5wdXRfY2hhbm5lbCwgeFdpZHRoLCB4SGVpZ2h0KTtcXG4gICAgICAgICAgZmxvYXQgd1ZhbCA9IGdldFcob3V0cHV0X2NoYW5uZWwsIHdJbkNoYW5uZWwsIHdXaWR0aCwgd0hlaWdodCk7XFxuICAgICAgICAgIHZhbHVlICs9IHhWYWwqd1ZhbDtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH1cXG4gICAgJHtjfVxcbiAgICAke2J9XFxuICAgICR7aC5vdXRwdXR9ID0gdmVjNCh2YWx1ZSwgLjAsIC4wLCAuMCk7XFxuICB9XFxuYDtyZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LG4pLHtvdXRwdXQ6e2RpbXM6ZCx0eXBlOmVbMF0udHlwZSx0ZXh0dXJlVHlwZTpvLlRleHR1cmVUeXBlLnVucGFja2VkfSxzaGFkZXJTb3VyY2U6bSxoYXNNYWluOiEwfSl9KSh0LGUsdSxuKX0pfX0sMTM4NjoodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5jb252MkRQYWNrZWQ9ZS5jb252MkRQYWNrZWRQb2ludHdpc2U9dm9pZCAwO2NvbnN0IHI9big4MTM4KSxpPW4oODU1NSksbz1uKDcwOCk7ZS5jb252MkRQYWNrZWRQb2ludHdpc2U9KHQsZSxuKT0+e2NvbnN0IGk9ZVswXS5kaW1zLGE9ZVsxXS5kaW1zLHM9KDAsci5jYWxjdWxhdGVPdXRwdXRTaGFwZSkoaSxhLG4uZGlsYXRpb25zLG4ucGFkcyxuLnN0cmlkZXMpLHU9dC5yZXNoYXBlUGFja2VkKGVbMF0sW2lbMV0saVsyXSppWzNdXSksYz10LnJlc2hhcGVQYWNrZWQoZVsxXSxbYVswXSxhWzFdXSksbD1lLmxlbmd0aD4yP1tjLHUsZVsyXV06W2MsdV0scD10LnJ1bigoMCxvLmNyZWF0ZVBhY2tlZE1hdG11bFByb2dyYW1JbmZvTG9hZGVyKSh0LGwsbiksbCk7cmV0dXJuIHQucmVzaGFwZVBhY2tlZChwLHMpfSxlLmNvbnYyRFBhY2tlZD0odCxlLG4pPT57Y29uc3QgYT1lWzBdLmRpbXMscz1lWzFdLmRpbXMsdT0oMCxyLmNhbGN1bGF0ZU91dHB1dFNoYXBlKShhLHMsbi5kaWxhdGlvbnMsbi5wYWRzLG4uc3RyaWRlcyksYz10LnJ1bigoMCxpLmNyZWF0ZVBhY2tlZEltMkNvbFByb2dyYW1JbmZvTG9hZGVyKSh0LGVbMF0sZVsxXSx1LG4pLFtlWzBdXSksbD10LnJlc2hhcGVQYWNrZWQoZVsxXSxbc1swXSxzWzFdKnNbMl0qc1szXV0pLHA9Mz09PWUubGVuZ3RoP1tsLGMsZVsyXV06W2wsY10sZj10LnJ1bigoMCxvLmNyZWF0ZVBhY2tlZE1hdG11bFByb2dyYW1JbmZvTG9hZGVyKSh0LHAsbikscCk7cmV0dXJuIHQucmVzaGFwZVBhY2tlZChmLHUpfX0sOTY2MzoodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5wYXJzZUNvbnZUcmFuc3Bvc2VBdHRyaWJ1dGVzPWUuY29udlRyYW5zcG9zZT12b2lkIDA7Y29uc3Qgcj1uKDI0NiksaT1uKDUwNjApLG89bigyMDM5KSxhPW4oMjgyMykscz0odCxlLG4scixpLG8pPT4odC0xKSplK24rKHItMSkqaSsxLW8sdT0odCxlLG4scixpKT0+e2NvbnN0IG89TWF0aC5mbG9vcih0LzIpO1wiU0FNRV9VUFBFUlwiPT09ZT8obltyXT1vLG5baV09dC1vKTpcIlNBTUVfTE9XRVJcIj09PWUmJihuW3JdPXQtbyxuW2ldPW8pfTtlLmNvbnZUcmFuc3Bvc2U9KHQsZSxuKT0+KGYoZSxuKSxjKHQsZSxuKSk7Y29uc3QgYz0odCxlLG4pPT57Y29uc3Qgcj1wKG4sZSk7cmV0dXJuW2wodCxlLHIpXX0sbD0odCxlLG4pPT50LnJ1bigoKHQsZSxuKT0+e2NvbnN0IHI9KHM9ZS5sZW5ndGg+Mix1PW4uY2FjaGVLZXkse25hbWU6XCJDb252VHJhbnNwb3NlXCIsaW5wdXROYW1lczpzP1tcIlhcIixcIldcIixcIkJcIl06W1wiWFwiLFwiV1wiXSxpbnB1dFR5cGVzOnM/W28uVGV4dHVyZVR5cGUudW5wYWNrZWQsby5UZXh0dXJlVHlwZS51bnBhY2tlZCxvLlRleHR1cmVUeXBlLnVucGFja2VkXTpbby5UZXh0dXJlVHlwZS51bnBhY2tlZCxvLlRleHR1cmVUeXBlLnVucGFja2VkXSxjYWNoZUhpbnQ6dX0pO3ZhciBzLHU7cmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxyKSx7Z2V0OigpPT4oKHQsZSxuLHIpPT57Y29uc3Qgcz1lLmxlbmd0aD4yP1wiZ2V0QihvdXRwdXRfY2hhbm5lbClcIjpcIjAuMFwiLHU9ZVswXS5kaW1zLGM9ZVsxXS5kaW1zLGw9Y1sxXSxwPWNbMF0vci5ncm91cCxmPVtlWzBdLmRpbXNbMF0sZVsxXS5kaW1zWzFdKnIuZ3JvdXAsLi4uci5vdXRwdXRTaGFwZV0sZD0oMCxpLmdldEdsc2wpKHQuc2Vzc2lvbi5iYWNrZW5kLmdsQ29udGV4dC52ZXJzaW9uKSx7YWN0aXZhdGlvbkZ1bmN0aW9uOmgsYXBwbHlBY3RpdmF0aW9uOmd9PSgwLGEuZ2V0QWN0aXZhdGlvblNuaXBwZXQpKHIpLGI9YFxcbiAgY29uc3QgaXZlYzIgc3RyaWRlcyA9IGl2ZWMyKCR7ci5zdHJpZGVzWzBdfSwgJHtyLnN0cmlkZXNbMV19KTtcXG4gIGNvbnN0IGl2ZWMyIHBhZHMgPSBpdmVjMigke3IucGFkc1swXX0sICR7ci5wYWRzWzFdfSk7XFxuICAke2h9XFxuICB2b2lkIG1haW4oKSB7XFxuICAgIGl2ZWM0IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICBpbnQgYmF0Y2ggPSBjb29yZHMueDtcXG4gICAgaW50IG91dHB1dF9jaGFubmVsID0gY29vcmRzLnk7XFxuXFxuICAgIGl2ZWMyIGxvYyA9IGNvb3Jkcy56dyArIHBhZHM7XFxuXFxuICAgIGludCBncm91cF9pZCA9IG91dHB1dF9jaGFubmVsIC8gJHtsfTtcXG4gICAgaW50IHdPdXRDaGFubmVsID0gb3V0cHV0X2NoYW5uZWwgLSBncm91cF9pZCAqICR7bH07XFxuXFxuICAgIGZsb2F0IHZhbHVlID0gJHtzfTtcXG4gICAgZm9yIChpbnQgaW5DaGFubmVsT2Zmc2V0ID0gMDsgaW5DaGFubmVsT2Zmc2V0IDwgJHtwfTsgaW5DaGFubmVsT2Zmc2V0KyspIHtcXG4gICAgICBpbnQgaW5wdXRfY2hhbm5lbCA9IGdyb3VwX2lkICogJHtwfSArIGluQ2hhbm5lbE9mZnNldDtcXG4gICAgICBmb3IgKGludCB3V09mZiA9IDA7IHdXT2ZmIDwgJHtjWzJdfTsgd1dPZmYrKykge1xcbiAgICAgICAgZm9yIChpbnQgd0hPZmYgPSAwOyB3SE9mZiA8ICR7Y1szXX07IHdIT2ZmKyspIHtcXG4gICAgICAgICAgaXZlYzIgd09mZiA9IGl2ZWMyKHdXT2ZmICogJHtyLmRpbGF0aW9uc1swXX0sIHdIT2ZmICogJHtyLmRpbGF0aW9uc1sxXX0pO1xcbiAgICAgICAgICBpdmVjMiB3TG9jID0gbG9jIC0gd09mZjtcXG4gICAgICAgICAgaXZlYzIgd0xvY0luID0gd0xvYyAvIHN0cmlkZXM7XFxuICAgICAgICAgIGlmIChcXG4gICAgICAgICAgICB3TG9jSW4gKiBzdHJpZGVzID09IHdMb2MgJiZcXG4gICAgICAgICAgICB3TG9jSW4ueCA+PSAwICYmIHdMb2NJbi54IDwgJHt1WzJdfSAmJlxcbiAgICAgICAgICAgIHdMb2NJbi55ID49IDAgJiYgd0xvY0luLnkgPCAke3VbM119XFxuICAgICAgICAgICkge1xcbiAgICAgICAgICAgIGZsb2F0IHhWYWwgPSBnZXRYKGJhdGNoLCBpbnB1dF9jaGFubmVsLCB3TG9jSW4ueSwgd0xvY0luLngpO1xcbiAgICAgICAgICAgIGZsb2F0IHdWYWwgPSBnZXRXKGlucHV0X2NoYW5uZWwsIHdPdXRDaGFubmVsLCB3SE9mZiwgd1dPZmYpO1xcbiAgICAgICAgICAgIHZhbHVlICs9IHhWYWwgKiB3VmFsO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9XFxuICAgICR7Z31cXG4gICAgJHtkLm91dHB1dH0gPSB2ZWM0KHZhbHVlLCAuMCwgLjAsIC4wKTtcXG4gIH1cXG5gO3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sbikse291dHB1dDp7ZGltczpmLHR5cGU6ZVswXS50eXBlLHRleHR1cmVUeXBlOm8uVGV4dHVyZVR5cGUudW5wYWNrZWR9LHNoYWRlclNvdXJjZTpiLGhhc01haW46ITB9KX0pKHQsZSxyLG4pfSl9KSh0LGUsbiksZSkscD0odCxlKT0+e2NvbnN0IG49dC5rZXJuZWxTaGFwZS5zbGljZSgpO2lmKDA9PT10Lmtlcm5lbFNoYXBlLmxlbmd0aClmb3IobGV0IHQ9Mjt0PGVbMV0uZGltcy5sZW5ndGg7Kyt0KW4ucHVzaChlWzFdLmRpbXNbdF0pO2NvbnN0IHI9dC5wYWRzLnNsaWNlKCksaT10Lm91dHB1dFNoYXBlLnNsaWNlKCk7KCh0LGUsbixyLGksbyxhLGMpPT57Y29uc3QgbD10Lmxlbmd0aC0yLHA9MD09PWMubGVuZ3RoO2ZvcihsZXQgZj0wO2Y8bDsrK2Ype2NvbnN0IGQ9cD90W2YrMl0qb1tmXTpjW2ZdLGg9cyh0W2YrMl0sb1tmXSxpW2ZdLGVbZl0sbltmXSxkKTt1KGgscixpLGYsZitsKSxwJiZjLnB1c2gob1tmXSoodFtmKzJdLTEpK2FbZl0rKGVbZl0tMSkqbltmXSsxLWlbZl0taVtmK2xdKX19KShlWzBdLmRpbXMsbix0LmRpbGF0aW9ucyx0LmF1dG9QYWQscix0LnN0cmlkZXMsdC5vdXRwdXRQYWRkaW5nLGkpO2NvbnN0IG89T2JqZWN0LmFzc2lnbih7fSx0KTtyZXR1cm4gT2JqZWN0LmFzc2lnbihvLHtrZXJuZWxTaGFwZTpuLHBhZHM6cixvdXRwdXRTaGFwZTppLGNhY2hlS2V5OnQuY2FjaGVLZXl9KSxvfTtlLnBhcnNlQ29udlRyYW5zcG9zZUF0dHJpYnV0ZXM9dD0+e2NvbnN0IGU9dC5hdHRyaWJ1dGVzLG49KDAsYS5wYXJzZUludGVybmFsQWN0aXZhdGlvbkF0dHJpYnV0ZXMpKGUpLGk9ZS5nZXRTdHJpbmcoXCJhdXRvX3BhZFwiLFwiTk9UU0VUXCIpLG89ZS5nZXRJbnRzKFwiZGlsYXRpb25zXCIsWzEsMV0pLHM9ZS5nZXRJbnQoXCJncm91cFwiLDEpLHU9ZS5nZXRJbnRzKFwia2VybmVsX3NoYXBlXCIsW10pLGM9ZS5nZXRJbnRzKFwib3V0cHV0X3BhZGRpbmdcIixbMCwwXSksbD1lLmdldEludHMoXCJvdXRwdXRfc2hhcGVcIixbXSkscD1lLmdldEludHMoXCJwYWRzXCIsWzAsMCwwLDBdKSxmPWUuZ2V0SW50cyhcInN0cmlkZXNcIixbMSwxXSk7cmV0dXJuKDAsci5jcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkpKE9iamVjdC5hc3NpZ24oe2F1dG9QYWQ6aSxkaWxhdGlvbnM6byxncm91cDpzLGtlcm5lbFNoYXBlOnUsb3V0cHV0UGFkZGluZzpjLG91dHB1dFNoYXBlOmwscGFkczpwLHN0cmlkZXM6Zn0sbikpfTtjb25zdCBmPSh0LGUpPT57aWYoIXR8fDIhPT10Lmxlbmd0aCYmMyE9PXQubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIkNvbnYgcmVxdWlyZXMgMiBvciAzIGlucHV0c1wiKTtpZig0IT09dFswXS5kaW1zLmxlbmd0aHx8NCE9PXRbMV0uZGltcy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiY3VycmVudGx5IG9ubHkgc3VwcG9ydCAyLWRpbWVuc2lvbmFsIGNvbnZcIik7aWYodFswXS5kaW1zWzFdIT09dFsxXS5kaW1zWzBdKXRocm93IG5ldyBFcnJvcihcIkZJTFRFUl9JTl9DSEFOTkVMIHNob3VsZCBiZSBlcXVhbCB0byBEQVRBX0NIQU5ORUxcIik7Y29uc3Qgbj10WzFdLmRpbXNbMV0qZS5ncm91cDtpZigzPT09dC5sZW5ndGgmJigxIT09dFsyXS5kaW1zLmxlbmd0aHx8dFsyXS5kaW1zWzBdIT09bikpdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBiaWFzXCIpO2NvbnN0IHI9dFswXS5kaW1zLmxlbmd0aC0yO2lmKGUuZGlsYXRpb25zLmxlbmd0aCE9PXIpdGhyb3cgbmV3IEVycm9yKGBkaWxhdGlvbnMgc2hvdWxkIGJlICR7cn1EYCk7aWYoZS5zdHJpZGVzLmxlbmd0aCE9PXIpdGhyb3cgbmV3IEVycm9yKGBzdHJpZGVzIHNob3VsZCBiZSAke3J9RGApO2lmKGUucGFkcy5sZW5ndGghPT0yKnIpdGhyb3cgbmV3IEVycm9yKGBwYWRzIHNob3VsZCBiZSAkezIqcn1EYCk7aWYoZS5vdXRwdXRQYWRkaW5nLmxlbmd0aCE9PXIpdGhyb3cgbmV3IEVycm9yKGBvdXRwdXRfcGFkZGluZyBzaG91bGQgYmUgJHtyfURgKTtpZigwIT09ZS5rZXJuZWxTaGFwZS5sZW5ndGgmJmUua2VybmVsU2hhcGUubGVuZ3RoIT09dFsxXS5kaW1zLmxlbmd0aC0yKXRocm93IG5ldyBFcnJvcihcImludmFsaWQga2VybmVsIHNoYXBlXCIpO2lmKDAhPT1lLm91dHB1dFNoYXBlLmxlbmd0aCYmZS5vdXRwdXRTaGFwZS5sZW5ndGghPT10WzBdLmRpbXMubGVuZ3RoLTIpdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBvdXRwdXQgc2hhcGVcIik7aWYoXCJmbG9hdDMyXCIhPT10WzBdLnR5cGV8fFwiZmxvYXQzMlwiIT09dFsxXS50eXBlKXRocm93IG5ldyBFcnJvcihcIkNvbnZUcmFuc3Bvc2UgaW5wdXQoWCxXKSBzaG91bGQgYmUgZmxvYXQgdGVuc29yXCIpO2lmKDM9PT10Lmxlbmd0aCYmXCJmbG9hdDMyXCIhPT10WzJdLnR5cGUpdGhyb3cgbmV3IEVycm9yKFwiQ29udlRyYW5zcG9zZSBpbnB1dChiaWFzKSBzaG91bGQgYmUgZmxvYXQgdGVuc29yXCIpfX0sODEzODoodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5wYXJzZUNvbnZBdHRyaWJ1dGVzPWUuY29udj1lLmNhbGN1bGF0ZU91dHB1dFNoYXBlPXZvaWQgMDtjb25zdCByPW4oMjQ2KSxpPW4oMjUxNyksbz1uKDQ3NzApLGE9bigxMzg2KSxzPW4oOTgyOCksdT1uKDI4MjMpLGM9bigzMjQ4KSxsPW4oNTYyMyk7ZS5jYWxjdWxhdGVPdXRwdXRTaGFwZT0odCxlLG4scixpKT0+e2NvbnN0IG89dFswXSxhPXQuc2xpY2UoMikscz1hLmxlbmd0aCx1PWVbMF0sYz1lLnNsaWNlKDIpLm1hcCgoKHQsZSk9PnQrKHQtMSkqKG5bZV0tMSkpKSxsPWEubWFwKCgodCxlKT0+dCtyW2VdK3JbZStzXSkpLHA9bC5tYXAoKCh0LGUpPT5NYXRoLmZsb29yKCh0LWNbZV0raVtlXSkvaVtlXSkpKTtyZXR1cm5bbyx1XS5jb25jYXQoLi4ucCl9LGUuY29udj0odCxlLG4pPT4oZyhlLG4pLHAodCxlLG4pKTtjb25zdCBwPSh0LGUsbik9Pntjb25zdCByPWgobixlKSxpPXQuc2Vzc2lvbi5wYWNrLHM9MT09PXIua2VybmVsU2hhcGVbMF0mJjE9PT1yLmtlcm5lbFNoYXBlWzFdO3JldHVybiByLmdyb3VwPjE/W3QucnVuKCgwLG8uY3JlYXRlVW5wYWNrZWRHcm91cGVkQ29udlByb2dyYW1JbmZvTG9hZGVyKSh0LGUsciksZSldOnMmJmk/W2YodCxlLHIpXTppJiY0PT09ZVswXS5kaW1zLmxlbmd0aCYmMT09PWVbMF0uZGltc1swXSYmIXM/WygwLGEuY29udjJEUGFja2VkKSh0LGUscildOltkKHQsZSxyKV19LGY9KHQsbixyKT0+e2NvbnN0IGk9blswXS5kaW1zLG89blsxXS5kaW1zLGE9KDAsZS5jYWxjdWxhdGVPdXRwdXRTaGFwZSkoaSxvLHIuZGlsYXRpb25zLHIucGFkcyxyLnN0cmlkZXMpLHM9dC5yZXNoYXBlVW5wYWNrZWQoblswXSxbaVsxXSxpWzJdKmlbM11dKSx1PXQucmVzaGFwZVVucGFja2VkKG5bMV0sW29bMF0sb1sxXV0pLGM9bi5sZW5ndGg+Mj9bdSxzLG5bMl1dOlt1LHNdLHA9dC5ydW4oKDAsbC5jcmVhdGVNYXRtdWxQcm9ncmFtSW5mb0xvYWRlcikoYyxyKSxjKTtyZXR1cm4gdC5yZXNoYXBlVW5wYWNrZWQocCxhKX0sZD0odCxuLHIpPT57Y29uc3QgaT1uWzBdLmRpbXMsbz1uWzFdLmRpbXMsYT0oMCxlLmNhbGN1bGF0ZU91dHB1dFNoYXBlKShpLG8sci5kaWxhdGlvbnMsci5wYWRzLHIuc3RyaWRlcyksdT10LnJ1bigoMCxjLmNyZWF0ZUltMkNvbFByb2dyYW1JbmZvTG9hZGVyKSh0LG5bMF0sblsxXSxhLHIpLFtuWzBdXSksbD0zPT09bi5sZW5ndGg/W3UsblsxXSxuWzJdXTpbdSxuWzFdXTtyZXR1cm4gdC5ydW4oKDAscy5jcmVhdGVEb3RQcm9kdWN0UHJvZ3JhbUluZm9Mb2FkZXIpKHQsbixhLHIpLGwpfSxoPSh0LGUpPT57Y29uc3Qgbj10Lmtlcm5lbFNoYXBlLnNsaWNlKCk7aWYoMD09PXQua2VybmVsU2hhcGUubGVuZ3RoKWZvcihsZXQgdD0yO3Q8ZVsxXS5kaW1zLmxlbmd0aDsrK3Qpbi5wdXNoKGVbMV0uZGltc1t0XSk7Y29uc3Qgcj10LnBhZHMuc2xpY2UoKTtpLlBvb2xDb252VXRpbC5hZGp1c3RQYWRzQmFzZWRPbkF1dG9QYWQoZVswXS5kaW1zLHQuc3RyaWRlcyx0LmRpbGF0aW9ucyxuLHIsdC5hdXRvUGFkKTtjb25zdCBvPU9iamVjdC5hc3NpZ24oe30sdCk7cmV0dXJuIE9iamVjdC5hc3NpZ24obyx7a2VybmVsU2hhcGU6bixwYWRzOnIsY2FjaGVLZXk6dC5jYWNoZUtleX0pLG99O2UucGFyc2VDb252QXR0cmlidXRlcz10PT57Y29uc3QgZT10LmF0dHJpYnV0ZXMsbj0oMCx1LnBhcnNlSW50ZXJuYWxBY3RpdmF0aW9uQXR0cmlidXRlcykoZSksaT1lLmdldFN0cmluZyhcImF1dG9fcGFkXCIsXCJOT1RTRVRcIiksbz1lLmdldEludHMoXCJkaWxhdGlvbnNcIixbMSwxXSksYT1lLmdldEludChcImdyb3VwXCIsMSkscz1lLmdldEludHMoXCJrZXJuZWxfc2hhcGVcIixbXSksYz1lLmdldEludHMoXCJwYWRzXCIsWzAsMCwwLDBdKSxsPWUuZ2V0SW50cyhcInN0cmlkZXNcIixbMSwxXSk7cmV0dXJuKDAsci5jcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkpKE9iamVjdC5hc3NpZ24oe2F1dG9QYWQ6aSxkaWxhdGlvbnM6byxncm91cDphLGtlcm5lbFNoYXBlOnMscGFkczpjLHN0cmlkZXM6bH0sbikpfTtjb25zdCBnPSh0LGUpPT57aWYoIXR8fDIhPT10Lmxlbmd0aCYmMyE9PXQubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIkNvbnYgcmVxdWlyZXMgMiBvciAzIGlucHV0c1wiKTtpZig0IT09dFswXS5kaW1zLmxlbmd0aHx8NCE9PXRbMV0uZGltcy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiY3VycmVudGx5IG9ubHkgc3VwcG9ydCAyLWRpbWVuc2lvbmFsIGNvbnZcIik7aWYodFswXS5kaW1zWzFdIT09dFsxXS5kaW1zWzFdKmUuZ3JvdXApdGhyb3cgbmV3IEVycm9yKFwiRklMVEVSX0lOX0NIQU5ORUwgc2hvdWxkIGJlIGVxdWFsIHRvIERBVEFfQ0hBTk5FTFwiKTtpZigzPT09dC5sZW5ndGgmJigxIT09dFsyXS5kaW1zLmxlbmd0aHx8dFsxXS5kaW1zWzBdIT09dFsyXS5kaW1zWzBdKSl0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGJpYXNcIik7Y29uc3Qgbj10WzBdLmRpbXMubGVuZ3RoLTI7aWYoZS5kaWxhdGlvbnMubGVuZ3RoIT09bil0aHJvdyBuZXcgRXJyb3IoYGRpbGF0aW9ucyBzaG91bGQgYmUgJHtufURgKTtpZihlLnN0cmlkZXMubGVuZ3RoIT09bil0aHJvdyBuZXcgRXJyb3IoYHN0cmlkZXMgc2hvdWxkIGJlICR7bn1EYCk7aWYoZS5wYWRzLmxlbmd0aCE9PTIqbil0aHJvdyBuZXcgRXJyb3IoYHBhZHMgc2hvdWxkIGJlICR7MipufURgKTtpZigwIT09ZS5rZXJuZWxTaGFwZS5sZW5ndGgmJmUua2VybmVsU2hhcGUubGVuZ3RoIT09dFsxXS5kaW1zLmxlbmd0aC0yKXRocm93IG5ldyBFcnJvcihcImludmFsaWQga2VybmVsIHNoYXBlXCIpO2lmKFwiZmxvYXQzMlwiIT09dFswXS50eXBlfHxcImZsb2F0MzJcIiE9PXRbMV0udHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJDb252IGlucHV0KFgsVykgc2hvdWxkIGJlIGZsb2F0IHRlbnNvclwiKTtpZigzPT09dC5sZW5ndGgmJlwiZmxvYXQzMlwiIT09dFsyXS50eXBlKXRocm93IG5ldyBFcnJvcihcIkNvbnYgaW5wdXQoYmlhcykgc2hvdWxkIGJlIGZsb2F0IHRlbnNvclwiKX19LDUxOTM6KHQsZSxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUucGFyc2VEZXB0aFRvU3BhY2VBdHRyaWJ1dGVzPWUuZGVwdGhUb1NwYWNlPXZvaWQgMDtjb25zdCByPW4oMzczOCk7ZS5kZXB0aFRvU3BhY2U9KHQsZSxuKT0+e2koZSk7Y29uc3Qgbz1uLmJsb2Nrc2l6ZSxhPW8qbyxzPVwiRENSXCI9PT1uLm1vZGU/WzAsMyw0LDEsNSwyXTpbMCwxLDQsMiw1LDNdLHU9XCJEQ1JcIj09PW4ubW9kZT9bZVswXS5kaW1zWzBdLG8sbyxlWzBdLmRpbXNbMV0vYSxlWzBdLmRpbXNbMl0sZVswXS5kaW1zWzNdXTpbZVswXS5kaW1zWzBdLGVbMF0uZGltc1sxXS9hLG8sbyxlWzBdLmRpbXNbMl0sZVswXS5kaW1zWzNdXSxjPXQucmVzaGFwZVVucGFja2VkKGVbMF0sdSksbD17cGVybTpzLGNhY2hlS2V5OmAke3N9YH0sW3BdPSgwLHIudHJhbnNwb3NlKSh0LFtjXSxsKSxmPVtlWzBdLmRpbXNbMF0sZVswXS5kaW1zWzFdL2EsZVswXS5kaW1zWzJdKm8sZVswXS5kaW1zWzNdKm9dO3JldHVyblt0LnJlc2hhcGVVbnBhY2tlZChwLGYpXX0sZS5wYXJzZURlcHRoVG9TcGFjZUF0dHJpYnV0ZXM9dD0+e2NvbnN0IGU9dC5hdHRyaWJ1dGVzLmdldEludChcImJsb2Nrc2l6ZVwiKTtpZihlPDEpdGhyb3cgbmV3IEVycm9yKGBibG9ja3NpemUgbXVzdCBiZSA+PSAxLCBidXQgZ290IDogJHtlfSBmb3IgRGVwdGhUb1NwYWNlYCk7Y29uc3Qgbj10LmF0dHJpYnV0ZXMuZ2V0U3RyaW5nKFwibW9kZVwiLFwiRENSXCIpO2lmKFwiRENSXCIhPT1uJiZcIkNSRFwiIT09bil0aHJvdyBuZXcgRXJyb3IoYHVucmVjb2duaXplZCBtb2RlOiAke259IGZvciBEZXB0aFRvU3BhY2VgKTtyZXR1cm57bW9kZTpuLGJsb2Nrc2l6ZTplfX07Y29uc3QgaT10PT57aWYoMSE9PXQubGVuZ3RoKXRocm93IG5ldyBFcnJvcihgRGVwdGhUb1NwYWNlIGV4cGVjdCAxIGlucHV0cywgYnV0IGdvdCAke3QubGVuZ3RofWApO2lmKFwic3RyaW5nXCI9PT10WzBdLnR5cGV8fDQhPT10WzBdLmRpbXMubGVuZ3RoKXRocm93IG5ldyBUeXBlRXJyb3IoXCJEZXB0aFRvU3BhY2UgaW5wdXQgc2hvdWxkIGJlIGEgNC1EIG51bWVyaWMgdGVuc29yXCIpfX0sOTgyODoodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5jcmVhdGVEb3RQcm9kdWN0UHJvZ3JhbUluZm9Mb2FkZXI9dm9pZCAwO2NvbnN0IHI9bigyNTE3KSxpPW4oNTA2MCksbz1uKDIwMzkpLGE9bigyODIzKSxzPW4oMzI0OCk7ZS5jcmVhdGVEb3RQcm9kdWN0UHJvZ3JhbUluZm9Mb2FkZXI9KHQsZSxuLHUpPT57Y29uc3QgYz0oKHQsZSk9Pih7bmFtZTpcIkNvbnZEb3RQcm9kdWN0XCIsaW5wdXROYW1lczp0P1tcIkltMkNvbFwiLFwiS1wiLFwiQlwiXTpbXCJJbTJDb2xcIixcIktcIl0saW5wdXRUeXBlczp0P1tvLlRleHR1cmVUeXBlLnVucGFja2VkLG8uVGV4dHVyZVR5cGUucGFja2VkTGFzdERpbWVuc2lvbixvLlRleHR1cmVUeXBlLnVucGFja2VkXTpbby5UZXh0dXJlVHlwZS51bnBhY2tlZCxvLlRleHR1cmVUeXBlLnBhY2tlZExhc3REaW1lbnNpb25dLGNhY2hlS2V5OmUuYWN0aXZhdGlvbkNhY2hlS2V5fSkpKGUubGVuZ3RoPjIsdSk7cmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxjKSx7Z2V0OigpPT4oKHQsZSxuLHUsYyk9Pntjb25zdCBsPW5bMF0uZGltcyxwPW5bMV0uZGltcyxmPVtwWzBdLE1hdGguY2VpbChsWzFdKnBbMl0qcFszXS80KV0sZD0oMCxzLmNhbGN1bGF0ZUltMkNvbERpbXMpKGwscCx1KSxbaCxnXT10LmNhbGN1bGF0ZVRleHR1cmVXaWR0aEFuZEhlaWdodChmLG8uVGV4dHVyZVR5cGUucGFja2VkTGFzdERpbWVuc2lvbiksYj1yLlNoYXBlVXRpbC5jb21wdXRlU3RyaWRlcyhkKSxbbSx5XT10LmNhbGN1bGF0ZVRleHR1cmVXaWR0aEFuZEhlaWdodChkLG8uVGV4dHVyZVR5cGUucGFja2VkTGFzdERpbWVuc2lvbiksXz11Lmxlbmd0aCx2PW4ubGVuZ3RoPDM/XCIwLjBcIjpcIl9CKGIpXCIsdz1NYXRoLmNlaWwobFsxXSpwWzJdKnBbM10vNCkse2FjdGl2YXRpb25GdW5jdGlvbjp4LGFwcGx5QWN0aXZhdGlvbjpUfT0oMCxhLmdldEFjdGl2YXRpb25TbmlwcGV0KShjKSxTPSgwLGkuZ2V0R2xzbCkodC5zZXNzaW9uLmJhY2tlbmQuZ2xDb250ZXh0LnZlcnNpb24pLE89YFxcbiR7eH1cXG5mbG9hdCBwcm9jZXNzKGludCBpbmRpY2VzWyR7X31dKSB7XFxuICBpbnQgYlsxXTtcXG4gIGJbMF0gPSBpbmRpY2VzWzFdO1xcbiAgaW50IGltMmNvbFs0XTtcXG4gIGltMmNvbFswXSA9IGluZGljZXNbMF07XFxuICBpbTJjb2xbMV0gPSBpbmRpY2VzWzJdO1xcbiAgaW0yY29sWzJdID0gaW5kaWNlc1szXTtcXG4gIGludCBpbTJjb2xPZmZzZXQgPSBpbTJjb2xbMF0gKiAke2JbMF19ICsgaW0yY29sWzFdICogJHtiWzFdfSArIGltMmNvbFsyXSAqICR7YlsyXX07XFxuICBpbnQga2VybmVsT2Zmc2V0ID0gaW5kaWNlc1sxXSAqICR7ZlsxXX07XFxuICBmbG9hdCB2YWx1ZSA9ICR7dn07XFxuICBmb3IgKGludCBpID0gMDsgaSA8ICR7d307ICsraSkge1xcbiAgICB2ZWMyIGltMmNvbENvb3JkcyA9IG9mZnNldFRvQ29vcmRzKGltMmNvbE9mZnNldCwgJHttfSwgJHt5fSk7XFxuICAgIHZlYzIga2VybmVsQ29vcmRzID0gb2Zmc2V0VG9Db29yZHMoa2VybmVsT2Zmc2V0LCAke2h9LCAke2d9KTtcXG4gICAgdmFsdWUgKz0gZG90KCR7Uy50ZXh0dXJlMkR9KEltMkNvbCwgaW0yY29sQ29vcmRzKSwgJHtTLnRleHR1cmUyRH0oSywga2VybmVsQ29vcmRzKSk7XFxuICAgICsraW0yY29sT2Zmc2V0O1xcbiAgICArK2tlcm5lbE9mZnNldDtcXG4gIH1cXG4gICR7VH1cXG4gIHJldHVybiB2YWx1ZTtcXG59YDtyZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LGUpLHtvdXRwdXQ6e2RpbXM6dSx0eXBlOm5bMF0udHlwZSx0ZXh0dXJlVHlwZTpvLlRleHR1cmVUeXBlLnVucGFja2VkfSxzaGFkZXJTb3VyY2U6T30pfSkodCxjLGUsbix1KX0pfX0sNzk5MjoodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5wYXJzZUZsYXR0ZW5BdHRyaWJ1dGVzPWUuZmxhdHRlbj12b2lkIDA7Y29uc3Qgcj1uKDI1MTcpO2UuZmxhdHRlbj0odCxlLG4pPT57aShlLG4pO2NvbnN0IG89ci5TaGFwZVV0aWwuZmxhdHRlblNoYXBlKGVbMF0uZGltcyxuKTtyZXR1cm5bdC5yZXNoYXBlVW5wYWNrZWQoZVswXSxvKV19LGUucGFyc2VGbGF0dGVuQXR0cmlidXRlcz10PT50LmF0dHJpYnV0ZXMuZ2V0SW50KFwiYXhpc1wiLDEpO2NvbnN0IGk9KHQsZSk9PntpZighdHx8MSE9PXQubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIkZsYXR0ZW4gcmVxdWlyZXMgMSBpbnB1dC5cIik7Y29uc3Qgbj10WzBdLmRpbXMubGVuZ3RoO2lmKDA9PT1uKXRocm93IG5ldyBFcnJvcihcInNjYWxhciB0ZW5zb3IgaXMgbm90IHN1cHBvcnRlZC5cIik7aWYoZTwtbnx8ZT5uKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgYXhpc1wiKTtpZihcInN0cmluZ1wiPT09dFswXS50eXBlKXRocm93IG5ldyBFcnJvcihcInN0cmluZyB0ZW5zb3IgaXMgbm90IHN1cHBvcnRlZC5cIil9fSwyODIzOih0LGUsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLnBhcnNlSW50ZXJuYWxBY3RpdmF0aW9uQXR0cmlidXRlcz1lLmdldEFjdGl2YXRpb25TbmlwcGV0PXZvaWQgMDtjb25zdCByPW4oMjUxNyksaT1uKDQ5MDkpO2UuZ2V0QWN0aXZhdGlvblNuaXBwZXQ9ZnVuY3Rpb24odCl7bGV0IGU7c3dpdGNoKHQuYWN0aXZhdGlvbil7Y2FzZVwiUmVsdVwiOmU9KDAsaS5nbHNsUmVsdSkoKTticmVhaztjYXNlXCJTaWdtb2lkXCI6ZT0oMCxpLmdsc2xTaWdtb2lkKSgpO2JyZWFrO2Nhc2VcIkNsaXBcIjplPSgwLGkuZ2xzbENsaXApKHQuY2xpcE1pbix0LmNsaXBNYXgpO2JyZWFrO2RlZmF1bHQ6cmV0dXJue2FjdGl2YXRpb25GdW5jdGlvbjpcIlwiLGFwcGx5QWN0aXZhdGlvbjpcIlwifX1jb25zdCBuPWUubmFtZTtyZXR1cm57YWN0aXZhdGlvbkZ1bmN0aW9uOmUuYm9keSxhcHBseUFjdGl2YXRpb246YHZhbHVlID0gJHtufV8odmFsdWUpO2B9fSxlLnBhcnNlSW50ZXJuYWxBY3RpdmF0aW9uQXR0cmlidXRlcz10PT57Y29uc3QgZT10LmdldFN0cmluZyhcImFjdGl2YXRpb25cIixcIlwiKTtpZihcIkNsaXBcIj09PWUpe2NvbnN0W24saV09dC5nZXRGbG9hdHMoXCJhY3RpdmF0aW9uX3BhcmFtc1wiLFtyLk1JTl9DTElQLHIuTUFYX0NMSVBdKTtyZXR1cm57YWN0aXZhdGlvbjplLGNsaXBNYXg6aSxjbGlwTWluOm4sYWN0aXZhdGlvbkNhY2hlS2V5OmAke2V9OiR7bn0sJHtpfWB9fXJldHVybnthY3RpdmF0aW9uOmUsYWN0aXZhdGlvbkNhY2hlS2V5OmV9fX0sMTI1MzoodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5wYXJzZUdhdGhlckF0dHJpYnV0ZXM9ZS5nYXRoZXI9dm9pZCAwO2NvbnN0IHI9bigyNDYpLGk9big3ODIpLG89bigyNTE3KSxhPW4oMjAzOSk7ZS5nYXRoZXI9KHQsZSxuKT0+KGMoZSxuLmF4aXMpLFt0LnJ1bih1KHQsZSxuKSxlKV0pLGUucGFyc2VHYXRoZXJBdHRyaWJ1dGVzPXQ9PigwLHIuY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KSh7YXhpczp0LmF0dHJpYnV0ZXMuZ2V0SW50KFwiYXhpc1wiLDApfSk7Y29uc3Qgcz17bmFtZTpcIkdhdGhlclwiLGlucHV0TmFtZXM6W1wiQVwiLFwiQlwiXSxpbnB1dFR5cGVzOlthLlRleHR1cmVUeXBlLnVucGFja2VkLGEuVGV4dHVyZVR5cGUudW5wYWNrZWRdfSx1PSh0LGUsbik9Pntjb25zdCByPU9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxzKSx7Y2FjaGVIaW50Om4uY2FjaGVLZXl9KTtyZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LHIpLHtnZXQ6KCk9PigodCxlLG4scik9Pntjb25zdCBpPW5bMF0uZGltcy5zbGljZSgpLHM9blsxXS5kaW1zLnNsaWNlKCksdT1uZXcgQXJyYXkoaS5sZW5ndGgrcy5sZW5ndGgtMSk7cj1vLlNoYXBlVXRpbC5ub3JtYWxpemVBeGlzKHIsaS5sZW5ndGgpO2NvbnN0IGM9W107Zm9yKGxldCB0PTA7dDx1Lmxlbmd0aDt0KyspdDxyPyh1W3RdPWlbdF0sYy5wdXNoKGBpbnB1dElkeFske3R9XSA9IG91dHB1dElkeFske3R9XTtgKSk6dDxyK3MubGVuZ3RoPyh1W3RdPXNbdC1yXSxjLnB1c2goYGluZGV4RGF0YUlkeFske3Qtcn1dID0gb3V0cHV0SWR4WyR7dH1dO2ApKToodVt0XT1pW3Qtcy5sZW5ndGgrMV0sYy5wdXNoKGBpbnB1dElkeFske3Qtcy5sZW5ndGgrMX1dID0gb3V0cHV0SWR4WyR7dH1dO2ApKTtjb25zdCBsPWBcXG4gICAgICBmbG9hdCBwcm9jZXNzKGludCBvdXRwdXRJZHhbJHt1Lmxlbmd0aHx8MX1dKSB7XFxuICAgICAgICBpbnQgaW5wdXRJZHhbJHtpLmxlbmd0aH1dO1xcbiAgICAgICAgaW50IGluZGV4RGF0YUlkeFske3MubGVuZ3RofHwxfV07XFxuICAgICAgICBpbmRleERhdGFJZHhbMF0gPSAwO1xcbiAgICAgICAgJHtjLmpvaW4oXCJcXG4gICAgICAgIFwiKX1cXG4gICAgICAgIGludCBpZHggPSBpbnQoX0IoaW5kZXhEYXRhSWR4KSk7XFxuICAgICAgICBpbnB1dElkeFske3J9XSA9IGlkeCA8IDAgPyBpZHggKyAke2lbcl19IDogaWR4O1xcbiAgICAgICAgcmV0dXJuIF9BKGlucHV0SWR4KTtcXG4gICAgICB9YDtyZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LGUpLHtvdXRwdXQ6e2RpbXM6dSx0eXBlOm5bMF0udHlwZSx0ZXh0dXJlVHlwZTphLlRleHR1cmVUeXBlLnVucGFja2VkfSxzaGFkZXJTb3VyY2U6bH0pfSkoMCxyLGUsbi5heGlzKX0pfSxjPSh0LGUpPT57aWYoIXR8fDIhPT10Lmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJHYXRoZXIgcmVxdWlyZXMgMiBpbnB1dHMuXCIpO2NvbnN0IG49dFswXS5kaW1zLmxlbmd0aDtpZihuPDEpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbnB1dCBzaGFwZS5cIik7aWYoZTwtbnx8ZT5uLTEpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBheGlzLlwiKTtpZigtMT09PWkuTlVNQkVSX1RZUEVTLmluZGV4T2YodFswXS50eXBlKSl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhaWQgaW5wdXQgdHlwZS5cIik7aWYoXCJpbnQzMlwiIT09dFsxXS50eXBlJiZcImludDE2XCIhPT10WzFdLnR5cGUpdGhyb3cgbmV3IEVycm9yKFwiSW52YWlkIGlucHV0IHR5cGUuXCIpfX0sNDc3NjoodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5wYXJzZUdlbW1BdHRyaWJ1dGVzVjExPWUucGFyc2VHZW1tQXR0cmlidXRlc1Y3PWUuZ2VtbT12b2lkIDA7Y29uc3Qgcj1uKDI0NiksaT1uKDI1MTcpLG89bigyMDM5KTtlLmdlbW09KHQsZSxuKT0+KGMoZSxuKSxbdC5ydW4ocyhlLG4pLGUpXSk7Y29uc3QgYT0odCxlKT0+e2NvbnN0IG49MCE9PXQuYXR0cmlidXRlcy5nZXRJbnQoXCJ0cmFuc0FcIiwwKSxpPTAhPT10LmF0dHJpYnV0ZXMuZ2V0SW50KFwidHJhbnNCXCIsMCksbz10LmF0dHJpYnV0ZXMuZ2V0RmxvYXQoXCJhbHBoYVwiLDEpLGE9dC5hdHRyaWJ1dGVzLmdldEZsb2F0KFwiYmV0YVwiLDEpO3JldHVybigwLHIuY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KSh7dHJhbnNBOm4sdHJhbnNCOmksYWxwaGE6byxiZXRhOmEsaXNPcHRpb25hbEM6ZX0pfTtlLnBhcnNlR2VtbUF0dHJpYnV0ZXNWNz10PT5hKHQsITEpLGUucGFyc2VHZW1tQXR0cmlidXRlc1YxMT10PT5hKHQsITApO2NvbnN0IHM9KHQsZSk9Pntjb25zdCBuPXtuYW1lOlwiR2VtbVwiLGlucHV0TmFtZXM6Mz09PXQubGVuZ3RoP1tcIkFcIixcIkJcIixcIkNcIl06W1wiQVwiLFwiQlwiXSxpbnB1dFR5cGVzOjM9PT10Lmxlbmd0aD9bby5UZXh0dXJlVHlwZS51bnBhY2tlZCxvLlRleHR1cmVUeXBlLnVucGFja2VkLG8uVGV4dHVyZVR5cGUudW5wYWNrZWRdOltvLlRleHR1cmVUeXBlLnVucGFja2VkLG8uVGV4dHVyZVR5cGUudW5wYWNrZWRdLGtleTplLmNhY2hlS2V5fTtyZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LG4pLHtnZXQ6KCk9PnUobix0LGUpfSl9LHU9KHQsZSxuKT0+e2NvbnN0IHI9ZVswXS5kaW1zLnNsaWNlKCksYT1lWzFdLmRpbXMuc2xpY2UoKSxbcyx1XT1pLkdlbW1VdGlsLmdldFNoYXBlT2ZHZW1tUmVzdWx0KHIsbi50cmFuc0EsYSxuLnRyYW5zQiwzPT09ZS5sZW5ndGg/ZVsyXS5kaW1zOnZvaWQgMCksYz1bcyx1XTtpZighYyl0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCB1c2UgZ2VtbSBvbiB0aGUgZ2l2ZW4gdGVuc29yc1wiKTtsZXQgbD1yW3IubGVuZ3RoLTFdLHA9XCJcIjtuLnRyYW5zQSYmKGw9clswXSksbi50cmFuc0EmJm4udHJhbnNCP3A9XCJ2YWx1ZSArPSBfQV9UKGEpICogX0JfVChiKTtcIjpuLnRyYW5zQSYmIW4udHJhbnNCP3A9XCJ2YWx1ZSArPSBfQV9UKGEpICogX0IoYik7XCI6IW4udHJhbnNBJiZuLnRyYW5zQj9wPVwidmFsdWUgKz0gX0EoYSkgKiBfQl9UKGIpO1wiOm4udHJhbnNBfHxuLnRyYW5zQnx8KHA9XCJ2YWx1ZSArPSBfQShhKSAqIF9CKGIpO1wiKTtjb25zdCBmPWMubGVuZ3RoLGQ9YFxcbiAgICAgIGZsb2F0IHByb2Nlc3MoaW50IGluZGljZXNbJHtmfV0pIHtcXG4gICAgICAgICAgaW50IGFbJHtmfV07XFxuICAgICAgICAgIGludCBiWyR7Zn1dO1xcbiAgICAgICAgICAkezM9PT1lLmxlbmd0aD9gaW50IGNbJHtlWzJdLmRpbXMubGVuZ3RofV07YDpcIlwifVxcblxcbiAgICAgICAgICBjb3B5VmVjKGluZGljZXMsIGEpO1xcbiAgICAgICAgICBjb3B5VmVjKGluZGljZXMsIGIpO1xcbiAgICAgICAgICAkezM9PT1lLmxlbmd0aD9cImJjYXN0SW5kaWNlc19DKGluZGljZXMsIGMpO1wiOlwiXCJ9XFxuXFxuICAgICAgICAgIGZsb2F0IHZhbHVlID0gMC4wO1xcbiAgICAgICAgICBmb3IgKGludCBrPTA7IGs8JHtsfTsgKytrKSB7XFxuICAgICAgICAgICAgICBhWyR7Zi0xfV0gPSBrO1xcbiAgICAgICAgICAgICAgYlske2YtMn1dID0gaztcXG4gICAgICAgICAgICAgICR7cH1cXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICB2YWx1ZSA9IHZhbHVlICogYWxwaGE7XFxuICAgICAgICAgICR7Mz09PWUubGVuZ3RoP1widmFsdWUgKz0gYmV0YSAqIF9DKGMpO1wiOlwiXCJ9XFxuICAgICAgICAgIHJldHVybiB2YWx1ZTtcXG4gICAgICB9YDtyZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LHQpLHtvdXRwdXQ6e2RpbXM6Yyx0eXBlOmVbMF0udHlwZSx0ZXh0dXJlVHlwZTpvLlRleHR1cmVUeXBlLnVucGFja2VkfSx2YXJpYWJsZXM6W3tuYW1lOlwiYWxwaGFcIix0eXBlOlwiZmxvYXRcIixkYXRhOm4uYWxwaGF9LHtuYW1lOlwiYmV0YVwiLHR5cGU6XCJmbG9hdFwiLGRhdGE6bi5iZXRhfV0sc2hhZGVyU291cmNlOmR9KX0sYz0odCxlKT0+e2lmKCF0KXRocm93IG5ldyBFcnJvcihcIklucHV0IGlzIG1pc3NpbmdcIik7aWYoZS5pc09wdGlvbmFsQyYmKHQubGVuZ3RoPDJ8fHQubGVuZ3RoPjMpKXRocm93IG5ldyBFcnJvcihcIkludmFpZCBpbnB1dCBzaGFwZS5cIik7aWYoIWUuaXNPcHRpb25hbEMmJjMhPT10Lmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJHZW1tIHJlcXVpcmVzIDMgaW5wdXRzXCIpO2lmKDM9PT10Lmxlbmd0aCYmMSE9PXRbMl0uZGltcy5sZW5ndGgmJjIhPT10WzJdLmRpbXMubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW5wdXQgc2hhcGUgb2YgQ1wiKTtpZihcImZsb2F0MzJcIiE9PXRbMF0udHlwZSYmXCJmbG9hdDY0XCIhPT10WzBdLnR5cGV8fFwiZmxvYXQzMlwiIT09dFsxXS50eXBlJiZcImZsb2F0NjRcIiE9PXRbMV0udHlwZXx8Mz09PXQubGVuZ3RoJiZcImZsb2F0MzJcIiE9PXRbMl0udHlwZSYmXCJmbG9hdDY0XCIhPT10WzJdLnR5cGUpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbnB1dCB0eXBlLlwiKTtpZih0WzBdLnR5cGUhPT10WzFdLnR5cGV8fDM9PT10Lmxlbmd0aCYmdFswXS50eXBlIT09dFsyXS50eXBlKXRocm93IG5ldyBFcnJvcihcIklucHV0IHR5cGVzIGFyZSBtaXNtYXRjaGVkXCIpfX0sODU1NToodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5jcmVhdGVQYWNrZWRJbTJDb2xQcm9ncmFtSW5mb0xvYWRlcj12b2lkIDA7Y29uc3Qgcj1uKDUwNjApLGk9bigyMDM5KSxvPW4oMjgyNyk7ZS5jcmVhdGVQYWNrZWRJbTJDb2xQcm9ncmFtSW5mb0xvYWRlcj0odCxlLG4sYSxzKT0+e2NvbnN0IHU9KGM9cy5jYWNoZUtleSx7bmFtZTpcIkltMkNvbCAocGFja2VkKVwiLGlucHV0TmFtZXM6W1wiQVwiXSxpbnB1dFR5cGVzOltpLlRleHR1cmVUeXBlLnBhY2tlZF0sY2FjaGVIaW50OmN9KTt2YXIgYztyZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LHUpLHtnZXQ6KCk9PigodCxlLG4sYSxzLHUpPT57Y29uc3QgYz1uLmRpbXMsbD1hLmRpbXMscD1zLmxlbmd0aCxmPVtsWzFdKmxbMl0qbFszXSxzWzJdKnNbM11dLGQ9bFsyXSpsWzNdLGg9KDAsby51bnBhY2tGcm9tQ2hhbm5lbCkoKSxnPSgwLHIuZ2V0R2xzbCkodC5zZXNzaW9uLmJhY2tlbmQuZ2xDb250ZXh0LnZlcnNpb24pO2xldCBiPVwiXCI7Zm9yKGxldCB0PTA7dDw9MTt0KyspZm9yKGxldCBlPTA7ZTw9MTtlKyspYis9YFxcbiAgICAgICAgICAgIGJsb2NrSW5kZXggPSByYy54ICsgJHtlfTtcXG4gICAgICAgICAgICBwb3MgPSByYy55ICsgJHt0fTtcXG5cXG4gICAgICAgICAgICBpZihibG9ja0luZGV4IDwgJHtmWzFdfSAmJiBwb3MgPCAke2ZbMF19KSB7XFxuICAgICAgICAgICAgICBvZmZzZXRZID0gaW50KGJsb2NrSW5kZXggLyAoJHtzW3AtMV19KSkgKiAke3Uuc3RyaWRlc1swXX0gLVxcbiAgICAgICAgICAgICAgICAke3UucGFkc1swXX07XFxuICAgICAgICAgICAgICBkMCA9IG9mZnNldFkgKyAke3UuZGlsYXRpb25zWzBdfSAqIChpbW9kKHBvcywgJHtkfSkgLyAke2xbMl19KTtcXG5cXG4gICAgICAgICAgICAgIGlmKGQwIDwgJHtjWzJdfSAmJiBkMCA+PSAwKSB7XFxuICAgICAgICAgICAgICAgIG9mZnNldFggPSBpbW9kKGJsb2NrSW5kZXgsICR7c1twLTFdfSkgKiAke3Uuc3RyaWRlc1sxXX0gLVxcbiAgICAgICAgICAgICAgICAgICR7dS5wYWRzWzFdfTtcXG4gICAgICAgICAgICAgICAgZDEgPSBvZmZzZXRYICsgJHt1LmRpbGF0aW9uc1sxXX0gKiBpbW9kKGltb2QocG9zLCAke2R9KSwgJHtsWzJdfSk7XFxuXFxuICAgICAgICAgICAgICAgIGlmKGQxIDwgJHtjWzNdfSAmJiBkMSA+PSAwKSB7XFxuXFxuICAgICAgICAgICAgICAgICAgY2ggPSBpbnQoZmxvYXQocG9zKS8gJHtkfS4pO1xcbiAgICAgICAgICAgICAgICAgICAgaW5uZXJEaW1zID0gdmVjMihkMCwgZDEpO1xcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0WyR7Mip0K2V9XSA9IGdldENoYW5uZWwoXFxuICAgICAgICAgICAgICAgICAgICAgIGdldEEoMCwgY2gsIGludChpbm5lckRpbXMueCksXFxuICAgICAgICAgICAgICAgICAgICAgIGludChpbm5lckRpbXMueSkpLCBpbm5lckRpbXMpO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICBgO2NvbnN0IG09YFxcbiAgICAgICR7aH1cXG5cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpdmVjMiByYyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgICB2ZWM0IHJlc3VsdCA9IHZlYzQoMC4wKTtcXG4gICAgICAgICAgaW50IGJsb2NrSW5kZXgsIHBvcywgb2Zmc2V0WSwgZDAsIG9mZnNldFgsIGQxLCBjaDtcXG4gICAgICAgICAgdmVjMiBpbm5lckRpbXM7XFxuICAgICAgICAgICR7Yn1cXG4gICAgICAgICAgJHtnLm91dHB1dH0gPSByZXN1bHQ7XFxuICAgICAgfVxcbiAgICAgICAgICAgIGA7cmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxlKSx7b3V0cHV0OntkaW1zOmYsdHlwZTpuLnR5cGUsdGV4dHVyZVR5cGU6aS5UZXh0dXJlVHlwZS5wYWNrZWR9LHNoYWRlclNvdXJjZTptLGhhc01haW46ITB9KX0pKHQsdSxlLG4sYSxzKX0pfX0sMzI0ODoodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5jYWxjdWxhdGVJbTJDb2xEaW1zPWUuY3JlYXRlSW0yQ29sUHJvZ3JhbUluZm9Mb2FkZXI9dm9pZCAwO2NvbnN0IHI9bigyMDM5KTtlLmNyZWF0ZUltMkNvbFByb2dyYW1JbmZvTG9hZGVyPSh0LG4saSxvLGEpPT57Y29uc3Qgcz0odT1hLmNhY2hlS2V5LHtuYW1lOlwiSW0yQ29sXCIsaW5wdXROYW1lczpbXCJYXCJdLGlucHV0VHlwZXM6W3IuVGV4dHVyZVR5cGUudW5wYWNrZWRdLGNhY2hlSGludDp1fSk7dmFyIHU7cmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxzKSx7Z2V0OigpPT4oKHQsbixpLG8sYSxzKT0+e2NvbnN0IHU9aS5kaW1zLGM9by5kaW1zLGw9YS5sZW5ndGgscD0oMCxlLmNhbGN1bGF0ZUltMkNvbERpbXMpKHUsYyxhLDQpLGY9YFxcbiAgICAgICAgY29uc3QgaW50IFhDID0gJHt1WzFdfTtcXG4gICAgICAgIGNvbnN0IGludCBYSCA9ICR7dVsyXX07XFxuICAgICAgICBjb25zdCBpbnQgWFcgPSAke3VbM119O1xcbiAgICAgICAgY29uc3QgaW50IEtIID0gJHtzLmtlcm5lbFNoYXBlWzBdfTtcXG4gICAgICAgIGNvbnN0IGludCBLVyA9ICR7cy5rZXJuZWxTaGFwZVsxXX07XFxuICAgICAgICBjb25zdCBpbnQgZGlsYXRpb25IID0gJHtzLmRpbGF0aW9uc1swXX07XFxuICAgICAgICBjb25zdCBpbnQgZGlsYXRpb25XID0gJHtzLmRpbGF0aW9uc1sxXX07XFxuICAgICAgICBjb25zdCBpbnQgc3RyaWRlSCA9ICR7cy5zdHJpZGVzWzBdfTtcXG4gICAgICAgIGNvbnN0IGludCBzdHJpZGVXID0gJHtzLnN0cmlkZXNbMV19O1xcbiAgICAgICAgY29uc3QgaW50IHBhZEggPSAke3MucGFkc1swXX07XFxuICAgICAgICBjb25zdCBpbnQgcGFkVyA9ICR7cy5wYWRzWzFdfTtcXG4gICAgICAgIGNvbnN0IGludCBLSEtXID0gS0gqS1c7XFxuICAgICAgICBjb25zdCBpbnQgWENLSEtXID0gWEMgKiBLSEtXO1xcbiAgICAgICAgY29uc3QgaW50IG91dHB1dENoYW5uZWxzID0gNDtcXG4gICAgICAgIHZlYzQgcHJvY2VzcyhpbnQgaW5kaWNlc1ske2x9XSkge1xcbiAgICAgICAgICBpbnQgYiAgPSBpbmRpY2VzWzBdOyAvLyBiYXRjaCBzaXplXFxuICAgICAgICAgIGludCBvaCA9IGluZGljZXNbMV0gKiBzdHJpZGVIIC0gcGFkSDsgLy9vdXRwdXQgaGVpZ2h0XFxuICAgICAgICAgIGludCBvdyA9IGluZGljZXNbMl0gKiBzdHJpZGVXIC0gcGFkVzsgLy9vdXRwdXQgd2lkdGhcXG4gICAgICAgICAgaW50IHAgPSBpbmRpY2VzWzNdICogb3V0cHV0Q2hhbm5lbHM7IC8vcGF0Y2hcXG4gICAgICAgICAgdmVjNCB2YWx1ZSA9IHZlYzQoMC4wKTtcXG4gICAgICAgICAgZm9yKGludCBpPTA7IGkgPCBvdXRwdXRDaGFubmVsczsgKytpKSB7XFxuICAgICAgICAgICAgaWYocCA8IFhDS0hLVykge1xcbiAgICAgICAgICAgICAgaW50IHBhdGNoQyA9IHAgLyBLSEtXO1xcbiAgICAgICAgICAgICAgaW50IHBhdGNoSCA9IChwIC0gcGF0Y2hDKktIS1cpIC8gS1c7XFxuICAgICAgICAgICAgICBpbnQgcGF0Y2hXID0gKHAgLSBwYXRjaEMqS0hLVykgLSBwYXRjaEggKiBLVztcXG4gICAgICAgICAgICAgIGludCB4aDIgPSBvaCArIHBhdGNoSCAqIGRpbGF0aW9uSDtcXG4gICAgICAgICAgICAgIGludCB4dzIgPSBvdyArIHBhdGNoVyAqIGRpbGF0aW9uVztcXG4gICAgICAgICAgICAgIGludCB4WyR7dS5sZW5ndGh9XTtcXG4gICAgICAgICAgICAgIHhbMF0gPSBiO1xcbiAgICAgICAgICAgICAgeFsxXSA9IHBhdGNoQztcXG4gICAgICAgICAgICAgIHhbMl0gPSB4aDI7XFxuICAgICAgICAgICAgICB4WzNdID0geHcyO1xcbiAgICAgICAgICAgICAgaWYoeGgyID49IDAgJiZcXG4gICAgICAgICAgICAgICAgICB4aDIgPCBYSCAmJlxcbiAgICAgICAgICAgICAgICAgIHh3MiA+PSAwICYmXFxuICAgICAgICAgICAgICAgICAgeHcyIDwgWFcpIHtcXG4gICAgICAgICAgICAgICAgdmFsdWVbaV0gPSBfWCh4KTtcXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgKytwO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIHJldHVybiB2YWx1ZTtcXG4gICAgICAgIH1cXG4gICAgICAgIGA7cmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxuKSx7b3V0cHV0OntkaW1zOnAsdHlwZTppLnR5cGUsdGV4dHVyZVR5cGU6ci5UZXh0dXJlVHlwZS5wYWNrZWRMYXN0RGltZW5zaW9ufSxzaGFkZXJTb3VyY2U6Zn0pfSkoMCxzLG4saSxvLGEpfSl9LGUuY2FsY3VsYXRlSW0yQ29sRGltcz0odCxlLG4scj00KT0+W25bMF0sblsyXSxuWzNdLE1hdGguY2VpbCh0WzFdKmVbMl0qZVszXS9yKV19LDY1NzI6KHQsZSxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUucGFyc2VJbWFnZVNjYWxlckF0dHJpYnV0ZXM9ZS5pbWFnZVNjYWxlcj12b2lkIDA7Y29uc3Qgcj1uKDI0NiksaT1uKDIwMzkpO2UuaW1hZ2VTY2FsZXI9KHQsZSxuKT0+KHUoZSksW3QucnVuKGEodCxlLG4pLGUpXSksZS5wYXJzZUltYWdlU2NhbGVyQXR0cmlidXRlcz10PT57Y29uc3QgZT10LmF0dHJpYnV0ZXMuZ2V0RmxvYXQoXCJzY2FsZVwiKSxuPXQuYXR0cmlidXRlcy5nZXRGbG9hdHMoXCJiaWFzXCIpO3JldHVybigwLHIuY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KSh7c2NhbGU6ZSxiaWFzOm59KX07Y29uc3Qgbz17bmFtZTpcIkltYWdlU2NhbGVyXCIsaW5wdXROYW1lczpbXCJYXCJdLGlucHV0VHlwZXM6W2kuVGV4dHVyZVR5cGUudW5wYWNrZWRdfSxhPSh0LGUsbik9Pntjb25zdCByPU9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxvKSx7Y2FjaGVIaW50Om4uY2FjaGVLZXl9KTtyZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LHIpLHtnZXQ6KCk9PigodCxlLG4scik9Pntjb25zdCBvPW5bMF0uZGltcy5zbGljZSgpLGE9by5sZW5ndGgsdT1gXFxuICAgICAgJHtzKHIuYmlhcy5sZW5ndGgpfVxcbiAgICAgIGZsb2F0IHByb2Nlc3MoaW50IGluZGljZXNbJHthfV0pIHtcXG4gICAgICAgIHJldHVybiBfWChpbmRpY2VzKSAqIHNjYWxlICsgZ2V0QmlhcyhiaWFzLCBpbmRpY2VzWzFdKTtcXG4gICAgICB9YDtyZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LGUpLHtvdXRwdXQ6e2RpbXM6byx0eXBlOm5bMF0udHlwZSx0ZXh0dXJlVHlwZTppLlRleHR1cmVUeXBlLnVucGFja2VkfSx2YXJpYWJsZXM6W3tuYW1lOlwiYmlhc1wiLHR5cGU6XCJmbG9hdFwiLGFycmF5TGVuZ3RoOnIuYmlhcy5sZW5ndGgsZGF0YTpyLmJpYXN9LHtuYW1lOlwic2NhbGVcIix0eXBlOlwiZmxvYXRcIixkYXRhOnIuc2NhbGV9XSxzaGFkZXJTb3VyY2U6dX0pfSkoMCxyLGUsbil9KX0scz10PT57Y29uc3QgZT1bYGZsb2F0IGdldEJpYXMoZmxvYXQgYmlhc1ske3R9XSwgaW50IGNoYW5uZWwpIHtgXTtmb3IobGV0IG49MDtuPHQ7KytuKTA9PT1uP2UucHVzaChgXFx0aWYgKGNoYW5uZWwgPT0gJHtufSkgeyByZXR1cm4gYmlhc1ske259XTsgfWApOm49PT10LTE/ZS5wdXNoKGBcXHRlbHNlIHsgcmV0dXJuIGJpYXNbJHtufV07IH1gKTplLnB1c2goYFxcdGVsc2UgaWYgKGNoYW5uZWwgPT0gJHtufSkgeyByZXR1cm4gYmlhc1ske259XTsgfWApO3JldHVybiBlLnB1c2goXCJcXHR9XCIpLGUuam9pbihcIlxcblwiKX0sdT10PT57aWYoIXR8fDEhPT10Lmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJJbWFnZVNjYWxlciByZXF1aXJlcyAxIGlucHV0LlwiKTtpZig0IT09dFswXS5kaW1zLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGlucHV0IHNoYXBlLlwiKTtpZihcImZsb2F0MzJcIiE9PXRbMF0udHlwZSYmXCJmbG9hdDY0XCIhPT10WzBdLnR5cGUpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbnB1dCB0eXBlLlwiKX19LDMzNDY6KHQsZSxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUucGFyc2VJbnN0YW5jZU5vcm1hbGl6YXRpb25BdHRyaWJ1dGVzPWUuaW5zdGFuY2VOb3JtYWxpemF0aW9uPXZvaWQgMDtjb25zdCByPW4oNTA2MCksaT1uKDIwMzkpO2UuaW5zdGFuY2VOb3JtYWxpemF0aW9uPSh0LGUsbik9PntjKGUpO2NvbnN0IHI9dC5ydW4oYShlWzBdKSxlKTtyZXR1cm5bdC5ydW4odSh0LGVbMF0sbixyLmRpbXMpLFtlWzBdLHIsZVsxXSxlWzJdXSldfSxlLnBhcnNlSW5zdGFuY2VOb3JtYWxpemF0aW9uQXR0cmlidXRlcz10PT50LmF0dHJpYnV0ZXMuZ2V0RmxvYXQoXCJlcHNpbG9uXCIsMWUtNSk7Y29uc3Qgbz17bmFtZTpcIkluc3RhbmNlTm9ybWFsaXphdGlvbl9NZWFuQW5kVmFyaWFuY2VcIixpbnB1dE5hbWVzOltcIlhcIl0saW5wdXRUeXBlczpbaS5UZXh0dXJlVHlwZS51bnBhY2tlZF19LGE9dD0+T2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LG8pLHtnZXQ6KCk9PigodCxlKT0+e2NvbnN0IG49ZS5kaW1zLnNsaWNlKCkscj1uWzFdLG89blsyXSpuWzNdLGE9W25bMF0scl0scz1gXFxuICAgICAgdmVjNCBwcm9jZXNzKGludFsyXSBpbmRpY2VzKSB7XFxuICAgICAgICB2ZWM0IHYgPSB2ZWM0KDAuMCk7XFxuICAgICAgICBpbnQgYVs0XTtcXG4gICAgICAgIGFbMF0gPSBpbmRpY2VzWzBdO1xcbiAgICAgICAgYVsxXSA9IGluZGljZXNbMV07XFxuICAgICAgICBmbG9hdCB0ZW1wID0gMC4wO1xcbiAgICAgICAgZm9yKGludCBhMj0wOyBhMjwke25bMl19OyBhMisrKSB7XFxuICAgICAgICAgIGFbMl0gPSBhMjtcXG4gICAgICAgICAgZm9yKGludCBhMz0wOyBhMzwke25bM119OyBhMysrKSB7XFxuICAgICAgICAgICAgYVszXSA9IGEzO1xcbiAgICAgICAgICAgIGZsb2F0IHggPSBfWChhKTtcXG4gICAgICAgICAgICB0ZW1wICs9IHg7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIGZsb2F0IG1lYW4gPSB0ZW1wIC8gZmxvYXQoJHtvfSk7XFxuICAgICAgICB0ZW1wID0gMC4wO1xcbiAgICAgICAgZm9yKGludCBhMj0wOyBhMjwke25bMl19OyBhMisrKSB7XFxuICAgICAgICAgIGFbMl0gPSBhMjtcXG4gICAgICAgICAgZm9yKGludCBhMz0wOyBhMzwke25bM119OyBhMysrKSB7XFxuICAgICAgICAgICAgYVszXSA9IGEzO1xcbiAgICAgICAgICAgIGZsb2F0IHggPSBfWChhKTtcXG4gICAgICAgICAgICB0ZW1wICs9ICh4IC0gbWVhbikgKiAoeCAtIG1lYW4pO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICB2LnIgPSBtZWFuO1xcbiAgICAgICAgdi5nID0gdGVtcCAvIGZsb2F0KCR7b30pO1xcblxcbiAgICAgICAgcmV0dXJuIHY7XFxuICAgICAgfWA7cmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSx0KSx7b3V0cHV0OntkaW1zOmEsdHlwZTplLnR5cGUsdGV4dHVyZVR5cGU6aS5UZXh0dXJlVHlwZS5wYWNrZWRMYXN0RGltZW5zaW9ufSxzaGFkZXJTb3VyY2U6c30pfSkobyx0KX0pLHM9e25hbWU6XCJJbnN0YW5jZU5vcm1hbGl6YXRpb25fQ29tcHV0ZU91dHB1dFwiLGlucHV0TmFtZXM6W1wiWFwiLFwiTWVhbkFuZFZhcmlhbmNlXCIsXCJTY2FsZVwiLFwiQlwiXSxpbnB1dFR5cGVzOltpLlRleHR1cmVUeXBlLnVucGFja2VkLGkuVGV4dHVyZVR5cGUucGFja2VkTGFzdERpbWVuc2lvbixpLlRleHR1cmVUeXBlLnVucGFja2VkLGkuVGV4dHVyZVR5cGUudW5wYWNrZWRdfSx1PSh0LGUsbixvKT0+e2NvbnN0IGE9T2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LHMpLHtjYWNoZUhpbnQ6YCR7bn1gfSk7cmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxhKSx7Z2V0OigpPT4oKHQsZSxuLG8sYSk9Pntjb25zdCBzPSgwLHIuZ2V0R2xzbCkodC5zZXNzaW9uLmJhY2tlbmQuZ2xDb250ZXh0LnZlcnNpb24pLFt1LGNdPXQuY2FsY3VsYXRlVGV4dHVyZVdpZHRoQW5kSGVpZ2h0KGEsaS5UZXh0dXJlVHlwZS5wYWNrZWRMYXN0RGltZW5zaW9uKSxbbCxwXT1bdS80LGNdLGY9YFxcbiAgICAgIHZlYzQgZ2V0X01lYW5BbmRWYXJpYW5jZShpbnRbMl0gbXYpIHtcXG4gICAgICAgIGludCBvZmZzZXQgPSBpbmRpY2VzVG9PZmZzZXRfTWVhbkFuZFZhcmlhbmNlKG12KTtcXG4gICAgICAgIHZlYzIgY29vcmRzID0gb2Zmc2V0VG9Db29yZHMob2Zmc2V0LCAke2x9LCAke3B9KTtcXG4gICAgICAgIHJldHVybiAke3MudGV4dHVyZTJEfShNZWFuQW5kVmFyaWFuY2UsIGNvb3Jkcyk7XFxuICAgICAgfVxcblxcbiAgICAgIGZsb2F0IHByb2Nlc3MoaW50WzRdIGluZGljZXMpIHtcXG4gICAgICAgIGludCBtdlsyXTtcXG4gICAgICAgIG12WzBdID0gaW5kaWNlc1swXTtcXG4gICAgICAgIG12WzFdID0gaW5kaWNlc1sxXTtcXG4gICAgICAgIHZlYzQgbWVhbl9hbmRfdmFyaWFuY2UgPSBnZXRfTWVhbkFuZFZhcmlhbmNlKG12KTtcXG4gICAgICAgIGZsb2F0IG1lYW4gPSBtZWFuX2FuZF92YXJpYW5jZS5yO1xcbiAgICAgICAgZmxvYXQgdmFyaWFuY2UgPSBtZWFuX2FuZF92YXJpYW5jZS5nO1xcblxcbiAgICAgICAgaW50IHNiWzFdO1xcbiAgICAgICAgc2JbMF0gPSBpbmRpY2VzWzFdO1xcbiAgICAgICAgZmxvYXQgc2NhbGUgPSBfU2NhbGUoc2IpO1xcbiAgICAgICAgZmxvYXQgYiA9IF9CKHNiKTtcXG5cXG4gICAgICAgIHJldHVybiBzY2FsZSAqIChfWChpbmRpY2VzKSAtIG1lYW4pIC8gc3FydCh2YXJpYW5jZSArIGVwc2lsb24pICsgYjtcXG4gICAgICB9YDtyZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LGUpLHtvdXRwdXQ6e2RpbXM6bi5kaW1zLHR5cGU6bi50eXBlLHRleHR1cmVUeXBlOmkuVGV4dHVyZVR5cGUudW5wYWNrZWR9LHZhcmlhYmxlczpbe25hbWU6XCJlcHNpbG9uXCIsdHlwZTpcImZsb2F0XCIsZGF0YTpvfV0sc2hhZGVyU291cmNlOmZ9KX0pKHQsYSxlLG4sbyl9KX0sYz10PT57aWYoIXR8fDMhPT10Lmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJJbnN0YW5jZU5vcm1hbGl6YXRpb24gcmVxdWlyZXMgMyBpbnB1dHMuXCIpO2NvbnN0IGU9dFswXSxuPXRbMV0scj10WzJdO2lmKGUuZGltcy5sZW5ndGg8M3x8MSE9PW4uZGltcy5sZW5ndGh8fDEhPT1yLmRpbXMubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW5wdXQgc2hhcGUuXCIpO2lmKG4uZGltc1swXSE9PWUuZGltc1sxXXx8ci5kaW1zWzBdIT09ZS5kaW1zWzFdKXRocm93IG5ldyBFcnJvcihcIklucHV0IHNoYXBlcyBhcmUgbWlzbWF0Y2hlZC5cIik7aWYoXCJmbG9hdDMyXCIhPT1lLnR5cGUmJlwiZmxvYXQ2NFwiIT09ZS50eXBlfHxcImZsb2F0MzJcIiE9PW4udHlwZSYmXCJmbG9hdDY0XCIhPT1uLnR5cGV8fFwiZmxvYXQzMlwiIT09ci50eXBlJiZcImZsb2F0NjRcIiE9PXIudHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGlucHV0IHR5cGUuXCIpO2lmKDQhPT10WzBdLmRpbXMubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIk9ubHkgc3VwcG9ydCA0LUQgaW5wdXQgc2hhcGUuXCIpfX0sNzA4Oih0LGUsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLmNyZWF0ZVBhY2tlZE1hdG11bFByb2dyYW1JbmZvTG9hZGVyPXZvaWQgMDtjb25zdCByPW4oMjUxNyksaT1uKDUwNjApLG89bigyMDM5KSxhPW4oOTM5MCkscz1uKDI4MjMpLHU9big1NjIzKTtlLmNyZWF0ZVBhY2tlZE1hdG11bFByb2dyYW1JbmZvTG9hZGVyPSh0LGUsbik9Pntjb25zdCBjPShsPWUubGVuZ3RoPjIscD1uLmFjdGl2YXRpb25DYWNoZUtleSx7bmFtZTpcIk1hdE11bCAocGFja2VkKVwiLGlucHV0TmFtZXM6bD9bXCJBXCIsXCJCXCIsXCJCaWFzXCJdOltcIkFcIixcIkJcIl0saW5wdXRUeXBlczpsP1tvLlRleHR1cmVUeXBlLnBhY2tlZCxvLlRleHR1cmVUeXBlLnBhY2tlZCxvLlRleHR1cmVUeXBlLnBhY2tlZF06W28uVGV4dHVyZVR5cGUucGFja2VkLG8uVGV4dHVyZVR5cGUucGFja2VkXSxjYWNoZUhpbnQ6cH0pO3ZhciBsLHA7cmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxjKSx7Z2V0OigpPT4oKHQsZSxuLGMpPT57Y29uc3QgbD1uLmxlbmd0aD4yLHA9bD9cInZhbHVlICs9IGdldEJpYXNGb3JNYXRtdWwoKTtcIjpcIlwiLGY9blswXS5kaW1zLGQ9blsxXS5kaW1zLGg9ci5Ccm9hZGNhc3RVdGlsLmNhbGNTaGFwZShmLGQsITApLGc9IXIuU2hhcGVVdGlsLmFyZUVxdWFsKG5bMF0uZGltcyxuWzFdLmRpbXMpO2lmKCFoKXRocm93IG5ldyBFcnJvcihcIkNhbid0IHVzZSBtYXRtdWwgb24gdGhlIGdpdmVuIHRlbnNvcnNcIik7Y29uc3QgYj1mW2YubGVuZ3RoLTFdLG09TWF0aC5jZWlsKGIvMikseT1mLmxlbmd0aCxfPWQubGVuZ3RoLHY9KDAsaS5nZXRHbHNsKSh0LnNlc3Npb24uYmFja2VuZC5nbENvbnRleHQudmVyc2lvbiksdz0oMCxhLmdldENvb3Jkc0RhdGFUeXBlKShoLmxlbmd0aCkseD1oLmxlbmd0aCxUPSgwLGEuZ2V0R2xDaGFubmVscykoKSx7YWN0aXZhdGlvbkZ1bmN0aW9uOlMsYXBwbHlBY3RpdmF0aW9uOk99PSgwLHMuZ2V0QWN0aXZhdGlvblNuaXBwZXQpKGMpLEE9bD9gJHsoMCx1LmdldEJpYXNGb3JNYXRtdWwpKHcsVCxuWzJdLmRpbXMsaCwhMCl9YDpcIlwiLEU9Zz9gJHtmdW5jdGlvbih0LGUsbixpKXtsZXQgbz1bXSxhPVtdO2NvbnN0IHM9blswXS5kaW1zLHU9blsxXS5kaW1zLGM9cy5sZW5ndGgsbD11Lmxlbmd0aCxwPWkubGVuZ3RoLGY9cC1jLGQ9cC1sO289cy5tYXAoKCh0LG4pPT5gY29vcmRzLiR7ZVtuK2ZdfWApKSxvW2MtMV09XCJpKjJcIixvLmpvaW4oXCIsIFwiKSxhPXUubWFwKCgodCxuKT0+YGNvb3Jkcy4ke2VbbitkXX1gKSksYVtsLTJdPVwiaSoyXCIsYS5qb2luKFwiLCBcIik7Y29uc3QgaD1yLkJyb2FkY2FzdFV0aWwuZ2V0QnJvYWRjYXN0RGltcyhzLGkpLGc9ci5Ccm9hZGNhc3RVdGlsLmdldEJyb2FkY2FzdERpbXModSxpKSxiPWgubWFwKCh0PT5gY29vcmRzLiR7ZVt0K2ZdfSA9IDA7YCkpLmpvaW4oXCJcXG5cIiksbT1nLm1hcCgodD0+YGNvb3Jkcy4ke2VbdCtkXX0gPSAwO2ApKS5qb2luKFwiXFxuXCIpLHk9YGludCBsYXN0RGltID0gY29vcmRzLiR7ZVtwLTFdfTtcXG4gIGNvb3Jkcy4ke2VbcC0xXX0gPSBjb29yZHMuJHtlW3AtMl19O1xcbiAgY29vcmRzLiR7ZVtwLTJdfSA9IGxhc3REaW07YDtyZXR1cm5gXFxudmVjNCBnZXRBQXRPdXRDb29yZHNNYXRtdWwoaW50IGkpIHtcXG4gICR7dH0gY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAke3l9XFxuICAke2J9XFxuICB2ZWM0IG91dHB1dFZhbHVlID0gZ2V0QSgke299KTtcXG4gIHJldHVybiBvdXRwdXRWYWx1ZTtcXG59XFxuXFxudmVjNCBnZXRCQXRPdXRDb29yZHNNYXRtdWwoaW50IGkpIHtcXG4gICR7dH0gY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAke3l9XFxuICAke219XFxuICB2ZWM0IG91dHB1dFZhbHVlID0gZ2V0Qigke2F9KTtcXG4gIHJldHVybiBvdXRwdXRWYWx1ZTtcXG59YH0odyxULG4saCl9YDpcIlwiLEk9Zz9cImdldEFBdE91dENvb3Jkc01hdG11bChpKVwiOmBnZXRBKCR7ZnVuY3Rpb24odCxlKXtsZXQgbj1cIlwiO2ZvcihsZXQgcj0wO3I8ZS0yO3IrKyluKz1gcmMuJHt0W3JdfSwgYDtyZXR1cm4gbis9YHJjLiR7dFtlLTJdfSwgaSoyYCxufShULHkpfSlgLFA9Zz9cImdldEJBdE91dENvb3Jkc01hdG11bChpKVwiOmBnZXRCKCR7ZnVuY3Rpb24odCxlKXtsZXQgbj1cIlwiO2ZvcihsZXQgcj0wO3I8ZS0yO3IrKyluKz1gcmMuJHt0W3JdfSwgYDtyZXR1cm4gbis9YGkqMiwgcmMuJHt0W2UtMV19YCxufShULF8pfSlgLEQ9YFxcbiAgICAgICAgICAgICR7RX1cXG4gICAgICAgICAgICAke0F9XFxuICAgICAgICAgICAgJHtTfVxcbiAgICAgICAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgICAgICAgICR7Zz9cIlwiOmAke3d9IHJjID1cXG4gICAgICAgICAgZ2V0T3V0cHV0Q29vcmRzKCk7IGludCBsYXN0RGltID0gcmMuJHtUW3gtMV19OyByYy4ke1RbeC0xXX0gPVxcbiAgICAgICAgICByYy4ke1RbeC0yXX07IHJjLiR7VFt4LTJdfSA9IGxhc3REaW07XFxuICAgICAgYH1cXG5cXG4gICAgICAgICAgICAgIHZlYzQgdmFsdWUgPSB2ZWM0KDApO1xcbiAgICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCAke219OyBpKyspIHtcXG4gICAgICAgICAgICAgICAgdmVjNCBhID0gJHtJfTtcXG4gICAgICAgICAgICAgICAgdmVjNCBiID0gJHtQfTtcXG5cXG4gICAgICAgICAgICAgICAgdmFsdWUgKz0gKGEucnJiYiAqIGIucmdyZyk7XFxuICAgICAgICAgICAgICAgIHZhbHVlICs9IChhLmdnYWEgKiBiLmJhYmEpO1xcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgJHtwfVxcbiAgICAgICAgICAgICAgJHtPfVxcbiAgICAgICAgICAgICAgJHt2Lm91dHB1dH0gPSB2YWx1ZTtcXG4gICAgICAgICAgICB9YDtyZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LGUpLHtvdXRwdXQ6e2RpbXM6aCx0eXBlOm5bMF0udHlwZSx0ZXh0dXJlVHlwZTpvLlRleHR1cmVUeXBlLnBhY2tlZH0sc2hhZGVyU291cmNlOkQsaGFzTWFpbjohMH0pfSkodCxjLGUsbil9KX19LDU2MjM6KHQsZSxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUuZ2V0Qmlhc0Zvck1hdG11bD1lLmNyZWF0ZU1hdG11bFByb2dyYW1JbmZvTG9hZGVyPWUucGFyc2VNYXRNdWxBdHRyaWJ1dGVzPWUubWF0TXVsPXZvaWQgMDtjb25zdCByPW4oMjUxNyksaT1uKDIwMzkpLG89big5MzkwKSxhPW4oMjgyMykscz1uKDcwOCk7ZnVuY3Rpb24gdSh0LGUpe2NvbnN0IG49KHM9dC5sZW5ndGg+Mix1PWUuYWN0aXZhdGlvbkNhY2hlS2V5LHtuYW1lOlwiTWF0TXVsXCIsaW5wdXROYW1lczpzP1tcIkFcIixcIkJcIixcIkJpYXNcIl06W1wiQVwiLFwiQlwiXSxpbnB1dFR5cGVzOnM/W2kuVGV4dHVyZVR5cGUudW5wYWNrZWQsaS5UZXh0dXJlVHlwZS51bnBhY2tlZCxpLlRleHR1cmVUeXBlLnVucGFja2VkXTpbaS5UZXh0dXJlVHlwZS51bnBhY2tlZCxpLlRleHR1cmVUeXBlLnVucGFja2VkXSxjYWNoZUhpbnQ6dX0pO3ZhciBzLHU7cmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxuKSx7Z2V0OigpPT5mdW5jdGlvbih0LGUsbil7Y29uc3Qgcz1lWzBdLmRpbXMsdT1lWzFdLmRpbXMsYz1yLkJyb2FkY2FzdFV0aWwuY2FsY1NoYXBlKHMsdSwhMCk7aWYoIWMpdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgdXNlIG1hdG11bCBvbiB0aGUgZ2l2ZW4gdGVuc29yc1wiKTtjb25zdCBwPSgwLG8uZ2V0Q29vcmRzRGF0YVR5cGUpKGMubGVuZ3RoKSxmPSgwLG8uZ2V0R2xDaGFubmVscykoKSx7YWN0aXZhdGlvbkZ1bmN0aW9uOmQsYXBwbHlBY3RpdmF0aW9uOmh9PSgwLGEuZ2V0QWN0aXZhdGlvblNuaXBwZXQpKG4pLGc9ZS5sZW5ndGg+MixiPWc/XCJ2YWx1ZSArPSBnZXRCaWFzRm9yTWF0bXVsKCk7XCI6XCJcIixtPWc/YCR7bChwLGYsZVsyXS5kaW1zLGMsITEpfWA6XCJcIix5PWMubGVuZ3RoLF89cy5sZW5ndGgsdj11Lmxlbmd0aCx3PWBcXG4gICAgJHtkfVxcbiAgICAke219XFxuICAgIGZsb2F0IHByb2Nlc3MoaW50IGluZGljZXNbJHt5fV0pIHtcXG4gICAgICAgIGludCBhWyR7X31dO1xcbiAgICAgICAgaW50IGJbJHt2fV07XFxuICAgICAgICBiY2FzdE1hdG11bEluZGljZXNfQShpbmRpY2VzLCBhKTtcXG4gICAgICAgIGJjYXN0TWF0bXVsSW5kaWNlc19CKGluZGljZXMsIGIpO1xcblxcbiAgICAgICAgZmxvYXQgdmFsdWU7XFxuICAgICAgICBmb3IgKGludCBrPTA7IGs8JHtzW3MubGVuZ3RoLTFdfTsgKytrKSB7XFxuICAgICAgICAgICAgYVske18tMX1dID0gaztcXG4gICAgICAgICAgICBiWyR7di0yfV0gPSBrO1xcbiAgICAgICAgICAgIHZhbHVlICs9IF9BKGEpICogX0IoYik7XFxuICAgICAgICB9XFxuICAgICAgICAke2J9XFxuICAgICAgICAke2h9XFxuICAgICAgICByZXR1cm4gdmFsdWU7XFxuICAgIH1gO3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sdCkse291dHB1dDp7ZGltczpjLHR5cGU6ZVswXS50eXBlLHRleHR1cmVUeXBlOmkuVGV4dHVyZVR5cGUudW5wYWNrZWR9LHNoYWRlclNvdXJjZTp3fSl9KG4sdCxlKX0pfWUubWF0TXVsPSh0LGUsbik9PihjKGUpLHQuc2Vzc2lvbi5wYWNrP1t0LnJ1bigoMCxzLmNyZWF0ZVBhY2tlZE1hdG11bFByb2dyYW1JbmZvTG9hZGVyKSh0LGUsbiksZSldOlt0LnJ1bih1KGUsbiksZSldKSxlLnBhcnNlTWF0TXVsQXR0cmlidXRlcz10PT4oMCxhLnBhcnNlSW50ZXJuYWxBY3RpdmF0aW9uQXR0cmlidXRlcykodC5hdHRyaWJ1dGVzKSxlLmNyZWF0ZU1hdG11bFByb2dyYW1JbmZvTG9hZGVyPXU7Y29uc3QgYz10PT57aWYoIXR8fDIhPT10Lmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJNYXRNdWwgcmVxdWlyZXMgMiBpbnB1dHMuXCIpO2lmKHRbMF0uZGltc1t0WzBdLmRpbXMubGVuZ3RoLTFdIT09dFsxXS5kaW1zW3RbMV0uZGltcy5sZW5ndGgtMl0pdGhyb3cgbmV3IEVycm9yKFwic2hhcmVkIGRpbWVuc2lvbiBkb2VzIG5vdCBtYXRjaC5cIik7aWYoXCJmbG9hdDMyXCIhPT10WzBdLnR5cGUmJlwiZmxvYXQ2NFwiIT09dFswXS50eXBlfHxcImZsb2F0MzJcIiE9PXRbMV0udHlwZSYmXCJmbG9hdDY0XCIhPT10WzFdLnR5cGUpdGhyb3cgbmV3IEVycm9yKFwiaW5wdXRzIHNob3VsZCBiZSBmbG9hdCB0eXBlXCIpO2lmKHRbMF0udHlwZSE9PXRbMV0udHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJpbnB1dHMgdHlwZXMgc2hvdWxkIG1hdGNoXCIpfTtmdW5jdGlvbiBsKHQsZSxuLGksbyl7bGV0IGE9XCJcIjtjb25zdCBzPW4ubGVuZ3RoLHU9aS5sZW5ndGgsYz11LXM7YT11PDImJnM+MD9cImNvb3Jkc1wiOm4ubWFwKCgodCxuKT0+YGNvb3Jkcy4ke2VbbitjXX1gKSkuam9pbihcIiwgXCIpO2NvbnN0IGw9ci5Ccm9hZGNhc3RVdGlsLmdldEJyb2FkY2FzdERpbXMobixpKS5tYXAoKHQ9PmBjb29yZHMuJHtlW3QrY119ID0gMDtgKSkuam9pbihcIlxcblwiKTtsZXQgcD1cInZlYzQob3V0cHV0VmFsdWUueHgsIG91dHB1dFZhbHVlLnl5KVwiO3JldHVybiAxPT09ci5TaGFwZVV0aWwuc2l6ZShuKSYmKHA9XCJ2ZWM0KG91dHB1dFZhbHVlLngpXCIpLG8/YFxcbnZlYzQgZ2V0Qmlhc0Zvck1hdG11bCgpIHtcXG4gICR7dH0gY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAke2x9XFxuICB2ZWM0IG91dHB1dFZhbHVlID0gZ2V0Qmlhcygke2F9KTtcXG4gIHJldHVybiAke3B9O1xcbn1gOmBcXG5mbG9hdCBnZXRCaWFzRm9yTWF0bXVsKCkge1xcbiAgJHt0fSBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICR7bH1cXG4gIHJldHVybiBnZXRCaWFzKGNvb3Jkcy54KTtcXG59YH1lLmdldEJpYXNGb3JNYXRtdWw9bH0sMjQwMzoodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5jcmVhdGVQYWNrUHJvZ3JhbUluZm9Mb2FkZXI9dm9pZCAwO2NvbnN0IHI9big1MDYwKSxpPW4oMjAzOSksbz1uKDkzOTApLGE9bigyODI3KSxzPXtuYW1lOlwicGFja1wiLGlucHV0TmFtZXM6W1wiQVwiXSxpbnB1dFR5cGVzOltpLlRleHR1cmVUeXBlLnVucGFja2VkUmV2ZXJzZWRdfTtlLmNyZWF0ZVBhY2tQcm9ncmFtSW5mb0xvYWRlcj0odCxlKT0+T2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LHMpLHtnZXQ6KCk9PigodCxlKT0+e2NvbnN0IG49KDAsci5nZXRHbHNsKSh0LnNlc3Npb24uYmFja2VuZC5nbENvbnRleHQudmVyc2lvbiksdT1lLmRpbXMsYz11Lmxlbmd0aCxsPWUuZGltcy5sZW5ndGgscD0oMCxvLmdldENvb3Jkc0RhdGFUeXBlKShsKSxmPSgwLGEuZ2V0Q2hhbm5lbHMpKFwicmNcIixsKSxkPShoPWwsZz1mLGI9dVt1Lmxlbmd0aC0yXSxtPXVbdS5sZW5ndGgtMV0sMD09PWh8fDE9PT1oP1wiXCI6YFxcbiAgICBpbnQgciA9ICR7Z1toLTJdfTtcXG4gICAgaW50IGMgPSAke2dbaC0xXX07XFxuICAgIGludCBycDEgPSAke2dbaC0yXX0gKyAxO1xcbiAgICBpbnQgY3AxID0gJHtnW2gtMV19ICsgMTtcXG4gICAgYm9vbCByRWRnZSA9IHJwMSA+PSAke219O1xcbiAgICBib29sIGNFZGdlID0gY3AxID49ICR7Yn07XFxuICAgIGApO3ZhciBoLGcsYixtO2xldCB5O3k9MD09PWM/WzEsMV06MT09PWM/W3VbMF0sMV06W3VbbC0xXSx1W2wtMl1dO2NvbnN0IF89ZnVuY3Rpb24odCxlLG4pe2lmKDA9PT10KXJldHVyblwiZmFsc2VcIjtpZigxPT09dClyZXR1cm5gcmMgPiAke2VbMF19YDtsZXQgcj1cIlwiO2ZvcihsZXQgaT10LTI7aTx0O2krKylyKz1gJHtuW2ldfSA+PSAke2VbaS10KzJdfWAsaTx0LTEmJihyKz1cInx8XCIpO3JldHVybiByfShsLHksZiksdj1mdW5jdGlvbih0LGUpe2NvbnN0IG49dC5sZW5ndGg7aWYoMD09PW4pcmV0dXJuXCJnZXRBKCksIDAsIDAsIDBcIjtpZigxPT09bilyZXR1cm5gZ2V0QShyYyksXFxuICAgICAgICAgICAgcmMgKyAxID49ICR7dFswXX0gPyAwLiA6IGdldEEocmMgKyAxKSxcXG4gICAgICAgICAgICAwLCAwYDtsZXQgcj1cIlwiO2lmKG4+Milmb3IobGV0IHQ9MDt0PG4tMjsrK3Qpcis9YCR7ZVt0XX0sYDtyZXR1cm5gZ2V0QSgke3J9ciwgYyksXFxuICAgICAgICAgIHJFZGdlID8gMC4gOiBnZXRBKCR7cn1ycDEsIGMpLFxcbiAgICAgICAgICBjRWRnZSA/IDAuIDogZ2V0QSgke3J9ciwgY3AxKSxcXG4gICAgICAgICAgckVkZ2UgfHwgY0VkZ2UgPyAwLiA6IGdldEEoJHtyfXJwMSwgY3AxKWB9KHUsZiksdz1gXFxuICAgICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICAgICR7cH0gcmMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG5cXG4gICAgICAgICAgaWYoJHtffSkge1xcbiAgICAgICAgICAgICR7bi5vdXRwdXR9ID0gdmVjNCgwKTtcXG4gICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAke2R9XFxuXFxuICAgICAgICAgICAgJHtuLm91dHB1dH0gPSB2ZWM0KCR7dn0pO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgYDtyZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LHMpLHtoYXNNYWluOiEwLG91dHB1dDp7ZGltczplLmRpbXMsdHlwZTplLnR5cGUsdGV4dHVyZVR5cGU6aS5UZXh0dXJlVHlwZS5wYWNrZWR9LHNoYWRlclNvdXJjZTp3fSl9KSh0LGUpfSl9LDI4Mjc6KHQsZSxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUudW5wYWNrRnJvbUNoYW5uZWw9ZS5nZXRDaGFubmVscz1lLmdldFZlY0NoYW5uZWxzPXZvaWQgMDtjb25zdCByPW4oOTM5MCk7ZnVuY3Rpb24gaSh0LGUpe3JldHVybigwLHIuZ2V0R2xDaGFubmVscykoZSkubWFwKChlPT5gJHt0fS4ke2V9YCkpfWUuZ2V0VmVjQ2hhbm5lbHM9aSxlLmdldENoYW5uZWxzPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIDE9PT1lP1t0XTppKHQsZSl9LGUudW5wYWNrRnJvbUNoYW5uZWw9ZnVuY3Rpb24oKXtyZXR1cm5cIlxcbiAgICBmbG9hdCBnZXRDaGFubmVsKHZlYzQgZnJhZywgaW50IGRpbSkge1xcbiAgICAgIGludCBtb2RDb29yZCA9IGltb2QoZGltLCAyKTtcXG4gICAgICByZXR1cm4gbW9kQ29vcmQgPT0gMCA/IGZyYWcuciA6IGZyYWcuZztcXG4gICAgfVxcblxcbiAgICBmbG9hdCBnZXRDaGFubmVsKHZlYzQgZnJhZywgdmVjMiBpbm5lckRpbXMpIHtcXG4gICAgICB2ZWMyIG1vZENvb3JkID0gbW9kKGlubmVyRGltcywgMi4pO1xcbiAgICAgIHJldHVybiBtb2RDb29yZC54ID09IDAuID9cXG4gICAgICAgIChtb2RDb29yZC55ID09IDAuID8gZnJhZy5yIDogZnJhZy5nKSA6XFxuICAgICAgICAobW9kQ29vcmQueSA9PSAwLiA/IGZyYWcuYiA6IGZyYWcuYSk7XFxuICAgIH1cXG4gIFwifX0sMjg3MDoodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5wYXJzZVBhZEF0dHJpYnV0ZXNWMTE9ZS5wYWRWMTE9ZS5wYXJzZVBhZEF0dHJpYnV0ZXNWMj1lLnBhZFYyPXZvaWQgMDtjb25zdCByPW4oMjQ2KSxpPW4oMjUxNyksbz1uKDUwNjApLGE9bigyMDM5KSxzPXtuYW1lOlwiUGFkXCIsaW5wdXROYW1lczpbXCJBXCJdLGlucHV0VHlwZXM6W2EuVGV4dHVyZVR5cGUudW5wYWNrZWRdfTtlLnBhZFYyPSh0LGUsbik9PihsKGUpLFt0LnJ1bihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30scykse2NhY2hlSGludDpuLmNhY2hlS2V5LGdldDooKT0+Yyh0LGVbMF0sbil9KSxlKV0pLGUucGFyc2VQYWRBdHRyaWJ1dGVzVjI9dD0+e2NvbnN0IGU9dC5hdHRyaWJ1dGVzLmdldFN0cmluZyhcIm1vZGVcIixcImNvbnN0YW50XCIpLG49dC5hdHRyaWJ1dGVzLmdldEZsb2F0KFwidmFsdWVcIiwwKSxpPXQuYXR0cmlidXRlcy5nZXRJbnRzKFwicGFkc1wiKTtyZXR1cm4oMCxyLmNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSkoe21vZGU6ZSx2YWx1ZTpuLHBhZHM6aX0pfSxlLnBhZFYxMT0odCxuLHIpPT57cChuKTtjb25zdCBpPXUodCxuLHIpO3JldHVybigwLGUucGFkVjIpKHQsW25bMF1dLGkpfSxlLnBhcnNlUGFkQXR0cmlidXRlc1YxMT10PT50LmF0dHJpYnV0ZXMuZ2V0U3RyaW5nKFwibW9kZVwiLFwiY29uc3RhbnRcIik7Y29uc3QgdT0odCxlLG4pPT57aWYoIXQuc2Vzc2lvbi5pc0luaXRpYWxpemVyKGVbMV0uZGF0YUlkKXx8ZS5sZW5ndGg+PTMmJiF0LnNlc3Npb24uaXNJbml0aWFsaXplcihlWzJdLmRhdGFJZCkpdGhyb3cgbmV3IEVycm9yKFwiZHluYW1pYyBwYWQgYXR0cmlidXRlcyBhcmUgbm90IGFsbG93ZWRcIik7Y29uc3QgaT1BcnJheS5mcm9tKGVbMV0uaW50ZWdlckRhdGEpLG89ZS5sZW5ndGg+PTM/ZVsyXS5mbG9hdERhdGFbMF06MDtyZXR1cm4oMCxyLmNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSkoe21vZGU6bixwYWRzOmksdmFsdWU6b30pfSxjPSh0LGUsbik9Pntjb25zdCByPWkuU2hhcGVVdGlsLnBhZFNoYXBlKGUuZGltcy5zbGljZSgpLG4ucGFkcyksbz1yLmxlbmd0aCxzPWBcXG4gICAgICAke2YodCxlLG4pfVxcbiAgICAgIGZsb2F0IHByb2Nlc3MoaW50WyR7b31dIGluZGljZXMpIHtcXG4gICAgICAgICAgcmV0dXJuIHBhZEEoaW5kaWNlcyk7XFxuICAgICAgfWA7cmV0dXJue25hbWU6XCJQYWRcIixpbnB1dE5hbWVzOltcIkFcIl0saW5wdXRUeXBlczpbYS5UZXh0dXJlVHlwZS51bnBhY2tlZF0sb3V0cHV0OntkaW1zOnIsdHlwZTplLnR5cGUsdGV4dHVyZVR5cGU6YS5UZXh0dXJlVHlwZS51bnBhY2tlZH0sc2hhZGVyU291cmNlOnN9fSxsPXQ9PntpZighdHx8MSE9PXQubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIlBhZCByZXF1aXJlcyAxIGlucHV0XCIpO2lmKFwiZmxvYXQzMlwiIT09dFswXS50eXBlJiZcImZsb2F0NjRcIiE9PXRbMF0udHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGlucHV0IHR5cGUuXCIpfSxwPXQ9PntpZighdHx8MiE9PXQubGVuZ3RoJiYzIT09dC5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiUGFkIHJlcXVpcmVzIDIgb3IgMyBpbnB1dHNcIik7aWYoXCJpbnQzMlwiIT09dFsxXS50eXBlKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW5wdXQgdHlwZS5cIik7aWYodC5sZW5ndGg+PTMmJlwic3RyaW5nXCI9PT10WzJdLnR5cGUpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbnB1dCB0eXBlLlwiKX0sZj0odCxlLG4pPT57Y29uc3Qgcj0oMCxvLmdldEdsc2wpKHQuc2Vzc2lvbi5iYWNrZW5kLmdsQ29udGV4dC52ZXJzaW9uKSxbcyx1XT10LmNhbGN1bGF0ZVRleHR1cmVXaWR0aEFuZEhlaWdodChlLmRpbXMsYS5UZXh0dXJlVHlwZS51bnBhY2tlZCksYz1pLlNoYXBlVXRpbC5jb21wdXRlU3RyaWRlcyhlLmRpbXMpO3N3aXRjaChuLm1vZGUpe2Nhc2VcImNvbnN0YW50XCI6cmV0dXJuIGQocixlLmRpbXMsYyxzLHUsbi5wYWRzLG4udmFsdWUpO2Nhc2VcInJlZmxlY3RcIjpyZXR1cm4gaChyLGUuZGltcyxjLHMsdSxuLnBhZHMpO2Nhc2VcImVkZ2VcIjpyZXR1cm4gZyhyLGUuZGltcyxjLHMsdSxuLnBhZHMpO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBtb2RlXCIpfX0sZD0odCxlLG4scixpLG8sYSk9Pntjb25zdCBzPWUubGVuZ3RoO2xldCB1PVwiXCI7Zm9yKGxldCB0PXMtMTt0Pj0wOy0tdCl1Kz1gXFxuICAgICAgICBrID0gbVske3R9XSAtICR7b1t0XX07XFxuICAgICAgICBpZiAoayA8IDApICByZXR1cm4gY29uc3RhbnQ7XFxuICAgICAgICBpZiAoayA+PSAke2VbdF19KSByZXR1cm4gY29uc3RhbnQ7XFxuICAgICAgICBvZmZzZXQgKz0gayAqICR7blt0XX07XFxuICAgICAgICBgO3JldHVybmBcXG4gICAgICBmbG9hdCBwYWRBKGludCBtWyR7c31dKSB7XFxuICAgICAgICBjb25zdCBmbG9hdCBjb25zdGFudCA9IGZsb2F0KCR7YX0pO1xcbiAgICAgICAgaW50IG9mZnNldCA9IDA7XFxuICAgICAgICBpbnQgayA9IDA7XFxuICAgICAgICAke3V9XFxuICAgICAgICB2ZWMyIGNvb3JkcyA9IG9mZnNldFRvQ29vcmRzKG9mZnNldCwgJHtyfSwgJHtpfSk7XFxuICAgICAgICBmbG9hdCB2YWx1ZSA9IGdldENvbG9yQXNGbG9hdCgke3QudGV4dHVyZTJEfShBLCBjb29yZHMpKTtcXG4gICAgICAgIHJldHVybiB2YWx1ZTtcXG4gICAgICB9XFxuICAgICAgYH0saD0odCxlLG4scixpLG8pPT57Y29uc3QgYT1lLmxlbmd0aDtsZXQgcz1cIlwiO2ZvcihsZXQgdD1hLTE7dD49MDstLXQpcys9YFxcbiAgICAgICAgayA9IG1bJHt0fV0gLSAke29bdF19O1xcbiAgICAgICAgaWYgKGsgPCAwKSB7IGsgPSAtazsgfVxcbiAgICAgICAge1xcbiAgICAgICAgICBjb25zdCBpbnQgXzJuXzEgPSAkezIqKGVbdF0tMSl9O1xcbiAgICAgICAgICBrID0gaW50KCBtb2QoIGZsb2F0KGspLCBmbG9hdChfMm5fMSkgKSApIDtcXG4gICAgICAgICAgaWYoayA+PSAke2VbdF19KSB7IGsgPSBfMm5fMSAtIGs7IH1cXG4gICAgICAgIH1cXG4gICAgICAgIG9mZnNldCArPSBrICogJHtuW3RdfTtcXG4gICAgICAgIGA7cmV0dXJuYFxcbiAgICAgIGZsb2F0IHBhZEEoaW50IG1bJHthfV0pIHtcXG4gICAgICAgIGludCBvZmZzZXQgPSAwO1xcbiAgICAgICAgaW50IGsgPSAwO1xcbiAgICAgICAgJHtzfVxcbiAgICAgICAgdmVjMiBjb29yZHMgPSBvZmZzZXRUb0Nvb3JkcyhvZmZzZXQsICR7cn0sICR7aX0pO1xcbiAgICAgICAgZmxvYXQgdmFsdWUgPSBnZXRDb2xvckFzRmxvYXQoJHt0LnRleHR1cmUyRH0oQSwgY29vcmRzKSk7XFxuICAgICAgICByZXR1cm4gdmFsdWU7XFxuICAgICAgfVxcbiAgICAgIGB9LGc9KHQsZSxuLHIsaSxvKT0+e2NvbnN0IGE9ZS5sZW5ndGg7bGV0IHM9XCJcIjtmb3IobGV0IHQ9YS0xO3Q+PTA7LS10KXMrPWBcXG4gICAgICAgIGsgPSBtWyR7dH1dIC0gJHtvW3RdfTtcXG4gICAgICAgIGlmIChrIDwgMCkgIGsgPSAwO1xcbiAgICAgICAgaWYgKGsgPj0gJHtlW3RdfSkgayA9ICR7ZVt0XS0xfTtcXG4gICAgICAgIG9mZnNldCArPSBrICogJHtuW3RdfTtcXG4gICAgICBgO3JldHVybmBcXG4gICAgICBmbG9hdCBwYWRBKGludCBtWyR7YX1dKSB7XFxuICAgICAgICBpbnQgb2Zmc2V0ID0gMDtcXG4gICAgICAgIGludCBrID0gMDtcXG4gICAgICAgICR7c31cXG4gICAgICAgIHZlYzIgY29vcmRzID0gb2Zmc2V0VG9Db29yZHMob2Zmc2V0LCAke3J9LCAke2l9KTtcXG4gICAgICAgIGZsb2F0IHZhbHVlID0gZ2V0Q29sb3JBc0Zsb2F0KCR7dC50ZXh0dXJlMkR9KEEsIGNvb3JkcykpO1xcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xcbiAgICAgIH1cXG4gICAgICBgfX0sMjE0MzoodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5nbG9iYWxNYXhQb29sPWUucGFyc2VNYXhQb29sQXR0cmlidXRlcz1lLm1heFBvb2w9ZS5wYXJzZUdsb2JhbEF2ZXJhZ2VQb29sQXR0cmlidXRlcz1lLmdsb2JhbEF2ZXJhZ2VQb29sPWUucGFyc2VBdmVyYWdlUG9vbEF0dHJpYnV0ZXM9ZS5hdmVyYWdlUG9vbD12b2lkIDA7Y29uc3Qgcj1uKDI0NiksaT1uKDI1MTcpLG89bigyMDM5KTtlLmF2ZXJhZ2VQb29sPSh0LGUsbik9PntwKGUpO2NvbnN0IHI9e25hbWU6XCJBdmVyYWdlUG9vbFwiLGlucHV0TmFtZXM6W1wiWFwiXSxpbnB1dFR5cGVzOltvLlRleHR1cmVUeXBlLnVucGFja2VkXSxjYWNoZUhpbnQ6bi5jYWNoZUtleX07cmV0dXJuW3QucnVuKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxyKSx7Z2V0OigpPT5hKGUsciwhMSxuKX0pLGUpXX0sZS5wYXJzZUF2ZXJhZ2VQb29sQXR0cmlidXRlcz10PT57Y29uc3QgZT10LmF0dHJpYnV0ZXMuZ2V0U3RyaW5nKFwiYXV0b19wYWRcIixcIk5PVFNFVFwiKSxuPXQuYXR0cmlidXRlcy5nZXRJbnQoXCJjZWlsX21vZGVcIiwwKSxpPTAhPT10LmF0dHJpYnV0ZXMuZ2V0SW50KFwiY291bnRfaW5jbHVkZV9wYWRcIiwwKSxvPXQuYXR0cmlidXRlcy5nZXRJbnRzKFwia2VybmVsX3NoYXBlXCIpLGE9dC5hdHRyaWJ1dGVzLmdldEludHMoXCJzdHJpZGVzXCIsW10pLHM9dC5hdHRyaWJ1dGVzLmdldEludHMoXCJwYWRzXCIsW10pO2lmKDAhPT1uKXRocm93IG5ldyBFcnJvcihcInVzaW5nIGNlaWwoKSBpbiBzaGFwZSBjb21wdXRhdGlvbiBpcyBub3QgeWV0IHN1cHBvcnRlZCBmb3IgQXZlcmFnZVBvb2xcIik7cmV0dXJuKDAsci5jcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkpKHthdXRvUGFkOmUsY2VpbE1vZGU6bixjb3VudEluY2x1ZGVQYWQ6aSxrZXJuZWxTaGFwZTpvLHN0cmlkZXM6YSxwYWRzOnN9KX07Y29uc3QgYT0odCxlLG4scik9Pntjb25zdFthLHNdPXUodCxyLG4pLGM9aS5TaGFwZVV0aWwuc2l6ZShhLmtlcm5lbFNoYXBlKTtsZXQgbD1cIlwiO2EuY291bnRJbmNsdWRlUGFkP2wrPWB2YWx1ZSAvPSBmbG9hdCgke2N9KTtgOmwrPWB2YWx1ZSAvPSBmbG9hdCgke2N9IC0gcGFkKTtgO2NvbnN0IHA9YFxcbiAgICAgICAgJHtmKHRbMF0uZGltcyxhLFwidmFsdWUgKz0gX1goeCk7XCIsbCxcIjAuMFwiKX1cXG4gICAgICBgO3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sZSkse291dHB1dDp7ZGltczpzLHR5cGU6dFswXS50eXBlLHRleHR1cmVUeXBlOm8uVGV4dHVyZVR5cGUudW5wYWNrZWR9LHNoYWRlclNvdXJjZTpwfSl9O2UuZ2xvYmFsQXZlcmFnZVBvb2w9KHQsZSxuKT0+e3AoZSk7Y29uc3Qgcj17bmFtZTpcIkdsb2JhbEF2ZXJhZ2VQb29sXCIsaW5wdXROYW1lczpbXCJYXCJdLGlucHV0VHlwZXM6W28uVGV4dHVyZVR5cGUudW5wYWNrZWRdLGNhY2hlSGludDpgJHtuLmNvdW50SW5jbHVkZVBhZH1gfTtyZXR1cm5bdC5ydW4oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LHIpLHtnZXQ6KCk9PmEoZSxyLCEwLG4pfSksZSldfSxlLnBhcnNlR2xvYmFsQXZlcmFnZVBvb2xBdHRyaWJ1dGVzPXQ9Pntjb25zdCBlPTAhPT10LmF0dHJpYnV0ZXMuZ2V0SW50KFwiY291bnRfaW5jbHVkZV9wYWRcIiwwKTtyZXR1cm4oMCxyLmNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSkoe2F1dG9QYWQ6XCJcIixjZWlsTW9kZTowLGNvdW50SW5jbHVkZVBhZDplLGtlcm5lbFNoYXBlOltdLHN0cmlkZXM6W10scGFkczpbXX0pfSxlLm1heFBvb2w9KHQsZSxuKT0+e3AoZSk7Y29uc3Qgcj17bmFtZTpcIk1heFBvb2xcIixpbnB1dE5hbWVzOltcIlhcIl0saW5wdXRUeXBlczpbby5UZXh0dXJlVHlwZS51bnBhY2tlZF0sY2FjaGVIaW50Om4uY2FjaGVLZXl9O3JldHVyblt0LnJ1bihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30scikse2dldDooKT0+cyhlLHIsITEsbil9KSxlKV19LGUucGFyc2VNYXhQb29sQXR0cmlidXRlcz10PT57Y29uc3QgZT10LmF0dHJpYnV0ZXMuZ2V0U3RyaW5nKFwiYXV0b19wYWRcIixcIk5PVFNFVFwiKSxuPXQuYXR0cmlidXRlcy5nZXRJbnQoXCJjZWlsX21vZGVcIiwwKSxpPXQuYXR0cmlidXRlcy5nZXRJbnRzKFwia2VybmVsX3NoYXBlXCIpLG89dC5hdHRyaWJ1dGVzLmdldEludHMoXCJzdHJpZGVzXCIsW10pLGE9dC5hdHRyaWJ1dGVzLmdldEludHMoXCJwYWRzXCIsW10pLHM9dC5hdHRyaWJ1dGVzLmdldEludChcInN0b3JhZ2Vfb3JkZXJcIiwwKSx1PXQuYXR0cmlidXRlcy5nZXRJbnRzKFwiZGlsYXRpb25zXCIsW10pO2lmKDAhPT1zKXRocm93IG5ldyBFcnJvcihcImNvbHVtbiBtYWpvciBzdG9yYWdlIG9yZGVyIGlzIG5vdCB5ZXQgc3VwcG9ydGVkIGZvciBNYXhQb29sXCIpO2lmKDAhPT1uKXRocm93IG5ldyBFcnJvcihcInVzaW5nIGNlaWwoKSBpbiBzaGFwZSBjb21wdXRhdGlvbiBpcyBub3QgeWV0IHN1cHBvcnRlZCBmb3IgTWF4UG9vbFwiKTtyZXR1cm4oMCxyLmNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSkoe2F1dG9QYWQ6ZSxjZWlsTW9kZTpuLGNvdW50SW5jbHVkZVBhZDohMSxrZXJuZWxTaGFwZTppLHN0cmlkZXM6byxwYWRzOmEsc3RvcmFnZU9yZGVyOnMsZGlsYXRpb25zOnV9KX07Y29uc3Qgcz0odCxlLG4scik9Pntjb25zdFtpLGFdPXUodCxyLG4pLHM9YFxcbiAgICAgICR7Zih0WzBdLmRpbXMsaSxcIlxcbiAgICAgIHZhbHVlID0gbWF4KF9YKHgpLCB2YWx1ZSk7XFxuICAgIFwiLFwiXCIsXCItMWU1XCIpfVxcbiAgICBgO3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sZSkse291dHB1dDp7ZGltczphLHR5cGU6dFswXS50eXBlLHRleHR1cmVUeXBlOm8uVGV4dHVyZVR5cGUudW5wYWNrZWR9LHNoYWRlclNvdXJjZTpzfSl9LHU9KHQsZSxuKT0+e2NvbnN0IHI9dFswXS5kaW1zLnNsaWNlKCksbz1PYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChlLFwiZGlsYXRpb25zXCIpLGE9ZS5rZXJuZWxTaGFwZS5zbGljZSgpLHM9ZS5zdHJpZGVzLnNsaWNlKCksdT1vP2UuZGlsYXRpb25zLnNsaWNlKCk6W10sYz1lLnBhZHMuc2xpY2UoKTtpLlBvb2xDb252VXRpbC5hZGp1c3RQb29sQXR0cmlidXRlcyhuLHIsYSxzLHUsYyk7Y29uc3QgbD1pLlBvb2xDb252VXRpbC5jb21wdXRlUG9vbE91dHB1dFNoYXBlKG4scixzLHUsYSxjLGUuYXV0b1BhZCkscD1PYmplY3QuYXNzaWduKHt9LGUpO3JldHVybiBvP09iamVjdC5hc3NpZ24ocCx7a2VybmVsU2hhcGU6YSxzdHJpZGVzOnMscGFkczpjLGRpbGF0aW9uczp1LGNhY2hlS2V5OmUuY2FjaGVLZXl9KTpPYmplY3QuYXNzaWduKHAse2tlcm5lbFNoYXBlOmEsc3RyaWRlczpzLHBhZHM6YyxjYWNoZUtleTplLmNhY2hlS2V5fSksW3AsbF19LGM9e2F1dG9QYWQ6XCJcIixjZWlsTW9kZTowLGNvdW50SW5jbHVkZVBhZDohMSxrZXJuZWxTaGFwZTpbXSxzdHJpZGVzOltdLHBhZHM6W10sc3RvcmFnZU9yZGVyOjAsZGlsYXRpb25zOltdLGNhY2hlS2V5OlwiXCJ9LGw9e25hbWU6XCJHbG9iYWxNYXhQb29sXCIsaW5wdXROYW1lczpbXCJYXCJdLGlucHV0VHlwZXM6W28uVGV4dHVyZVR5cGUudW5wYWNrZWRdfTtlLmdsb2JhbE1heFBvb2w9KHQsZSk9PihwKGUpLFt0LnJ1bihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sbCkse2dldDooKT0+cyhlLGwsITAsYyl9KSxlKV0pO2NvbnN0IHA9dD0+e2lmKCF0fHwxIT09dC5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiUG9vbCBvcHMgcmVxdWlyZXMgMSBpbnB1dC5cIik7aWYoXCJmbG9hdDMyXCIhPT10WzBdLnR5cGUmJlwiZmxvYXQ2NFwiIT09dFswXS50eXBlKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW5wdXQgdHlwZS5cIil9LGY9KHQsZSxuLHIsbyk9Pntjb25zdCBhPXQubGVuZ3RoO2lmKGUua2VybmVsU2hhcGUubGVuZ3RoPD0yKXtjb25zdCBpPWUua2VybmVsU2hhcGVbZS5rZXJuZWxTaGFwZS5sZW5ndGgtMV0scz1lLnN0cmlkZXNbZS5zdHJpZGVzLmxlbmd0aC0xXSx1PWUucGFkc1tlLnBhZHMubGVuZ3RoLzItMV0sYz1lLnBhZHNbZS5wYWRzLmxlbmd0aC0xXSxsPXRbYS0xXTtsZXQgcD1cIlwiLGY9XCJcIixkPVwiXCI7aWYocD11K2MhPT0wP2BcXG4gICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCAke2l9OyBpKyspIHtcXG4gICAgICAgICAgICB4WyR7YX0gLSAxXSA9IGluZGljZXNbJHthfSAtIDFdICogJHtzfSAtICR7dX0gKyBpO1xcbiAgICAgICAgICAgIGlmICh4WyR7YX0gLSAxXSA8IDAgfHwgeFske2F9IC0gMV0gPj0gJHtsfSkge1xcbiAgICAgICAgICAgICAgcGFkKys7XFxuICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgJHtufVxcbiAgICAgICAgICB9YDpgXFxuICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgJHtpfTsgaSsrKSB7XFxuICAgICAgICAgICAgeFske2F9IC0gMV0gPSBpbmRpY2VzWyR7YX0gLSAxXSAqICR7c30gLSAke3V9ICsgaTtcXG4gICAgICAgICAgICAke259XFxuICAgICAgICAgIH1gLDI9PT1lLmtlcm5lbFNoYXBlLmxlbmd0aCl7Y29uc3Qgbj1lLmtlcm5lbFNoYXBlW2Uua2VybmVsU2hhcGUubGVuZ3RoLTJdLHI9ZS5zdHJpZGVzW2Uuc3RyaWRlcy5sZW5ndGgtMl0sbz1lLnBhZHNbZS5wYWRzLmxlbmd0aC8yLTJdLHM9ZS5wYWRzW2UucGFkcy5sZW5ndGgtMl0sdT10W2EtMl07Zj1vK3MhPT0wP2BcXG4gICAgICAgICAgICBmb3IgKGludCBqID0gMDsgaiA8ICR7bn07IGorKykge1xcbiAgICAgICAgICAgICAgeFske2F9IC0gMl0gPSBpbmRpY2VzWyR7YX0gLSAyXSAqICR7cn0gLSAke299ICsgajtcXG4gICAgICAgICAgICAgIGlmICh4WyR7YX0gLSAyXSA8IDAgfHwgeFske2F9IC0gMl0gPj0gJHt1fSkge1xcbiAgICAgICAgICAgICAgICBwYWQrPSAke2l9O1xcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgYDpgXFxuICAgICAgICAgICAgZm9yIChpbnQgaiA9IDA7IGogPCAke259OyBqKyspIHtcXG4gICAgICAgICAgICAgIHhbJHthfSAtIDJdID0gaW5kaWNlc1ske2F9IC0gMl0gKiAke3J9IC0gJHtvfSArIGo7XFxuICAgICAgICAgICAgYCxkPVwiXFxuICAgICAgICAgIH1cXG4gICAgICAgIFwifXJldHVybmBcXG4gICAgICAgIGZsb2F0IHByb2Nlc3MoaW50IGluZGljZXNbJHthfV0pIHtcXG4gICAgICAgICAgaW50IHhbJHthfV07XFxuICAgICAgICAgIGNvcHlWZWMoaW5kaWNlcywgeCk7XFxuXFxuICAgICAgICAgIGZsb2F0IHZhbHVlID0gJHtvfTtcXG4gICAgICAgICAgaW50IHBhZCA9IDA7XFxuICAgICAgICAgICR7Zn1cXG4gICAgICAgICAgJHtwfVxcbiAgICAgICAgICAke2R9XFxuICAgICAgICAgICR7cn1cXG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xcbiAgICAgICAgfVxcbiAgICAgIGB9e2NvbnN0IHM9aS5TaGFwZVV0aWwuc2l6ZShlLmtlcm5lbFNoYXBlKSx1PWkuU2hhcGVVdGlsLmNvbXB1dGVTdHJpZGVzKGUua2VybmVsU2hhcGUpLGM9dS5sZW5ndGgsbD1lLnBhZHMubGVuZ3RoLHA9aChjKSxmPWQodCxcImlucHV0RGltc1wiKSxnPWQoZS5wYWRzLFwicGFkc1wiKSxiPWQodSxcImtlcm5lbFN0cmlkZXNcIiksbT1kKGUuc3RyaWRlcyxcInN0cmlkZXNcIik7bGV0IHk9XCJcIjtyZXR1cm4geT1lLnBhZHMucmVkdWNlKCgodCxlKT0+dCtlKSk/YFxcbiAgICAgICAgICAgIGlmICh4W2pdID49IGlucHV0RGltc1tqXSB8fCB4W2pdIDwgMCkge1xcbiAgICAgICAgICAgICAgcGFkKys7XFxuICAgICAgICAgICAgICBpc1BhZCA9IHRydWU7XFxuICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgaWYgKCFpc1BhZCkge1xcbiAgICAgICAgICAgICR7bn1cXG4gICAgICAgICAgfWA6YFxcbiAgICAgICAgICB9XFxuICAgICAgICAgICR7bn1cXG4gICAgICAgIGAsYFxcbiAgICAgICAgJHtwfVxcbiAgICAgICAgZmxvYXQgcHJvY2VzcyhpbnQgaW5kaWNlc1ske2F9XSkge1xcbiAgICAgICAgICBpbnQgeFske2F9XTtcXG4gICAgICAgICAgY29weVZlYyhpbmRpY2VzLCB4KTtcXG4gICAgICAgICAgaW50IG9mZnNldFske2N9XTtcXG4gICAgICAgICAgaW50IHBhZHNbJHtsfV07XFxuICAgICAgICAgIGludCBpbnB1dERpbXNbJHthfV07XFxuICAgICAgICAgIGludCBrZXJuZWxTdHJpZGVzWyR7Y31dO1xcbiAgICAgICAgICBpbnQgc3RyaWRlc1ske2N9XTtcXG4gICAgICAgICAgJHtnfVxcbiAgICAgICAgICAke2Z9XFxuICAgICAgICAgICR7bX1cXG4gICAgICAgICAgJHtifVxcblxcbiAgICAgICAgICBmbG9hdCB2YWx1ZSA9ICR7b307XFxuICAgICAgICAgIGludCBwYWQgPSAwO1xcbiAgICAgICAgICBib29sIGlzUGFkID0gZmFsc2U7XFxuICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgJHtzfTsgaSsrKSB7XFxuICAgICAgICAgICAgb2Zmc2V0VG9JbmRpY2VzKGksIGtlcm5lbFN0cmlkZXMsIG9mZnNldCk7XFxuICAgICAgICAgICAgaXNQYWQgPSBmYWxzZTtcXG4gICAgICAgICAgICBmb3IgKGludCBqID0gJHthfSAtICR7Y307IGogPCAke2F9OyBqKyspIHtcXG4gICAgICAgICAgICAgIHhbal0gPSBpbmRpY2VzW2pdICogc3RyaWRlc1tqIC0gJHthfSArICR7Y31dXFxuICAgICAgICAgICAgICAgICsgb2Zmc2V0W2ogLSAke2F9ICsgJHtjfV0gLSBwYWRzW2ogLSAyXTtcXG4gICAgICAgICAgICAgICR7eX1cXG4gICAgICAgICAgfVxcbiAgICAgICAgICAke3J9XFxuXFxuICAgICAgICAgIHJldHVybiB2YWx1ZTtcXG4gICAgICAgIH1cXG4gICAgICBgfX0sZD0odCxlKT0+e2xldCBuPVwiXCI7Zm9yKGxldCByPTA7cjx0Lmxlbmd0aDtyKyspbis9YFxcbiAgICAgICR7ZX1bJHtyfV0gPSAke3Rbcl19O1xcbiAgICBgO3JldHVybiBufSxoPXQ9PmBcXG4gIHZvaWQgb2Zmc2V0VG9JbmRpY2VzKGludCBvZmZzZXQsIGludFske3R9XSBzdHJpZGVzLCBvdXQgaW50WyR7dH1dIGluZGljZXMpIHtcXG4gICAgaWYgKCR7dH0gPT0gMCkge1xcbiAgICAgIHJldHVybjtcXG4gICAgfVxcbiAgICBmb3IgKGludCBpID0gMDsgaSA8ICR7dH0gLSAxOyArK2kpIHtcXG4gICAgICBpbmRpY2VzW2ldID0gb2Zmc2V0IC8gc3RyaWRlc1tpXTtcXG4gICAgICBvZmZzZXQgLT0gaW5kaWNlc1tpXSAqIHN0cmlkZXNbaV07XFxuICAgIH1cXG4gICAgaW5kaWNlc1ske3R9IC0gMV0gPSBvZmZzZXQ7XFxuICB9YH0sNDkzOToodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5yZWR1Y2VMb2dTdW1TcXVhcmU9ZS5yZWR1Y2VMb2dTdW09ZS5yZWR1Y2VQcm9kPWUucmVkdWNlTWluPWUucmVkdWNlTWF4PWUucmVkdWNlTWVhbj1lLnJlZHVjZVN1bT1lLnBhcnNlUmVkdWNlQXR0cmlidXRlcz12b2lkIDA7Y29uc3Qgcj1uKDI0NiksaT1uKDc4Miksbz1uKDI1MTcpLGE9bigyMDM5KSxzPSh0LGUsbixyLGkpPT57YyhlKTtjb25zdCBvPXtuYW1lOnIsaW5wdXROYW1lczpbXCJBXCJdLGlucHV0VHlwZXM6W2EuVGV4dHVyZVR5cGUudW5wYWNrZWRdfTtyZXR1cm5bdC5ydW4oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LG8pLHtjYWNoZUhpbnQ6bi5jYWNoZUtleSxnZXQ6KCk9PnUodCxlLG4scixpLG8pfSksZSldfTtlLnBhcnNlUmVkdWNlQXR0cmlidXRlcz10PT57Y29uc3QgZT10LmF0dHJpYnV0ZXMuZ2V0SW50cyhcImF4ZXNcIixbXSksbj0xPT09dC5hdHRyaWJ1dGVzLmdldEludChcImtlZXBkaW1zXCIsMSk7cmV0dXJuKDAsci5jcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkpKHtheGVzOmUsa2VlcERpbXM6bn0pfTtjb25zdCB1PSh0LGUsbixyLGkscyk9Pntjb25zdCB1PVtdLGM9ZVswXS5kaW1zLmxlbmd0aHx8MSxsPVtdLHA9by5TaGFwZVV0aWwubm9ybWFsaXplQXhlcyhuLmF4ZXMsZVswXS5kaW1zLmxlbmd0aCksZj1pKGUscCk7bGV0IGQ9ZlsxXTtmb3IobGV0IHQ9MDt0PGVbMF0uZGltcy5sZW5ndGg7dCsrKXAuaW5kZXhPZih0KT49MHx8MD09PXAubGVuZ3RoPyhuLmtlZXBEaW1zJiZ1LnB1c2goMSksZD1gXFxuICAgICAgICAgIGZvcihpbnQgaiR7dH0gPSAwOyBqJHt0fSA8ICR7ZVswXS5kaW1zW3RdfTsgaiR7dH0rKykge1xcbiAgICAgICAgICAgIGlucHV0SWR4WyR7dH1dID0gaiR7dH07XFxuICAgICAgICAgICAgJHtkfVxcbiAgICAgICAgICB9YCk6KGwucHVzaChgaW5wdXRJZHhbJHt0fV0gPSBvdXRwdXRJZHhbJHt1Lmxlbmd0aH1dO2ApLHUucHVzaChlWzBdLmRpbXNbdF0pKTtjb25zdCBoPWBcXG4gICAgICBmbG9hdCBwcm9jZXNzKGludCBvdXRwdXRJZHhbJHt1Lmxlbmd0aHx8MX1dKSB7XFxuICAgICAgICBmbG9hdCB2YWx1ZTsgICAgICAgICAgICAgICAgIC8vIGZpbmFsIHJlc3VsdFxcbiAgICAgICAgaW50IGlucHV0SWR4WyR7Y31dOyAgICAgIC8vIGFkZHJlc3NpbmcgaW5wdXQgZGF0YVxcbiAgICAgICAgJHtsLmpvaW4oXCJcXG5cIil9XFxuICAgICAgICAke2ZbMF19ICAgICAgIC8vIGluaXQgb3BzIGZvciByZWR1Y2UgbWF4L21pblxcbiAgICAgICAgJHtkfVxcbiAgICAgICAgJHtmWzJdfSAgICAgICAvLyBmaW5hbCBjb21wdXRhdGlvbiBmb3IgcmVkdWNlIG1lYW5cXG4gICAgICAgIHJldHVybiB2YWx1ZTtcXG4gICAgICB9YDtyZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LHMpLHtvdXRwdXQ6e2RpbXM6dSx0eXBlOmVbMF0udHlwZSx0ZXh0dXJlVHlwZTphLlRleHR1cmVUeXBlLnVucGFja2VkfSxzaGFkZXJTb3VyY2U6aH0pfSxjPXQ9PntpZighdHx8MSE9PXQubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIlJlZHVjZSBvcCByZXF1aXJlcyAxIGlucHV0LlwiKTtpZigtMT09PWkuTlVNQkVSX1RZUEVTLmluZGV4T2YodFswXS50eXBlKSl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGlucHV0IHR5cGUuXCIpfTtlLnJlZHVjZVN1bT0odCxlLG4pPT5zKHQsZSxuLFwiUmVkdWNlU3VtXCIsKCgpPT5bXCJ2YWx1ZSA9IDAuMDtcIixcInZhbHVlICs9IF9BKGlucHV0SWR4KTtcIixcIlwiXSkpLGUucmVkdWNlTWVhbj0odCxlLG4pPT5zKHQsZSxuLFwiUmVkdWNlTWVhblwiLCgodCxlKT0+e2xldCBuPTE7Zm9yKGxldCByPTA7cjx0WzBdLmRpbXMubGVuZ3RoO3IrKykoZS5pbmRleE9mKHIpPj0wfHwwPT09ZS5sZW5ndGgpJiYobio9dFswXS5kaW1zW3JdKTtyZXR1cm5bXCJ2YWx1ZSA9IDAuMDtcIixcInZhbHVlICs9IF9BKGlucHV0SWR4KTtcIixgdmFsdWUgLz0gJHtufS47YF19KSksZS5yZWR1Y2VNYXg9KHQsZSxuKT0+cyh0LGUsbixcIlJlZHVjZU1heFwiLCgodCxlKT0+e2NvbnN0IG49W107Zm9yKGxldCByPTA7cjx0WzBdLmRpbXMubGVuZ3RoO3IrKykoZS5pbmRleE9mKHIpPj0wfHwwPT09ZS5sZW5ndGgpJiZuLnB1c2goYGlucHV0SWR4WyR7cn1dID0gMDtgKTtyZXR1cm5bYCR7bi5qb2luKFwiXFxuXCIpfVxcbnZhbHVlID0gX0EoaW5wdXRJZHgpO2AsXCJ2YWx1ZSA9IG1heCh2YWx1ZSwgX0EoaW5wdXRJZHgpKTtcIixcIlwiXX0pKSxlLnJlZHVjZU1pbj0odCxlLG4pPT5zKHQsZSxuLFwiUmVkdWNlTWluXCIsKCh0LGUpPT57Y29uc3Qgbj1bXTtmb3IobGV0IHI9MDtyPHRbMF0uZGltcy5sZW5ndGg7cisrKShlLmluZGV4T2Yocik+PTB8fDA9PT1lLmxlbmd0aCkmJm4ucHVzaChgaW5wdXRJZHhbJHtyfV0gPSAwO2ApO3JldHVybltgJHtuLmpvaW4oXCJcXG5cIil9XFxudmFsdWUgPSBfQShpbnB1dElkeCk7YCxcInZhbHVlID0gbWluKHZhbHVlLCBfQShpbnB1dElkeCkpO1wiLFwiXCJdfSkpLGUucmVkdWNlUHJvZD0odCxlLG4pPT5zKHQsZSxuLFwiUmVkdWNlUHJvZFwiLCgoKT0+W1widmFsdWUgPSAxLjA7XCIsXCJ2YWx1ZSAqPSBfQShpbnB1dElkeCk7XCIsXCJcIl0pKSxlLnJlZHVjZUxvZ1N1bT0odCxlLG4pPT5zKHQsZSxuLFwiUmVkdWNlTG9nU3VtXCIsKCgpPT5bXCJ2YWx1ZSA9IDAuMDtcIixcInZhbHVlICs9IF9BKGlucHV0SWR4KTtcIixcInZhbHVlID0gbG9nKHZhbHVlKTtcIl0pKSxlLnJlZHVjZUxvZ1N1bVNxdWFyZT0odCxlLG4pPT5zKHQsZSxuLFwiUmVkdWNlTG9nU3VtU3F1YXJlXCIsKCgpPT5bXCJmbG9hdCB0OyB2YWx1ZSA9IDAuMDtcIixcInQgPSBfQShpbnB1dElkeCk7IHZhbHVlICs9IHQgKiB0O1wiLFwiXCJdKSl9LDcwMTk6KHQsZSxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUuaXNSZXNoYXBlQ2hlYXA9ZS5wcm9jZXNzRGltczNEPWUuY3JlYXRlUGFja2VkUmVzaGFwZTNEUHJvZ3JhbUluZm9Mb2FkZXI9dm9pZCAwO2NvbnN0IHI9bigyNTE3KSxpPW4oNTA2MCksbz1uKDIwMzkpLGE9bigyODI3KTtlLmNyZWF0ZVBhY2tlZFJlc2hhcGUzRFByb2dyYW1JbmZvTG9hZGVyPSh0LGUsbik9Pntjb25zdCBzPSh0PT4oe25hbWU6XCJSZXNoYXBlIChwYWNrZWQpXCIsaW5wdXRUeXBlczpbby5UZXh0dXJlVHlwZS5wYWNrZWRdLGlucHV0TmFtZXM6W1wiQVwiXSxjYWNoZUhpbnQ6YCR7dH1gfSkpKG4pO3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30scykse2dldDooKT0+KCh0LGUsbixzKT0+e2NvbnN0IHU9ZS5kaW1zLGM9cztsZXQgbD1cIlwiO2ZvcihsZXQgdD0wO3Q8NDt0Kyspe2xldCBlPVwiXCI7c3dpdGNoKHQpe2Nhc2UgMDplPVwib3V0cHV0Q29vcmRzID0gcmM7XCI7YnJlYWs7Y2FzZSAxOmU9XCJvdXRwdXRDb29yZHMgPSBpdmVjMyhyYy54LCByYy55KzEsIHJjLnopO1wiO2JyZWFrO2Nhc2UgMjplPVwib3V0cHV0Q29vcmRzID0gaXZlYzMocmMueCwgcmMueSwgcmMueisxKTtcIjticmVhaztjYXNlIDM6ZT1cIm91dHB1dENvb3JkcyA9IGl2ZWMzKHJjLngsIHJjLnkrMSwgcmMueisxKTtcIjticmVhaztkZWZhdWx0OnRocm93IG5ldyBFcnJvcn1sKz1gXFxuICAgICAgICAke2V9XFxuICAgICAgICAke3Q+MD9cImlmKG91dHB1dENvb3Jkcy55IDwgcm93cyAmJiBvdXRwdXRDb29yZHMueiA8IGNvbHMpe1wiOlwiXCJ9XFxuICAgICAgICAgIGludCBmbGF0dGVuZWRJbmRleCA9IGdldEZsYXR0ZW5lZEluZGV4KG91dHB1dENvb3Jkcyk7XFxuXFxuICAgICAgICAgIGl2ZWMzIGlucHV0UkMgPSBpbnB1dENvb3Jkc0Zyb21SZXNoYXBlZE91dENvb3JkcyhmbGF0dGVuZWRJbmRleCk7XFxuICAgICAgICAgIHZlYzIgaW5uZXJEaW1zID0gdmVjMihmbG9hdChpbnB1dFJDLnkpLGZsb2F0KGlucHV0UkMueikpO1xcblxcbiAgICAgICAgICByZXN1bHRbJHt0fV0gPSBnZXRDaGFubmVsKGdldEEoaW5wdXRSQy54LCBpbnB1dFJDLnksIGlucHV0UkMueiksIGlubmVyRGltcyk7XFxuXFxuICAgICAgICAke3Q+MD9cIn1cIjpcIlwifVxcbiAgICAgIGB9Y29uc3QgcD0oMCxpLmdldEdsc2wpKHQuc2Vzc2lvbi5iYWNrZW5kLmdsQ29udGV4dC52ZXJzaW9uKSxmPWBcXG4gICAgICAke2Z1bmN0aW9uKHQpe2NvbnN0IGU9ci5TaGFwZVV0aWwuY29tcHV0ZVN0cmlkZXModCksbj1bXCJiXCIsXCJyXCIsXCJjXCJdLGk9XCJpbmRleFwiLG89ZS5tYXAoKCh0LHIpPT5gaW50ICR7bltyXX0gPSAke2l9IC8gJHt0fTsgJHtyPT09ZS5sZW5ndGgtMT9gaW50ICR7bltyKzFdfSA9ICR7aX0gLSAke25bcl19ICogJHt0fWA6YGluZGV4IC09ICR7bltyXX0gKiAke3R9YH07YCkpLmpvaW4oXCJcIik7cmV0dXJuYFxcbiAgICBpdmVjMyBpbnB1dENvb3Jkc0Zyb21SZXNoYXBlZE91dENvb3JkcyhpbnQgaW5kZXgpIHtcXG4gICAgICAke299XFxuICAgICAgcmV0dXJuIGl2ZWMzKGIsIHIsIGMpO1xcbiAgICB9XFxuICBgfSh1KX1cXG4gICAgICAke2Z1bmN0aW9uKHQpe2NvbnN0IGU9ci5TaGFwZVV0aWwuY29tcHV0ZVN0cmlkZXModCk7cmV0dXJuYFxcbiAgaW50IGdldEZsYXR0ZW5lZEluZGV4KGl2ZWMzIGNvb3Jkcykge1xcbiAgICAvLyByZXZlcnNlIHksIHogb3JkZXJcXG4gICAgcmV0dXJuIGNvb3Jkcy54ICogJHtlWzBdfSArIGNvb3Jkcy56ICogJHtlWzFdfSArIGNvb3Jkcy55O1xcbiAgfVxcbmB9KGMpfVxcbiAgICAgICR7KDAsYS51bnBhY2tGcm9tQ2hhbm5lbCkoKX1cXG5cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpdmVjMyByYyA9IGdldE91dHB1dENvb3JkcygpO1xcblxcbiAgICAgICAgdmVjNCByZXN1bHQgPSB2ZWM0KDAuMCk7XFxuXFxuICAgICAgICBpdmVjMyBvdXRwdXRDb29yZHM7XFxuICAgICAgICBpbnQgcm93cyA9ICR7Y1syXX07XFxuICAgICAgICBpbnQgY29scyA9ICR7Y1sxXX07XFxuXFxuICAgICAgICAke2x9XFxuICAgICAgICAke3Aub3V0cHV0fSA9IHJlc3VsdDtcXG4gICAgICB9XFxuICAgIGA7cmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxuKSx7b3V0cHV0OntkaW1zOmMsdHlwZTplLnR5cGUsdGV4dHVyZVR5cGU6by5UZXh0dXJlVHlwZS5wYWNrZWR9LHNoYWRlclNvdXJjZTpmLGhhc01haW46ITB9KX0pKHQsZSxzLG4pfSl9LGUucHJvY2Vzc0RpbXMzRD1mdW5jdGlvbih0KXtpZigwPT09dC5sZW5ndGgpcmV0dXJuWzEsMSwxXTtsZXQgZT0xO2ZvcihsZXQgbj0wO248dC5sZW5ndGgtMjsrK24pZSo9dFtuXTtyZXR1cm5bZSx0Lmxlbmd0aD4xP3RbdC5sZW5ndGgtMl06MSx0W3QubGVuZ3RoLTFdXX0sZS5pc1Jlc2hhcGVDaGVhcD1mdW5jdGlvbih0LGUpe2xldCBuPSExO3JldHVybiBuPTA9PT10Lmxlbmd0aHx8MD09PWUubGVuZ3RofHwodC5sZW5ndGg8Mnx8ZS5sZW5ndGg8Mj90W3QubGVuZ3RoLTFdPT09ZVtlLmxlbmd0aC0xXTp0W3QubGVuZ3RoLTFdPT09ZVtlLmxlbmd0aC0xXSYmdFt0Lmxlbmd0aC0yXT09PWVbZS5sZW5ndGgtMl0pLG59fSw3MTg6KHQsZSxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUucmVzaGFwZT12b2lkIDA7Y29uc3Qgcj1uKDI1MTcpO2UucmVzaGFwZT0odCxlKT0+e2NvbnN0IG49ci5TaGFwZVV0aWwuY2FsY3VsYXRlUmVzaGFwZWREaW1zKGVbMF0uZGltcyxlWzFdLmludGVnZXJEYXRhKTtyZXR1cm4gdC5zZXNzaW9uLnBhY2s/W3QucmVzaGFwZVBhY2tlZChlWzBdLG4pXTpbdC5yZXNoYXBlVW5wYWNrZWQoZVswXSxuKV19fSwyMjY4Oih0LGUsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLnBhcnNlUmVzaXplQXR0cmlidXRlc1YxMT1lLnBhcnNlUmVzaXplQXR0cmlidXRlc1YxMD1lLnJlc2l6ZT12b2lkIDA7Y29uc3Qgcj1uKDUwNjApLGk9bigyMDM5KSxvPW4oOTM5MCksYT1uKDI4MjcpLHM9big5NzkzKSx1PXtuYW1lOlwiUmVzaXplXCIsaW5wdXROYW1lczpbXCJBXCJdLGlucHV0VHlwZXM6W2kuVGV4dHVyZVR5cGUucGFja2VkXX07ZS5yZXNpemU9KHQsZSxuKT0+KCgwLHMudmFsaWRhdGVJbnB1dHMpKGUsbiksW3QucnVuKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSx1KSx7Y2FjaGVIaW50Om4uY2FjaGVLZXksZ2V0OigpPT5jKHQsZSxuKX0pLGUpXSksZS5wYXJzZVJlc2l6ZUF0dHJpYnV0ZXNWMTA9dD0+KDAscy5wYXJzZVVwc2FtcGxlQXR0cmlidXRlcykodCwxMCksZS5wYXJzZVJlc2l6ZUF0dHJpYnV0ZXNWMTE9dD0+KDAscy5wYXJzZVVwc2FtcGxlQXR0cmlidXRlcykodCwxMSk7Y29uc3QgYz0odCxlLG4pPT57Y29uc3Qgcz0oMCxyLmdldEdsc2wpKHQuc2Vzc2lvbi5iYWNrZW5kLmdsQ29udGV4dC52ZXJzaW9uKSxbYyxwXT1sKGUsbik7aWYoYy5ldmVyeSgodD0+MT09PXQpKSYmXCJ0Zl9jcm9wX2FuZF9yZXNpemVcIiE9PW4uY29vcmRpbmF0ZVRyYW5zZm9ybU1vZGUpcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSx1KSx7b3V0cHV0OntkaW1zOnAsdHlwZTplWzBdLnR5cGUsdGV4dHVyZVR5cGU6aS5UZXh0dXJlVHlwZS5wYWNrZWR9LGhhc01haW46ITAsc2hhZGVyU291cmNlOmB2b2lkIG1haW4oKSB7XFxuICAgICAgICAgICAgICAgICAgICB2ZWM0IHYgPSAke3MudGV4dHVyZTJEfShYLCBUZXhDb29yZHMpO1xcbiAgICAgICAgICAgICAgICAgICAgJHtzLm91dHB1dH0gPSB2O1xcbiAgICAgICAgICAgICAgICB9YH0pO2NvbnN0IGY9cC5sZW5ndGg7aWYoZjwyKXRocm93IG5ldyBFcnJvcihgb3V0cHV0IGRpbWVuc2lvbiBzaG91bGQgYmUgYXQgbGVhc3QgMiwgYnV0IGdvdCAke2Z9YCk7Y29uc3QgZD1wW2YtMl0saD1wW2YtMV0sZz1lWzBdLmRpbXM7aWYoZiE9PWcubGVuZ3RoKXRocm93IG5ldyBFcnJvcihgb3V0cHV0IGRpbWVuc2lvbiBzaG91bGQgbWF0Y2ggaW5wdXQgJHtnLmxlbmd0aH0sIGJ1dCBnb3QgJHtmfWApO2NvbnN0IGI9Z1tmLTJdLG09Z1tmLTFdLHk9Y1tmLTJdLF89Y1tmLTFdO2xldCB2PVwiXCI7aWYoXCJsaW5lYXJcIiE9PW4ubW9kZSl0aHJvdyBuZXcgRXJyb3IoYHJlc2l6ZSAocGFja2VkKSBkb2VzIG5vdCBzdXBwb3J0IG1vZGU6ICcke24ubW9kZX0nYCk7c3dpdGNoKG4uY29vcmRpbmF0ZVRyYW5zZm9ybU1vZGUpe2Nhc2VcImFzeW1tZXRyaWNcIjp2PVwiXFxuICAgICAgICAgICAgICAgICAgICB2ZWM0IGdldFNvdXJjZUZyYWNJbmRleChpdmVjNCBjb29yZHMpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmVjNChjb29yZHMpIC8gc2NhbGVXSFdIO1xcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICBcIjticmVhaztjYXNlXCJoYWxmX3BpeGVsXCI6dj1cIlxcbiAgICAgICAgICAgICAgICAgICAgdmVjNCBnZXRTb3VyY2VGcmFjSW5kZXgoaXZlYzQgY29vcmRzKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICh2ZWM0KGNvb3JkcykgKyAwLjUpIC8gc2NhbGVXSFdIIC0gMC41O1xcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICBcIjticmVhaztjYXNlXCJweXRvcmNoX2hhbGZfcGl4ZWxcIjp2PWBcXG4gICAgICAgICAgICAgICAgICAgIHZlYzQgZ2V0U291cmNlRnJhY0luZGV4KGl2ZWM0IGNvb3Jkcykge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlYzQgZmNvb3JkcyA9IHZlYzQoY29vcmRzKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmVjNChcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJHtofS4wID4gMS4wID8gKGZjb29yZHMueCArIDAuNSkgLyBzY2FsZVdIV0gueCAtIDAuNSA6IDAuMCxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJHtkfS4wID4gMS4wID8gKGZjb29yZHMueSArIDAuNSkgLyBzY2FsZVdIV0gueSAtIDAuNSA6IDAuMCxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJHtofS4wID4gMS4wID8gKGZjb29yZHMueiArIDAuNSkgLyBzY2FsZVdIV0gueiAtIDAuNSA6IDAuMCxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJHtkfS4wID4gMS4wID8gKGZjb29yZHMudyArIDAuNSkgLyBzY2FsZVdIV0gudyAtIDAuNSA6IDAuMFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgYDticmVhaztjYXNlXCJhbGlnbl9jb3JuZXJzXCI6dj1gXFxuICAgICAgICAgICAgICAgICAgICB2ZWM0IGdldFNvdXJjZUZyYWNJbmRleChpdmVjNCBjb29yZHMpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICB2ZWM0IHJlc2l6ZWQgPSB2ZWM0KCR7aH0uMCAtIDEuMCwgJHtkfS4wIC0gMS4wLCAke2h9LjAgLSAxLjAsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICR7ZH0uMCAtIDEuMCk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgdmVjNCBvcmlnaW5hbCA9IHZlYzQoJHttfS4wIC0gMS4wLCAke2J9LjAgLSAxLjAsICR7bX0uMCAtIDEuMCxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJHtifS4wIC0gMS4wKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICB2ZWM0IG5ld19zY2FsZSA9IG9yaWdpbmFsIC8gcmVzaXplZDtcXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmVjNChjb29yZHMpICogbmV3X3NjYWxlO1xcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICBgO2JyZWFrO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGByZXNpemUgKHBhY2tlZCkgZG9lcyBub3Qgc3VwcG9ydCBjb29yZGluYXRlVHJhbnNmb3JtTW9kZTogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnJHtuLmNvb3JkaW5hdGVUcmFuc2Zvcm1Nb2RlfSdgKX1jb25zdCB3PSgwLG8uZ2V0Q29vcmRzRGF0YVR5cGUpKGYpLHg9YFxcbiAgICAgICAgICAgIGNvbnN0IHZlYzIgaW5wdXRXSCA9IHZlYzIoJHtifS4wLCAke219LjApO1xcbiAgICAgICAgICAgIGNvbnN0IHZlYzQgc2NhbGVXSFdIID0gdmVjNChmbG9hdCgke3l9KSwgZmxvYXQoJHtffSksIGZsb2F0KCR7eX0pLCBmbG9hdCgke199KSk7XFxuICAgICAgICAgICAgJHsoMCxhLnVucGFja0Zyb21DaGFubmVsKSgpfVxcbiAgICAgICAgICAgICR7dn1cXG4gICAgICAgICAgICBmbG9hdCBnZXRBVmFsdWUoaW50IHgxMCwgaW50IHIsIGludCBjLCBpbnQgZCkge1xcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0Q2hhbm5lbChnZXRBKHgxMCwgciwgYywgZCksIHZlYzIoYywgZCkpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICAgICAgICAgICR7d30gcmMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG5cXG4gICAgICAgICAgICAgICAgaW50IGJhdGNoID0gcmNbMF07XFxuICAgICAgICAgICAgICAgIGludCBkZXB0aCA9IHJjWzFdO1xcblxcbiAgICAgICAgICAgICAgICAvLyByZXRyaWV2ZSB0aGUgNCBjb29yZGluYXRlcyB0aGF0IGlzIHVzZWQgaW4gdGhlIDQgcGFja2VkIG91dHB1dCB2YWx1ZXMuXFxuICAgICAgICAgICAgICAgIGl2ZWM0IGNvb3JkcyA9IGl2ZWM0KHJjLnd6LCByYy53ICsgMSwgcmMueiArIDEpO1xcblxcbiAgICAgICAgICAgICAgICAvLyBjYWxjdWxhdGUgdGhlIHNvdXJjZSBpbmRleCBpbiBmcmFjdGlvblxcbiAgICAgICAgICAgICAgICB2ZWM0IHNvdXJjZUZyYWMgPSBnZXRTb3VyY2VGcmFjSW5kZXgoY29vcmRzKTtcXG5cXG4gICAgICAgICAgICAgICAgLy8gZ2V0IHRoZSBsb3dlciBhbmQgdXBwZXIgYm91bmQgb2YgdGhlIDQgdmFsdWVzIHRoYXQgd2lsbCBiZSBwYWNrZWQgaW50byBvbmUgdGV4ZWwuXFxuICAgICAgICAgICAgICAgIGl2ZWM0IHgwMCA9IGl2ZWM0KG1heChzb3VyY2VGcmFjLnh5LCB2ZWMyKDAuMCkpLCBtaW4oaW5wdXRXSCAtIDEuMCwgY2VpbChzb3VyY2VGcmFjLnh5KSkpO1xcbiAgICAgICAgICAgICAgICBpdmVjNCB4MDEgPSBpdmVjNChtYXgoc291cmNlRnJhYy54dywgdmVjMigwLjApKSwgbWluKGlucHV0V0ggLSAxLjAsIGNlaWwoc291cmNlRnJhYy54dykpKTtcXG4gICAgICAgICAgICAgICAgaXZlYzQgeDEwID0gaXZlYzQobWF4KHNvdXJjZUZyYWMuenksIHZlYzIoMC4wKSksIG1pbihpbnB1dFdIIC0gMS4wLCBjZWlsKHNvdXJjZUZyYWMuenkpKSk7XFxuICAgICAgICAgICAgICAgIGl2ZWM0IHgxMSA9IGl2ZWM0KG1heChzb3VyY2VGcmFjLnp3LCB2ZWMyKDAuMCkpLCBtaW4oaW5wdXRXSCAtIDEuMCwgY2VpbChzb3VyY2VGcmFjLnp3KSkpO1xcblxcbiAgICAgICAgICAgICAgICBib29sIGhhc05leHRSb3cgPSByYy53IDwgJHtkLTF9O1xcbiAgICAgICAgICAgICAgICBib29sIGhhc05leHRDb2wgPSByYy56IDwgJHtoLTF9O1xcblxcbiAgICAgICAgICAgICAgICAvLyBwYWNrIHgwMCwgeDAxLCB4MTAsIHgxMSdzIHRvcC1sZWZ0IGNvcm5lciBpbnRvIG9uZSB2ZWM0IHN0cnVjdHVyZVxcbiAgICAgICAgICAgICAgICB2ZWM0IHRvcExlZnQgPSB2ZWM0KFxcbiAgICAgICAgICAgICAgICAgICAgZ2V0QVZhbHVlKGJhdGNoLCBkZXB0aCwgeDAwLngsIHgwMC55KSxcXG4gICAgICAgICAgICAgICAgICAgIGhhc05leHRDb2wgPyBnZXRBVmFsdWUoYmF0Y2gsIGRlcHRoLCB4MDEueCwgeDAxLnkpIDogMC4wLFxcbiAgICAgICAgICAgICAgICAgICAgaGFzTmV4dFJvdyA/IGdldEFWYWx1ZShiYXRjaCwgZGVwdGgsIHgxMC54LCB4MTAueSkgOiAwLjAsXFxuICAgICAgICAgICAgICAgICAgICAoaGFzTmV4dFJvdyAmJiBoYXNOZXh0Q29sKSA/IGdldEFWYWx1ZShiYXRjaCwgZGVwdGgsIHgxMS54LCB4MTEueSkgOiAwLjApO1xcblxcbiAgICAgICAgICAgICAgICAvLyBwYWNrIHgwMCwgeDAxLCB4MTAsIHgxMSdzIHRvcC1yaWdodCBjb3JuZXIgaW50byBvbmUgdmVjNCBzdHJ1Y3R1cmVcXG4gICAgICAgICAgICAgICAgdmVjNCB0b3BSaWdodCA9IHZlYzQoXFxuICAgICAgICAgICAgICAgICAgICBnZXRBVmFsdWUoYmF0Y2gsIGRlcHRoLCB4MDAueCwgeDAwLncpLFxcbiAgICAgICAgICAgICAgICAgICAgaGFzTmV4dENvbCA/IGdldEFWYWx1ZShiYXRjaCwgZGVwdGgsIHgwMS54LCB4MDEudykgOiAwLjAsXFxuICAgICAgICAgICAgICAgICAgICBoYXNOZXh0Um93ID8gZ2V0QVZhbHVlKGJhdGNoLCBkZXB0aCwgeDEwLngsIHgxMC53KSA6IDAuMCxcXG4gICAgICAgICAgICAgICAgICAgIChoYXNOZXh0Um93ICYmIGhhc05leHRDb2wpID8gZ2V0QVZhbHVlKGJhdGNoLCBkZXB0aCwgeDExLngsIHgxMS53KSA6IDAuMCk7XFxuXFxuICAgICAgICAgICAgICAgIC8vIHBhY2sgeDAwLCB4MDEsIHgxMCwgeDExJ3MgYm90dG9tLWxlZnQgY29ybmVyIGludG8gb25lIHZlYzQgc3RydWN0dXJlXFxuICAgICAgICAgICAgICAgIHZlYzQgYm90dG9tTGVmdCA9IHZlYzQoXFxuICAgICAgICAgICAgICAgICAgICBnZXRBVmFsdWUoYmF0Y2gsIGRlcHRoLCB4MDAueiwgeDAwLnkpLFxcbiAgICAgICAgICAgICAgICAgICAgaGFzTmV4dENvbCA/IGdldEFWYWx1ZShiYXRjaCwgZGVwdGgsIHgwMS56LCB4MDEueSkgOiAwLjAsXFxuICAgICAgICAgICAgICAgICAgICBoYXNOZXh0Um93ID8gZ2V0QVZhbHVlKGJhdGNoLCBkZXB0aCwgeDEwLnosIHgxMC55KSA6IDAuMCxcXG4gICAgICAgICAgICAgICAgICAgIChoYXNOZXh0Um93ICYmIGhhc05leHRDb2wpID8gZ2V0QVZhbHVlKGJhdGNoLCBkZXB0aCwgeDExLnosIHgxMS55KSA6IDAuMCk7XFxuXFxuICAgICAgICAgICAgICAgIC8vIHBhY2sgeDAwLCB4MDEsIHgxMCwgeDExJ3MgYm90dG9tLXJpZ2h0IGNvcm5lciBpbnRvIG9uZSB2ZWM0IHN0cnVjdHVyZVxcbiAgICAgICAgICAgICAgICB2ZWM0IGJvdHRvbVJpZ2h0ID0gdmVjNChcXG4gICAgICAgICAgICAgICAgICAgIGdldEFWYWx1ZShiYXRjaCwgZGVwdGgsIHgwMC56LCB4MDAudyksXFxuICAgICAgICAgICAgICAgICAgICBoYXNOZXh0Q29sID8gZ2V0QVZhbHVlKGJhdGNoLCBkZXB0aCwgeDAxLnosIHgwMS53KSA6IDAuMCxcXG4gICAgICAgICAgICAgICAgICAgIGhhc05leHRSb3cgPyBnZXRBVmFsdWUoYmF0Y2gsIGRlcHRoLCB4MTAueiwgeDEwLncpIDogMC4wLFxcbiAgICAgICAgICAgICAgICAgICAgKGhhc05leHRSb3cgJiYgaGFzTmV4dENvbCkgPyBnZXRBVmFsdWUoYmF0Y2gsIGRlcHRoLCB4MTEueiwgeDExLncpIDogMC4wKTtcXG5cXG4gICAgICAgICAgICAgICAgLy8gY2FsY3VsYXRlIHRoZSBpbnRlcnBvbGF0aW9uIGZyYWN0aW9uIG9uIHUgYW5kIHYgZGlyZWN0aW9uXFxuICAgICAgICAgICAgICAgIHZlYzQgZnJhYyA9IHZlYzQoc291cmNlRnJhYykgLSBmbG9vcihzb3VyY2VGcmFjKTtcXG4gICAgICAgICAgICAgICAgdmVjNCBjbGFtcEZyYWMgPSBjbGFtcChmcmFjLCB2ZWM0KDAuMCksIHZlYzQoMS4wKSk7XFxuXFxuICAgICAgICAgICAgICAgIHZlYzQgdG9wID0gbWl4KHRvcExlZnQsIHRvcFJpZ2h0LCBjbGFtcEZyYWMueXd5dyk7XFxuICAgICAgICAgICAgICAgIHZlYzQgYm90dG9tID0gbWl4KGJvdHRvbUxlZnQsIGJvdHRvbVJpZ2h0LCBjbGFtcEZyYWMueXd5dyk7XFxuICAgICAgICAgICAgICAgIHZlYzQgbmV3VmFsdWUgPSBtaXgodG9wLCBib3R0b20sIGNsYW1wRnJhYy54eHp6KTtcXG5cXG4gICAgICAgICAgICAgICAgJHtzLm91dHB1dH0gPSB2ZWM0KG5ld1ZhbHVlKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICBgO3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sdSkse291dHB1dDp7ZGltczpwLHR5cGU6ZVswXS50eXBlLHRleHR1cmVUeXBlOmkuVGV4dHVyZVR5cGUucGFja2VkfSxoYXNNYWluOiEwLHNoYWRlclNvdXJjZTp4fSl9LGw9KHQsZSk9Pntjb25zdCBuPXRbMF0uZGltcztsZXQgcixpPWUuc2NhbGVzO2lmKDA9PT1pLmxlbmd0aCl7Y29uc3Qgbz10W2Uuc2NhbGVzSW5wdXRJZHhdO2lmKG8mJjAhPT1vLnNpemUpe2lmKHRbZS5zaXplc0lucHV0SWR4XSl0aHJvdyBuZXcgRXJyb3IoXCJPbmx5IG9uZSBvZiBzY2FsZXMgb3Igc2l6ZXMgbXVzdCBiZSBwcm92aWRlZCBhcyBpbnB1dC5cIik7aT1wKG8sZS5tb2RlLGUuaXNSZXNpemUpfWVsc2V7Y29uc3Qgbz10W2Uuc2l6ZXNJbnB1dElkeF07aWYoIW98fDA9PT1vLnNpemUpdGhyb3cgbmV3IEVycm9yKFwiRWl0aGVyIHNjYWxlcyBvciBzaXplcyBNVVNUIGJlIHByb3ZpZGVkIGFzIGlucHV0LlwiKTtyPUFycmF5LmZyb20oby5pbnRlZ2VyRGF0YSksaT1mKHIsbixlLm1vZGUsZS5pc1Jlc2l6ZSl9fWVsc2UgaWYodFtlLnNpemVzSW5wdXRJZHhdKXRocm93IG5ldyBFcnJvcihcIk9ubHkgb25lIG9mIHNjYWxlcyBvciBzaXplcyBtdXN0IGJlIHByb3ZpZGVkIGFzIGlucHV0LlwiKTtjb25zdCBvPXJ8fG4ubWFwKCgodCxlKT0+TWF0aC5mbG9vcih0KmlbZV0pKSk7cmV0dXJuW2ksb119LHA9KHQsZSxuKT0+e2NvbnN0IHI9QXJyYXkuZnJvbSh0LmZsb2F0RGF0YSk7cmV0dXJuKDAscy5zY2FsZXNWYWxpZGF0aW9uKShyLGUsbikscn0sZj0odCxlLG4scik9Pntjb25zdCBpPWUubGVuZ3RoLG89bmV3IEFycmF5KGkpO2ZvcihsZXQgbj0wLHI9aTtuPHI7bisrKWlmKDA9PT1lW25dKXtpZigwIT09dFtuXSl0aHJvdyBuZXcgRXJyb3IoXCJJbnB1dCBkaW0gaXMgemVybyBidXQgcmVxdWlyZWQgb3V0cHV0IGRpbSBpcyBub24temVyby5cIik7b1tuXT0xfWVsc2Ugb1tuXT10W25dL2Vbbl07cmV0dXJuKDAscy5zY2FsZXNWYWxpZGF0aW9uKShvLG4sciksb319LDgxMTc6KHQsZSxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUuc2hhcGU9dm9pZCAwO2NvbnN0IHI9big5MTYyKTtlLnNoYXBlPSh0LGUpPT4oaShlKSxbbmV3IHIuVGVuc29yKFtlWzBdLmRpbXMubGVuZ3RoXSxcImludDMyXCIsdm9pZCAwLHZvaWQgMCxuZXcgSW50MzJBcnJheShlWzBdLmRpbXMpKV0pO2NvbnN0IGk9dD0+e2lmKCF0fHwxIT09dC5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiU2hhcGUgcmVxdWlyZXMgMSBpbnB1dC5cIil9fSwyMjc4Oih0LGUsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLnNsaWNlVjEwPWUucGFyc2VTbGljZUF0dHJpYnV0ZXM9ZS5zbGljZT12b2lkIDA7Y29uc3Qgcj1uKDI0NiksaT1uKDc4Miksbz1uKDI1MTcpLGE9bigyMDM5KSxzPXtuYW1lOlwiU2xpY2VcIixpbnB1dE5hbWVzOltcIkFcIl0saW5wdXRUeXBlczpbYS5UZXh0dXJlVHlwZS51bnBhY2tlZF19O2Uuc2xpY2U9KHQsZSxuKT0+KGMoZSksW3QucnVuKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxzKSx7Y2FjaGVIaW50Om4uY2FjaGVLZXksZ2V0OigpPT51KHQsZVswXSxuKX0pLGUpXSksZS5wYXJzZVNsaWNlQXR0cmlidXRlcz10PT57Y29uc3QgZT10LmF0dHJpYnV0ZXMuZ2V0SW50cyhcInN0YXJ0c1wiKSxuPXQuYXR0cmlidXRlcy5nZXRJbnRzKFwiZW5kc1wiKSxpPXQuYXR0cmlidXRlcy5nZXRJbnRzKFwiYXhlc1wiLFtdKTtyZXR1cm4oMCxyLmNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSkoe3N0YXJ0czplLGVuZHM6bixheGVzOml9KX07Y29uc3QgdT0odCxlLG4pPT57Y29uc3Qgcj0wPT09bi5heGVzLmxlbmd0aD9lLmRpbXMuc2xpY2UoMCkubWFwKCgodCxlKT0+ZSkpOm4uYXhlcyxpPW8uU2hhcGVVdGlsLm5vcm1hbGl6ZUF4ZXMocixlLmRpbXMubGVuZ3RoKSx1PW4uc3RhcnRzLm1hcCgoKHQsbik9PnQ+ZS5kaW1zW2lbbl1dLTE/ZS5kaW1zW2lbbl1dOm8uU2hhcGVVdGlsLm5vcm1hbGl6ZUF4aXModCxlLmRpbXNbaVtuXV0pKSksYz1uLmVuZHMubWFwKCgodCxuKT0+dD5lLmRpbXNbaVtuXV0tMT9lLmRpbXNbaVtuXV06by5TaGFwZVV0aWwubm9ybWFsaXplQXhpcyh0LGUuZGltc1tpW25dXSkpKSxsPWUuZGltcy5zbGljZSgpLHA9W107Zm9yKGxldCB0PTA7dDxpLmxlbmd0aDt0KyspbFtpW3RdXT1jW3RdLXVbdF0sdVt0XT4wJiZwLnB1c2goYG91dHB1dElkeFske2lbdF19XSArPSAke3VbdF19O2ApO2NvbnN0IGY9YFxcbiAgICAgIGZsb2F0IHByb2Nlc3MoaW50IG91dHB1dElkeFske2wubGVuZ3RofV0pIHtcXG4gICAgICAgICR7cC5qb2luKFwiXFxuICAgICAgXCIpfVxcbiAgICAgICAgcmV0dXJuIF9BKG91dHB1dElkeCk7XFxuICAgICAgfWA7cmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxzKSx7b3V0cHV0OntkaW1zOmwsdHlwZTplLnR5cGUsdGV4dHVyZVR5cGU6YS5UZXh0dXJlVHlwZS51bnBhY2tlZH0sc2hhZGVyU291cmNlOmZ9KX0sYz10PT57aWYoIXR8fDEhPT10Lmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJTbGljZSByZXF1aXJlcyAxIGlucHV0LlwiKTtpZigtMT09PWkuTlVNQkVSX1RZUEVTLmluZGV4T2YodFswXS50eXBlKSl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGlucHV0IHR5cGUuXCIpfTtlLnNsaWNlVjEwPSh0LGUpPT57cChlKTtjb25zdCBuPWwodCxlKTtyZXR1cm5bdC5ydW4oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LHMpLHtjYWNoZUhpbnQ6bi5jYWNoZUtleSxnZXQ6KCk9PnUodCxlWzBdLG4pfSksW2VbMF1dKV19O2NvbnN0IGw9KHQsZSk9PntpZighdC5zZXNzaW9uLmlzSW5pdGlhbGl6ZXIoZVsxXS5kYXRhSWQpfHwhdC5zZXNzaW9uLmlzSW5pdGlhbGl6ZXIoZVsyXS5kYXRhSWQpfHxlLmxlbmd0aD49NCYmIXQuc2Vzc2lvbi5pc0luaXRpYWxpemVyKGVbM10uZGF0YUlkKXx8ZS5sZW5ndGg+PTUmJiF0LnNlc3Npb24uaXNJbml0aWFsaXplcihlWzRdLmRhdGFJZCkpdGhyb3cgbmV3IEVycm9yKFwiZHluYW1pYyBzbGljZSBhdHRyaWJ1dGVzIGFyZSBub3QgYWxsb3dlZFwiKTtpZihlLmxlbmd0aD49NSYmZVs0XS5pbnRlZ2VyRGF0YS5zb21lKCh0PT4xIT09dCkpKXRocm93IG5ldyBFcnJvcihcImN1cnJlbnRseSBub24tMSBzdGVwcyBpcyBub3Qgc3VwcG9ydGVkIGZvciBTbGljZVwiKTtjb25zdCBuPUFycmF5LmZyb20oZVsxXS5pbnRlZ2VyRGF0YSkscj1BcnJheS5mcm9tKGVbMl0uaW50ZWdlckRhdGEpLGk9ZS5sZW5ndGg+PTQ/QXJyYXkuZnJvbShlWzNdLmludGVnZXJEYXRhKTpbXTtyZXR1cm57c3RhcnRzOm4sZW5kczpyLGF4ZXM6aSxjYWNoZUtleTpgJHtpfTske259OyR7cn1gfX0scD10PT57aWYoIXR8fHQubGVuZ3RoPDN8fHQubGVuZ3RoPjUpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbnB1dCBudW1iZXIuXCIpO2lmKFwiaW50MzJcIiE9PXRbMV0udHlwZXx8MSE9PXRbMV0uZGltcy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbnB1dCB0eXBlLlwiKTtpZihcImludDMyXCIhPT10WzJdLnR5cGV8fDEhPT10WzJdLmRpbXMubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW5wdXQgdHlwZS5cIik7aWYodC5sZW5ndGg+PTQmJihcImludDMyXCIhPT10WzNdLnR5cGV8fDEhPT10WzNdLmRpbXMubGVuZ3RoKSl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGlucHV0IHR5cGUuXCIpO2lmKHQubGVuZ3RoPj01JiYoXCJpbnQzMlwiIT09dFs0XS50eXBlfHwxIT09dFs0XS5kaW1zLmxlbmd0aCkpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbnB1dCB0eXBlLlwiKX19LDU1MjQ6KHQsZSxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUuc29mdG1heFYxMz1lLnBhcnNlU29mdG1heEF0dHJpYnV0ZXNWMTM9ZS5wYXJzZVNvZnRtYXhBdHRyaWJ1dGVzPWUuc29mdG1heD12b2lkIDA7Y29uc3Qgcj1uKDI0NiksaT1uKDI1MTcpLG89big1MDYwKSxhPW4oMjAzOSkscz1uKDM3MzgpLHU9e25hbWU6XCJTb2Z0bWF4Q29tcHV0ZU1heFwiLGlucHV0TmFtZXM6W1wiQVwiXSxpbnB1dFR5cGVzOlthLlRleHR1cmVUeXBlLnVucGFja2VkXX0sYz17bmFtZTpcIlNvZnRtYXhDb21wdXRlU2NhbGVcIixpbnB1dE5hbWVzOltcIkFcIixcIk1heFwiXSxpbnB1dFR5cGVzOlthLlRleHR1cmVUeXBlLnVucGFja2VkLGEuVGV4dHVyZVR5cGUudW5wYWNrZWRdfSxsPXtuYW1lOlwiU29mdE1heFwiLGlucHV0TmFtZXM6W1wiQVwiLFwiTWF4XCIsXCJOb3JtXCJdLGlucHV0VHlwZXM6W2EuVGV4dHVyZVR5cGUudW5wYWNrZWQsYS5UZXh0dXJlVHlwZS51bnBhY2tlZCxhLlRleHR1cmVUeXBlLnVucGFja2VkXX07ZS5zb2Z0bWF4PSh0LGUsbik9PntnKGUpO2NvbnN0IHI9ZVswXS5kaW1zLnNsaWNlKCksbz1pLlNoYXBlVXRpbC5ub3JtYWxpemVBeGlzKG4uYXhpcyxyLmxlbmd0aCksYT1pLlNoYXBlVXRpbC5zaXplVG9EaW1lbnNpb24ocixvKSxzPWkuU2hhcGVVdGlsLnNpemVGcm9tRGltZW5zaW9uKHIsbyk7cmV0dXJuIHAodCxlLG4sYSxzKX0sZS5wYXJzZVNvZnRtYXhBdHRyaWJ1dGVzPXQ9PigwLHIuY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KSh7YXhpczp0LmF0dHJpYnV0ZXMuZ2V0SW50KFwiYXhpc1wiLDEpfSksZS5wYXJzZVNvZnRtYXhBdHRyaWJ1dGVzVjEzPXQ9PigwLHIuY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KSh7YXhpczp0LmF0dHJpYnV0ZXMuZ2V0SW50KFwiYXhpc1wiLC0xKX0pLGUuc29mdG1heFYxMz0odCxlLG4pPT57ZyhlKTtjb25zdCBvPWVbMF0uZGltcy5zbGljZSgpLGE9aS5TaGFwZVV0aWwubm9ybWFsaXplQXhpcyhuLmF4aXMsby5sZW5ndGgpLHU9by5sZW5ndGgsYz1hIT09dS0xLGw9W107bGV0IGYsZD1bXSxoPVtdO2MmJihkPUFycmF5LmZyb20oe2xlbmd0aDp1fSkubWFwKCgodCxlKT0+ZSkpLGRbYV09dS0xLGRbdS0xXT1hLGQubWFwKCh0PT5sLnB1c2gob1t0XSkpKSxmPSgwLHIuY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KSh7cGVybTpkfSksaD0oMCxzLnRyYW5zcG9zZSkodCxlLGYpKTtjb25zdCBiPWM/aS5TaGFwZVV0aWwuc2l6ZVRvRGltZW5zaW9uKGwsdS0xKTppLlNoYXBlVXRpbC5zaXplVG9EaW1lbnNpb24obyx1LTEpLG09Yz9pLlNoYXBlVXRpbC5zaXplRnJvbURpbWVuc2lvbihsLHUtMSk6aS5TaGFwZVV0aWwuc2l6ZUZyb21EaW1lbnNpb24obyx1LTEpLHk9cCh0LGM/aDplLG4sYixtKTtyZXR1cm4gYz8oMCxzLnRyYW5zcG9zZSkodCx5LGYpOnl9O2NvbnN0IHA9KHQsZSxuLHIsaSk9Pntjb25zdCBvPWYodCxlWzBdLHIsaSxbcl0pLGE9dC5ydW4oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LHUpLHtjYWNoZUhpbnQ6bi5jYWNoZUtleSxnZXQ6KCk9Pm99KSxlKSxzPWQodCxlWzBdLHIsaSxvLm91dHB1dC5kaW1zLFtyXSkscD10LnJ1bihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sYykse2NhY2hlSGludDpuLmNhY2hlS2V5LGdldDooKT0+c30pLFtlWzBdLGFdKSxnPWgodCxlWzBdLHIsaSxvLm91dHB1dC5kaW1zLHMub3V0cHV0LmRpbXMpO3JldHVyblt0LnJ1bihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sbCkse2NhY2hlSGludDpuLmNhY2hlS2V5LGdldDooKT0+Z30pLFtlWzBdLGEscF0pXX0sZj0odCxlLG4scixpKT0+e2NvbnN0W3MsY109dC5jYWxjdWxhdGVUZXh0dXJlV2lkdGhBbmRIZWlnaHQoZS5kaW1zLGEuVGV4dHVyZVR5cGUudW5wYWNrZWQpLGw9aS5sZW5ndGg7aWYobjwxfHxyPDEpdGhyb3cgbmV3IEVycm9yKFwiTG9naWNhbCByb3cgY291bnQgTiBhbmQgZmVhdHVyZSBjb3VudCBEIG11c3QgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIDFcIik7aWYoMSE9PWkubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIkRpbWVuc2lvbmFsaXR5IG9mIHRoZSBvdXRwdXQgc2hvdWxkIGJlIDFcIik7aWYoaVswXSE9PW4pdGhyb3cgbmV3IEVycm9yKFwiU2hhcGUgb2YgdGhlIG91dHB1dCBzaG91bGQgYmUgZXF1YWwgdG8gbG9naWNhbCByb3cgY291bnRcIik7Y29uc3QgcD0oMCxvLmdldEdsc2wpKHQuc2Vzc2lvbi5iYWNrZW5kLmdsQ29udGV4dC52ZXJzaW9uKSxmPWBcXG4gICAgICBmbG9hdCBwcm9jZXNzKGludFske2x9XSBpbmRpY2VzKSB7XFxuICAgICAgICBpbnQgbG9naWNhbF9yb3dfc3RhcnRfb2Zmc2V0ID0gaW5kaWNlc1swXSAqICR7cn07XFxuXFxuICAgICAgICBmbG9hdCBtYXggPSBnZXRDb2xvckFzRmxvYXQoJHtwLnRleHR1cmUyRH0oQSwgb2Zmc2V0VG9Db29yZHMobG9naWNhbF9yb3dfc3RhcnRfb2Zmc2V0LCAke3N9LFxcbiAgICAgICAgJHtjfSApKSk7XFxuICAgICAgICBmb3IoaW50IGk9MTsgaTwke3J9OyArK2kpXFxuICAgICAgICB7XFxuICAgICAgICAgIGZsb2F0IGN1cnJlbnQgPSBnZXRDb2xvckFzRmxvYXQoJHtwLnRleHR1cmUyRH0oQSwgb2Zmc2V0VG9Db29yZHMobG9naWNhbF9yb3dfc3RhcnRfb2Zmc2V0ICsgaSxcXG4gICAgICAgICAgICAke3N9LCAke2N9KSkpO1xcbiAgICAgICAgICBpZihjdXJyZW50ID4gbWF4KVxcbiAgICAgICAgICBtYXggPSBjdXJyZW50O1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgcmV0dXJuIG1heDtcXG4gICAgICB9YDtyZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LHUpLHtvdXRwdXQ6e2RpbXM6aSx0eXBlOmUudHlwZSx0ZXh0dXJlVHlwZTphLlRleHR1cmVUeXBlLnVucGFja2VkfSxzaGFkZXJTb3VyY2U6Zn0pfSxkPSh0LGUsbixyLGkscyk9Pntjb25zdFt1LGxdPXQuY2FsY3VsYXRlVGV4dHVyZVdpZHRoQW5kSGVpZ2h0KGUuZGltcyxhLlRleHR1cmVUeXBlLnVucGFja2VkKSxwPXMubGVuZ3RoO2lmKG48MXx8cjwxKXRocm93IG5ldyBFcnJvcihcIkxvZ2ljYWwgcm93IGNvdW50IE4gYW5kIGZlYXR1cmUgY291bnQgRCBtdXN0IGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAxXCIpO2lmKDEhPT1zLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJEaW1lbnNpb25hbGl0eSBvZiB0aGUgb3V0cHV0IHNob3VsZCBiZSAxXCIpO2lmKHNbMF0hPT1uKXRocm93IG5ldyBFcnJvcihcIlNoYXBlIG9mIHRoZSBvdXRwdXQgc2hvdWxkIGJlIGVxdWFsIHRvIGxvZ2ljYWwgcm93IGNvdW50XCIpO2lmKDEhPT1pLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJEaW1lbnNpb25hbGl0eSBvZiB0aGUgaW50ZXJtZWRpYXRlIHJlc3VsdHMgc2hvdWxkIGJlIDFcIik7aWYoaVswXSE9PW4pdGhyb3cgbmV3IEVycm9yKFwiU2hhcGUgb2YgdGhlIGludGVybWVkaWF0ZSByZXN1bHRzIHNob3VsZCBiZSBlcXVhbCB0byBsb2dpY2FsIHJvdyBjb3VudFwiKTtjb25zdCBmPWBcXG4gICAgICBmbG9hdCBwcm9jZXNzKGludFske3B9XSBpbmRpY2VzKSB7XFxuICAgICAgICBpbnQgbG9naWNhbF9yb3dfc3RhcnRfb2Zmc2V0ID0gaW5kaWNlc1swXSAqICR7cn07XFxuXFxuICAgICAgICBmbG9hdCBub3JtX2ZhY3RvciA9IDAuMDtcXG4gICAgICAgIGZsb2F0IG1heCA9IF9NYXgoaW5kaWNlcyk7XFxuICAgICAgICBmb3IoaW50IGk9MDsgaTwke3J9OyArK2kpXFxuICAgICAgICB7XFxuICAgICAgICAgIG5vcm1fZmFjdG9yICs9IGV4cChnZXRDb2xvckFzRmxvYXQoJHsoMCxvLmdldEdsc2wpKHQuc2Vzc2lvbi5iYWNrZW5kLmdsQ29udGV4dC52ZXJzaW9uKS50ZXh0dXJlMkR9KEEsIG9mZnNldFRvQ29vcmRzKGxvZ2ljYWxfcm93X3N0YXJ0X29mZnNldCArIGksXFxuICAgICAgICAgICAgJHt1fSwgJHtsfSkpKSAtIG1heCk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICByZXR1cm4gbm9ybV9mYWN0b3I7XFxuICAgICAgfWA7cmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxjKSx7b3V0cHV0OntkaW1zOnMsdHlwZTplLnR5cGUsdGV4dHVyZVR5cGU6YS5UZXh0dXJlVHlwZS51bnBhY2tlZH0sc2hhZGVyU291cmNlOmZ9KX0saD0odCxlLG4scixpLG8pPT57Y29uc3Rbcyx1XT10LmNhbGN1bGF0ZVRleHR1cmVXaWR0aEFuZEhlaWdodChlLmRpbXMsYS5UZXh0dXJlVHlwZS51bnBhY2tlZCksYz1lLmRpbXMubGVuZ3RoO2lmKG48MXx8cjwxKXRocm93IG5ldyBFcnJvcihcIkxvZ2ljYWwgcm93IGNvdW50IE4gYW5kIGZlYXR1cmUgY291bnQgRCBtdXN0IGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAxXCIpO2lmKDEhPT1pLmxlbmd0aHx8MSE9PW8ubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIkRpbWVuc2lvbmFsaXR5IG9mIHRoZSBpbnRlcm1lZGlhdGUgcmVzdWx0cyBzaG91bGQgYmUgMVwiKTtpZihpWzBdIT09bnx8b1swXSE9PW4pdGhyb3cgbmV3IEVycm9yKFwiU2hhcGUgb2YgdGhlIGludGVybWVkaWF0ZSByZXN1bHRzIHNob3VsZCBiZSBlcXVhbCB0byBsb2dpY2FsIHJvdyBjb3VudFwiKTtjb25zdCBwPWBcXG4gICAgICBmbG9hdCBwcm9jZXNzKGludFske2N9XSBpbmRpY2VzKSB7XFxuXFxuICAgICAgLy8gZ2V0IG9mZnNldCBvZiBjdXJyZW50IGxvZ2ljYWwgdGVuc29yIGluZGV4IGZyb20gdGhlIDItRCB0ZXh0dXJlIGNvb3JkaW5hdGVzIChUZXhDb29yZHMpXFxuICAgICAgaW50IG9mZnNldCA9IGNvb3Jkc1RvT2Zmc2V0KFRleENvb3JkcywgJHtzfSwgJHt1fSk7XFxuXFxuICAgICAgLy9kZXRlcm1pbmUgdGhlIGxvZ2ljYWwgcm93IGZvciB0aGlzIGluZGV4XFxuICAgICAgaW50IGxvZ2ljYWxfcm93X2luZGV4WzFdO1xcbiAgICAgIGxvZ2ljYWxfcm93X2luZGV4WzBdID0gb2Zmc2V0IC8gJHtyfTtcXG5cXG4gICAgICBmbG9hdCBub3JtX2ZhY3RvciA9IF9Ob3JtKGxvZ2ljYWxfcm93X2luZGV4KTtcXG5cXG4gICAgICAvLyBhdm9pZCBwb3NzaWJsZSBkaXZpc2lvbiBieSAwXFxuICAgICAgLy8gaWYgbm9ybV9mYWNvciBpcyAwLCBhbGwgZWxlbWVudHMgYXJlIHplcm9cXG4gICAgICAvLyBpZiBzbywgcmV0dXJuIDBcXG4gICAgICBpZihub3JtX2ZhY3RvciA9PSAwLjApXFxuICAgICAgICByZXR1cm4gMC4wO1xcblxcbiAgICAgIHJldHVybiBleHAoX0EoaW5kaWNlcykgLSBfTWF4KGxvZ2ljYWxfcm93X2luZGV4KSkgLyBub3JtX2ZhY3RvcjtcXG4gICAgfWA7cmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxsKSx7b3V0cHV0OntkaW1zOmUuZGltcyx0eXBlOmUudHlwZSx0ZXh0dXJlVHlwZTphLlRleHR1cmVUeXBlLnVucGFja2VkfSxzaGFkZXJTb3VyY2U6cH0pfSxnPXQ9PntpZighdHx8MSE9PXQubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIlNvZnRtYXggcmVxdWlyZXMgMSBpbnB1dC5cIik7aWYoXCJmbG9hdDMyXCIhPT10WzBdLnR5cGUmJlwiZmxvYXQ2NFwiIT09dFswXS50eXBlKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW5wdXQgdHlwZVwiKX19LDU5NzU6KHQsZSxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUucGFyc2VTcGxpdEF0dHJpYnV0ZXM9ZS5zcGxpdD12b2lkIDA7Y29uc3Qgcj1uKDI0NiksaT1uKDI1MTcpLG89bigyMDM5KSxhPXtuYW1lOlwiU3BsaXRcIixpbnB1dE5hbWVzOltcIkFcIl0saW5wdXRUeXBlczpbby5UZXh0dXJlVHlwZS51bnBhY2tlZF19O2Uuc3BsaXQ9KHQsZSxuKT0+e2MoZSk7Y29uc3Qgcj1pLlNoYXBlVXRpbC5ub3JtYWxpemVBeGlzKG4uYXhpcyxlWzBdLmRpbXMubGVuZ3RoKSxvPXModCxlLHIsbiksbD1bXTtmb3IobGV0IGk9MDtpPG87KytpKWwucHVzaCh0LnJ1bihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sYSkse2NhY2hlSGludDpgJHtuLmNhY2hlS2V5fTske2l9YCxnZXQ6KCk9PnUodCxlWzBdLG4scixpKX0pLGUpKTtyZXR1cm4gbH0sZS5wYXJzZVNwbGl0QXR0cmlidXRlcz10PT57Y29uc3QgZT10LmF0dHJpYnV0ZXMuZ2V0SW50KFwiYXhpc1wiLDApLG49dC5hdHRyaWJ1dGVzLmdldEludHMoXCJzcGxpdFwiLFtdKSxpPXQub3V0cHV0cy5sZW5ndGg7cmV0dXJuKDAsci5jcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkpKHtheGlzOmUsc3BsaXQ6bixudW1PdXRwdXRzOml9KX07Y29uc3Qgcz0odCxlLG4scik9Pntjb25zdFssb109aS5TcGxpdFV0aWwuc3BsaXRTaGFwZShlWzBdLmRpbXMsbixyLnNwbGl0LHIubnVtT3V0cHV0cyk7cmV0dXJuIG8ubGVuZ3RofSx1PSh0LGUsbixyLHMpPT57Y29uc3RbdSxjXT1pLlNwbGl0VXRpbC5zcGxpdFNoYXBlKGUuZGltcyxyLG4uc3BsaXQsbi5udW1PdXRwdXRzKSxsPWNbc10scD11W3NdLGY9YFxcbiAgICAgIGZsb2F0IHByb2Nlc3MoaW50IGluZGljZXNbJHtwLmxlbmd0aH1dKSB7XFxuICAgICAgICBpbmRpY2VzWyR7cn1dICs9ICR7bH07XFxuICAgICAgICByZXR1cm4gX0EoaW5kaWNlcyk7XFxuICAgICAgfVxcbiAgICBgO3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sYSkse2NhY2hlSGludDpgJHtuLmNhY2hlS2V5fToke3N9YCxvdXRwdXQ6e2RpbXM6cCx0eXBlOmUudHlwZSx0ZXh0dXJlVHlwZTpvLlRleHR1cmVUeXBlLnVucGFja2VkfSxzaGFkZXJTb3VyY2U6Zn0pfSxjPXQ9PntpZighdHx8MSE9PXQubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIlNwbGl0IHJlcXVpcmVzIG9uZSBpbnB1dC5cIik7aWYoXCJpbnQ4XCIhPT10WzBdLnR5cGUmJlwidWludDhcIiE9PXRbMF0udHlwZSYmXCJpbnQxNlwiIT09dFswXS50eXBlJiZcInVpbnQxNlwiIT09dFswXS50eXBlJiZcImludDMyXCIhPT10WzBdLnR5cGUmJlwidWludDMyXCIhPT10WzBdLnR5cGUmJlwiZmxvYXQzMlwiIT09dFswXS50eXBlJiZcImZsb2F0NjRcIiE9PXRbMF0udHlwZSYmXCJib29sXCIhPT10WzBdLnR5cGUpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbnB1dCB0eXBlLlwiKX19LDM5MzM6KHQsZSxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUucGFyc2VTcXVlZXplQXR0cmlidXRlcz1lLnNxdWVlemVWMTM9ZS5zcXVlZXplPXZvaWQgMDtjb25zdCByPW4oMjUxNyk7ZS5zcXVlZXplPSh0LGUsbik9PntpKGUpO2NvbnN0IG89ci5TaGFwZVV0aWwuc3F1ZWV6ZVNoYXBlKGVbMF0uZGltcyxuKTtyZXR1cm5bdC5yZXNoYXBlVW5wYWNrZWQoZVswXSxvKV19LGUuc3F1ZWV6ZVYxMz0odCxuKT0+KG8obiksKDAsZS5zcXVlZXplKSh0LFtuWzBdXSxBcnJheS5mcm9tKG5bMV0uaW50ZWdlckRhdGEpKSksZS5wYXJzZVNxdWVlemVBdHRyaWJ1dGVzPXQ9PnQuYXR0cmlidXRlcy5nZXRJbnRzKFwiYXhlc1wiKTtjb25zdCBpPXQ9PntpZighdHx8MSE9PXQubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIlNxdWVlemUgcmVxdWlyZXMgMSBpbnB1dC5cIik7aWYoXCJzdHJpbmdcIj09PXRbMF0udHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGlucHV0IHRlbnNvciB0eXBlcy5cIil9LG89dD0+e2lmKCF0fHwyIT09dC5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiU3F1ZWV6ZSByZXF1aXJlcyAyIGlucHV0cy5cIik7aWYoXCJpbnQzMlwiIT09dFsxXS50eXBlKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW5wdXQgdHlwZS5cIil9fSw2NTU4Oih0LGUsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLnN1bT12b2lkIDA7Y29uc3Qgcj1uKDUwNjApLGk9bigyMDM5KTtlLnN1bT0odCxlKT0+e2EoZSk7Y29uc3Qgbj17bmFtZTpcIlN1bVwiLGlucHV0TmFtZXM6ZS5tYXAoKCh0LGUpPT5gWCR7ZX1gKSksaW5wdXRUeXBlczpuZXcgQXJyYXkoZS5sZW5ndGgpLmZpbGwoaS5UZXh0dXJlVHlwZS51bnBhY2tlZCl9O3JldHVyblt0LnJ1bihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sbikse2dldDooKT0+byh0LGUsbil9KSxlKV19O2NvbnN0IG89KHQsZSxuKT0+e2NvbnN0IG89KDAsci5nZXRHbHNsKSh0LnNlc3Npb24uYmFja2VuZC5nbENvbnRleHQudmVyc2lvbiksYT1lWzBdLmRpbXMuc2xpY2UoKSxzPWUubWFwKCgodCxlKT0+YCR7by50ZXh0dXJlMkR9KFgke2V9LFRleENvb3JkcylgKSkuam9pbihcIiArIFwiKSx1PWBcXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICB2ZWM0IHJlc3VsdCA9ICR7c307XFxuICAgICAgICAke28ub3V0cHV0fSA9IHJlc3VsdDtcXG4gICAgICB9XFxuICAgIGA7cmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxuKSx7b3V0cHV0OntkaW1zOmEsdHlwZTplWzBdLnR5cGUsdGV4dHVyZVR5cGU6aS5UZXh0dXJlVHlwZS51bnBhY2tlZH0saGFzTWFpbjohMCxzaGFkZXJTb3VyY2U6dX0pfSxhPXQ9PntpZighdHx8MD09PXQubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIlN1bSByZXF1aXJlcyBpbnB1dHMuXCIpO2NvbnN0IGU9dFswXS5kaW1zLmxlbmd0aDtmb3IobGV0IG49MTtuPHQubGVuZ3RoO24rKyl7aWYoZSE9PXRbbl0uZGltcy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiSW5wdXQgc2hhcGVzIGFyZSBtaXNtYXRjaGVkLlwiKTtmb3IobGV0IHI9MDtyPGU7cisrKWlmKHRbMF0uZGltc1tyXSE9PXRbbl0uZGltc1tyXSl0aHJvdyBuZXcgRXJyb3IoXCJJbnB1dCBzaGFwZXMgYXJlIG5vdCBtYXRjaGVkLlwiKX1pZihcImZsb2F0MzJcIiE9PXRbMF0udHlwZSYmXCJmbG9hdDY0XCIhPT10WzBdLnR5cGUpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbnB1dCB0eXBlLlwiKTtmb3IobGV0IGU9MTtlPHQubGVuZ3RoO2UrKylpZih0WzBdLnR5cGUhPT10W2VdLnR5cGUpdGhyb3cgbmV3IEVycm9yKFwiSW5wdXQgdHlwZXMgYXJlIG5vdCBtYXRjaGVkLlwiKX19LDU3MjM6KHQsZSxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUudGlsZT12b2lkIDA7Y29uc3Qgcj1uKDc4MiksaT1uKDIwMzkpO2UudGlsZT0odCxlKT0+e2EoZSk7Y29uc3Qgbj17bmFtZTpcIlRpbGVcIixpbnB1dE5hbWVzOltcIkFcIl0saW5wdXRUeXBlczpbaS5UZXh0dXJlVHlwZS51bnBhY2tlZF19O3JldHVyblt0LnJ1bihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sbikse2dldDooKT0+byh0LGUsbil9KSxlKV19O2NvbnN0IG89KHQsZSxuKT0+e2NvbnN0IHI9ZVswXS5kaW1zLnNsaWNlKCksbz1uZXcgQXJyYXkoci5sZW5ndGgpLGE9W107Zm9yKGxldCB0PTA7dDxyLmxlbmd0aDt0Kyspb1t0XT1yW3RdKmVbMV0ubnVtYmVyRGF0YVt0XSxhLnB1c2goYGlucHV0SWR4WyR7dH1dID0gaW50KG1vZChmbG9hdChvdXRwdXRJZHhbJHt0fV0pLCAke3JbdF19LikpO2ApO2NvbnN0IHM9by5sZW5ndGgsdT1gXFxuICAgICAgZmxvYXQgcHJvY2VzcyhpbnQgb3V0cHV0SWR4WyR7c31dKSB7XFxuICAgICAgICBpbnQgaW5wdXRJZHhbJHtzfV07XFxuICAgICAgICAke2Euam9pbihcIlxcblwiKX1cXG4gICAgICAgIHJldHVybiBfQShpbnB1dElkeCk7XFxuICAgICAgfVxcbiAgICBgO3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sbikse291dHB1dDp7ZGltczpvLHR5cGU6ZVswXS50eXBlLHRleHR1cmVUeXBlOmkuVGV4dHVyZVR5cGUudW5wYWNrZWR9LHNoYWRlclNvdXJjZTp1fSl9LGE9dD0+e2lmKCF0fHwyIT09dC5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiVGlsZSByZXF1aXJlcyAyIGlucHV0LlwiKTtpZigxIT09dFsxXS5kaW1zLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJUaGUgc2Vjb25kIGlucHV0IHNoYXBlIG11c3QgMSBkaW1lbnNpb24uXCIpO2lmKHRbMV0uZGltc1swXSE9PXRbMF0uZGltcy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbnB1dCBzaGFwZS5cIik7aWYoLTE9PT1yLk5VTUJFUl9UWVBFUy5pbmRleE9mKHRbMF0udHlwZSkpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbnB1dCB0eXBlLlwiKTtpZihcImludDMyXCIhPT10WzFdLnR5cGUmJlwiaW50MTZcIiE9PXRbMV0udHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHJlcGVhdCB0eXBlLlwiKX19LDM3Mzg6KHQsZSxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUucGFyc2VUcmFuc3Bvc2VBdHRyaWJ1dGVzPWUudHJhbnNwb3NlPXZvaWQgMDtjb25zdCByPW4oMjQ2KSxpPW4oMjUxNyksbz1uKDIwMzkpLGE9e25hbWU6XCJUcmFuc3Bvc2VcIixpbnB1dE5hbWVzOltcIkFcIl0saW5wdXRUeXBlczpbby5UZXh0dXJlVHlwZS51bnBhY2tlZF19O2UudHJhbnNwb3NlPSh0LGUsbik9PihwKGUpLFt0LnJ1bihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sYSkse2NhY2hlSGludDpuLmNhY2hlS2V5LGdldDooKT0+cyh0LGVbMF0sbi5wZXJtKX0pLGUpXSksZS5wYXJzZVRyYW5zcG9zZUF0dHJpYnV0ZXM9dD0+KDAsci5jcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkpKHtwZXJtOnQuYXR0cmlidXRlcy5nZXRJbnRzKFwicGVybVwiLFtdKX0pO2NvbnN0IHM9KHQsZSxuKT0+e2NvbnN0IHI9ZS5kaW1zO249dShyLG4pO2NvbnN0IGk9YyhyLG4pLHM9ci5sZW5ndGgscD1gXFxuICAgICAgJHtsKFwicGVybVwiLG4scyl9XFxuICAgICAgZmxvYXQgcHJvY2VzcyhpbnQgaW5kaWNlc1ske3N9XSkge1xcbiAgICAgICAgaW50IGFbJHtzfV07XFxuICAgICAgICBwZXJtKGEsIGluZGljZXMpO1xcbiAgICAgICAgcmV0dXJuIF9BKGEpO1xcbiAgICAgIH1gO3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sYSkse291dHB1dDp7ZGltczppLHR5cGU6ZS50eXBlLHRleHR1cmVUeXBlOm8uVGV4dHVyZVR5cGUudW5wYWNrZWR9LHNoYWRlclNvdXJjZTpwfSl9LHU9KHQsZSk9PihlJiZlLmxlbmd0aCE9PXQubGVuZ3RoJiYoZT1bLi4udC5rZXlzKCldLnJldmVyc2UoKSksZSksYz0odCxlKT0+KGU9dSh0LGUpLGkuU2hhcGVVdGlsLnNvcnRCYXNlZE9uUGVybSh0LGUpKSxsPSh0LGUsbik9Pntjb25zdCByPVtdO3IucHVzaChgdm9pZCAke3R9KG91dCBpbnQgYVske259XSwgaW50IHNyY1ske259XSkge2ApO2ZvcihsZXQgdD0wO3Q8bjsrK3Qpci5wdXNoKGBcXHRhWyR7ZVt0XX1dPXNyY1ske3R9XTtgKTtyZXR1cm4gci5wdXNoKFwiXFx0fVwiKSxyLmpvaW4oXCJcXG5cIil9LHA9dD0+e2lmKCF0fHwxIT09dC5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiVHJhbnNwb3NlIHJlcXVpcmVzIDEgaW5wdXQuXCIpO2lmKFwiZmxvYXQzMlwiIT09dFswXS50eXBlJiZcImZsb2F0NjRcIiE9PXRbMF0udHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJpbnB1dCBzaG91bGQgYmUgZmxvYXQgdGVuc29yXCIpfX0sODcxMDoodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5lbmNvZGVBc1VpbnQ4PXZvaWQgMDtjb25zdCByPW4oNTA2MCksaT1uKDIwMzkpO2UuZW5jb2RlQXNVaW50OD0odCxlKT0+e2NvbnN0IG49ZS5zaGFwZSxvPSgwLHIuZ2V0R2xzbCkodC5zZXNzaW9uLmJhY2tlbmQuZ2xDb250ZXh0LnZlcnNpb24pLGE9YFxcbiAgICBjb25zdCBmbG9hdCBGTE9BVF9NQVggPSAxLjcwMTQxMTg0ZTM4O1xcbiAgICBjb25zdCBmbG9hdCBGTE9BVF9NSU4gPSAxLjE3NTQ5NDM1ZS0zODtcXG5cXG4gICAgYm9vbCBpc05hTihmbG9hdCB2YWwpIHtcXG4gICAgICByZXR1cm4gKHZhbCA8IDEuMCB8fCAwLjAgPCB2YWwgfHwgdmFsID09IDAuMCkgPyBmYWxzZSA6IHRydWU7XFxuICAgIH1cXG5cXG4gICAgaGlnaHAgdmVjNCBlbmNvZGVBc1VpbnQ4KGhpZ2hwIGZsb2F0IHYpIHtcXG4gICAgICBpZiAoaXNOYU4odikpIHtcXG4gICAgICAgIHJldHVybiB2ZWM0KDI1NSwgMjU1LCAyNTUsIDI1NSk7XFxuICAgICAgfVxcblxcbiAgICAgIGhpZ2hwIGZsb2F0IGF2ID0gYWJzKHYpO1xcblxcbiAgICAgIGlmKGF2IDwgRkxPQVRfTUlOKSB7XFxuICAgICAgICByZXR1cm4gdmVjNCgwLjAsIDAuMCwgMC4wLCAwLjApO1xcbiAgICAgIH0gZWxzZSBpZih2ID4gRkxPQVRfTUFYKSB7XFxuICAgICAgICByZXR1cm4gdmVjNCgwLjAsIDAuMCwgMTI4LjAsIDEyNy4wKSAvIDI1NS4wO1xcbiAgICAgIH0gZWxzZSBpZih2IDwgLUZMT0FUX01BWCkge1xcbiAgICAgICAgcmV0dXJuIHZlYzQoMC4wLCAwLjAsICAxMjguMCwgMjU1LjApIC8gMjU1LjA7XFxuICAgICAgfVxcblxcbiAgICAgIGhpZ2hwIHZlYzQgYyA9IHZlYzQoMCwwLDAsMCk7XFxuXFxuICAgICAgaGlnaHAgZmxvYXQgZSA9IGZsb29yKGxvZzIoYXYpKTtcXG4gICAgICBoaWdocCBmbG9hdCBtID0gZXhwMihmcmFjdChsb2cyKGF2KSkpIC0gMS4wO1xcblxcbiAgICAgIGNbMl0gPSBmbG9vcigxMjguMCAqIG0pO1xcbiAgICAgIG0gLT0gY1syXSAvIDEyOC4wO1xcbiAgICAgIGNbMV0gPSBmbG9vcigzMjc2OC4wICogbSk7XFxuICAgICAgbSAtPSBjWzFdIC8gMzI3NjguMDtcXG4gICAgICBjWzBdID0gZmxvb3IoODM4ODYwOC4wICogbSk7XFxuXFxuICAgICAgaGlnaHAgZmxvYXQgZWJpYXMgPSBlICsgMTI3LjA7XFxuICAgICAgY1szXSA9IGZsb29yKGViaWFzIC8gMi4wKTtcXG4gICAgICBlYmlhcyAtPSBjWzNdICogMi4wO1xcbiAgICAgIGNbMl0gKz0gZmxvb3IoZWJpYXMpICogMTI4LjA7XFxuXFxuICAgICAgY1szXSArPSAxMjguMCAqIHN0ZXAoMC4wLCAtdik7XFxuXFxuICAgICAgcmV0dXJuIGMgLyAyNTUuMDtcXG4gICAgfVxcblxcbiAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgZmxvYXQgdmFsdWUgPSAke28udGV4dHVyZTJEfShYLFRleENvb3JkcykucjtcXG4gICAgICAke28ub3V0cHV0fSA9IGVuY29kZUFzVWludDgodmFsdWUpO1xcbiAgICB9YCxzPXtuYW1lOlwiVWludDhFbmNvZGVcIixpbnB1dFR5cGVzOltpLlRleHR1cmVUeXBlLnVucGFja2VkXSxpbnB1dE5hbWVzOltcIlhcIl0sb3V0cHV0OntkaW1zOm4sdHlwZTplLnRlbnNvci50eXBlLHRleHR1cmVUeXBlOmkuVGV4dHVyZVR5cGUuZG93bmxvYWRVaW50OEFzRmxvYXR9LHNoYWRlclNvdXJjZTphLGhhc01haW46ITB9O3JldHVybiB0LmV4ZWN1dGVQcm9ncmFtKHMsW2UudGVuc29yXSl9fSw0OTA5Oih0LGUsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLnRhbmg9ZS50YW49ZS5zcXJ0PWUuc2luPWUuc2lnbW9pZD1lLnJlbHU9ZS5ub3Q9ZS5uZWc9ZS5sb2c9ZS5wYXJzZUxlYWt5UmVsdUF0dHJpYnV0ZXM9ZS5sZWFreVJlbHU9ZS5pZGVudGl0eT1lLmZsb29yPWUuZXhwPWUucGFyc2VFbHVBdHRyaWJ1dGVzPWUuZWx1PWUuY29zPWUuY2VpbD1lLmNsaXBWMTE9ZS5wYXJzZUNsaXBBdHRyaWJ1dGVzPWUuY2xpcD1lLmF0YW49ZS5hc2luPWUuYWNvcz1lLmFicz1lLmdsc2xUYW5oPWUuZ2xzbFRhbj1lLmdsc2xTcXJ0PWUuZ2xzbFNpZ21vaWQ9ZS5nbHNsUmVsdT1lLmdsc2xTaW49ZS5nbHNsTm90PWUuZ2xzbE5lZz1lLmdsc2xMb2c9ZS5nbHNsTGVha3lSZWx1PWUuZ2xzbElkZW50aXR5PWUuZ2xzbENsaXA9ZS5nbHNsRmxvb3I9ZS5nbHNsRXhwPWUuZ2xzbEVsdT1lLmdsc2xDb3M9ZS5nbHNsQ2VpbD1lLmdsc2xBdGFuPWUuZ2xzbEFzaW49ZS5nbHNsQWNvcz1lLmdsc2xBYnM9dm9pZCAwO2NvbnN0IHI9bigyNDYpLGk9bigyNTE3KSxvPW4oODUyMCksYT1uKDUwNjApLHM9bigyMDM5KTtmdW5jdGlvbiB1KCl7cmV0dXJuIFAoXCJhYnNcIil9ZnVuY3Rpb24gYygpe3JldHVybiBQKFwiYWNvc1wiKX1mdW5jdGlvbiBsKCl7cmV0dXJuIFAoXCJhc2luXCIpfWZ1bmN0aW9uIHAoKXtyZXR1cm4gUChcImF0YW5cIil9ZnVuY3Rpb24gZigpe3JldHVybiBQKFwiY2VpbFwiKX1mdW5jdGlvbiBkKCl7cmV0dXJuIFAoXCJjb3NcIil9ZnVuY3Rpb24gaCh0KXtjb25zdCBlPVwiZWx1XCI7cmV0dXJue2JvZHk6YFxcbiAgY29uc3QgZmxvYXQgYWxwaGEgPSBmbG9hdCgke3R9KTtcXG5cXG4gIGZsb2F0ICR7ZX1fKGZsb2F0IGEpIHtcXG4gICAgcmV0dXJuIGEgPj0gMC4wID8gYTogKGV4cChhKSAtIDEuMCkgKiBhbHBoYTtcXG4gIH1cXG4gIHZlYzQgJHtlfV8odmVjNCB2KSB7XFxuICAgIHJldHVybiB2ZWM0KCR7ZX1fKHYueCksICR7ZX1fKHYueSksICR7ZX1fKHYueiksICR7ZX1fKHYudykpO1xcbiAgfVxcbiAgYCxuYW1lOmUsdHlwZTpvLkZ1bmN0aW9uVHlwZS5WYWx1ZUJhc2VkfX1mdW5jdGlvbiBnKCl7cmV0dXJuIFAoXCJleHBcIil9ZnVuY3Rpb24gYigpe3JldHVybiBQKFwiZmxvb3JcIil9ZnVuY3Rpb24gbSh0LGUpe2NvbnN0IG49XCJjbGlwXCI7cmV0dXJue2JvZHk6YFxcbiAgY29uc3QgZmxvYXQgbWluID0gZmxvYXQoJHt0fSk7XFxuICBjb25zdCBmbG9hdCBtYXggPSBmbG9hdCgke2V9KTtcXG5cXG4gIGZsb2F0ICR7bn1fKGZsb2F0IGEpIHtcXG4gICAgcmV0dXJuIGNsYW1wKGEsIG1pbiwgbWF4KTtcXG4gIH1cXG4gIHZlYzQgJHtufV8odmVjNCB2KSB7XFxuICAgIHJldHVybiBjbGFtcCh2LCBtaW4sIG1heCk7XFxuICB9XFxuICBgLG5hbWU6bix0eXBlOm8uRnVuY3Rpb25UeXBlLlZhbHVlQmFzZWR9fWZ1bmN0aW9uIHkoKXtjb25zdCB0PVwiaW5kZW50aXR5XCI7cmV0dXJue2JvZHk6YFxcbiAgZmxvYXQgJHt0fV8oZmxvYXQgYSkge1xcbiAgICByZXR1cm4gYTtcXG4gIH1cXG4gIHZlYzQgJHt0fV8odmVjNCB2KSB7XFxuICAgIHJldHVybiB2O1xcbiAgfVxcbiAgYCxuYW1lOnQsdHlwZTpvLkZ1bmN0aW9uVHlwZS5WYWx1ZUJhc2VkfX1mdW5jdGlvbiBfKHQpe2NvbnN0IGU9XCJsZWFreVJlbHVcIjtyZXR1cm57Ym9keTpgXFxuICBjb25zdCBmbG9hdCBhbHBoYSA9IGZsb2F0KCR7dH0pO1xcblxcbiAgZmxvYXQgJHtlfV8oZmxvYXQgYSkge1xcbiAgICByZXR1cm4gYSA8IDAuMCA/IGEgKiBhbHBoYSA6IGE7XFxuICB9XFxuICB2ZWM0ICR7ZX1fKHZlYzQgdikge1xcbiAgICByZXR1cm4gdmVjNCgke2V9Xyh2LngpLCAke2V9Xyh2LnkpLCAke2V9Xyh2LnopLCAke2V9Xyh2LncpKTtcXG4gIH1cXG4gIGAsbmFtZTplLHR5cGU6by5GdW5jdGlvblR5cGUuVmFsdWVCYXNlZH19ZnVuY3Rpb24gdigpe3JldHVybiBQKFwibG9nXCIpfWZ1bmN0aW9uIHcoKXtjb25zdCB0PVwibmVnXCI7cmV0dXJue2JvZHk6YFxcbiAgZmxvYXQgJHt0fV8oZmxvYXQgYSkge1xcbiAgICByZXR1cm4gLWE7XFxuICB9XFxuICB2ZWM0ICR7dH1fKHZlYzQgdikge1xcbiAgICByZXR1cm4gLXY7XFxuICB9XFxuICBgLG5hbWU6dCx0eXBlOm8uRnVuY3Rpb25UeXBlLlZhbHVlQmFzZWR9fWZ1bmN0aW9uIHgoKXtjb25zdCB0PVwibm90XCI7cmV0dXJue2JvZHk6YFxcbiAgZmxvYXQgJHt0fV8oZmxvYXQgYSkge1xcbiAgICByZXR1cm4gZmxvYXQoICEgYm9vbChhKSApO1xcbiAgfVxcbiAgYm9vbCAke3R9Xyhib29sIGEpIHtcXG4gICAgcmV0dXJuICFhO1xcbiAgfVxcbiAgdmVjNCAke3R9Xyh2ZWM0IHYpIHtcXG4gICAgcmV0dXJuIHZlYzQoIWJvb2wodi54KSwgIWJvb2wodi55KSwgIWJvb2wodi56KSwgIWJvb2wodi53KSk7XFxuICB9XFxuICBidmVjNCAke3R9XyhidmVjNCB2KSB7XFxuICAgIHJldHVybiBidmVjNCghdi54LCAhdi55LCAhdi56LCAhdi53KTtcXG4gIH1cXG4gIGAsbmFtZTp0LHR5cGU6by5GdW5jdGlvblR5cGUuVmFsdWVCYXNlZH19ZnVuY3Rpb24gVCgpe3JldHVybiBQKFwic2luXCIpfWZ1bmN0aW9uIFMoKXtjb25zdCB0PVwicmVsdVwiO3JldHVybntib2R5OmBcXG4gIGZsb2F0ICR7dH1fKGZsb2F0IGEpIHtcXG4gICAgcmV0dXJuIG1heCggYSwgMC4wICk7XFxuICB9XFxuICB2ZWM0ICR7dH1fKHZlYzQgdikge1xcbiAgICByZXR1cm4gbWF4KCB2LCAwLjAgKTtcXG4gIH1cXG4gIGAsbmFtZTp0LHR5cGU6by5GdW5jdGlvblR5cGUuVmFsdWVCYXNlZH19ZnVuY3Rpb24gTygpe2NvbnN0IHQ9XCJzaWdtb2lkXCI7cmV0dXJue2JvZHk6YFxcbiAgZmxvYXQgJHt0fV8oZmxvYXQgYSkge1xcbiAgICByZXR1cm4gMS4wIC8gKDEuMCArIGV4cCgtYSkpO1xcbiAgfVxcbiAgdmVjNCAke3R9Xyh2ZWM0IHYpIHtcXG4gICAgcmV0dXJuIDEuMCAvICgxLjAgKyBleHAoLXYpKTtcXG4gIH1cXG4gIGAsbmFtZTp0LHR5cGU6by5GdW5jdGlvblR5cGUuVmFsdWVCYXNlZH19ZnVuY3Rpb24gQSgpe3JldHVybiBQKFwic3FydFwiKX1mdW5jdGlvbiBFKCl7cmV0dXJuIFAoXCJ0YW5cIil9ZnVuY3Rpb24gSSgpe2NvbnN0IHQ9XCJ0YW5oXCI7cmV0dXJue2JvZHk6YFxcbiAgZmxvYXQgJHt0fV8oZmxvYXQgYSkge1xcbiAgICBhID0gY2xhbXAoYSwgLTEwLiwgMTAuKTtcXG4gICAgYSA9IGV4cCgyLiphKTtcXG4gICAgcmV0dXJuIChhIC0gMS4pIC8gKGEgKyAxLik7XFxuICB9XFxuICB2ZWM0ICR7dH1fKHZlYzQgdikge1xcbiAgICB2ID0gY2xhbXAodiwgLTEwLiwgMTAuKTtcXG4gICAgdiA9IGV4cCgyLip2KTtcXG4gICAgcmV0dXJuICh2IC0gMS4pIC8gKHYgKyAxLik7XFxuICB9XFxuICBgLG5hbWU6dCx0eXBlOm8uRnVuY3Rpb25UeXBlLlZhbHVlQmFzZWR9fWZ1bmN0aW9uIFAodCl7cmV0dXJue2JvZHk6YFxcbiAgZmxvYXQgJHt0fV8oZmxvYXQgYSkge1xcbiAgICByZXR1cm4gJHt0fShhKTtcXG4gIH1cXG4gIHZlYzQgJHt0fV8odmVjNCB2KSB7XFxuICAgIHJldHVybiAke3R9KHYpO1xcbiAgfVxcbiAgYCxuYW1lOnQsdHlwZTpvLkZ1bmN0aW9uVHlwZS5WYWx1ZUJhc2VkfX1lLmdsc2xBYnM9dSxlLmdsc2xBY29zPWMsZS5nbHNsQXNpbj1sLGUuZ2xzbEF0YW49cCxlLmdsc2xDZWlsPWYsZS5nbHNsQ29zPWQsZS5nbHNsRWx1PWgsZS5nbHNsRXhwPWcsZS5nbHNsRmxvb3I9YixlLmdsc2xDbGlwPW0sZS5nbHNsSWRlbnRpdHk9eSxlLmdsc2xMZWFreVJlbHU9XyxlLmdsc2xMb2c9dixlLmdsc2xOZWc9dyxlLmdsc2xOb3Q9eCxlLmdsc2xTaW49VCxlLmdsc2xSZWx1PVMsZS5nbHNsU2lnbW9pZD1PLGUuZ2xzbFNxcnQ9QSxlLmdsc2xUYW49RSxlLmdsc2xUYW5oPUk7Y29uc3QgRD0odCxlLG4scik9Pntjb25zdCBpPXQuc2Vzc2lvbi5wYWNrP3MuVGV4dHVyZVR5cGUucGFja2VkOnMuVGV4dHVyZVR5cGUudW5wYWNrZWQsbz17bmFtZTpuLm5hbWUsaW5wdXRUeXBlczpbaV0saW5wdXROYW1lczpbXCJBXCJdLGNhY2hlSGludDpyfTtyZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LG8pLHtnZXQ6KCk9PigodCxlLG4scik9Pntjb25zdCBpPXQuc2Vzc2lvbi5wYWNrP3MuVGV4dHVyZVR5cGUucGFja2VkOnMuVGV4dHVyZVR5cGUudW5wYWNrZWQsbz0oMCxhLmdldEdsc2wpKHQuc2Vzc2lvbi5iYWNrZW5kLmdsQ29udGV4dC52ZXJzaW9uKTtyZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LGUpLHtvdXRwdXQ6e2RpbXM6bi5kaW1zLHR5cGU6bi50eXBlLHRleHR1cmVUeXBlOml9LHNoYWRlclNvdXJjZTpgXFxuICAgICAke3IuYm9keX1cXG4gICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgdmVjNCB2ID0gJHtvLnRleHR1cmUyRH0oQSwgVGV4Q29vcmRzKTtcXG4gICAgICAgdiA9ICR7ci5uYW1lfV8odik7XFxuICAgICAgICR7by5vdXRwdXR9ID0gdjtcXG4gICAgIH1cXG4gICAgIGAsaGFzTWFpbjohMH0pfSkodCxvLGUsbil9KX07ZS5hYnM9KHQsZSk9Plt0LnJ1bihEKHQsZVswXSx1KCkpLGUpXSxlLmFjb3M9KHQsZSk9Plt0LnJ1bihEKHQsZVswXSxjKCkpLGUpXSxlLmFzaW49KHQsZSk9Plt0LnJ1bihEKHQsZVswXSxsKCkpLGUpXSxlLmF0YW49KHQsZSk9Plt0LnJ1bihEKHQsZVswXSxwKCkpLGUpXSxlLmNsaXA9KHQsZSxuKT0+W3QucnVuKEQodCxlWzBdLG0obi5taW4sbi5tYXgpLG4uY2FjaGVLZXkpLGUpXSxlLnBhcnNlQ2xpcEF0dHJpYnV0ZXM9dD0+KDAsci5jcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkpKHttaW46dC5hdHRyaWJ1dGVzLmdldEZsb2F0KFwibWluXCIsaS5NSU5fQ0xJUCksbWF4OnQuYXR0cmlidXRlcy5nZXRGbG9hdChcIm1heFwiLGkuTUFYX0NMSVApfSksZS5jbGlwVjExPSh0LG4pPT57Y29uc3Qgcj0kKHQsbik7cmV0dXJuKDAsZS5jbGlwKSh0LFtuWzBdXSxyKX07Y29uc3QgJD0odCxlKT0+e2lmKGUubGVuZ3RoPj0zJiYoIXQuc2Vzc2lvbi5pc0luaXRpYWxpemVyKGVbMV0uZGF0YUlkKXx8IXQuc2Vzc2lvbi5pc0luaXRpYWxpemVyKGVbMl0uZGF0YUlkKSkpdGhyb3cgbmV3IEVycm9yKFwiZHluYW1pYyBjbGlwIGF0dHJpYnV0ZXMgYXJlIG5vdCBhbGxvd2VkXCIpO2NvbnN0IG49ZS5sZW5ndGg+PTM/ZVsxXS5udW1iZXJEYXRhWzBdOmkuTUlOX0NMSVAsbz1lLmxlbmd0aD49Mz9lWzJdLm51bWJlckRhdGFbMF06aS5NQVhfQ0xJUDtyZXR1cm4oMCxyLmNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSkoe21pbjpuLG1heDpvfSl9O2UuY2VpbD0odCxlKT0+W3QucnVuKEQodCxlWzBdLGYoKSksZSldLGUuY29zPSh0LGUpPT5bdC5ydW4oRCh0LGVbMF0sZCgpKSxlKV0sZS5lbHU9KHQsZSxuKT0+W3QucnVuKEQodCxlWzBdLGgobi5hbHBoYSksbi5jYWNoZUtleSksZSldLGUucGFyc2VFbHVBdHRyaWJ1dGVzPXQ9PigwLHIuY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KSh7YWxwaGE6dC5hdHRyaWJ1dGVzLmdldEZsb2F0KFwiYWxwaGFcIiwxKX0pLGUuZXhwPSh0LGUpPT5bdC5ydW4oRCh0LGVbMF0sZygpKSxlKV0sZS5mbG9vcj0odCxlKT0+W3QucnVuKEQodCxlWzBdLGIoKSksZSldLGUuaWRlbnRpdHk9KHQsZSk9Plt0LnJ1bihEKHQsZVswXSx5KCkpLGUpXSxlLmxlYWt5UmVsdT0odCxlLG4pPT5bdC5ydW4oRCh0LGVbMF0sXyhuLmFscGhhKSxuLmNhY2hlS2V5KSxlKV0sZS5wYXJzZUxlYWt5UmVsdUF0dHJpYnV0ZXM9dD0+KDAsci5jcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkpKHthbHBoYTp0LmF0dHJpYnV0ZXMuZ2V0RmxvYXQoXCJhbHBoYVwiLC4wMSl9KSxlLmxvZz0odCxlKT0+W3QucnVuKEQodCxlWzBdLHYoKSksZSldLGUubmVnPSh0LGUpPT5bdC5ydW4oRCh0LGVbMF0sdygpKSxlKV0sZS5ub3Q9KHQsZSk9Plt0LnJ1bihEKHQsZVswXSx4KCkpLGUpXSxlLnJlbHU9KHQsZSk9Plt0LnJ1bihEKHQsZVswXSxTKCkpLGUpXSxlLnNpZ21vaWQ9KHQsZSk9Plt0LnJ1bihEKHQsZVswXSxPKCkpLGUpXSxlLnNpbj0odCxlKT0+W3QucnVuKEQodCxlWzBdLFQoKSksZSldLGUuc3FydD0odCxlKT0+W3QucnVuKEQodCxlWzBdLEEoKSksZSldLGUudGFuPSh0LGUpPT5bdC5ydW4oRCh0LGVbMF0sRSgpKSxlKV0sZS50YW5oPSh0LGUpPT5bdC5ydW4oRCh0LGVbMF0sSSgpKSxlKV19LDU2MTE6KHQsZSxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUuY3JlYXRlVW5wYWNrUHJvZ3JhbUluZm9Mb2FkZXI9ZS5jcmVhdGVVbnBhY2tQcm9ncmFtSW5mbz12b2lkIDA7Y29uc3Qgcj1uKDUwNjApLGk9bigyMDM5KSxvPW4oOTM5MCksYT1uKDI4MjcpLHM9e25hbWU6XCJ1bnBhY2tcIixpbnB1dE5hbWVzOltcIkFcIl0saW5wdXRUeXBlczpbaS5UZXh0dXJlVHlwZS5wYWNrZWRdfTtlLmNyZWF0ZVVucGFja1Byb2dyYW1JbmZvPSh0LGUpPT57Y29uc3Qgbj1lLmRpbXMubGVuZ3RoLHU9KDAsYS5nZXRDaGFubmVscykoXCJyY1wiLG4pLGM9dS5zbGljZSgtMiksbD0oMCxvLmdldENvb3Jkc0RhdGFUeXBlKShuKSxwPSgwLGEudW5wYWNrRnJvbUNoYW5uZWwpKCksZj0wPT09ZS5kaW1zLmxlbmd0aD9cIlwiOmZ1bmN0aW9uKHQsZSl7aWYoMT09PXQpcmV0dXJuXCJyY1wiO2xldCBuPVwiXCI7Zm9yKGxldCByPTA7cjx0O3IrKyluKz1lW3JdLHI8dC0xJiYobis9XCIsXCIpO3JldHVybiBufShuLHUpLGQ9bjw9MT9cInJjXCI6YHZlYzIoJHtjLmpvaW4oXCIsXCIpfSlgLGg9YFxcbiAgICAke3B9XFxuICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAke2x9IHJjID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuXFxuICAgICAgIC8vIFNhbXBsZSB0aGUgdGV4dHVyZSB3aXRoIHRoZSBjb29yZHMgdG8gZ2V0IHRoZSByZ2JhIGNoYW5uZWwgdmFsdWUuXFxuICAgICAgIHZlYzQgcGFja2VkSW5wdXQgPSBnZXRBKCR7Zn0pO1xcblxcbiAgICAgICAkeygwLHIuZ2V0R2xzbCkodC5zZXNzaW9uLmJhY2tlbmQuZ2xDb250ZXh0LnZlcnNpb24pLm91dHB1dH0gPSB2ZWM0KGdldENoYW5uZWwocGFja2VkSW5wdXQsICR7ZH0pLCAwLCAwLCAwKTtcXG4gICAgIH1cXG4gICBgO3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30scykse2hhc01haW46ITAsb3V0cHV0OntkaW1zOmUuZGltcyx0eXBlOmUudHlwZSx0ZXh0dXJlVHlwZTppLlRleHR1cmVUeXBlLnVucGFja2VkfSxzaGFkZXJTb3VyY2U6aH0pfSxlLmNyZWF0ZVVucGFja1Byb2dyYW1JbmZvTG9hZGVyPSh0LG4pPT5PYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30scykse2dldDooKT0+KDAsZS5jcmVhdGVVbnBhY2tQcm9ncmFtSW5mbykodCxuKX0pfSw4NDI4Oih0LGUsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLnBhcnNlVW5zcXVlZXplQXR0cmlidXRlcz1lLnVuc3F1ZWV6ZVYxMz1lLnVuc3F1ZWV6ZT12b2lkIDA7Y29uc3Qgcj1uKDI1MTcpO2UudW5zcXVlZXplPSh0LGUsbik9PntpKGUpO2NvbnN0IG89ci5TaGFwZVV0aWwudW5zcXVlZXplU2hhcGUoZVswXS5kaW1zLG4pO3JldHVyblt0LnJlc2hhcGVVbnBhY2tlZChlWzBdLG8pXX0sZS51bnNxdWVlemVWMTM9KHQsbik9PihvKG4pLCgwLGUudW5zcXVlZXplKSh0LFtuWzBdXSxBcnJheS5mcm9tKG5bMV0uaW50ZWdlckRhdGEpKSksZS5wYXJzZVVuc3F1ZWV6ZUF0dHJpYnV0ZXM9dD0+dC5hdHRyaWJ1dGVzLmdldEludHMoXCJheGVzXCIpO2NvbnN0IGk9dD0+e2lmKCF0fHwxIT09dC5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiVW5zcXVlZXplIHJlcXVpcmVzIDEgaW5wdXQuXCIpO2lmKFwic3RyaW5nXCI9PT10WzBdLnR5cGUpdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBpbnB1dCB0ZW5zb3IgdHlwZXMuXCIpfSxvPXQ9PntpZighdHx8MiE9PXQubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIlVuc3F1ZWV6ZSByZXF1aXJlcyAyIGlucHV0cy5cIik7aWYoXCJpbnQzMlwiIT09dFsxXS50eXBlKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW5wdXQgdHlwZS5cIil9fSw5NzkzOih0LGUsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLnNjYWxlc1ZhbGlkYXRpb249ZS52YWxpZGF0ZUlucHV0cz1lLnBhcnNlVXBzYW1wbGVBdHRyaWJ1dGVzPWUucGFyc2VVcHNhbXBsZUF0dHJpYnV0ZXNWOT1lLnBhcnNlVXBzYW1wbGVBdHRyaWJ1dGVzVjc9ZS51cHNhbXBsZT12b2lkIDA7Y29uc3Qgcj1uKDI0NiksaT1uKDUwNjApLG89bigyMDM5KSxhPXtuYW1lOlwiVXBzYW1wbGVcIixpbnB1dE5hbWVzOltcIlhcIl0saW5wdXRUeXBlczpbby5UZXh0dXJlVHlwZS51bnBhY2tlZF19O2UudXBzYW1wbGU9KHQsbixyKT0+KCgwLGUudmFsaWRhdGVJbnB1dHMpKG4sciksW3QucnVuKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxhKSx7Y2FjaGVIaW50OnIuY2FjaGVLZXksZ2V0OigpPT5zKHQsbixyKX0pLG4pXSksZS5wYXJzZVVwc2FtcGxlQXR0cmlidXRlc1Y3PXQ9PigwLGUucGFyc2VVcHNhbXBsZUF0dHJpYnV0ZXMpKHQsNyksZS5wYXJzZVVwc2FtcGxlQXR0cmlidXRlc1Y5PXQ9PigwLGUucGFyc2VVcHNhbXBsZUF0dHJpYnV0ZXMpKHQsOSksZS5wYXJzZVVwc2FtcGxlQXR0cmlidXRlcz0odCxuKT0+e2NvbnN0IGk9bj49MTAsbz10LmF0dHJpYnV0ZXMuZ2V0U3RyaW5nKFwibW9kZVwiLFwibmVhcmVzdFwiKTtpZihcIm5lYXJlc3RcIiE9PW8mJlwibGluZWFyXCIhPT1vJiYobjwxMXx8XCJjdWJpY1wiIT09bykpdGhyb3cgbmV3IEVycm9yKGB1bnJlY29nbml6ZWQgbW9kZTogJHtvfWApO2xldCBhPVtdO248OSYmKGE9dC5hdHRyaWJ1dGVzLmdldEZsb2F0cyhcInNjYWxlc1wiKSwoMCxlLnNjYWxlc1ZhbGlkYXRpb24pKGEsbyxpKSk7Y29uc3Qgcz10LmF0dHJpYnV0ZXMuZ2V0RmxvYXQoXCJleHRyYXBvbGF0aW9uX3ZhbHVlXCIsMCksdT1uPjEwP3QuYXR0cmlidXRlcy5nZXRTdHJpbmcoXCJjb29yZGluYXRlX3RyYW5zZm9ybWF0aW9uX21vZGVcIixcImhhbGZfcGl4ZWxcIik6XCJhc3ltbWV0cmljXCI7aWYoLTE9PT1bXCJhc3ltbWV0cmljXCIsXCJweXRvcmNoX2hhbGZfcGl4ZWxcIixcInRmX2hhbGZfcGl4ZWxfZm9yX25uXCIsXCJhbGlnbl9jb3JuZXJzXCIsXCJ0Zl9jcm9wX2FuZF9yZXNpemVcIixcImhhbGZfcGl4ZWxcIl0uaW5kZXhPZih1KSl0aHJvdyBuZXcgRXJyb3IoYGNvb3JkaW5hdGVfdHJhbnNmb3JtX21vZGUgJyR7dX0nIGlzIG5vdCBzdXBwb3J0ZWRgKTtjb25zdCBjPVwidGZfY3JvcF9hbmRfcmVzaXplXCI9PT11LGw9YyxwPVwibmVhcmVzdFwiPT09byYmbj49MTE/dC5hdHRyaWJ1dGVzLmdldFN0cmluZyhcIm5lYXJlc3RfbW9kZVwiLFwicm91bmRfcHJlZmVyX2Zsb29yXCIpOlwiXCI7aWYoLTE9PT1bXCJyb3VuZF9wcmVmZXJfZmxvb3JcIixcInJvdW5kX3ByZWZlcl9jZWlsXCIsXCJmbG9vclwiLFwiY2VpbFwiLFwiXCJdLmluZGV4T2YocCkpdGhyb3cgbmV3IEVycm9yKGBuZWFyZXN0X21vZGUgJyR7cH0nIGlzIG5vdCBzdXBwb3J0ZWRgKTtjb25zdCBmPXQuYXR0cmlidXRlcy5nZXRGbG9hdChcImN1YmljX2NvZWZmX2FcIiwtLjc1KSxkPTAhPT10LmF0dHJpYnV0ZXMuZ2V0SW50KFwiZXhjbHVkZV9vdXRzaWRlXCIsMCk7aWYoZCYmXCJjdWJpY1wiIT09byl0aHJvdyBuZXcgRXJyb3IoXCJleGNsdWRlX291dHNpZGUgY2FuIGJlIHNldCB0byAxIG9ubHkgd2hlbiBtb2RlIGlzIENVQklDLlwiKTtjb25zdCBoPW48MTF8fFwibmVhcmVzdFwiPT09byYmXCJhc3ltbWV0cmljXCI9PT11JiZcImZsb29yXCI9PT1wO2xldCBnPTAsYj0wLG09MDtyZXR1cm4gbj4xMD90LmlucHV0cy5sZW5ndGg+Mj8oZz0xLGI9MixtPTMpOihiPTEsbT0yKTo5PT09biYmKGI9MSksKDAsci5jcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkpKHtvcHNldDpuLGlzUmVzaXplOmksbW9kZTpvLHNjYWxlczphLGV4dHJhcG9sYXRpb25WYWx1ZTpzLGNvb3JkaW5hdGVUcmFuc2Zvcm1Nb2RlOnUsdXNlRXh0cmFwb2xhdGlvbjpsLG5lZWRSb2lJbnB1dDpjLG5lYXJlc3RNb2RlOnAsY3ViaWNDb2VmZmljaWVudEE6ZixleGNsdWRlT3V0c2lkZTpkLHVzZU5lYXJlc3QyeE9wdGltaXphdGlvbjpoLHJvaUlucHV0SWR4Omcsc2NhbGVzSW5wdXRJZHg6YixzaXplc0lucHV0SWR4Om19KX07Y29uc3Qgcz0odCxlLG4pPT57Y29uc3Qgcj0oMCxpLmdldEdsc2wpKHQuc2Vzc2lvbi5iYWNrZW5kLmdsQ29udGV4dC52ZXJzaW9uKSxbcyx1XT10LmNhbGN1bGF0ZVRleHR1cmVXaWR0aEFuZEhlaWdodChlWzBdLmRpbXMsby5UZXh0dXJlVHlwZS51bnBhY2tlZCksYz1lWzBdLmRpbXMubWFwKCgodCxlKT0+TWF0aC5mbG9vcih0Km4uc2NhbGVzW2VdKSkpLFtsLHBdPXQuY2FsY3VsYXRlVGV4dHVyZVdpZHRoQW5kSGVpZ2h0KGMsby5UZXh0dXJlVHlwZS51bnBhY2tlZCksZj1jLmxlbmd0aCxkPW5ldyBBcnJheShmKSxoPW5ldyBBcnJheShmKTtsZXQgZz1gXFxuICAgICAgaW50IG91dHB1dF9waXRjaGVzWyR7Zn1dO1xcbiAgICAgIGludCBpbnB1dF9waXRjaGVzWyR7Zn1dO1xcbiAgICAgIGA7Zm9yKGxldCB0PWYtMTt0Pj0wO3QtLSlkW3RdPXQ9PT1mLTE/MTpkW3QrMV0qY1t0KzFdLGhbdF09dD09PWYtMT8xOmhbdCsxXSplWzBdLmRpbXNbdCsxXSxnKz1gXFxuICAgICAgICBvdXRwdXRfcGl0Y2hlc1ske3R9XSA9ICR7ZFt0XX07XFxuICAgICAgICBpbnB1dF9waXRjaGVzWyR7dH1dID0gJHtoW3RdfTtcXG4gICAgICAgIGA7Y29uc3QgYj1gXFxuICAgICAgZmxvYXQgZ2V0SW5wdXRGbG9hdChpbnQgaW5kZXgpIHtcXG4gICAgICAgIHZlYzIgY29vcmRzID0gb2Zmc2V0VG9Db29yZHMoaW5kZXgsICR7c30sICR7dX0pO1xcbiAgICAgICAgZmxvYXQgdmFsdWUgPSBnZXRDb2xvckFzRmxvYXQoJHtyLnRleHR1cmUyRH0oWCwgY29vcmRzKSk7XFxuICAgICAgICByZXR1cm4gdmFsdWU7XFxuICAgICAgfVxcbiAgICAgIGAsbT1cIm5lYXJlc3RcIj09PW4ubW9kZT9gXFxuICAgICR7Yn1cXG4gICAgZmxvYXQgcHJvY2VzcyhpbnQgaW5kaWNlc1ske2Z9XSkge1xcbiAgICAgIGludCBpbnB1dF9pbmRleCA9IDA7XFxuICAgICAgaW50IG91dHB1dF9pbmRleCA9IGNvb3Jkc1RvT2Zmc2V0KFRleENvb3JkcywgJHtsfSwgJHtwfSk7XFxuXFxuICAgICAgJHtnfVxcblxcbiAgICAgIGludCBkLCBtO1xcbiAgICAgIGZvciAoaW50IGRpbSA9IDA7IGRpbSA8ICR7Zn07ICsrZGltKSB7XFxuICAgICAgICBkID0gb3V0cHV0X2luZGV4IC8gb3V0cHV0X3BpdGNoZXNbZGltXTtcXG4gICAgICAgIG0gPSBvdXRwdXRfaW5kZXggLSBkICogb3V0cHV0X3BpdGNoZXNbZGltXTtcXG4gICAgICAgIG91dHB1dF9pbmRleCA9IG07XFxuXFxuICAgICAgICBpZiAoc2NhbGVzW2RpbV0gIT0gMSAmJiBkID4gMCkge1xcbiAgICAgICAgICBpbnQgZDIgPSBkIC8gc2NhbGVzW2RpbV07XFxuICAgICAgICAgIG0gPSBkIC0gZDIgKiBzY2FsZXNbZGltXTtcXG4gICAgICAgICAgZCA9IGQyO1xcbiAgICAgICAgfVxcbiAgICAgICAgaW5wdXRfaW5kZXggKz0gaW5wdXRfcGl0Y2hlc1tkaW1dICogZDtcXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIGdldElucHV0RmxvYXQoaW5wdXRfaW5kZXgpO1xcbiAgICB9YDo0PT09Zj9gXFxuICAgICR7Yn1cXG4gICAgZmxvYXQgcHJvY2VzcyhpbnQgaW5kaWNlc1s0XSkge1xcbiAgICAgIGludCBpbnB1dF9pbmRleCA9IDA7XFxuICAgICAgaW50IG91dHB1dF9pbmRleCA9IGNvb3Jkc1RvT2Zmc2V0KFRleENvb3JkcywgJHtsfSwgJHtwfSk7XFxuXFxuICAgICAgJHtnfVxcblxcbiAgICAgIGludCBtO1xcbiAgICAgIGludCBpbmRleF9vZl9kaW0wLCBpbmRleF9vZl9kaW0xLCBpbmRleF9vZl9kaW0yLCBpbmRleF9vZl9kaW0zO1xcbiAgICAgIGluZGV4X29mX2RpbTAgPSBvdXRwdXRfaW5kZXggLyBvdXRwdXRfcGl0Y2hlc1swXTtcXG4gICAgICBtID0gb3V0cHV0X2luZGV4IC0gaW5kZXhfb2ZfZGltMCAqIG91dHB1dF9waXRjaGVzWzBdO1xcbiAgICAgIGluZGV4X29mX2RpbTEgPSBtIC8gb3V0cHV0X3BpdGNoZXNbMV07XFxuICAgICAgbSA9IG0gLSBpbmRleF9vZl9kaW0xICogb3V0cHV0X3BpdGNoZXNbMV07XFxuICAgICAgaW5kZXhfb2ZfZGltMiA9IG0gLyBvdXRwdXRfcGl0Y2hlc1syXTtcXG4gICAgICBtID0gbSAtIGluZGV4X29mX2RpbTIgKiBvdXRwdXRfcGl0Y2hlc1syXTtcXG4gICAgICBpbmRleF9vZl9kaW0zID0gbTtcXG5cXG4gICAgICBpbnQgaW5kZXhfb2ZfaW5wdXRfZGltMiwgaW5kZXhfb2ZfaW5wdXRfZGltMywgeF9vZmZzZXQsIHlfb2Zmc2V0O1xcbiAgICAgIGluZGV4X29mX2lucHV0X2RpbTIgPSBpbmRleF9vZl9kaW0yIC8gc2NhbGVzWzJdO1xcbiAgICAgIHlfb2Zmc2V0ID0gaW5kZXhfb2ZfZGltMiAtIGluZGV4X29mX2lucHV0X2RpbTIgKiBzY2FsZXNbMl07XFxuICAgICAgaW5kZXhfb2ZfaW5wdXRfZGltMyA9IGluZGV4X29mX2RpbTMgLyBzY2FsZXNbM107XFxuICAgICAgeF9vZmZzZXQgPSBpbmRleF9vZl9kaW0zIC0gaW5kZXhfb2ZfaW5wdXRfZGltMyAqIHNjYWxlc1szXTtcXG5cXG4gICAgICBpbnB1dF9pbmRleCA9IGluZGV4X29mX2RpbTAgKiBpbnB1dF9waXRjaGVzWzBdICtcXG4gICAgICAgICAgICBpbmRleF9vZl9kaW0xICogaW5wdXRfcGl0Y2hlc1sxXSArXFxuICAgICAgICAgICAgaW5kZXhfb2ZfaW5wdXRfZGltMiAqIGlucHV0X3BpdGNoZXNbMl0gK1xcbiAgICAgICAgICAgIGluZGV4X29mX2lucHV0X2RpbTM7XFxuXFxuICAgICAgZmxvYXQgeDAwID0gZ2V0SW5wdXRGbG9hdChpbnB1dF9pbmRleCk7XFxuICAgICAgZmxvYXQgeDEwLCB4MDEsIHgxMTtcXG5cXG4gICAgICBib29sIGVuZF9vZl9kaW0yID0gZmFsc2U7XFxuICAgICAgaWYgKGluZGV4X29mX2lucHV0X2RpbTIgPT0gKCR7ZVswXS5kaW1zWzJdfSAtIDEpKSB7XFxuICAgICAgICAvLyBJdCdzIHRoZSBlbmQgaW4gZGltZW5zaW9uIDJcXG4gICAgICAgIHgwMSA9IHgwMDtcXG4gICAgICAgIGVuZF9vZl9kaW0yID0gdHJ1ZTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgeDAxID0gZ2V0SW5wdXRGbG9hdChpbnB1dF9pbmRleCArIGlucHV0X3BpdGNoZXNbMl0pO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoaW5kZXhfb2ZfaW5wdXRfZGltMyA9PSAoaW5wdXRfcGl0Y2hlc1syXSAtIDEpKSB7XFxuICAgICAgICAvLyBJdCdzIHRoZSBlbmQgaW4gZGltZW5zaW9uIDNcXG4gICAgICAgIHgxMCA9IHgwMDtcXG4gICAgICAgIHgxMSA9IHgwMTtcXG4gICAgICB9XFxuICAgICAgZWxzZSB7XFxuICAgICAgICB4MTAgPSBnZXRJbnB1dEZsb2F0KGlucHV0X2luZGV4ICsgMSk7XFxuICAgICAgICB4MTEgPSBlbmRfb2ZfZGltMiA/IHgxMCA6IGdldElucHV0RmxvYXQoaW5wdXRfaW5kZXggKyBpbnB1dF9waXRjaGVzWzJdICsgMSk7XFxuICAgICAgfVxcblxcbiAgICAgIGZsb2F0IHkwID0geDAwICsgZmxvYXQoeV9vZmZzZXQpICogKHgwMSAtIHgwMCkgLyBmbG9hdChzY2FsZXNbMl0pO1xcbiAgICAgIGZsb2F0IHkxID0geDEwICsgZmxvYXQoeV9vZmZzZXQpICogKHgxMSAtIHgxMCkgLyBmbG9hdChzY2FsZXNbMl0pO1xcbiAgICAgIHJldHVybiB5MCArIGZsb2F0KHhfb2Zmc2V0KSAqICh5MSAtIHkwKSAvIGZsb2F0KHNjYWxlc1szXSk7XFxuICAgIH1gOmBcXG4gICAgJHtifVxcbiAgICBmbG9hdCBwcm9jZXNzKGludCBpbmRpY2VzWzJdKSB7XFxuICAgICAgaW50IGlucHV0X2luZGV4ID0gMDtcXG4gICAgICBpbnQgb3V0cHV0X2luZGV4ID0gY29vcmRzVG9PZmZzZXQoVGV4Q29vcmRzLCAke2x9LCAke3B9KTtcXG5cXG4gICAgICAke2d9XFxuXFxuICAgICAgaW50IG07XFxuICAgICAgaW50IGluZGV4X29mX2RpbTAsIGluZGV4X29mX2RpbTE7XFxuICAgICAgaW5kZXhfb2ZfZGltMCA9IG91dHB1dF9pbmRleCAvIG91dHB1dF9waXRjaGVzWzBdO1xcbiAgICAgIG0gPSBvdXRwdXRfaW5kZXggLSBpbmRleF9vZl9kaW0wICogb3V0cHV0X3BpdGNoZXNbMF07XFxuICAgICAgaW5kZXhfb2ZfZGltMSA9IG07XFxuXFxuICAgICAgaW50IGluZGV4X29mX2lucHV0X2RpbTAsIGluZGV4X29mX2lucHV0X2RpbTEsIHhfb2Zmc2V0LCB5X29mZnNldDtcXG4gICAgICBpbmRleF9vZl9pbnB1dF9kaW0wID0gaW5kZXhfb2ZfZGltMCAvIHNjYWxlc1swXTtcXG4gICAgICB5X29mZnNldCA9IGluZGV4X29mX2RpbTAgLSBpbmRleF9vZl9pbnB1dF9kaW0wICogc2NhbGVzWzBdO1xcbiAgICAgIGluZGV4X29mX2lucHV0X2RpbTEgPSBpbmRleF9vZl9kaW0xIC8gc2NhbGVzWzFdO1xcbiAgICAgIHhfb2Zmc2V0ID0gaW5kZXhfb2ZfZGltMSAtIGluZGV4X29mX2lucHV0X2RpbTEgKiBzY2FsZXNbMV07XFxuXFxuICAgICAgaW5wdXRfaW5kZXggPSBpbmRleF9vZl9pbnB1dF9kaW0wICogaW5wdXRfcGl0Y2hlc1swXSArIGluZGV4X29mX2lucHV0X2RpbTE7XFxuXFxuICAgICAgZmxvYXQgeDAwID0gZ2V0SW5wdXRGbG9hdChpbnB1dF9pbmRleCk7XFxuICAgICAgZmxvYXQgeDEwLCB4MDEsIHgxMTtcXG5cXG4gICAgICBib29sIGVuZF9vZl9kaW0wID0gZmFsc2U7XFxuICAgICAgaWYgKGluZGV4X29mX2lucHV0X2RpbTAgPT0gKCR7ZVswXS5kaW1zWzBdfSAtIDEpKSB7XFxuICAgICAgICAvLyBJdCdzIHRoZSBlbmQgaW4gZGltZW5zaW9uIDBcXG4gICAgICAgIHgwMSA9IHgwMDtcXG4gICAgICAgIGVuZF9vZl9kaW0wID0gdHJ1ZTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgeDAxID0gZ2V0SW5wdXRGbG9hdChpbnB1dF9pbmRleCArIGlucHV0X3BpdGNoZXNbMF0pO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoaW5kZXhfb2ZfaW5wdXRfZGltMSA9PSAoaW5wdXRfcGl0Y2hlc1swXSAtIDEpKSB7XFxuICAgICAgICAvLyBJdCdzIHRoZSBlbmQgaW4gZGltZW5zaW9uIDFcXG4gICAgICAgIHgxMCA9IHgwMDtcXG4gICAgICAgIHgxMSA9IHgwMTtcXG4gICAgICB9XFxuICAgICAgZWxzZSB7XFxuICAgICAgICB4MTAgPSBnZXRJbnB1dEZsb2F0KGlucHV0X2luZGV4ICsgMSk7XFxuICAgICAgICB4MTEgPSBlbmRfb2ZfZGltMCA/IHgxMCA6IGdldElucHV0RmxvYXQoaW5wdXRfaW5kZXggKyBpbnB1dF9waXRjaGVzWzBdICsgMSk7XFxuICAgICAgfVxcblxcbiAgICAgIGZsb2F0IHkwID0geDAwICsgZmxvYXQoeV9vZmZzZXQpICogKHgwMSAtIHgwMCkgLyBmbG9hdChzY2FsZXNbMF0pO1xcbiAgICAgIGZsb2F0IHkxID0geDEwICsgZmxvYXQoeV9vZmZzZXQpICogKHgxMSAtIHgxMCkgLyBmbG9hdChzY2FsZXNbMF0pO1xcbiAgICAgIHJldHVybiB5MCArIGZsb2F0KHhfb2Zmc2V0KSAqICh5MSAtIHkwKSAvIGZsb2F0KHNjYWxlc1sxXSk7XFxuICAgIH1gO3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sYSkse291dHB1dDp7ZGltczpjLHR5cGU6ZVswXS50eXBlLHRleHR1cmVUeXBlOm8uVGV4dHVyZVR5cGUudW5wYWNrZWR9LHNoYWRlclNvdXJjZTptLHZhcmlhYmxlczpbe25hbWU6XCJzY2FsZXNcIix0eXBlOlwiaW50XCIsYXJyYXlMZW5ndGg6bi5zY2FsZXMubGVuZ3RoLGRhdGE6bi5zY2FsZXMubWFwKCh0PT5NYXRoLmNlaWwodCkpKX1dfSl9O2UudmFsaWRhdGVJbnB1dHM9KHQsZSk9PntpZighdHx8ZS5vcHNldDw5JiYxIT09dC5sZW5ndGh8fGUub3BzZXQ+PTkmJmUub3BzZXQ8MTEmJjIhPT10Lmxlbmd0aHx8ZS5vcHNldD49MTEmJnQubGVuZ3RoPDIpdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBpbnB1dHMuXCIpO2lmKGUuc2NhbGVzLmxlbmd0aD4wJiZ0WzBdLmRpbXMubGVuZ3RoIT09ZS5zY2FsZXMubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW5wdXQgc2hhcGUuXCIpO2lmKFwic3RyaW5nXCI9PT10WzBdLnR5cGUpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbnB1dCB0ZW5zb3IgdHlwZXMuXCIpfSxlLnNjYWxlc1ZhbGlkYXRpb249KHQsZSxuKT0+e2lmKG4pe2Zvcihjb25zdCBlIG9mIHQpaWYoZTw9MCl0aHJvdyBuZXcgRXJyb3IoXCJTY2FsZSB2YWx1ZSBzaG91bGQgYmUgZ3JlYXRlciB0aGFuIDAuXCIpfWVsc2UgZm9yKGNvbnN0IGUgb2YgdClpZihlPDEpdGhyb3cgbmV3IEVycm9yKFwiU2NhbGUgdmFsdWUgc2hvdWxkIGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAxLlwiKTtpZighKFwibGluZWFyXCIhPT1lJiZcImN1YmljXCIhPT1lfHwyPT09dC5sZW5ndGh8fDQ9PT10Lmxlbmd0aCYmMT09PXRbMF0mJjE9PT10WzFdKSl0aHJvdyBuZXcgRXJyb3IoYCdMaW5lYXInIG1vZGUgYW5kICdDdWJpYycgbW9kZSBvbmx5IHN1cHBvcnQgMi1EIGlucHV0cyAoJ0JpbGluZWFyJywgJ0JpY3ViaWMnKSAgICAgICAgIG9yIDQtRCBpbnB1dHMgd2l0aCB0aGUgY29ycmVzcG9uZGluZyBvdXRlcm1vc3QgMiBzY2FsZSB2YWx1ZXMgYmVpbmcgMSAgICAgICAgIGluIHRoZSAke24/XCJSZXNpemVcIjpcIlVwc2FtcGxlXCJ9IG9wZWFydG9yLmApfX0sMTk1ODoodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5Qcm9ncmFtTWFuYWdlcj12b2lkIDA7Y29uc3Qgcj1uKDYyMDcpLGk9bigzNjk0KSxvPW4oODg3OSksYT1uKDUwNjApO2UuUHJvZ3JhbU1hbmFnZXI9Y2xhc3N7Y29uc3RydWN0b3IodCxlLG4pe3RoaXMucHJvZmlsZXI9dCx0aGlzLmdsQ29udGV4dD1lLHRoaXMudGV4dHVyZUxheW91dFN0cmF0ZWd5PW4sdGhpcy5yZXBvPW5ldyBNYXAsdGhpcy5hdHRyaWJ1dGVzQm91bmQ9ITF9Z2V0QXJ0aWZhY3QodCl7cmV0dXJuIHRoaXMucmVwby5nZXQodCl9c2V0QXJ0aWZhY3QodCxlKXt0aGlzLnJlcG8uc2V0KHQsZSl9cnVuKHQsZSxuKXt2YXIgcjt0aGlzLnByb2ZpbGVyLmV2ZW50KFwib3BcIixgUHJvZ3JhbU1hbmFnZXIucnVuICR7bnVsbCE9PShyPXQucHJvZ3JhbUluZm8ubmFtZSkmJnZvaWQgMCE9PXI/cjpcInVua25vd24ga2VybmVsXCJ9YCwoKCk9Pnt2YXIgcjtjb25zdCBvPXRoaXMuZ2xDb250ZXh0LmdsLGE9dC5wcm9ncmFtO28udXNlUHJvZ3JhbShhKTt0cnl7dGhpcy5iaW5kT3V0cHV0KG4pLHRoaXMuYXR0cmlidXRlc0JvdW5kfHx0aGlzLmJpbmRBdHRyaWJ1dGVzKHQuYXR0cmliTG9jYXRpb25zKSx0aGlzLmJpbmRVbmlmb3Jtcyh0LnVuaWZvcm1Mb2NhdGlvbnMsbnVsbCE9PShyPXQucHJvZ3JhbUluZm8udmFyaWFibGVzKSYmdm9pZCAwIT09cj9yOltdLGUpfWNhdGNoKGUpe3Rocm93IGkuTG9nZ2VyLmVycm9yKFwiUHJvZ3JhbU1hbmFnZXJcIix0LnByb2dyYW1JbmZvLnNoYWRlclNvdXJjZSksZX10aGlzLnByb2ZpbGVyLmV2ZW50KFwiYmFja2VuZFwiLFwiR2xDb250ZXh0LmRyYXcoKVwiLCgoKT0+e3RoaXMuZ2xDb250ZXh0LmRyYXcoKX0pKX0pLHRoaXMuZ2xDb250ZXh0KX1kaXNwb3NlKCl7dGhpcy52ZXJ0ZXhTaGFkZXImJnRoaXMuZ2xDb250ZXh0LmRlbGV0ZVNoYWRlcih0aGlzLnZlcnRleFNoYWRlciksdGhpcy5yZXBvLmZvckVhY2goKHQ9PnRoaXMuZ2xDb250ZXh0LmRlbGV0ZVByb2dyYW0odC5wcm9ncmFtKSkpfWJ1aWxkKHQsZSxuKXtyZXR1cm4gdGhpcy5wcm9maWxlci5ldmVudChcImJhY2tlbmRcIixcIlByb2dyYW1NYW5hZ2VyLmJ1aWxkXCIsKCgpPT57Y29uc3Qgcj1uZXcgby5HbHNsUHJlcHJvY2Vzc29yKHRoaXMuZ2xDb250ZXh0LHQsZSxuKSxpPXIucHJlcHJvY2VzcygpLGE9dGhpcy5jb21waWxlKGkpO3JldHVybntwcm9ncmFtSW5mbzp0LHByb2dyYW06YSx1bmlmb3JtTG9jYXRpb25zOnRoaXMuZ2V0VW5pZm9ybUxvY2F0aW9ucyhhLHIuY29udGV4dC5wcm9ncmFtSW5mby5pbnB1dE5hbWVzLHIuY29udGV4dC5wcm9ncmFtSW5mby52YXJpYWJsZXMpLGF0dHJpYkxvY2F0aW9uczp0aGlzLmdldEF0dHJpYkxvY2F0aW9ucyhhKX19KSl9Y29tcGlsZSh0KXtpZighdGhpcy52ZXJ0ZXhTaGFkZXIpe2kuTG9nZ2VyLnZlcmJvc2UoXCJQcm9yZ3JhbU1hbmFnZXJcIixcIkNvbXBpbGluZyBhbmQgY2FjaGluZyBWZXJ0ZXggc2hhZGVyIGZvciB0aGUgZmlyc3QgdGltZVwiKTtjb25zdCB0PSgwLGEuZ2V0VmVydGV4U2hhZGVyU291cmNlKSh0aGlzLmdsQ29udGV4dC52ZXJzaW9uKTt0aGlzLnZlcnRleFNoYWRlcj10aGlzLmdsQ29udGV4dC5jb21waWxlU2hhZGVyKHQsdGhpcy5nbENvbnRleHQuZ2wuVkVSVEVYX1NIQURFUil9ci5lbnYuZGVidWcmJmkuTG9nZ2VyLnZlcmJvc2UoXCJQcm9yZ3JhbU1hbmFnZXJcIixgRnJhZ1NoYWRlcjpcXG4ke3R9XFxuYCk7Y29uc3QgZT10aGlzLmdsQ29udGV4dC5jb21waWxlU2hhZGVyKHQsdGhpcy5nbENvbnRleHQuZ2wuRlJBR01FTlRfU0hBREVSKSxuPXRoaXMuZ2xDb250ZXh0LmNyZWF0ZVByb2dyYW0odGhpcy52ZXJ0ZXhTaGFkZXIsZSk7cmV0dXJuIHRoaXMuZ2xDb250ZXh0LmRlbGV0ZVNoYWRlcihlKSxufWJpbmRPdXRwdXQodCl7Y29uc3QgZT10LndpZHRoLG49dC5oZWlnaHQ7aS5Mb2dnZXIudmVyYm9zZShcIlByb3JncmFtTWFuYWdlclwiLGBCaW5kaW5nIG91dHB1dCB0ZXh0dXJlIHRvIEZyYW1lYnVmZmVyOiB3L2g9JHtlfS8ke259LCBzaGFwZT0ke3Quc2hhcGV9LCB0eXBlPSR7dC50ZW5zb3IudHlwZX1gKSx0aGlzLmdsQ29udGV4dC5hdHRhY2hGcmFtZWJ1ZmZlcih0LnRleHR1cmUsZSxuKX1iaW5kQXR0cmlidXRlcyh0KXtjb25zdCBlPXQucG9zaXRpb24sbj10LnRleHR1cmVDb29yZDt0aGlzLmdsQ29udGV4dC5zZXRWZXJ0ZXhBdHRyaWJ1dGVzKGUsbiksdGhpcy5hdHRyaWJ1dGVzQm91bmQ9ITB9YmluZFVuaWZvcm1zKHQsZSxuKXt2YXIgcjtjb25zdCBpPXRoaXMuZ2xDb250ZXh0LmdsO2xldCBvPTA7Zm9yKGNvbnN0e25hbWU6YSx0eXBlOnMsbG9jYXRpb246dSxhcnJheUxlbmd0aDpjfW9mIHQpe2NvbnN0IHQ9bnVsbD09PShyPWUuZmluZCgodD0+dC5uYW1lPT09YSkpKXx8dm9pZCAwPT09cj92b2lkIDA6ci5kYXRhO2lmKFwic2FtcGxlcjJEXCIhPT1zJiYhdCl0aHJvdyBuZXcgRXJyb3IoYHZhcmlhYmxlICcke2F9JyBkb2VzIG5vdCBoYXZlIGRhdGEgZGVmaW5lZCBpbiBwcm9ncmFtIGluZm9gKTtzd2l0Y2gocyl7Y2FzZVwic2FtcGxlcjJEXCI6dGhpcy5iaW5kVGV4dHVyZShuW29dLHUsbyksbysrO2JyZWFrO2Nhc2VcImZsb2F0XCI6Yz9pLnVuaWZvcm0xZnYodSx0KTppLnVuaWZvcm0xZih1LHQpO2JyZWFrO2Nhc2VcImludFwiOmM/aS51bmlmb3JtMWl2KHUsdCk6aS51bmlmb3JtMWkodSx0KTticmVhaztkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgVW5pZm9ybSBub3QgaW1wbGVtZW50ZWQ6ICR7c31gKX19fWJpbmRUZXh0dXJlKHQsZSxuKXt0aGlzLmdsQ29udGV4dC5iaW5kVGV4dHVyZVRvVW5pZm9ybSh0LnRleHR1cmUsbixlKX1nZXRBdHRyaWJMb2NhdGlvbnModCl7cmV0dXJue3Bvc2l0aW9uOnRoaXMuZ2V0QXR0cmliTG9jYXRpb24odCxcInBvc2l0aW9uXCIpLHRleHR1cmVDb29yZDp0aGlzLmdldEF0dHJpYkxvY2F0aW9uKHQsXCJ0ZXh0dXJlQ29vcmRcIil9fWdldFVuaWZvcm1Mb2NhdGlvbnModCxlLG4pe2NvbnN0IHI9W107aWYoZSlmb3IoY29uc3QgbiBvZiBlKXIucHVzaCh7bmFtZTpuLHR5cGU6XCJzYW1wbGVyMkRcIixsb2NhdGlvbjp0aGlzLmdldFVuaWZvcm1Mb2NhdGlvbih0LG4pfSk7aWYobilmb3IoY29uc3QgZSBvZiBuKXIucHVzaChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sZSkse2xvY2F0aW9uOnRoaXMuZ2V0VW5pZm9ybUxvY2F0aW9uKHQsZS5uYW1lKX0pKTtyZXR1cm4gcn1nZXRVbmlmb3JtTG9jYXRpb24odCxlKXtjb25zdCBuPXRoaXMuZ2xDb250ZXh0LmdsLmdldFVuaWZvcm1Mb2NhdGlvbih0LGUpO2lmKG51bGw9PT1uKXRocm93IG5ldyBFcnJvcihgVW5pZm9ybSAke2V9IG5vdCBmb3VuZC5gKTtyZXR1cm4gbn1nZXRBdHRyaWJMb2NhdGlvbih0LGUpe3JldHVybiB0aGlzLmdsQ29udGV4dC5nbC5nZXRBdHRyaWJMb2NhdGlvbih0LGUpfX19LDY0MTY6KHQsZSxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUuV2ViR0xTZXNzaW9uSGFuZGxlcj12b2lkIDA7Y29uc3Qgcj1uKDM2OTQpLGk9bigxMDQ3KSxvPW4oODMxNiksYT1uKDE2NDApLHM9bigxOTU4KSx1PW4oNzg1OSksYz1uKDU3MDIpO2UuV2ViR0xTZXNzaW9uSGFuZGxlcj1jbGFzc3tjb25zdHJ1Y3Rvcih0LGUpe3RoaXMuYmFja2VuZD10LHRoaXMuY29udGV4dD1lLHRoaXMubGF5b3V0U3RyYXRlZ3k9bmV3IHUuUHJlZmVyTG9naWNhbFN0cmF0ZWd5KHQuZ2xDb250ZXh0Lm1heFRleHR1cmVTaXplKSx0aGlzLnByb2dyYW1NYW5hZ2VyPW5ldyBzLlByb2dyYW1NYW5hZ2VyKHRoaXMuY29udGV4dC5wcm9maWxlcix0LmdsQ29udGV4dCx0aGlzLmxheW91dFN0cmF0ZWd5KSx0aGlzLnRleHR1cmVNYW5hZ2VyPW5ldyBjLlRleHR1cmVNYW5hZ2VyKHQuZ2xDb250ZXh0LHRoaXMubGF5b3V0U3RyYXRlZ3ksdGhpcy5jb250ZXh0LnByb2ZpbGVyLHtyZXVzZVRleHR1cmVzOlwiZnVsbFwiPT09dC50ZXh0dXJlQ2FjaGVNb2RlfSksdGhpcy5wYWNrZWRUZXh0dXJlRGF0YUNhY2hlPW5ldyBNYXAsdGhpcy51bnBhY2tlZFRleHR1cmVEYXRhQ2FjaGU9bmV3IE1hcCx0aGlzLnBhY2s9dC5wYWNrLHRoaXMucGFjazJ1bnBhY2tNYXA9bmV3IE1hcCx0aGlzLnVucGFjazJwYWNrTWFwPW5ldyBNYXB9Y3JlYXRlSW5mZXJlbmNlSGFuZGxlcigpe3JldHVybiBuZXcgby5XZWJHTEluZmVyZW5jZUhhbmRsZXIodGhpcyl9b25HcmFwaEluaXRpYWxpemVkKHQpe2NvbnN0IGU9dC5nZXRWYWx1ZXMoKS5maWx0ZXIoKHQ9Pi0xPT09dC5mcm9tJiZ0LnRlbnNvcikpLm1hcCgodD0+dC50ZW5zb3IuZGF0YUlkKSk7dGhpcy5pbml0aWFsaXplcnM9bmV3IFNldChlKX1pc0luaXRpYWxpemVyKHQpe3JldHVybiEhdGhpcy5pbml0aWFsaXplcnMmJnRoaXMuaW5pdGlhbGl6ZXJzLmhhcyh0KX1hZGRJbml0aWFsaXplcih0KXt0aGlzLmluaXRpYWxpemVycy5hZGQodCl9Z2V0VGV4dHVyZURhdGEodCxlKXtyZXR1cm4gZT90aGlzLnBhY2tlZFRleHR1cmVEYXRhQ2FjaGUuZ2V0KHQpOnRoaXMudW5wYWNrZWRUZXh0dXJlRGF0YUNhY2hlLmdldCh0KX1zZXRUZXh0dXJlRGF0YSh0LGUsbj0hMSl7ci5Mb2dnZXIudmVyYm9zZShcIldlYkdMU2Vzc2lvbkhhbmRsZXJcIixcIlN0b3JpbmcgVGV4dHVyZSBkYXRhIGluIGNhY2hlXCIpLG4/dGhpcy5wYWNrZWRUZXh0dXJlRGF0YUNhY2hlLnNldCh0LGUpOnRoaXMudW5wYWNrZWRUZXh0dXJlRGF0YUNhY2hlLnNldCh0LGUpfWRpc3Bvc2UoKXt0aGlzLnByb2dyYW1NYW5hZ2VyLmRpc3Bvc2UoKSx0aGlzLnRleHR1cmVNYW5hZ2VyLmNsZWFyQWN0aXZlVGV4dHVyZXMoKSx0aGlzLnBhY2tlZFRleHR1cmVEYXRhQ2FjaGUuZm9yRWFjaCgodD0+dGhpcy50ZXh0dXJlTWFuYWdlci5yZWxlYXNlVGV4dHVyZSh0LCEwKSkpLHRoaXMucGFja2VkVGV4dHVyZURhdGFDYWNoZT1uZXcgTWFwLHRoaXMudW5wYWNrZWRUZXh0dXJlRGF0YUNhY2hlLmZvckVhY2goKHQ9PnRoaXMudGV4dHVyZU1hbmFnZXIucmVsZWFzZVRleHR1cmUodCwhMCkpKSx0aGlzLnVucGFja2VkVGV4dHVyZURhdGFDYWNoZT1uZXcgTWFwfXJlc29sdmUodCxlLG4pe2NvbnN0IHI9KDAsaS5yZXNvbHZlT3BlcmF0b3IpKHQsZSxhLldFQkdMX09QX1JFU09MVkVfUlVMRVMpO3JldHVybntpbXBsOnIub3BJbXBsLGNvbnRleHQ6ci5vcEluaXQ/ci5vcEluaXQodCxuKTp0fX19fSw3NzY5Oih0LGUsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLlVpbnQ4RGF0YUVuY29kZXI9ZS5SR0JBRmxvYXREYXRhRW5jb2Rlcj1lLlJlZEZsb2F0MzJEYXRhRW5jb2Rlcj12b2lkIDA7Y29uc3Qgcj1uKDM2OTQpO2UuUmVkRmxvYXQzMkRhdGFFbmNvZGVyPWNsYXNze2NvbnN0cnVjdG9yKHQsZT0xKXtpZigxPT09ZSl0aGlzLmludGVybmFsRm9ybWF0PXQuUjMyRix0aGlzLmZvcm1hdD10LlJFRCx0aGlzLnRleHR1cmVUeXBlPXQuRkxPQVQsdGhpcy5jaGFubmVsU2l6ZT1lO2Vsc2V7aWYoNCE9PWUpdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIG51bWJlciBvZiBjaGFubmVsczogJHtlfWApO3RoaXMuaW50ZXJuYWxGb3JtYXQ9dC5SR0JBMzJGLHRoaXMuZm9ybWF0PXQuUkdCQSx0aGlzLnRleHR1cmVUeXBlPXQuRkxPQVQsdGhpcy5jaGFubmVsU2l6ZT1lfX1lbmNvZGUodCxlKXtsZXQgbixpO3JldHVybiB0LmNvbnN0cnVjdG9yIT09RmxvYXQzMkFycmF5JiYoci5Mb2dnZXIud2FybmluZyhcIkVuY29kZXJcIixcImRhdGEgd2FzIG5vdCBvZiB0eXBlIEZsb2F0MzI7IGNyZWF0aW5nIG5ldyBGbG9hdDMyQXJyYXlcIiksaT1uZXcgRmxvYXQzMkFycmF5KHQpKSxlKnRoaXMuY2hhbm5lbFNpemU+dC5sZW5ndGg/KHIuTG9nZ2VyLndhcm5pbmcoXCJFbmNvZGVyXCIsXCJTb3VyY2UgZGF0YSB0b28gc21hbGwuIEFsbG9jYXRpbmcgbGFyZ2VyIGFycmF5XCIpLGk9dCxuPXRoaXMuYWxsb2NhdGUoZSp0aGlzLmNoYW5uZWxTaXplKSxpLmZvckVhY2goKCh0LGUpPT5uW2VdPXQpKSk6KGk9dCxuPWkpLG59YWxsb2NhdGUodCl7cmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkoNCp0KX1kZWNvZGUodCxlKXtyZXR1cm4gMT09PXRoaXMuY2hhbm5lbFNpemU/dC5maWx0ZXIoKCh0LGUpPT5lJTQ9PTApKS5zdWJhcnJheSgwLGUpOnQuc3ViYXJyYXkoMCxlKX19LGUuUkdCQUZsb2F0RGF0YUVuY29kZXI9Y2xhc3N7Y29uc3RydWN0b3IodCxlPTEsbil7aWYoMSE9PWUmJjQhPT1lKXRocm93IG5ldyBFcnJvcihgSW52YWxpZCBudW1iZXIgb2YgY2hhbm5lbHM6ICR7ZX1gKTt0aGlzLmludGVybmFsRm9ybWF0PXQuUkdCQSx0aGlzLmZvcm1hdD10LlJHQkEsdGhpcy5jaGFubmVsU2l6ZT1lLHRoaXMudGV4dHVyZVR5cGU9bnx8dC5GTE9BVH1lbmNvZGUodCxlKXtsZXQgbj10O3JldHVybiAxPT09dGhpcy5jaGFubmVsU2l6ZSYmKHIuTG9nZ2VyLnZlcmJvc2UoXCJFbmNvZGVyXCIsXCJFeHBsb2RpbmcgaW50byBhIGxhcmdlciBhcnJheVwiKSxuPXRoaXMuYWxsb2NhdGUoZSksdC5mb3JFYWNoKCgodCxlKT0+bls0KmVdPXQpKSksbn1hbGxvY2F0ZSh0KXtyZXR1cm4gbmV3IEZsb2F0MzJBcnJheSg0KnQpfWRlY29kZSh0LGUpe3JldHVybiAxPT09dGhpcy5jaGFubmVsU2l6ZT90LmZpbHRlcigoKHQsZSk9PmUlND09MCkpLnN1YmFycmF5KDAsZSk6dC5zdWJhcnJheSgwLGUpfX0sZS5VaW50OERhdGFFbmNvZGVyPWNsYXNze2NvbnN0cnVjdG9yKHQsZT0xKXtpZih0aGlzLmNoYW5uZWxTaXplPTQsMT09PWUpdGhpcy5pbnRlcm5hbEZvcm1hdD10LkFMUEhBLHRoaXMuZm9ybWF0PXQuQUxQSEEsdGhpcy50ZXh0dXJlVHlwZT10LlVOU0lHTkVEX0JZVEUsdGhpcy5jaGFubmVsU2l6ZT1lO2Vsc2V7aWYoNCE9PWUpdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIG51bWJlciBvZiBjaGFubmVsczogJHtlfWApO3RoaXMuaW50ZXJuYWxGb3JtYXQ9dC5SR0JBLHRoaXMuZm9ybWF0PXQuUkdCQSx0aGlzLnRleHR1cmVUeXBlPXQuVU5TSUdORURfQllURSx0aGlzLmNoYW5uZWxTaXplPWV9fWVuY29kZSh0LGUpe3JldHVybiBuZXcgVWludDhBcnJheSh0LmJ1ZmZlcix0LmJ5dGVPZmZzZXQsdC5ieXRlTGVuZ3RoKX1hbGxvY2F0ZSh0KXtyZXR1cm4gbmV3IFVpbnQ4QXJyYXkodCp0aGlzLmNoYW5uZWxTaXplKX1kZWNvZGUodCxlKXtpZih0IGluc3RhbmNlb2YgVWludDhBcnJheSlyZXR1cm4gdC5zdWJhcnJheSgwLGUpO3Rocm93IG5ldyBFcnJvcihgSW52YWxpZCBhcnJheSB0eXBlOiAke3QuY29uc3RydWN0b3J9YCl9fX0sNzg1OToodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5nZXRCYXRjaERpbT1lLnNpemVUb1NxdWFyaXNoU2hhcGU9ZS5nZXRSb3dzQ29scz1lLnNpemVGcm9tU2hhcGU9ZS5pc0ludD1lLnBhcnNlQXhpc1BhcmFtPWUuc3F1ZWV6ZVNoYXBlPWUuUHJlZmVyTG9naWNhbFN0cmF0ZWd5PWUuQWx3YXlzS2VlcE9yaWdpbmFsU2l6ZVN0cmF0ZWd5PXZvaWQgMDtjb25zdCByPW4oMzY5NCksaT1uKDI1MTcpO2Z1bmN0aW9uIG8odCxlKXtjb25zdCBuPVtdLHI9W10saT1udWxsIT1lJiZBcnJheS5pc0FycmF5KGUpJiYwPT09ZS5sZW5ndGgsbz1udWxsPT1lfHxpP251bGw6YShlLHQpLnNvcnQoKTtsZXQgcz0wO2ZvcihsZXQgZT0wO2U8dC5sZW5ndGg7KytlKXtpZihudWxsIT1vKXtpZihvW3NdPT09ZSYmMSE9PXRbZV0pdGhyb3cgbmV3IEVycm9yKGBDYW4ndCBzcXVlZXplIGF4aXMgJHtlfSBzaW5jZSBpdHMgZGltICcke3RbZV19JyBpcyBub3QgMWApOyhudWxsPT1vW3NdfHxvW3NdPmUpJiYxPT09dFtlXSYmKG4ucHVzaCh0W2VdKSxyLnB1c2goZSkpLG9bc108PWUmJnMrK30xIT09dFtlXSYmKG4ucHVzaCh0W2VdKSxyLnB1c2goZSkpfXJldHVybntuZXdTaGFwZTpuLGtlcHREaW1zOnJ9fWZ1bmN0aW9uIGEodCxlKXtjb25zdCBuPWUubGVuZ3RoO3JldHVybiB0PW51bGw9PXQ/ZS5tYXAoKCh0LGUpPT5lKSk6W10uY29uY2F0KHQpLCgwLGkuYXNzZXJ0KSh0LmV2ZXJ5KCh0PT50Pj0tbiYmdDxuKSksKCgpPT5gQWxsIHZhbHVlcyBpbiBheGlzIHBhcmFtIG11c3QgYmUgaW4gcmFuZ2UgWy0ke259LCAke259KSBidXQgZ290IGF4aXMgJHt0fWApKSwoMCxpLmFzc2VydCkodC5ldmVyeShzKSwoKCk9PmBBbGwgdmFsdWVzIGluIGF4aXMgcGFyYW0gbXVzdCBiZSBpbnRlZ2VycyBidXQgZ290IGF4aXMgJHt0fWApKSx0Lm1hcCgodD0+dDwwP24rdDp0KSl9ZnVuY3Rpb24gcyh0KXtyZXR1cm4gdCUxPT0wfWZ1bmN0aW9uIHUodCl7aWYoMD09PXQubGVuZ3RoKXJldHVybiAxO2xldCBlPXRbMF07Zm9yKGxldCBuPTE7bjx0Lmxlbmd0aDtuKyspZSo9dFtuXTtyZXR1cm4gZX1mdW5jdGlvbiBjKHQpe2NvbnN0IGU9TWF0aC5jZWlsKE1hdGguc3FydCh0KSk7cmV0dXJuW2UsTWF0aC5jZWlsKHQvZSldfWUuQWx3YXlzS2VlcE9yaWdpbmFsU2l6ZVN0cmF0ZWd5PWNsYXNze2NvbnN0cnVjdG9yKHQpe3RoaXMubWF4VGV4dHVyZVNpemU9dH1jb21wdXRlVGV4dHVyZVdIKHQsZSl7aWYoMD09PXQubGVuZ3RoKXJldHVyblsxLDFdO2NvbnN0IG49dGhpcy5tYXhUZXh0dXJlU2l6ZTtpZihlJiZ2b2lkIDAhPT1lLmJyZWFrQXhpcyl7Y29uc3QgaT1lLmJyZWFrQXhpcz49dC5sZW5ndGg/MTp0LnNsaWNlKGUuYnJlYWtBeGlzKS5yZWR1Y2UoKCh0LGUpPT50KmUpKSxvPWUuYnJlYWtBeGlzPD0wPzE6dC5zbGljZSgwLGUuYnJlYWtBeGlzKS5yZWR1Y2UoKCh0LGUpPT50KmUpKTtpZighKGk+bnx8bz5uKSlyZXR1cm5baSxvXTtyLkxvZ2dlci52ZXJib3NlKFwiVGV4dHVyZUxheW91dFwiLGBHaXZlbiB3aWR0aC9oZWlnaHQgcHJlZmVyZW5jZXMgd2VyZSB1bmF0dGFpbmFibGU6IHNoYXBlOiR7dH0sIGJyZWFrQXhpczoke2UuYnJlYWtBeGlzfWApfWNvbnN0IGk9dC5yZWR1Y2UoKCh0LGUpPT50KmUpKTtsZXQgbz1NYXRoLmZsb29yKE1hdGguc3FydChpKSk7Zm9yKDtvPG4mJm88aSYmaSVvIT0wO28rKyk7aWYobz49bnx8aSVvIT0wKXRocm93IG5ldyBFcnJvcihgVGhlIGdpdmVuIGRpbWVuc2lvbnMgYXJlIG91dHNpZGUgdGhpcyBHUFUncyBib3VuZGFyaWVzOiAke3R9YCk7cmV0dXJuW28saS9vXX19LGUuUHJlZmVyTG9naWNhbFN0cmF0ZWd5PWNsYXNze2NvbnN0cnVjdG9yKHQpe3RoaXMubWF4VGV4dHVyZVNpemU9dH1jb21wdXRlVGV4dHVyZVdIKHQsZSl7Y29uc3Qgbj10aGlzLmNvbXB1dGVUZXh0dXJlKHQsZSk7cmV0dXJuIGUmJmUuaXNQYWNrZWQmJihuWzBdLz0yLG5bMV0vPTIpLGUmJmUucmV2ZXJzZVdIP1tuWzFdLG5bMF1dOm59Y29tcHV0ZVRleHR1cmUodCxlKXtjb25zdCBuPWUmJmUuaXNQYWNrZWQ7aWYoMD09PXQubGVuZ3RoKXJldHVybiBuP1syLDJdOlsxLDFdO2xldCBpPXRoaXMubWF4VGV4dHVyZVNpemU7aWYoZSYmdm9pZCAwIT09ZS5icmVha0F4aXMpe2NvbnN0IG49ZS5icmVha0F4aXM+PXQubGVuZ3RoPzE6dC5zbGljZShlLmJyZWFrQXhpcykucmVkdWNlKCgodCxlKT0+dCplKSksbz1lLmJyZWFrQXhpczw9MD8xOnQuc2xpY2UoMCxlLmJyZWFrQXhpcykucmVkdWNlKCgodCxlKT0+dCplKSk7aWYoIShuPml8fG8+aSkpcmV0dXJuW24sb107ci5Mb2dnZXIudmVyYm9zZShcIlRleHR1cmVMYXlvdXRcIixgR2l2ZW4gd2lkdGgvaGVpZ2h0IHByZWZlcmVuY2VzIHdlcmUgdW5hdHRhaW5hYmxlOiBzaGFwZToke3R9LCBicmVha0F4aXM6JHtlLmJyZWFrQXhpc31gKX1sZXQgYT10LnNsaWNlKDApO2lmKG4mJihpKj0yLGE9YS5tYXAoKCh0LGUpPT5lPj1hLmxlbmd0aC0yP2FbZV0lMj09MD9hW2VdOmFbZV0rMTphW2VdKSksMT09PWEubGVuZ3RoJiYoYT1bMixhWzBdXSkpLDIhPT1hLmxlbmd0aCl7Y29uc3QgdD1vKGEpO2E9dC5uZXdTaGFwZX1jb25zdCBzPXUoYSk7cmV0dXJuIGEubGVuZ3RoPD0xJiZzPD1pP1sxLHNdOjI9PT1hLmxlbmd0aCYmYVswXTw9aSYmYVsxXTw9aT9hOjM9PT1hLmxlbmd0aCYmYVswXSphWzFdPD1pJiZhWzJdPD1pP1thWzBdKmFbMV0sYVsyXV06Mz09PWEubGVuZ3RoJiZhWzBdPD1pJiZhWzFdKmFbMl08PWk/W2FbMF0sYVsxXSphWzJdXTo0PT09YS5sZW5ndGgmJmFbMF0qYVsxXSphWzJdPD1pJiZhWzNdPD1pP1thWzBdKmFbMV0qYVsyXSxhWzNdXTo0PT09YS5sZW5ndGgmJmFbMF08PWkmJmFbMV0qYVsyXSphWzNdPD1pP1thWzBdLGFbMV0qYVsyXSphWzNdXTpuP2Mocy80KS5tYXAoKHQ9PjIqdCkpOmMocyl9fSxlLnNxdWVlemVTaGFwZT1vLGUucGFyc2VBeGlzUGFyYW09YSxlLmlzSW50PXMsZS5zaXplRnJvbVNoYXBlPXUsZS5nZXRSb3dzQ29scz1mdW5jdGlvbih0KXtpZigwPT09dC5sZW5ndGgpdGhyb3cgRXJyb3IoXCJDYW5ub3QgZ2V0IHJvd3MgYW5kIGNvbHVtbnMgb2YgYW4gZW1wdHkgc2hhcGUgYXJyYXkuXCIpO3JldHVyblt0Lmxlbmd0aD4xP3RbdC5sZW5ndGgtMl06MSx0W3QubGVuZ3RoLTFdXX0sZS5zaXplVG9TcXVhcmlzaFNoYXBlPWMsZS5nZXRCYXRjaERpbT1mdW5jdGlvbih0LGU9Mil7cmV0dXJuIHUodC5zbGljZSgwLHQubGVuZ3RoLWUpKX19LDQwNTc6KHQsZSxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUuY3JlYXRlVGV4dHVyZUxheW91dEZyb21TaGFwZT1lLmNhbGN1bGF0ZVRleHR1cmVXaWR0aEFuZEhlaWdodD1lLmNyZWF0ZVRleHR1cmVMYXlvdXRGcm9tVGV4dHVyZVR5cGU9dm9pZCAwO2NvbnN0IHI9bigyNTE3KSxpPW4oMjAzOSk7ZS5jcmVhdGVUZXh0dXJlTGF5b3V0RnJvbVRleHR1cmVUeXBlPSh0LG4scik9Pntjb25zdCBvPXI9PT1pLlRleHR1cmVUeXBlLnVucGFja2VkfHxyPT09aS5UZXh0dXJlVHlwZS51bnBhY2tlZFJldmVyc2VkPzE6NCxhPXI9PT1pLlRleHR1cmVUeXBlLnBhY2tlZCxzPXI9PT1pLlRleHR1cmVUeXBlLnVucGFja2VkUmV2ZXJzZWR8fHI9PT1pLlRleHR1cmVUeXBlLnBhY2tlZCx1PXI9PT1pLlRleHR1cmVUeXBlLnBhY2tlZExhc3REaW1lbnNpb24/bi5sZW5ndGgtMTp2b2lkIDAsYz1yPT09aS5UZXh0dXJlVHlwZS5wYWNrZWRMYXN0RGltZW5zaW9uP24ubWFwKCgodCxlKT0+ZT09PW4ubGVuZ3RoLTE/NCp0OnQpKTp2b2lkIDA7cmV0dXJuKDAsZS5jcmVhdGVUZXh0dXJlTGF5b3V0RnJvbVNoYXBlKSh0LG4sbyxjLHtpc1BhY2tlZDphLHJldmVyc2VXSDpzLGJyZWFrQXhpczp1fSl9LGUuY2FsY3VsYXRlVGV4dHVyZVdpZHRoQW5kSGVpZ2h0PSh0LG4scik9Pntjb25zdCBpPSgwLGUuY3JlYXRlVGV4dHVyZUxheW91dEZyb21UZXh0dXJlVHlwZSkodCxuLHIpO3JldHVybltpLndpZHRoLGkuaGVpZ2h0XX0sZS5jcmVhdGVUZXh0dXJlTGF5b3V0RnJvbVNoYXBlPSh0LGUsbj0xLGksbyk9Pntjb25zdCBhPSEoIW98fCFvLmlzUGFja2VkKSxbcyx1XT10LmNvbXB1dGVUZXh0dXJlV0goYSYmaXx8ZSxvKSxjPWUubGVuZ3RoO2xldCBsPWUuc2xpY2UoMCk7aWYoMD09PWMmJihsPVsxXSksMT09PW4paT1lO2Vsc2UgaWYoYSl7aWYoNCE9PW4pdGhyb3cgbmV3IEVycm9yKFwiYSBwYWNrZWQgdGV4dHVyZSBtdXN0IGJlIDQtY2hhbm5lbFwiKTtpPWUsYz4wJiYobFtjLTFdPU1hdGguY2VpbChsW2MtMV0vMikpLGM+MSYmKGxbYy0yXT1NYXRoLmNlaWwobFtjLTJdLzIpKX1lbHNlIGlmKCFpKXRocm93IG5ldyBFcnJvcihcIlVucGFja2VkIHNoYXBlIGlzIG5lZWRlZCB3aGVuIHVzaW5nIGNoYW5uZWxzID4gMVwiKTtyZXR1cm57d2lkdGg6cyxoZWlnaHQ6dSxjaGFubmVsczpuLGlzUGFja2VkOmEsc2hhcGU6bCxzdHJpZGVzOnIuU2hhcGVVdGlsLmNvbXB1dGVTdHJpZGVzKGwpLHVucGFja2VkU2hhcGU6aSxyZXZlcnNlZFdIOm8mJm8ucmV2ZXJzZVdIfX19LDU3MDI6KHQsZSxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUuVGV4dHVyZU1hbmFnZXI9dm9pZCAwO2NvbnN0IHI9bigzNjk0KTtlLlRleHR1cmVNYW5hZ2VyPWNsYXNze2NvbnN0cnVjdG9yKHQsZSxuLHIpe3RoaXMuZ2xDb250ZXh0PXQsdGhpcy5sYXlvdXRTdHJhdGVneT1lLHRoaXMucHJvZmlsZXI9bix0aGlzLmNvbmZpZz1yLHRoaXMucGVuZGluZ1JlYWQ9bmV3IE1hcCxyLnJldXNlVGV4dHVyZXMmJih0aGlzLmluVXNlVGV4dHVyZXM9bmV3IE1hcCx0aGlzLmlkbGVUZXh0dXJlcz1uZXcgTWFwLHRoaXMudGV4dHVyZUxvb2t1cD1uZXcgTWFwKX1jcmVhdGVUZXh0dXJlRnJvbUxheW91dCh0LGUsbixpKXtjb25zdCBvPXRoaXMudG9FbmNvZGVyVHlwZSh0KSxhPXRoaXMuZ2xDb250ZXh0LmdldEVuY29kZXIobyxlLmNoYW5uZWxzfHwxLGkpO2lmKGUuaXNQYWNrZWQmJjE9PT1pKXRocm93IG5ldyBFcnJvcihcIm5vdCBpbXBsZW1lbnRlZFwiKTtjb25zdCBzPWUud2lkdGgsdT1lLmhlaWdodDtsZXQgYyxsO2lmKHRoaXMuY29uZmlnLnJldXNlVGV4dHVyZXMpe2M9YCR7c314JHt1fV8ke2EuZm9ybWF0fV8ke2EuaW50ZXJuYWxGb3JtYXR9XyR7YS50ZXh0dXJlVHlwZX1gLGw9dGhpcy5pblVzZVRleHR1cmVzLmdldChjKSxsfHwobD1bXSx0aGlzLmluVXNlVGV4dHVyZXMuc2V0KGMsbCkpO2NvbnN0IGU9dGhpcy5pZGxlVGV4dHVyZXMuZ2V0KGMpO2lmKGUmJmUubGVuZ3RoPjApe2NvbnN0IHI9ZS5wb3AoKTtyZXR1cm4gbC5wdXNoKHIpLDE9PT1pJiZ0aGlzLmdsQ29udGV4dC51cGRhdGVUZXh0dXJlKHIscyx1LGEsdGhpcy50b1RleHR1cmVEYXRhKHQsbikpLHJ9fXIuTG9nZ2VyLnZlcmJvc2UoXCJUZXh0dXJlTWFuYWdlclwiLGBDcmVhdGluZyBuZXcgdGV4dHVyZSBvZiBzaXplICR7ZS53aWR0aH14JHtlLmhlaWdodH1gKTtjb25zdCBwPXRoaXMuZ2xDb250ZXh0LmFsbG9jYXRlVGV4dHVyZShzLHUsYSx0aGlzLnRvVGV4dHVyZURhdGEodCxuKSk7cmV0dXJuIHRoaXMuY29uZmlnLnJldXNlVGV4dHVyZXMmJihsLnB1c2gocCksdGhpcy50ZXh0dXJlTG9va3VwLnNldChwLGMpKSxwfXJlYWRUZXh0dXJlKHQsZSxuKXtyZXR1cm4gbnx8KG49MSksdGhpcy5wcm9maWxlci5ldmVudChcImJhY2tlbmRcIixcIlRleHR1cmVNYW5hZ2VyLnJlYWRUZXh0dXJlXCIsKCgpPT57Y29uc3Qgcj10LnNoYXBlLnJlZHVjZSgoKHQsZSk9PnQqZSkpKm4saT10aGlzLmdsQ29udGV4dC5yZWFkVGV4dHVyZSh0LnRleHR1cmUsdC53aWR0aCx0LmhlaWdodCxyLHRoaXMudG9FbmNvZGVyVHlwZShlKSxuKTtyZXR1cm4gdGhpcy50b1RlbnNvckRhdGEoZSxpKX0pKX1hc3luYyByZWFkVGV4dHVyZUFzeW5jKHQsZSxuKXtjb25zdCByPXQudGVuc29yLmRhdGFJZDtpZihufHwobj0xKSx0aGlzLnBlbmRpbmdSZWFkLmhhcyhyKSl7Y29uc3QgdD10aGlzLnBlbmRpbmdSZWFkLmdldChyKTtyZXR1cm4gbmV3IFByb21pc2UoKGU9Pm51bGw9PXQ/dm9pZCAwOnQucHVzaChlKSkpfXJldHVybiB0aGlzLnByb2ZpbGVyLmV2ZW50KFwiYmFja2VuZFwiLFwiVGV4dHVyZU1hbmFnZXIucmVhZFRleHR1cmVBc3luY1wiLChhc3luYygpPT57dGhpcy5wZW5kaW5nUmVhZC5zZXQocixbXSk7Y29uc3QgaT10LnNoYXBlLnJlZHVjZSgoKHQsZSk9PnQqZSkpKm47YXdhaXQgdGhpcy5nbENvbnRleHQuY3JlYXRlQW5kV2FpdEZvckZlbmNlKCk7Y29uc3Qgbz10aGlzLmdsQ29udGV4dC5yZWFkVGV4dHVyZSh0LnRleHR1cmUsdC53aWR0aCx0LmhlaWdodCxpLHRoaXMudG9FbmNvZGVyVHlwZShlKSxuKSxhPXRoaXMudG9UZW5zb3JEYXRhKGUsbykscz10aGlzLnBlbmRpbmdSZWFkLmdldChyKTtyZXR1cm4gdGhpcy5wZW5kaW5nUmVhZC5kZWxldGUociksbnVsbD09c3x8cy5mb3JFYWNoKCh0PT50KGEpKSksYX0pKX1yZWFkVWludDhUZXh0dXJlQXNGbG9hdCh0KXtyZXR1cm4gdGhpcy5wcm9maWxlci5ldmVudChcImJhY2tlbmRcIixcIlRleHR1cmVNYW5hZ2VyLnJlYWRVaW50OFRleHR1cmVBc0Zsb2F0XCIsKCgpPT57Y29uc3QgZT10LnNoYXBlLnJlZHVjZSgoKHQsZSk9PnQqZSkpLG49dGhpcy5nbENvbnRleHQucmVhZFRleHR1cmUodC50ZXh0dXJlLHQud2lkdGgsdC5oZWlnaHQsNCplLFwiYnl0ZVwiLDQpO3JldHVybiBuZXcgRmxvYXQzMkFycmF5KG4uYnVmZmVyLG4uYnl0ZU9mZnNldCxlKX0pKX1yZWxlYXNlVGV4dHVyZSh0LGUpe2xldCBuO2lmKHRoaXMuY29uZmlnLnJldXNlVGV4dHVyZXMmJihuPXRoaXMudGV4dHVyZUxvb2t1cC5nZXQodC50ZXh0dXJlKSxuKSl7ZSYmdGhpcy50ZXh0dXJlTG9va3VwLmRlbGV0ZShuKTtjb25zdCByPXRoaXMuaW5Vc2VUZXh0dXJlcy5nZXQobik7aWYocil7Y29uc3QgZT1yLmluZGV4T2YodC50ZXh0dXJlKTtpZigtMSE9PWUpe3Iuc3BsaWNlKGUsMSk7bGV0IGk9dGhpcy5pZGxlVGV4dHVyZXMuZ2V0KG4pO2l8fChpPVtdLHRoaXMuaWRsZVRleHR1cmVzLnNldChuLGkpKSxpLnB1c2godC50ZXh0dXJlKX19fW4mJiFlfHwoci5Mb2dnZXIudmVyYm9zZShcIlRleHR1cmVNYW5hZ2VyXCIsYERlbGV0aW5nIHRleHR1cmUgb2Ygc2l6ZSAke3Qud2lkdGh9eCR7dC5oZWlnaHR9YCksdGhpcy5nbENvbnRleHQuZGVsZXRlVGV4dHVyZSh0LnRleHR1cmUpKX10b1RlbnNvckRhdGEodCxlKXtzd2l0Y2godCl7Y2FzZVwiaW50MTZcIjpyZXR1cm4gZSBpbnN0YW5jZW9mIEludDE2QXJyYXk/ZTpJbnQxNkFycmF5LmZyb20oZSk7Y2FzZVwiaW50MzJcIjpyZXR1cm4gZSBpbnN0YW5jZW9mIEludDMyQXJyYXk/ZTpJbnQzMkFycmF5LmZyb20oZSk7Y2FzZVwiaW50OFwiOnJldHVybiBlIGluc3RhbmNlb2YgSW50OEFycmF5P2U6SW50OEFycmF5LmZyb20oZSk7Y2FzZVwidWludDE2XCI6cmV0dXJuIGUgaW5zdGFuY2VvZiBVaW50MTZBcnJheT9lOlVpbnQxNkFycmF5LmZyb20oZSk7Y2FzZVwidWludDMyXCI6cmV0dXJuIGUgaW5zdGFuY2VvZiBVaW50MzJBcnJheT9lOlVpbnQzMkFycmF5LmZyb20oZSk7Y2FzZVwidWludDhcIjpjYXNlXCJib29sXCI6cmV0dXJuIGUgaW5zdGFuY2VvZiBVaW50OEFycmF5P2U6VWludDhBcnJheS5mcm9tKGUpO2Nhc2VcImZsb2F0MzJcIjpyZXR1cm4gZSBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheT9lOkZsb2F0MzJBcnJheS5mcm9tKGUpO2Nhc2VcImZsb2F0NjRcIjpyZXR1cm4gZSBpbnN0YW5jZW9mIEZsb2F0NjRBcnJheT9lOkZsb2F0NjRBcnJheS5mcm9tKGUpO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBUZW5zb3JEYXRhIHR5cGUgJHt0fSBpcyBub3Qgc3VwcG9ydGVkYCl9fXRvVGV4dHVyZURhdGEodCxlKXtpZihlKXJldHVybiBlIGluc3RhbmNlb2YgRmxvYXQzMkFycmF5P2U6bmV3IEZsb2F0MzJBcnJheShlKX10b0VuY29kZXJUeXBlKHQpe3JldHVyblwiZmxvYXRcIn1jbGVhckFjdGl2ZVRleHR1cmVzKCl7dGhpcy5nbENvbnRleHQuY2xlYXJBY3RpdmVUZXh0dXJlcygpfX19LDIwMzk6KHQsZSk9PntcInVzZSBzdHJpY3RcIjt2YXIgbjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLlRleHR1cmVUeXBlPXZvaWQgMCwobj1lLlRleHR1cmVUeXBlfHwoZS5UZXh0dXJlVHlwZT17fSkpW24udW5wYWNrZWQ9MF09XCJ1bnBhY2tlZFwiLG5bbi51bnBhY2tlZFJldmVyc2VkPTFdPVwidW5wYWNrZWRSZXZlcnNlZFwiLG5bbi5wYWNrZWQ9Ml09XCJwYWNrZWRcIixuW24uZG93bmxvYWRVaW50OEFzRmxvYXQ9M109XCJkb3dubG9hZFVpbnQ4QXNGbG9hdFwiLG5bbi5wYWNrZWRMYXN0RGltZW5zaW9uPTRdPVwicGFja2VkTGFzdERpbWVuc2lvblwifSw5MzkwOih0LGUsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLmdldEdsQ2hhbm5lbHM9ZS5nZXRDb29yZHNEYXRhVHlwZT1lLmdldFNxdWVlemVkUGFyYW1zPWUuc3F1ZWV6ZUlucHV0U2hhcGU9ZS5nZW5lcmF0ZVNoYWRlckZ1bmNOYW1lRnJvbUlucHV0U2FtcGxlck5hbWVBdE91dENvb3Jkcz1lLmdlbmVyYXRlU2hhZGVyRnVuY05hbWVGcm9tSW5wdXRTYW1wbGVyTmFtZT1lLnJlcGVhdGVkVHJ5PWUuZ2V0UGFja2VkU2hhcGU9dm9pZCAwO2NvbnN0IHI9bigyNTE3KTtlLmdldFBhY2tlZFNoYXBlPWZ1bmN0aW9uKHQpe2NvbnN0IGU9dC5sZW5ndGg7cmV0dXJuIHQuc2xpY2UoMCxlLTEpLmNvbmNhdCh0W2UtMV0vNCl9LGUucmVwZWF0ZWRUcnk9YXN5bmMgZnVuY3Rpb24odCxlPSh0PT4wKSxuKXtyZXR1cm4gbmV3IFByb21pc2UoKChyLGkpPT57bGV0IG89MDtjb25zdCBhPSgpPT57aWYodCgpKXJldHVybiB2b2lkIHIoKTtvKys7Y29uc3Qgcz1lKG8pO251bGwhPW4mJm8+PW4/aSgpOnNldFRpbWVvdXQoYSxzKX07YSgpfSkpfSxlLmdlbmVyYXRlU2hhZGVyRnVuY05hbWVGcm9tSW5wdXRTYW1wbGVyTmFtZT1mdW5jdGlvbih0KXtyZXR1cm4oMCxyLmFzc2VydCkodm9pZCAwIT09dCYmMCE9PXQubGVuZ3RoLCgoKT0+XCJlbXB0eSBzdHJpbmcgZm91bmQgZm9yIHNhbXBsZXIgbmFtZVwiKSksXCJnZXRcIit0LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpK3Quc2xpY2UoMSl9LGUuZ2VuZXJhdGVTaGFkZXJGdW5jTmFtZUZyb21JbnB1dFNhbXBsZXJOYW1lQXRPdXRDb29yZHM9ZnVuY3Rpb24odCl7cmV0dXJuKDAsci5hc3NlcnQpKHZvaWQgMCE9PXQmJjAhPT10Lmxlbmd0aCwoKCk9PlwiZW1wdHkgc3RyaW5nIGZvdW5kIGZvciBzYW1wbGVyIG5hbWVcIikpLFwiZ2V0XCIrdC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSt0LnNsaWNlKDEpK1wiQXRPdXRDb29yZHNcIn0sZS5zcXVlZXplSW5wdXRTaGFwZT1mdW5jdGlvbih0LGUpe2xldCBuPUpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkodCkpO3JldHVybiBuPWUsbn0sZS5nZXRTcXVlZXplZFBhcmFtcz1mdW5jdGlvbih0LGUpe3JldHVybiBlLm1hcCgoZT0+dFtlXSkpLmpvaW4oXCIsIFwiKX0sZS5nZXRDb29yZHNEYXRhVHlwZT1mdW5jdGlvbih0KXtpZih0PD0xKXJldHVyblwiaW50XCI7aWYoMj09PXQpcmV0dXJuXCJpdmVjMlwiO2lmKDM9PT10KXJldHVyblwiaXZlYzNcIjtpZig0PT09dClyZXR1cm5cIml2ZWM0XCI7aWYoNT09PXQpcmV0dXJuXCJpdmVjNVwiO2lmKDY9PT10KXJldHVyblwiaXZlYzZcIjt0aHJvdyBFcnJvcihgR1BVIGZvciByYW5rICR7dH0gaXMgbm90IHlldCBzdXBwb3J0ZWRgKX0sZS5nZXRHbENoYW5uZWxzPWZ1bmN0aW9uKHQ9Nil7cmV0dXJuW1wieFwiLFwieVwiLFwielwiLFwid1wiLFwidVwiLFwidlwiXS5zbGljZSgwLHQpfX0sNzMwNToodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5jcmVhdGVOZXdXZWJHTENvbnRleHQ9ZS5jcmVhdGVXZWJHTENvbnRleHQ9dm9pZCAwO2NvbnN0IHI9bigzNjk0KSxpPW4oMTcxMyksbz17fTtmdW5jdGlvbiBhKHQpe2NvbnN0IGU9ZnVuY3Rpb24oKXtpZihcInVuZGVmaW5lZFwiPT10eXBlb2YgZG9jdW1lbnQpe2lmKFwidW5kZWZpbmVkXCI9PXR5cGVvZiBPZmZzY3JlZW5DYW52YXMpdGhyb3cgbmV3IFR5cGVFcnJvcihcImZhaWxlZCB0byBjcmVhdGUgY2FudmFzOiBPZmZzY3JlZW5DYW52YXMgaXMgbm90IHN1cHBvcnRlZFwiKTtyZXR1cm4gbmV3IE9mZnNjcmVlbkNhbnZhcygxLDEpfWNvbnN0IHQ9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtyZXR1cm4gdC53aWR0aD0xLHQuaGVpZ2h0PTEsdH0oKTtsZXQgbjtjb25zdCBvPXthbHBoYTohMSxkZXB0aDohMSxhbnRpYWxpYXM6ITEsc3RlbmNpbDohMSxwcmVzZXJ2ZURyYXdpbmdCdWZmZXI6ITEscHJlbXVsdGlwbGllZEFscGhhOiExLGZhaWxJZk1ham9yUGVyZm9ybWFuY2VDYXZlYXQ6ITF9O2lmKCghdHx8XCJ3ZWJnbDJcIj09PXQpJiYobj1lLmdldENvbnRleHQoXCJ3ZWJnbDJcIixvKSxuKSl0cnl7cmV0dXJuIG5ldyBpLldlYkdMQ29udGV4dChuLDIpfWNhdGNoKHQpe3IuTG9nZ2VyLndhcm5pbmcoXCJHbENvbnRleHRGYWN0b3J5XCIsYGZhaWxlZCB0byBjcmVhdGUgV2ViR0xDb250ZXh0IHVzaW5nIGNvbnRleHRJZCAnd2ViZ2wyJy4gRXJyb3I6ICR7dH1gKX1pZigoIXR8fFwid2ViZ2xcIj09PXQpJiYobj1lLmdldENvbnRleHQoXCJ3ZWJnbFwiLG8pfHxlLmdldENvbnRleHQoXCJleHBlcmltZW50YWwtd2ViZ2xcIixvKSxuKSl0cnl7cmV0dXJuIG5ldyBpLldlYkdMQ29udGV4dChuLDEpfWNhdGNoKHQpe3IuTG9nZ2VyLndhcm5pbmcoXCJHbENvbnRleHRGYWN0b3J5XCIsYGZhaWxlZCB0byBjcmVhdGUgV2ViR0xDb250ZXh0IHVzaW5nIGNvbnRleHRJZCAnd2ViZ2wnIG9yICdleHBlcmltZW50YWwtd2ViZ2wnLiBFcnJvcjogJHt0fWApfXRocm93IG5ldyBFcnJvcihcIldlYkdMIGlzIG5vdCBzdXBwb3J0ZWRcIil9ZS5jcmVhdGVXZWJHTENvbnRleHQ9ZnVuY3Rpb24gdChlKXtsZXQgbjtlJiZcIndlYmdsMlwiIT09ZXx8IShcIndlYmdsMlwiaW4gbyk/ZSYmXCJ3ZWJnbFwiIT09ZXx8IShcIndlYmdsXCJpbiBvKXx8KG49by53ZWJnbCk6bj1vLndlYmdsMixuPW58fGEoZSksZT1lfHwxPT09bi52ZXJzaW9uP1wid2ViZ2xcIjpcIndlYmdsMlwiO2NvbnN0IHI9bi5nbDtyZXR1cm4gb1tlXT1uLHIuaXNDb250ZXh0TG9zdCgpPyhkZWxldGUgb1tlXSx0KGUpKTooci5kaXNhYmxlKHIuREVQVEhfVEVTVCksci5kaXNhYmxlKHIuU1RFTkNJTF9URVNUKSxyLmRpc2FibGUoci5CTEVORCksci5kaXNhYmxlKHIuRElUSEVSKSxyLmRpc2FibGUoci5QT0xZR09OX09GRlNFVF9GSUxMKSxyLmRpc2FibGUoci5TQU1QTEVfQ09WRVJBR0UpLHIuZW5hYmxlKHIuU0NJU1NPUl9URVNUKSxyLmVuYWJsZShyLkNVTExfRkFDRSksci5jdWxsRmFjZShyLkJBQ0spLG4pfSxlLmNyZWF0ZU5ld1dlYkdMQ29udGV4dD1hfSwxNzEzOmZ1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjt2YXIgcj10aGlzJiZ0aGlzLl9fY3JlYXRlQmluZGluZ3x8KE9iamVjdC5jcmVhdGU/ZnVuY3Rpb24odCxlLG4scil7dm9pZCAwPT09ciYmKHI9bik7dmFyIGk9T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLG4pO2kmJiEoXCJnZXRcImluIGk/IWUuX19lc01vZHVsZTppLndyaXRhYmxlfHxpLmNvbmZpZ3VyYWJsZSl8fChpPXtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBlW25dfX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LHIsaSl9OmZ1bmN0aW9uKHQsZSxuLHIpe3ZvaWQgMD09PXImJihyPW4pLHRbcl09ZVtuXX0pLGk9dGhpcyYmdGhpcy5fX3NldE1vZHVsZURlZmF1bHR8fChPYmplY3QuY3JlYXRlP2Z1bmN0aW9uKHQsZSl7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJkZWZhdWx0XCIse2VudW1lcmFibGU6ITAsdmFsdWU6ZX0pfTpmdW5jdGlvbih0LGUpe3QuZGVmYXVsdD1lfSksbz10aGlzJiZ0aGlzLl9faW1wb3J0U3Rhcnx8ZnVuY3Rpb24odCl7aWYodCYmdC5fX2VzTW9kdWxlKXJldHVybiB0O3ZhciBlPXt9O2lmKG51bGwhPXQpZm9yKHZhciBuIGluIHQpXCJkZWZhdWx0XCIhPT1uJiZPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCxuKSYmcihlLHQsbik7cmV0dXJuIGkoZSx0KSxlfTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLldlYkdMQ29udGV4dD1lLmxpbmVhclNlYXJjaExhc3RUcnVlPXZvaWQgMDtjb25zdCBhPW4oNjIwNykscz1vKG4oNzc2OSkpLHU9big5MzkwKTtmdW5jdGlvbiBjKHQpe2xldCBlPTA7Zm9yKDtlPHQubGVuZ3RoJiZ0W2VdKCk7KytlKTtyZXR1cm4gZS0xfWUubGluZWFyU2VhcmNoTGFzdFRydWU9YyxlLldlYkdMQ29udGV4dD1jbGFzc3tjb25zdHJ1Y3Rvcih0LGUpe3RoaXMuZnJhbWVCdWZmZXJCb3VuZD0hMSx0aGlzLml0ZW1zVG9Qb2xsPVtdLHRoaXMuZ2w9dCx0aGlzLnZlcnNpb249ZSx0aGlzLmdldEV4dGVuc2lvbnMoKSx0aGlzLnZlcnRleGJ1ZmZlcj10aGlzLmNyZWF0ZVZlcnRleGJ1ZmZlcigpLHRoaXMuZnJhbWVidWZmZXI9dGhpcy5jcmVhdGVGcmFtZWJ1ZmZlcigpLHRoaXMucXVlcnlWaXRhbFBhcmFtZXRlcnMoKX1hbGxvY2F0ZVRleHR1cmUodCxlLG4scil7Y29uc3QgaT10aGlzLmdsLG89aS5jcmVhdGVUZXh0dXJlKCk7aS5iaW5kVGV4dHVyZShpLlRFWFRVUkVfMkQsbyksaS50ZXhQYXJhbWV0ZXJpKGkuVEVYVFVSRV8yRCxpLlRFWFRVUkVfTUlOX0ZJTFRFUixpLk5FQVJFU1QpLGkudGV4UGFyYW1ldGVyaShpLlRFWFRVUkVfMkQsaS5URVhUVVJFX01BR19GSUxURVIsaS5ORUFSRVNUKSxpLnRleFBhcmFtZXRlcmkoaS5URVhUVVJFXzJELGkuVEVYVFVSRV9XUkFQX1MsaS5DTEFNUF9UT19FREdFKSxpLnRleFBhcmFtZXRlcmkoaS5URVhUVVJFXzJELGkuVEVYVFVSRV9XUkFQX1QsaS5DTEFNUF9UT19FREdFKTtjb25zdCBhPXI/bi5lbmNvZGUocix0KmUpOm51bGw7cmV0dXJuIGkudGV4SW1hZ2UyRChpLlRFWFRVUkVfMkQsMCxuLmludGVybmFsRm9ybWF0LHQsZSwwLG4uZm9ybWF0LG4udGV4dHVyZVR5cGUsYSksdGhpcy5jaGVja0Vycm9yKCksb311cGRhdGVUZXh0dXJlKHQsZSxuLHIsaSl7Y29uc3Qgbz10aGlzLmdsO28uYmluZFRleHR1cmUoby5URVhUVVJFXzJELHQpO2NvbnN0IGE9ci5lbmNvZGUoaSxlKm4pO28udGV4U3ViSW1hZ2UyRChvLlRFWFRVUkVfMkQsMCwwLDAsZSxuLHIuZm9ybWF0LHIudGV4dHVyZVR5cGUsYSksdGhpcy5jaGVja0Vycm9yKCl9YXR0YWNoRnJhbWVidWZmZXIodCxlLG4pe2NvbnN0IHI9dGhpcy5nbDtyLmJpbmRUZXh0dXJlKHIuVEVYVFVSRV8yRCx0KSxyLmJpbmRGcmFtZWJ1ZmZlcihyLkZSQU1FQlVGRkVSLHRoaXMuZnJhbWVidWZmZXIpLHIuZnJhbWVidWZmZXJUZXh0dXJlMkQoci5GUkFNRUJVRkZFUixyLkNPTE9SX0FUVEFDSE1FTlQwLHIuVEVYVFVSRV8yRCx0LDApLHRoaXMuY2hlY2tFcnJvcigpLHIudmlld3BvcnQoMCwwLGUsbiksci5zY2lzc29yKDAsMCxlLG4pfXJlYWRUZXh0dXJlKHQsZSxuLHIsaSxvKXtjb25zdCBhPXRoaXMuZ2w7b3x8KG89MSksdGhpcy5mcmFtZUJ1ZmZlckJvdW5kfHx0aGlzLmF0dGFjaEZyYW1lYnVmZmVyKHQsZSxuKTtjb25zdCBzPXRoaXMuZ2V0RW5jb2RlcihpLG8pLHU9cy5hbGxvY2F0ZShlKm4pO3JldHVybiBhLmJpbmRUZXh0dXJlKGEuVEVYVFVSRV8yRCx0KSxhLmZyYW1lYnVmZmVyVGV4dHVyZTJEKGEuRlJBTUVCVUZGRVIsYS5DT0xPUl9BVFRBQ0hNRU5UMCxhLlRFWFRVUkVfMkQsdCwwKSxhLnJlYWRQaXhlbHMoMCwwLGUsbixhLlJHQkEscy50ZXh0dXJlVHlwZSx1KSx0aGlzLmNoZWNrRXJyb3IoKSxzLmRlY29kZSh1LHIpfWlzRnJhbWVidWZmZXJSZWFkeSgpe3JldHVybiEwfWdldEFjdGl2ZVRleHR1cmUoKXtjb25zdCB0PXRoaXMuZ2w7cmV0dXJuXCJURVhUVVJFXCIrKHQuZ2V0UGFyYW1ldGVyKHRoaXMuZ2wuQUNUSVZFX1RFWFRVUkUpLXQuVEVYVFVSRTApfWdldFRleHR1cmVCaW5kaW5nKCl7cmV0dXJuIHRoaXMuZ2wuZ2V0UGFyYW1ldGVyKHRoaXMuZ2wuVEVYVFVSRV9CSU5ESU5HXzJEKX1nZXRGcmFtZWJ1ZmZlckJpbmRpbmcoKXtyZXR1cm4gdGhpcy5nbC5nZXRQYXJhbWV0ZXIodGhpcy5nbC5GUkFNRUJVRkZFUl9CSU5ESU5HKX1zZXRWZXJ0ZXhBdHRyaWJ1dGVzKHQsZSl7Y29uc3Qgbj10aGlzLmdsO24udmVydGV4QXR0cmliUG9pbnRlcih0LDMsbi5GTE9BVCwhMSwyMCwwKSxuLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHQpLC0xIT09ZSYmKG4udmVydGV4QXR0cmliUG9pbnRlcihlLDIsbi5GTE9BVCwhMSwyMCwxMiksbi5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShlKSksdGhpcy5jaGVja0Vycm9yKCl9Y3JlYXRlUHJvZ3JhbSh0LGUpe2NvbnN0IG49dGhpcy5nbCxyPW4uY3JlYXRlUHJvZ3JhbSgpO3JldHVybiBuLmF0dGFjaFNoYWRlcihyLHQpLG4uYXR0YWNoU2hhZGVyKHIsZSksbi5saW5rUHJvZ3JhbShyKSxyfWNvbXBpbGVTaGFkZXIodCxlKXtjb25zdCBuPXRoaXMuZ2wscj1uLmNyZWF0ZVNoYWRlcihlKTtpZighcil0aHJvdyBuZXcgRXJyb3IoYGNyZWF0ZVNoYWRlcigpIHJldHVybmVkIG51bGwgd2l0aCB0eXBlICR7ZX1gKTtpZihuLnNoYWRlclNvdXJjZShyLHQpLG4uY29tcGlsZVNoYWRlcihyKSwhMT09PW4uZ2V0U2hhZGVyUGFyYW1ldGVyKHIsbi5DT01QSUxFX1NUQVRVUykpdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gY29tcGlsZSBzaGFkZXI6ICR7bi5nZXRTaGFkZXJJbmZvTG9nKHIpfVxcblNoYWRlciBzb3VyY2U6XFxuJHt0fWApO3JldHVybiByfWRlbGV0ZVNoYWRlcih0KXt0aGlzLmdsLmRlbGV0ZVNoYWRlcih0KX1iaW5kVGV4dHVyZVRvVW5pZm9ybSh0LGUsbil7Y29uc3Qgcj10aGlzLmdsO3IuYWN0aXZlVGV4dHVyZShyLlRFWFRVUkUwK2UpLHRoaXMuY2hlY2tFcnJvcigpLHIuYmluZFRleHR1cmUoci5URVhUVVJFXzJELHQpLHRoaXMuY2hlY2tFcnJvcigpLHIudW5pZm9ybTFpKG4sZSksdGhpcy5jaGVja0Vycm9yKCl9ZHJhdygpe3RoaXMuZ2wuZHJhd0FycmF5cyh0aGlzLmdsLlRSSUFOR0xFX1NUUklQLDAsNCksdGhpcy5jaGVja0Vycm9yKCl9Y2hlY2tFcnJvcigpe2lmKGEuZW52LmRlYnVnKXtjb25zdCB0PXRoaXMuZ2wsZT10LmdldEVycm9yKCk7bGV0IG49XCJcIjtzd2l0Y2goZSl7Y2FzZSB0Lk5PX0VSUk9SOnJldHVybjtjYXNlIHQuSU5WQUxJRF9FTlVNOm49XCJJTlZBTElEX0VOVU1cIjticmVhaztjYXNlIHQuSU5WQUxJRF9WQUxVRTpuPVwiSU5WQUxJRF9WQUxVRVwiO2JyZWFrO2Nhc2UgdC5JTlZBTElEX09QRVJBVElPTjpuPVwiSU5WQUxJRF9PUEVSQVRJT05cIjticmVhaztjYXNlIHQuSU5WQUxJRF9GUkFNRUJVRkZFUl9PUEVSQVRJT046bj1cIklOVkFMSURfRlJBTUVCVUZGRVJfT1BFUkFUSU9OXCI7YnJlYWs7Y2FzZSB0Lk9VVF9PRl9NRU1PUlk6bj1cIk9VVF9PRl9NRU1PUllcIjticmVhaztjYXNlIHQuQ09OVEVYVF9MT1NUX1dFQkdMOm49XCJDT05URVhUX0xPU1RfV0VCR0xcIjticmVhaztkZWZhdWx0Om49YFVua25vd24gV2ViR0wgRXJyb3I6ICR7ZS50b1N0cmluZygxNil9YH10aHJvdyBuZXcgRXJyb3Iobil9fWRlbGV0ZVRleHR1cmUodCl7dGhpcy5nbC5kZWxldGVUZXh0dXJlKHQpfWRlbGV0ZVByb2dyYW0odCl7dGhpcy5nbC5kZWxldGVQcm9ncmFtKHQpfWdldEVuY29kZXIodCxlLG49MCl7aWYoMj09PXRoaXMudmVyc2lvbilyZXR1cm4gbmV3IHMuUmVkRmxvYXQzMkRhdGFFbmNvZGVyKHRoaXMuZ2wsZSk7c3dpdGNoKHQpe2Nhc2VcImZsb2F0XCI6cmV0dXJuIDE9PT1ufHx0aGlzLmlzUmVuZGVyRmxvYXQzMlN1cHBvcnRlZD9uZXcgcy5SR0JBRmxvYXREYXRhRW5jb2Rlcih0aGlzLmdsLGUpOm5ldyBzLlJHQkFGbG9hdERhdGFFbmNvZGVyKHRoaXMuZ2wsZSx0aGlzLnRleHR1cmVIYWxmRmxvYXRFeHRlbnNpb24uSEFMRl9GTE9BVF9PRVMpO2Nhc2VcImludFwiOnRocm93IG5ldyBFcnJvcihcIm5vdCBpbXBsZW1lbnRlZFwiKTtjYXNlXCJieXRlXCI6cmV0dXJuIG5ldyBzLlVpbnQ4RGF0YUVuY29kZXIodGhpcy5nbCxlKTtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgSW52YWxpZCBkYXRhVHlwZTogJHt0fWApfX1jbGVhckFjdGl2ZVRleHR1cmVzKCl7Y29uc3QgdD10aGlzLmdsO2ZvcihsZXQgZT0wO2U8dGhpcy5tYXhUZXh0dXJlSW1hZ2VVbml0czsrK2UpdC5hY3RpdmVUZXh0dXJlKHQuVEVYVFVSRTArZSksdC5iaW5kVGV4dHVyZSh0LlRFWFRVUkVfMkQsbnVsbCl9ZGlzcG9zZSgpe2lmKHRoaXMuZGlzcG9zZWQpcmV0dXJuO2NvbnN0IHQ9dGhpcy5nbDt0LmJpbmRGcmFtZWJ1ZmZlcih0LkZSQU1FQlVGRkVSLG51bGwpLHQuZGVsZXRlRnJhbWVidWZmZXIodGhpcy5mcmFtZWJ1ZmZlciksdC5iaW5kQnVmZmVyKHQuQVJSQVlfQlVGRkVSLG51bGwpLHQuZGVsZXRlQnVmZmVyKHRoaXMudmVydGV4YnVmZmVyKSx0LmJpbmRCdWZmZXIodC5FTEVNRU5UX0FSUkFZX0JVRkZFUixudWxsKSx0LmZpbmlzaCgpLHRoaXMuZGlzcG9zZWQ9ITB9Y3JlYXRlRGVmYXVsdEdlb21ldHJ5KCl7cmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkoWy0xLDEsMCwwLDEsLTEsLTEsMCwwLDAsMSwxLDAsMSwxLDEsLTEsMCwxLDBdKX1jcmVhdGVWZXJ0ZXhidWZmZXIoKXtjb25zdCB0PXRoaXMuZ2wsZT10LmNyZWF0ZUJ1ZmZlcigpO2lmKCFlKXRocm93IG5ldyBFcnJvcihcImNyZWF0ZUJ1ZmZlcigpIHJldHVybmVkIG51bGxcIik7Y29uc3Qgbj10aGlzLmNyZWF0ZURlZmF1bHRHZW9tZXRyeSgpO3JldHVybiB0LmJpbmRCdWZmZXIodC5BUlJBWV9CVUZGRVIsZSksdC5idWZmZXJEYXRhKHQuQVJSQVlfQlVGRkVSLG4sdC5TVEFUSUNfRFJBVyksdGhpcy5jaGVja0Vycm9yKCksZX1jcmVhdGVGcmFtZWJ1ZmZlcigpe2NvbnN0IHQ9dGhpcy5nbC5jcmVhdGVGcmFtZWJ1ZmZlcigpO2lmKCF0KXRocm93IG5ldyBFcnJvcihcImNyZWF0ZUZyYW1lYnVmZmVyIHJldHVybmVkIG51bGxcIik7cmV0dXJuIHR9cXVlcnlWaXRhbFBhcmFtZXRlcnMoKXtjb25zdCB0PXRoaXMuZ2w7aWYodGhpcy5pc0Zsb2F0VGV4dHVyZUF0dGFjaGFibGVUb0ZyYW1lQnVmZmVyPXRoaXMuY2hlY2tGbG9hdFRleHR1cmVBdHRhY2hhYmxlVG9GcmFtZUJ1ZmZlcigpLHRoaXMuaXNSZW5kZXJGbG9hdDMyU3VwcG9ydGVkPXRoaXMuY2hlY2tSZW5kZXJGbG9hdDMyKCksdGhpcy5pc0Zsb2F0MzJEb3dubG9hZFN1cHBvcnRlZD10aGlzLmNoZWNrRmxvYXQzMkRvd25sb2FkKCksMT09PXRoaXMudmVyc2lvbiYmIXRoaXMudGV4dHVyZUhhbGZGbG9hdEV4dGVuc2lvbiYmIXRoaXMuaXNSZW5kZXJGbG9hdDMyU3VwcG9ydGVkKXRocm93IG5ldyBFcnJvcihcImJvdGggZmxvYXQzMiBhbmQgZmxvYXQxNiBUZXh0dXJlVHlwZSBhcmUgbm90IHN1cHBvcnRlZFwiKTt0aGlzLmlzQmxlbmRTdXBwb3J0ZWQ9IXRoaXMuaXNSZW5kZXJGbG9hdDMyU3VwcG9ydGVkfHx0aGlzLmNoZWNrRmxvYXQzMkJsZW5kKCksdGhpcy5tYXhUZXh0dXJlU2l6ZT10LmdldFBhcmFtZXRlcih0Lk1BWF9URVhUVVJFX1NJWkUpLHRoaXMubWF4VGV4dHVyZUltYWdlVW5pdHM9dC5nZXRQYXJhbWV0ZXIodC5NQVhfVEVYVFVSRV9JTUFHRV9VTklUUyksdGhpcy52ZXJzaW9ufWdldEV4dGVuc2lvbnMoKXsyPT09dGhpcy52ZXJzaW9uPyh0aGlzLmNvbG9yQnVmZmVyRmxvYXRFeHRlbnNpb249dGhpcy5nbC5nZXRFeHRlbnNpb24oXCJFWFRfY29sb3JfYnVmZmVyX2Zsb2F0XCIpLHRoaXMuZGlzam9pbnRUaW1lclF1ZXJ5V2ViZ2wyRXh0ZW5zaW9uPXRoaXMuZ2wuZ2V0RXh0ZW5zaW9uKFwiRVhUX2Rpc2pvaW50X3RpbWVyX3F1ZXJ5X3dlYmdsMlwiKSk6KHRoaXMudGV4dHVyZUZsb2F0RXh0ZW5zaW9uPXRoaXMuZ2wuZ2V0RXh0ZW5zaW9uKFwiT0VTX3RleHR1cmVfZmxvYXRcIiksdGhpcy50ZXh0dXJlSGFsZkZsb2F0RXh0ZW5zaW9uPXRoaXMuZ2wuZ2V0RXh0ZW5zaW9uKFwiT0VTX3RleHR1cmVfaGFsZl9mbG9hdFwiKSl9Y2hlY2tGbG9hdFRleHR1cmVBdHRhY2hhYmxlVG9GcmFtZUJ1ZmZlcigpe2NvbnN0IHQ9dGhpcy5nbCxlPXQuY3JlYXRlVGV4dHVyZSgpO3QuYmluZFRleHR1cmUodC5URVhUVVJFXzJELGUpO2NvbnN0IG49Mj09PXRoaXMudmVyc2lvbj90LlJHQkEzMkY6dC5SR0JBO3QudGV4SW1hZ2UyRCh0LlRFWFRVUkVfMkQsMCxuLDEsMSwwLHQuUkdCQSx0LkZMT0FULG51bGwpO2NvbnN0IHI9dC5jcmVhdGVGcmFtZWJ1ZmZlcigpO3QuYmluZEZyYW1lYnVmZmVyKHQuRlJBTUVCVUZGRVIsciksdC5mcmFtZWJ1ZmZlclRleHR1cmUyRCh0LkZSQU1FQlVGRkVSLHQuQ09MT1JfQVRUQUNITUVOVDAsdC5URVhUVVJFXzJELGUsMCk7Y29uc3QgaT10LmNoZWNrRnJhbWVidWZmZXJTdGF0dXModC5GUkFNRUJVRkZFUik9PT10LkZSQU1FQlVGRkVSX0NPTVBMRVRFO3JldHVybiB0LmJpbmRUZXh0dXJlKHQuVEVYVFVSRV8yRCxudWxsKSx0LmJpbmRGcmFtZWJ1ZmZlcih0LkZSQU1FQlVGRkVSLG51bGwpLHQuZGVsZXRlVGV4dHVyZShlKSx0LmRlbGV0ZUZyYW1lYnVmZmVyKHIpLGl9Y2hlY2tSZW5kZXJGbG9hdDMyKCl7aWYoMj09PXRoaXMudmVyc2lvbil7aWYoIXRoaXMuY29sb3JCdWZmZXJGbG9hdEV4dGVuc2lvbilyZXR1cm4hMX1lbHNlIGlmKCF0aGlzLnRleHR1cmVGbG9hdEV4dGVuc2lvbilyZXR1cm4hMTtyZXR1cm4gdGhpcy5pc0Zsb2F0VGV4dHVyZUF0dGFjaGFibGVUb0ZyYW1lQnVmZmVyfWNoZWNrRmxvYXQzMkRvd25sb2FkKCl7aWYoMj09PXRoaXMudmVyc2lvbil7aWYoIXRoaXMuY29sb3JCdWZmZXJGbG9hdEV4dGVuc2lvbilyZXR1cm4hMX1lbHNle2lmKCF0aGlzLnRleHR1cmVGbG9hdEV4dGVuc2lvbilyZXR1cm4hMTtpZighdGhpcy5nbC5nZXRFeHRlbnNpb24oXCJXRUJHTF9jb2xvcl9idWZmZXJfZmxvYXRcIikpcmV0dXJuITF9cmV0dXJuIHRoaXMuaXNGbG9hdFRleHR1cmVBdHRhY2hhYmxlVG9GcmFtZUJ1ZmZlcn1jaGVja0Zsb2F0MzJCbGVuZCgpe2NvbnN0IHQ9dGhpcy5nbDtsZXQgZSxuLHIsaSxvO3RyeXtlPXQuY3JlYXRlVGV4dHVyZSgpLG49dC5jcmVhdGVGcmFtZWJ1ZmZlcigpLHQuYmluZFRleHR1cmUodC5URVhUVVJFXzJELGUpO2NvbnN0IGE9Mj09PXRoaXMudmVyc2lvbj90LlJHQkEzMkY6dC5SR0JBO3JldHVybiB0LnRleEltYWdlMkQodC5URVhUVVJFXzJELDAsYSwxLDEsMCx0LlJHQkEsdC5GTE9BVCxudWxsKSx0LmJpbmRGcmFtZWJ1ZmZlcih0LkZSQU1FQlVGRkVSLG4pLHQuZnJhbWVidWZmZXJUZXh0dXJlMkQodC5GUkFNRUJVRkZFUix0LkNPTE9SX0FUVEFDSE1FTlQwLHQuVEVYVFVSRV8yRCxlLDApLHQuZW5hYmxlKHQuQkxFTkQpLHI9dC5jcmVhdGVTaGFkZXIodC5WRVJURVhfU0hBREVSKSwhIXImJih0LnNoYWRlclNvdXJjZShyLFwidm9pZCBtYWluKCl7fVwiKSx0LmNvbXBpbGVTaGFkZXIociksaT10LmNyZWF0ZVNoYWRlcih0LkZSQUdNRU5UX1NIQURFUiksISFpJiYodC5zaGFkZXJTb3VyY2UoaSxcInByZWNpc2lvbiBoaWdocCBmbG9hdDt2b2lkIG1haW4oKXtnbF9GcmFnQ29sb3I9dmVjNCgwLjUpO31cIiksdC5jb21waWxlU2hhZGVyKGkpLG89dC5jcmVhdGVQcm9ncmFtKCksISFvJiYodC5hdHRhY2hTaGFkZXIobyxyKSx0LmF0dGFjaFNoYWRlcihvLGkpLHQubGlua1Byb2dyYW0obyksdC51c2VQcm9ncmFtKG8pLHQuZHJhd0FycmF5cyh0LlBPSU5UUywwLDEpLHQuZ2V0RXJyb3IoKT09PXQuTk9fRVJST1IpKSl9ZmluYWxseXt0LmRpc2FibGUodC5CTEVORCksbyYmdC5kZWxldGVQcm9ncmFtKG8pLHImJnQuZGVsZXRlU2hhZGVyKHIpLGkmJnQuZGVsZXRlU2hhZGVyKGkpLG4mJih0LmJpbmRGcmFtZWJ1ZmZlcih0LkZSQU1FQlVGRkVSLG51bGwpLHQuZGVsZXRlRnJhbWVidWZmZXIobikpLGUmJih0LmJpbmRUZXh0dXJlKHQuVEVYVFVSRV8yRCxudWxsKSx0LmRlbGV0ZVRleHR1cmUoZSkpfX1iZWdpblRpbWVyKCl7aWYoMj09PXRoaXMudmVyc2lvbiYmdGhpcy5kaXNqb2ludFRpbWVyUXVlcnlXZWJnbDJFeHRlbnNpb24pe2NvbnN0IHQ9dGhpcy5nbCxlPXRoaXMuZGlzam9pbnRUaW1lclF1ZXJ5V2ViZ2wyRXh0ZW5zaW9uLG49dC5jcmVhdGVRdWVyeSgpO3JldHVybiB0LmJlZ2luUXVlcnkoZS5USU1FX0VMQVBTRURfRVhULG4pLG59dGhyb3cgbmV3IEVycm9yKFwiV2ViR0wxIHByb2ZpbGluZyBjdXJyZW50bHkgbm90IHN1cHBvcnRlZC5cIil9ZW5kVGltZXIoKXtpZigyIT09dGhpcy52ZXJzaW9ufHwhdGhpcy5kaXNqb2ludFRpbWVyUXVlcnlXZWJnbDJFeHRlbnNpb24pdGhyb3cgbmV3IEVycm9yKFwiV2ViR0wxIHByb2ZpbGluZyBjdXJyZW50bHkgbm90IHN1cHBvcnRlZFwiKTt7Y29uc3QgdD10aGlzLmdsLGU9dGhpcy5kaXNqb2ludFRpbWVyUXVlcnlXZWJnbDJFeHRlbnNpb247dC5lbmRRdWVyeShlLlRJTUVfRUxBUFNFRF9FWFQpfX1pc1RpbWVyUmVzdWx0QXZhaWxhYmxlKHQpe2xldCBlPSExLG49ITE7aWYoMiE9PXRoaXMudmVyc2lvbnx8IXRoaXMuZGlzam9pbnRUaW1lclF1ZXJ5V2ViZ2wyRXh0ZW5zaW9uKXRocm93IG5ldyBFcnJvcihcIldlYkdMMSBwcm9maWxpbmcgY3VycmVudGx5IG5vdCBzdXBwb3J0ZWRcIik7e2NvbnN0IHI9dGhpcy5nbCxpPXRoaXMuZGlzam9pbnRUaW1lclF1ZXJ5V2ViZ2wyRXh0ZW5zaW9uO2U9ci5nZXRRdWVyeVBhcmFtZXRlcih0LHIuUVVFUllfUkVTVUxUX0FWQUlMQUJMRSksbj1yLmdldFBhcmFtZXRlcihpLkdQVV9ESVNKT0lOVF9FWFQpfXJldHVybiBlJiYhbn1nZXRUaW1lclJlc3VsdCh0KXtsZXQgZT0wO2lmKDIhPT10aGlzLnZlcnNpb24pdGhyb3cgbmV3IEVycm9yKFwiV2ViR0wxIHByb2ZpbGluZyBjdXJyZW50bHkgbm90IHN1cHBvcnRlZFwiKTt7Y29uc3Qgbj10aGlzLmdsO2U9bi5nZXRRdWVyeVBhcmFtZXRlcih0LG4uUVVFUllfUkVTVUxUKSxuLmRlbGV0ZVF1ZXJ5KHQpfXJldHVybiBlLzFlNn1hc3luYyB3YWl0Rm9yUXVlcnlBbmRHZXRUaW1lKHQpe3JldHVybiBhd2FpdCgwLHUucmVwZWF0ZWRUcnkpKCgoKT0+dGhpcy5pc1RpbWVyUmVzdWx0QXZhaWxhYmxlKHQpKSksdGhpcy5nZXRUaW1lclJlc3VsdCh0KX1hc3luYyBjcmVhdGVBbmRXYWl0Rm9yRmVuY2UoKXtjb25zdCB0PXRoaXMuY3JlYXRlRmVuY2UodGhpcy5nbCk7cmV0dXJuIHRoaXMucG9sbEZlbmNlKHQpfWNyZWF0ZUZlbmNlKHQpe2xldCBlO2NvbnN0IG49dCxyPW4uZmVuY2VTeW5jKG4uU1lOQ19HUFVfQ09NTUFORFNfQ09NUExFVEUsMCk7cmV0dXJuIHQuZmx1c2goKSxlPW51bGw9PT1yPygpPT4hMDooKT0+e2NvbnN0IHQ9bi5jbGllbnRXYWl0U3luYyhyLDAsMCk7cmV0dXJuIHQ9PT1uLkFMUkVBRFlfU0lHTkFMRUR8fHQ9PT1uLkNPTkRJVElPTl9TQVRJU0ZJRUR9LHtxdWVyeTpyLGlzRmVuY2VQYXNzZWQ6ZX19YXN5bmMgcG9sbEZlbmNlKHQpe3JldHVybiBuZXcgUHJvbWlzZSgoZT0+e3RoaXMuYWRkSXRlbVRvUG9sbCgoKCk9PnQuaXNGZW5jZVBhc3NlZCgpKSwoKCk9PmUoKSkpfSkpfXBvbGxJdGVtcygpe2NvbnN0IHQ9Yyh0aGlzLml0ZW1zVG9Qb2xsLm1hcCgodD0+dC5pc0RvbmVGbikpKTtmb3IobGV0IGU9MDtlPD10OysrZSl7Y29uc3R7cmVzb2x2ZUZuOnR9PXRoaXMuaXRlbXNUb1BvbGxbZV07dCgpfXRoaXMuaXRlbXNUb1BvbGw9dGhpcy5pdGVtc1RvUG9sbC5zbGljZSh0KzEpfWFzeW5jIGFkZEl0ZW1Ub1BvbGwodCxlKXt0aGlzLml0ZW1zVG9Qb2xsLnB1c2goe2lzRG9uZUZuOnQscmVzb2x2ZUZuOmV9KSx0aGlzLml0ZW1zVG9Qb2xsLmxlbmd0aD4xfHxhd2FpdCgwLHUucmVwZWF0ZWRUcnkpKCgoKT0+KHRoaXMucG9sbEl0ZW1zKCksMD09PXRoaXMuaXRlbXNUb1BvbGwubGVuZ3RoKSkpfX19LDEwMzY6KHQsZSxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUuRXhlY3V0aW9uUGxhbj12b2lkIDA7Y29uc3Qgcj1uKDM2OTQpO2NsYXNzIGl7Y29uc3RydWN0b3IodCxlKXt0aGlzLm9wPXQsdGhpcy5ub2RlPWV9fWUuRXhlY3V0aW9uUGxhbj1jbGFzc3tjb25zdHJ1Y3Rvcih0LGUsbil7dGhpcy5ncmFwaD10LHRoaXMucHJvZmlsZXI9bix0aGlzLmluaXRpYWxpemUoZSl9aW5pdGlhbGl6ZSh0KXt0aGlzLnByb2ZpbGVyLmV2ZW50KFwic2Vzc2lvblwiLFwiRXhlY3V0aW9uUGxhbi5pbml0aWFsaXplXCIsKCgpPT57Y29uc3QgZT10aGlzLmdyYXBoLmdldE5vZGVzKCk7aWYoZS5sZW5ndGghPT10Lmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJUaGUgc2l6ZSBvZiBub2RlcyBhbmQgT1BzIGRvIG5vdCBtYXRjaC5cIik7dGhpcy5fb3BzPXQubWFwKCgodCxuKT0+bmV3IGkodCxlW25dKSkpLHRoaXMucmVzZXQoKSx0aGlzLl9zdGFydGVyPVtdLHRoaXMuX29wcy5mb3JFYWNoKCgodCxlKT0+e2xldCBuPSEwO2Zvcihjb25zdCBlIG9mIHQubm9kZS5pbnB1dHMpaWYoIXRoaXMuX3ZhbHVlc1tlXSYmLTE9PT10aGlzLmdyYXBoLmdldElucHV0SW5kaWNlcygpLmluZGV4T2YoZSkpe249ITE7YnJlYWt9biYmdGhpcy5fc3RhcnRlci5wdXNoKGUpfSkpfSkpfXJlc2V0KCl7dGhpcy5fdmFsdWVzPXRoaXMuZ3JhcGguZ2V0VmFsdWVzKCkubWFwKCh0PT50LnRlbnNvcikpfWFzeW5jIGV4ZWN1dGUodCxlKXtyZXR1cm4gdGhpcy5wcm9maWxlci5ldmVudChcInNlc3Npb25cIixcIkV4ZWN1dGlvblBsYW4uZXhlY3V0ZVwiLChhc3luYygpPT57dGhpcy5yZXNldCgpO2NvbnN0IG49dC5jcmVhdGVJbmZlcmVuY2VIYW5kbGVyKCksaT10aGlzLmdyYXBoLmdldElucHV0SW5kaWNlcygpO2lmKGUubGVuZ3RoIT09aS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKGBudW1iZXIgb2YgaW5wdXQgdGVuc29ycyBkb24ndCBtYXRjaCB0aGUgbnVtYmVyIG9mIGlucHV0cyB0byB0aGUgbW9kZWw6IGFjdHVhbDogJHtlLmxlbmd0aH0gZXhwZWN0ZWQ6ICR7aS5sZW5ndGh9YCk7ZS5mb3JFYWNoKCgodCxlKT0+e2NvbnN0IG49aVtlXTt0aGlzLl92YWx1ZXNbbl09dH0pKTtjb25zdCBvPXRoaXMuX3N0YXJ0ZXIuc2xpY2UoMCksYT10aGlzLmdyYXBoLmdldFZhbHVlcygpLHM9dGhpcy5ncmFwaC5nZXROb2RlcygpO2xldCB1PTA7Zm9yKDt1PG8ubGVuZ3RoOyl7Y29uc3QgdD1vW3UrK10sZT10aGlzLl9vcHNbdF0saT1lLm5vZGUuaW5wdXRzLm1hcCgodD0+dGhpcy5fdmFsdWVzW3RdKSk7aWYoLTEhPT1pLmluZGV4T2Yodm9pZCAwKSl0aHJvdyBuZXcgRXJyb3IoYHVucmVzb2x2ZWQgaW5wdXQgZGV0ZWN0ZWQ6IG9wOiAke2Uubm9kZX1gKTtjb25zdCBjPWk7ci5Mb2dnZXIudmVyYm9zZShcIkV4ZWNQbGFuXCIsYFJ1bmluZyBvcDoke2Uubm9kZS5uYW1lfSAoJHtjLm1hcCgoKHQsbik9PmAnJHtlLm5vZGUuaW5wdXRzW25dfSc6ICR7dC50eXBlfVske3QuZGltcy5qb2luKFwiLFwiKX1dYCkpLmpvaW4oXCIsIFwiKX0pYCk7Y29uc3QgbD1hd2FpdCB0aGlzLnByb2ZpbGVyLmV2ZW50KFwibm9kZVwiLGUubm9kZS5uYW1lLChhc3luYygpPT5lLm9wLmltcGwobixjLGUub3AuY29udGV4dCkpKTtpZihsLmxlbmd0aCE9PWUubm9kZS5vdXRwdXRzLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJ0aGUgc2l6ZSBvZiBvdXRwdXQgZG9lcyBub3QgbWF0Y2ggbW9kZWwgZGVmaW5pdGlvbi5cIik7bC5mb3JFYWNoKCgodCxuKT0+e2NvbnN0IHI9ZS5ub2RlLm91dHB1dHNbbl07aWYodGhpcy5fdmFsdWVzW3JdKXRocm93IG5ldyBFcnJvcihgb3V0cHV0IFske3J9XSBhbHJlYWR5IGhhcyB2YWx1ZTogb3A6JHtlLm5vZGUubmFtZX1gKTt0aGlzLl92YWx1ZXNbcl09dH0pKTtjb25zdCBwPW5ldyBTZXQ7bC5mb3JFYWNoKCgodCxuKT0+e2NvbnN0IHI9ZS5ub2RlLm91dHB1dHNbbl07Zm9yKGNvbnN0IHQgb2YgYVtyXS50byl7Y29uc3QgZT1zW3RdO2xldCBuPSEwO2Zvcihjb25zdCB0IG9mIGUuaW5wdXRzKWlmKCF0aGlzLl92YWx1ZXNbdF0pe249ITE7YnJlYWt9biYmcC5hZGQodCl9fSkpLG8ucHVzaCguLi5wKX1jb25zdCBjPVtdO2ZvcihsZXQgdD0wO3Q8dGhpcy5ncmFwaC5nZXRPdXRwdXRJbmRpY2VzKCkubGVuZ3RoO3QrKyl7Y29uc3QgZT10aGlzLmdyYXBoLmdldE91dHB1dEluZGljZXMoKVt0XSxuPXRoaXMuX3ZhbHVlc1tlXTtpZih2b2lkIDA9PT1uKXRocm93IG5ldyBFcnJvcihgcmVxdWlyZWQgb3V0cHV0IFske2V9XSBkb2VzIG5vdCBoYXZlIHZhbHVlYCk7MD09PWU/YXdhaXQgbi5nZXREYXRhKCk6bi5kYXRhLGMucHVzaChuKX1yZXR1cm4gci5Mb2dnZXIudmVyYm9zZShcIkV4ZWNQbGFuXCIsXCJkaXNwb3Npbmcgb2YgaW5mZXJlbmNlSGFuZGxlclwiKSxuLmRpc3Bvc2UoKSxjfSkpfX19LDcwNzA6KHQsZSxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUuR3JhcGg9dm9pZCAwO2NvbnN0IHI9bigxNDQ2KSxpPW4oNzc3OCksbz1uKDkzOTUpLGE9big5MTYyKSxzPW4oMjUxNyk7dmFyIHU9by5vbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzO2UuR3JhcGg9e2Zyb206KHQsZSk9Pm5ldyBwKHQsZSl9O2NsYXNzIGN7Y29uc3RydWN0b3IodCl7dGhpcy5fZnJvbT12b2lkIDAsdGhpcy5fdG89W10sdGhpcy50ZW5zb3I9dm9pZCAwLHRoaXMudHlwZT12b2lkIDAsdCYmKHRoaXMudHlwZT1zLlByb3RvVXRpbC50ZW5zb3JWYWx1ZVR5cGVGcm9tUHJvdG8odC50eXBlLnRlbnNvclR5cGUpKX1nZXQgZnJvbSgpe3JldHVybiB0aGlzLl9mcm9tfWdldCB0bygpe3JldHVybiB0aGlzLl90b319Y2xhc3MgbHtjb25zdHJ1Y3Rvcih0LGUpe3QgaW5zdGFuY2VvZiByLm9ubnguTm9kZVByb3RvPyh0aGlzLm5hbWU9dC5uYW1lLHRoaXMub3BUeXBlPXQub3BUeXBlLHRoaXMuYXR0cmlidXRlcz1uZXcgaS5BdHRyaWJ1dGUodC5hdHRyaWJ1dGUpKTp0IGluc3RhbmNlb2YgdS5Ob2RlJiYodGhpcy5uYW1lPW51bGwhPWU/ZTp0Lm5hbWUoKSx0aGlzLm9wVHlwZT10Lm9wVHlwZSgpLHRoaXMuYXR0cmlidXRlcz1uZXcgaS5BdHRyaWJ1dGUocy5Qcm90b1V0aWwudGVuc29yQXR0cmlidXRlc0Zyb21PUlRGb3JtYXQodCkpKSx0aGlzLmlucHV0cz1bXSx0aGlzLm91dHB1dHM9W10sdGhpcy5leGVjdXRlTm9kZT0hMH19Y2xhc3MgcHtjb25zdHJ1Y3Rvcih0LGUpe2lmKCF0KXRocm93IG5ldyBUeXBlRXJyb3IoXCJncmFwaCBpcyBlbXB0eVwiKTt0aGlzLmJ1aWxkR3JhcGgodCksdGhpcy50cmFuc2Zvcm1HcmFwaChlKSx0aGlzLmNoZWNrSXNBY3ljbGljKCl9Z2V0SW5wdXRJbmRpY2VzKCl7cmV0dXJuIHRoaXMuX2FsbElucHV0SW5kaWNlc31nZXRJbnB1dE5hbWVzKCl7cmV0dXJuIHRoaXMuX2FsbElucHV0TmFtZXN9Z2V0T3V0cHV0SW5kaWNlcygpe3JldHVybiB0aGlzLl9hbGxPdXRwdXRJbmRpY2VzfWdldE91dHB1dE5hbWVzKCl7cmV0dXJuIHRoaXMuX2FsbE91dHB1dE5hbWVzfWdldFZhbHVlcygpe3JldHVybiB0aGlzLl9hbGxEYXRhfWdldE5vZGVzKCl7cmV0dXJuIHRoaXMuX25vZGVzfWJ1aWxkR3JhcGgodCl7aWYodCBpbnN0YW5jZW9mIHIub25ueC5HcmFwaFByb3RvKXRoaXMuYnVpbGRHcmFwaEZyb21Pbm54Rm9ybWF0KHQpO2Vsc2V7aWYoISh0IGluc3RhbmNlb2YgdS5HcmFwaCkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdyYXBoIHR5cGUgaXMgbm90IHN1cHBvcnRlZC5cIik7dGhpcy5idWlsZEdyYXBoRnJvbU9ydEZvcm1hdCh0KX19YnVpbGRHcmFwaEZyb21Pbm54Rm9ybWF0KHQpe2NvbnN0IGU9bmV3IE1hcDt0aGlzLl9hbGxEYXRhPVtdLHRoaXMuX2FsbElucHV0SW5kaWNlcz1bXSx0aGlzLl9hbGxJbnB1dE5hbWVzPVtdLHRoaXMuX2FsbE91dHB1dEluZGljZXM9W10sdGhpcy5fYWxsT3V0cHV0TmFtZXM9W10sdGhpcy5fbm9kZXM9W107Y29uc3Qgbj1uZXcgTWFwO2lmKCF0LmlucHV0KXRocm93IG5ldyBFcnJvcihcIm1pc3NpbmcgaW5mb3JtYXRpb24gaW4gZ3JhcGg6IGlucHV0XCIpO2NvbnN0IHI9W107Zm9yKGNvbnN0IG4gb2YgdC5pbnB1dCl7aWYoZS5oYXMobi5uYW1lKSl0aHJvdyBuZXcgRXJyb3IoYGR1cGxpY2F0ZWQgaW5wdXQgbmFtZTogJHtuLm5hbWV9YCk7Y29uc3QgdD10aGlzLl9hbGxEYXRhLnB1c2gobmV3IGMobikpLTE7ZS5zZXQobi5uYW1lLHQpLHIucHVzaChuLm5hbWUpfWlmKCF0LmluaXRpYWxpemVyKXRocm93IG5ldyBFcnJvcihcIm1pc3NpbmcgaW5mb3JtYXRpb24gaW4gZ3JhcGg6IGluaXRpYWxpemVyXCIpO2Zvcihjb25zdCBuIG9mIHQuaW5pdGlhbGl6ZXIpe2xldCB0PWUuZ2V0KG4ubmFtZSk7aWYodm9pZCAwPT09dCl7Y29uc3Qgcj1uZXcgYztyLnR5cGU9e3NoYXBlOntkaW1zOnMuUHJvdG9VdGlsLnRlbnNvckRpbXNGcm9tUHJvdG8obi5kaW1zKX0sdGVuc29yVHlwZTpzLlByb3RvVXRpbC50ZW5zb3JEYXRhVHlwZUZyb21Qcm90byhuLmRhdGFUeXBlKX0sdD10aGlzLl9hbGxEYXRhLnB1c2gociktMSxlLnNldChuLm5hbWUsdCl9dGhpcy5fYWxsRGF0YVt0XS5fZnJvbT0tMSx0aGlzLl9hbGxEYXRhW3RdLnRlbnNvcj1hLlRlbnNvci5mcm9tUHJvdG8obil9Zm9yKGxldCB0PTA7dDx0aGlzLl9hbGxEYXRhLmxlbmd0aDt0KyspdGhpcy5fYWxsRGF0YVt0XS50ZW5zb3J8fCh0aGlzLl9hbGxJbnB1dEluZGljZXMucHVzaCh0KSx0aGlzLl9hbGxJbnB1dE5hbWVzLnB1c2goclt0XSkpO2lmKCF0Lm91dHB1dCl0aHJvdyBuZXcgRXJyb3IoXCJtaXNzaW5nIGluZm9ybWF0aW9uIGluIGdyYXBoOiBvdXRwdXRcIik7Zm9yKGNvbnN0IG4gb2YgdC5vdXRwdXQpe2lmKGUuaGFzKG4ubmFtZSkpdGhyb3cgbmV3IEVycm9yKGBkdXBsaWNhdGVkIG91dHB1dCBuYW1lOiAke24ubmFtZX1gKTtjb25zdCB0PXRoaXMuX2FsbERhdGEucHVzaChuZXcgYyhuKSktMTtlLnNldChuLm5hbWUsdCksdGhpcy5fYWxsT3V0cHV0SW5kaWNlcy5wdXNoKHQpLHRoaXMuX2FsbE91dHB1dE5hbWVzLnB1c2gobi5uYW1lKX1pZighdC5ub2RlKXRocm93IG5ldyBFcnJvcihcIm1pc3NpbmcgaW5mb3JtYXRpb24gaW4gZ3JhcGg6IG5vZGVcIik7Zm9yKGNvbnN0IGUgb2YgdC5ub2RlKXtpZighZS5uYW1lKWZvcihsZXQgdD0wOzt0Kyspe2NvbnN0IHI9YHVubmFtZWRfJHtlLm9wVHlwZX1fJHt0fWA7aWYoIW4uaGFzKHIpKXtlLm5hbWU9cjticmVha319aWYobi5oYXMoZS5uYW1lKSl0aHJvdyBuZXcgRXJyb3IoYGR1cGxpY2F0ZWQgbm9kZSBuYW1lOiAke2UubmFtZX1gKTtjb25zdCB0PXRoaXMuX25vZGVzLnB1c2gobmV3IGwoZSkpLTE7bi5zZXQoZS5uYW1lLHQpfWZvcihsZXQgbj0wO248dGhpcy5fbm9kZXMubGVuZ3RoO24rKyl7Y29uc3Qgcj10aGlzLl9ub2Rlc1tuXSxpPXQubm9kZVtuXTtpZighaS5vdXRwdXQpdGhyb3cgbmV3IEVycm9yKGBtaXNzaW5nIG91dHB1dCBmb3Igbm9kZTogJHtpLm5hbWV9YCk7Zm9yKGNvbnN0IHQgb2YgaS5vdXRwdXQpe2xldCBvPWUuZ2V0KHQpO2lmKHZvaWQgMD09PW8mJihvPXRoaXMuX2FsbERhdGEucHVzaChuZXcgYyktMSxlLnNldCh0LG8pKSxyLm91dHB1dHMucHVzaChvKSx2b2lkIDAhPT10aGlzLl9hbGxEYXRhW29dLl9mcm9tKXRocm93IG5ldyBFcnJvcihgbXVsdGlwbGUgbm9kZXMgb3V0cHV0IHRvIG9uZSBkYXRhIHZhbHVlOiAke299YCk7aWYodGhpcy5fYWxsRGF0YVtvXS5fZnJvbT1uLFwiQ29uc3RhbnRcIj09PWkub3BUeXBlKXtpZighaS5hdHRyaWJ1dGV8fDEhPT1pLmF0dHJpYnV0ZS5sZW5ndGh8fCFpLmF0dHJpYnV0ZVswXS50KXRocm93IG5ldyBFcnJvcihcIm1pc3NpbmcgYXR0cmlidXRlcyBvciBtaXNzaW5nIHRlbnNvciB2YWx1ZSBpbiBhdHRyaWJ1dGVzIGZvciB0aGlzIENvbnN0YW50IG9wZXJhdG9yXCIpO2lmKCFpLm91dHB1dHx8MSE9PWkub3V0cHV0Lmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJtaXNzaW5nIG91dHB1dCBvciBpbmNvcnJlY3QgbnVtYmVyIG9mIG91dHB1dHMgZm9yIHRoaXMgQ29uc3RhbnQgb3BlcmF0b3JcIik7ci5vdXRwdXRzLnBvcCgpLHIuZXhlY3V0ZU5vZGU9ITEsdGhpcy5fYWxsRGF0YVtvXS5fZnJvbT0tMSx0aGlzLl9hbGxEYXRhW29dLnRlbnNvcj1hLlRlbnNvci5mcm9tUHJvdG8oaS5hdHRyaWJ1dGVbMF0udCl9fX1mb3IobGV0IG49MDtuPHRoaXMuX25vZGVzLmxlbmd0aDtuKyspe2NvbnN0IHI9dGhpcy5fbm9kZXNbbl0saT10Lm5vZGVbbl07aWYoIWkuaW5wdXQpdGhyb3cgbmV3IEVycm9yKGBtaXNzaW5nIGlucHV0IGZvciBub2RlOiAke2kubmFtZX1gKTtmb3IoY29uc3QgdCBvZiBpLmlucHV0KXtjb25zdCBvPWUuZ2V0KHQpO2lmKHZvaWQgMD09PW8pe2lmKFwiXCI9PT10JiYzPT09aS5pbnB1dC5sZW5ndGgmJlwiUmVzaXplXCI9PT1pLm9wVHlwZSljb250aW51ZTt0aHJvdyBuZXcgRXJyb3IoYHVucmVjb2duaXplZCBpbnB1dCAnJHt0fScgZm9yIG5vZGU6ICR7aS5uYW1lfWApfXIuaW5wdXRzLnB1c2gobyksdGhpcy5fYWxsRGF0YVtvXS5fdG8ucHVzaChuKX19cmV0dXJuITB9YnVpbGRHcmFwaEZyb21PcnRGb3JtYXQodCl7dmFyIGUsbixyO2NvbnN0IGk9bmV3IE1hcDt0aGlzLl9hbGxEYXRhPVtdLHRoaXMuX2FsbElucHV0SW5kaWNlcz1bXSx0aGlzLl9hbGxJbnB1dE5hbWVzPVtdLHRoaXMuX2FsbE91dHB1dEluZGljZXM9W10sdGhpcy5fYWxsT3V0cHV0TmFtZXM9W10sdGhpcy5fbm9kZXM9W107Y29uc3Qgbz1uZXcgTWFwLHA9W107Zm9yKGxldCBvPTA7bzx0LmlucHV0c0xlbmd0aCgpO28rKyl7Y29uc3QgYT10LmlucHV0cyhvKTtpZihpLmhhcyhhKSl0aHJvdyBuZXcgRXJyb3IoYGR1cGxpY2F0ZWQgaW5wdXQgbmFtZTogJHthfWApO2ZvcihsZXQgbz0wO288dC5ub2RlQXJnc0xlbmd0aCgpO28rKylpZigobnVsbD09PShlPXQubm9kZUFyZ3MobykpfHx2b2lkIDA9PT1lP3ZvaWQgMDplLm5hbWUoKSk9PT1hKXtjb25zdCBlPW5ldyBjO2lmKChudWxsPT09KHI9bnVsbD09PShuPXQubm9kZUFyZ3MobykpfHx2b2lkIDA9PT1uP3ZvaWQgMDpuLnR5cGUoKSl8fHZvaWQgMD09PXI/dm9pZCAwOnIudmFsdWVUeXBlKCkpIT09dS5UeXBlSW5mb1ZhbHVlLnRlbnNvcl90eXBlKXRocm93IG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgdmFsdWUgdHlwZSBmb3IgdGhlIG5vZGVBcmcuXCIpO2NvbnN0IGw9dC5ub2RlQXJncyhvKS50eXBlKCkudmFsdWUobmV3IHUuVGVuc29yVHlwZUFuZFNoYXBlKSxmPXMuUHJvdG9VdGlsLnRlbnNvckRhdGFUeXBlRnJvbVByb3RvKGwuZWxlbVR5cGUoKSksZD1sLnNoYXBlKCksaD1bXTtmb3IobGV0IHQ9MDt0PGQuZGltTGVuZ3RoKCk7dCsrKWgucHVzaChzLkxvbmdVdGlsLmxvbmdUb051bWJlcihkLmRpbSh0KS52YWx1ZSgpLmRpbVZhbHVlKCkpKTtlLnR5cGU9e3NoYXBlOntkaW1zOmh9LHRlbnNvclR5cGU6Zn07Y29uc3QgZz10aGlzLl9hbGxEYXRhLnB1c2goZSktMTtpLnNldChhLGcpLHAucHVzaChhKX19Zm9yKGxldCBlPTA7ZTx0LmluaXRpYWxpemVyc0xlbmd0aCgpO2UrKyl7Y29uc3Qgbj10LmluaXRpYWxpemVycyhlKTtsZXQgcj1pLmdldChuLm5hbWUoKSk7aWYodm9pZCAwPT09cil7Y29uc3QgdD1uZXcgYyxlPXMuUHJvdG9VdGlsLnRlbnNvckRpbXNGcm9tT1JURm9ybWF0KG4pLG89cy5Qcm90b1V0aWwudGVuc29yRGF0YVR5cGVGcm9tUHJvdG8obi5kYXRhVHlwZSgpKTt0LnR5cGU9e3NoYXBlOntkaW1zOmV9LHRlbnNvclR5cGU6b30scj10aGlzLl9hbGxEYXRhLnB1c2godCktMSxpLnNldChuLm5hbWUoKSxyKX10aGlzLl9hbGxEYXRhW3JdLl9mcm9tPS0xLHRoaXMuX2FsbERhdGFbcl0udGVuc29yPWEuVGVuc29yLmZyb21PcnRUZW5zb3Iobil9Zm9yKGxldCB0PTA7dDx0aGlzLl9hbGxEYXRhLmxlbmd0aDt0KyspdGhpcy5fYWxsRGF0YVt0XS50ZW5zb3J8fCh0aGlzLl9hbGxJbnB1dEluZGljZXMucHVzaCh0KSx0aGlzLl9hbGxJbnB1dE5hbWVzLnB1c2gocFt0XSkpO2ZvcihsZXQgZT0wO2U8dC5vdXRwdXRzTGVuZ3RoKCk7ZSsrKXtjb25zdCBuPXQub3V0cHV0cyhlKTtpZihpLmhhcyhuKSl0aHJvdyBuZXcgRXJyb3IoYGR1cGxpY2F0ZWQgb3V0cHV0IG5hbWU6ICR7bn1gKTtjb25zdCByPXRoaXMuX2FsbERhdGEucHVzaChuZXcgYyktMTtpLnNldChuLHIpLHRoaXMuX2FsbE91dHB1dEluZGljZXMucHVzaChyKSx0aGlzLl9hbGxPdXRwdXROYW1lcy5wdXNoKG4pfWlmKCF0Lm5vZGVzKXRocm93IG5ldyBFcnJvcihcIm1pc3NpbmcgaW5mb3JtYXRpb24gaW4gZ3JhcGg6IG5vZGVcIik7Zm9yKGxldCBlPTA7ZTx0Lm5vZGVzTGVuZ3RoKCk7ZSsrKXtjb25zdCBuPXQubm9kZXMoZSk7bGV0IHI9bi5uYW1lKCk7aWYoIXIpZm9yKGxldCB0PTA7cj1gdW5uYW1lZF8ke24ub3BUeXBlKCl9XyR7dH1gLG8uaGFzKHIpO3QrKyk7aWYoby5oYXMocikpdGhyb3cgbmV3IEVycm9yKGBkdXBsaWNhdGVkIG5vZGUgbmFtZTogJHtyfWApO2NvbnN0IGk9dGhpcy5fbm9kZXMucHVzaChuZXcgbChuLHIpKS0xO28uc2V0KHIsaSl9Zm9yKGxldCBlPTA7ZTx0aGlzLl9ub2Rlcy5sZW5ndGg7ZSsrKXtjb25zdCBuPXRoaXMuX25vZGVzW2VdLHI9dC5ub2RlcyhlKTtpZihudWxsPT1yKXRocm93IG5ldyBFcnJvcihgTm8gbm9kZSBleGlzdHMgYXQgaW5kZXggJHtlfWApO2lmKDA9PT0obnVsbD09cj92b2lkIDA6ci5vdXRwdXRzTGVuZ3RoKCkpKXRocm93IG5ldyBFcnJvcihgbWlzc2luZyBvdXRwdXQgZm9yIG5vZGU6ICR7ci5uYW1lfWApO2ZvcihsZXQgdD0wO3Q8KG51bGw9PXI/dm9pZCAwOnIub3V0cHV0c0xlbmd0aCgpKTt0Kyspe2NvbnN0IG89bnVsbD09cj92b2lkIDA6ci5vdXRwdXRzKHQpO2xldCBzPWkuZ2V0KG8pO2lmKHZvaWQgMD09PXMmJihzPXRoaXMuX2FsbERhdGEucHVzaChuZXcgYyktMSxpLnNldChvLHMpKSxuLm91dHB1dHMucHVzaChzKSx2b2lkIDAhPT10aGlzLl9hbGxEYXRhW3NdLl9mcm9tKXRocm93IG5ldyBFcnJvcihgbXVsdGlwbGUgbm9kZXMgb3V0cHV0IHRvIG9uZSBkYXRhIHZhbHVlOiAke3N9YCk7aWYodGhpcy5fYWxsRGF0YVtzXS5fZnJvbT1lLFwiQ29uc3RhbnRcIj09PXIub3BUeXBlKCkpe2lmKDEhPT1yLmF0dHJpYnV0ZXNMZW5ndGgoKXx8IXIuYXR0cmlidXRlcygwKS50KCkpdGhyb3cgbmV3IEVycm9yKFwibWlzc2luZyBhdHRyaWJ1dGVzIG9yIG1pc3NpbmcgdGVuc29yIHZhbHVlIGluIGF0dHJpYnV0ZXMgZm9yIHRoaXMgQ29uc3RhbnQgb3BlcmF0b3JcIik7aWYoMSE9PXIub3V0cHV0c0xlbmd0aCgpKXRocm93IG5ldyBFcnJvcihcIm1pc3Npbmcgb3V0cHV0IG9yIGluY29ycmVjdCBudW1iZXIgb2Ygb3V0cHV0cyBmb3IgdGhpcyBDb25zdGFudCBvcGVyYXRvclwiKTtuLm91dHB1dHMucG9wKCksbi5leGVjdXRlTm9kZT0hMSx0aGlzLl9hbGxEYXRhW3NdLl9mcm9tPS0xLHRoaXMuX2FsbERhdGFbc10udGVuc29yPWEuVGVuc29yLmZyb21PcnRUZW5zb3Ioci5hdHRyaWJ1dGVzKDApLnQoKSl9fX1mb3IobGV0IGU9MDtlPHRoaXMuX25vZGVzLmxlbmd0aDtlKyspe2NvbnN0IG49dGhpcy5fbm9kZXNbZV0scj10Lm5vZGVzKGUpO2lmKDA9PT1yLmlucHV0c0xlbmd0aCgpKXRocm93IG5ldyBFcnJvcihgbWlzc2luZyBpbnB1dCBmb3Igbm9kZTogJHtyLm5hbWV9YCk7Zm9yKGxldCB0PTA7dDxyLmlucHV0c0xlbmd0aCgpO3QrKyl7Y29uc3Qgbz1yLmlucHV0cyh0KSxhPWkuZ2V0KG8pO2lmKHZvaWQgMD09PWEpdGhyb3cgbmV3IEVycm9yKGB1bnJlY29nbml6ZWQgaW5wdXQgJyR7b30nIGZvciBub2RlOiAke3IubmFtZSgpfWApO24uaW5wdXRzLnB1c2goYSksdGhpcy5fYWxsRGF0YVthXS5fdG8ucHVzaChlKX19fWNoZWNrSXNBY3ljbGljKCl7Y29uc3QgdD1uZXcgU2V0O3RoaXMuX2FsbElucHV0SW5kaWNlcy5mb3JFYWNoKChlPT57dGhpcy5fYWxsRGF0YVtlXS5fdG8uZm9yRWFjaCgoZT0+e3QuYWRkKGUpfSkpfSkpO2NvbnN0IGU9QXJyYXkuZnJvbSh0KSxuPW5ldyBBcnJheSh0aGlzLl9ub2Rlcy5sZW5ndGgpLmZpbGwoXCJ3aGl0ZVwiKTtmb3IoO2UubGVuZ3RoPjA7KXtjb25zdCB0PWUucG9wKCk7XCJncmF5XCI9PT1uW3RdP25bdF09XCJibGFja1wiOihlLnB1c2godCksblt0XT1cImdyYXlcIix0aGlzLl9ub2Rlc1t0XS5vdXRwdXRzLmZvckVhY2goKHI9Pntjb25zdCBpPXRoaXMuX2FsbERhdGFbcl07aWYodm9pZCAwIT09aS50ZW5zb3IpdGhyb3cgbmV3IEVycm9yKFwibm9kZSBvdXRwdXRzIHNob3VsZCBub3QgYmUgaW5pdGlhbGl6ZWRcIik7aWYoaS5fZnJvbSE9PXQpdGhyb3cgbmV3IEVycm9yKFwiZnJvbSBwcm9wZXJ0eSBvZiB0aGUgVmFsdWUgb2JqZWN0IGRvZXNuJ3QgbWF0Y2ggaW5kZXggb2YgTm9kZSBiZWluZyBwcm9jZXNzZWRcIik7aS5fdG8uZm9yRWFjaCgodD0+e2lmKFwiZ3JheVwiPT09blt0XSl0aHJvdyBuZXcgRXJyb3IoXCJtb2RlbCBncmFwaCBpcyBjeWNsaWNcIik7XCJ3aGl0ZVwiPT09blt0XSYmZS5wdXNoKHQpfSkpfSkpKX19dHJhbnNmb3JtR3JhcGgodCl7dGhpcy5yZW1vdmVBbGxJZGVudGl0eU5vZGVzKCksdGhpcy5yZW1vdmVBbGxEcm9wb3V0Tm9kZXMoKSx0aGlzLmZ1c2VDb252QWN0aXZhdGlvbk5vZGVzKCksdCYmdC50cmFuc2Zvcm1HcmFwaCh0aGlzKSx0aGlzLmZpbmFsaXplR3JhcGgoKX1maW5hbGl6ZUdyYXBoKCl7bGV0IHQ9MDtmb3IobGV0IGU9MDtlPHRoaXMuX25vZGVzLmxlbmd0aDtlKyspdGhpcy5fbm9kZXNbZV0uZXhlY3V0ZU5vZGU/dD4wJiYodGhpcy5fbm9kZXNbZV0uaW5wdXRzLmZvckVhY2goKG49Pntjb25zdCByPXRoaXMuX2FsbERhdGFbbl0uX3RvLmluZGV4T2YoZSt0KTstMSE9PXImJih0aGlzLl9hbGxEYXRhW25dLl90b1tyXT1lKX0pKSx0aGlzLl9ub2Rlc1tlXS5vdXRwdXRzLmZvckVhY2goKG49Pnt0aGlzLl9hbGxEYXRhW25dLl9mcm9tJiZ0aGlzLl9hbGxEYXRhW25dLl9mcm9tPT09ZSt0JiYodGhpcy5fYWxsRGF0YVtuXS5fZnJvbT1lKX0pKSk6KHQrKyx0aGlzLl9ub2Rlc1tlXS5vdXRwdXRzLmZvckVhY2goKHQ9Pnt0aGlzLl9hbGxEYXRhW3RdLl9mcm9tPS0yfSkpLHRoaXMuX25vZGVzLnNwbGljZShlLDEpLGUtLSk7dD0wO2ZvcihsZXQgZT0wO2U8dGhpcy5fYWxsRGF0YS5sZW5ndGg7ZSsrKWlmKC0yIT09dGhpcy5fYWxsRGF0YVtlXS5mcm9tfHwtMSE9PXRoaXMuX2FsbE91dHB1dEluZGljZXMuaW5kZXhPZihlK3QpKXtpZih0PjApe2xldCBuPS0xO3ZvaWQgMCE9PXRoaXMuX2FsbERhdGFbZV0uZnJvbSYmLTEhPT10aGlzLl9hbGxEYXRhW2VdLmZyb20/KG49dGhpcy5fbm9kZXNbdGhpcy5fYWxsRGF0YVtlXS5mcm9tXS5vdXRwdXRzLmluZGV4T2YoZSt0KSwtMSE9PW4mJih0aGlzLl9ub2Rlc1t0aGlzLl9hbGxEYXRhW2VdLmZyb21dLm91dHB1dHNbbl09ZSkpOihuPXRoaXMuX2FsbElucHV0SW5kaWNlcy5pbmRleE9mKGUrdCksLTEhPT1uJiYodGhpcy5fYWxsSW5wdXRJbmRpY2VzW25dPWUpKSx0aGlzLl9hbGxEYXRhW2VdLnRvLmZvckVhY2goKHI9PntuPXRoaXMuX25vZGVzW3JdLmlucHV0cy5pbmRleE9mKGUrdCksLTEhPT1uJiYodGhpcy5fbm9kZXNbcl0uaW5wdXRzW25dPWUpfSkpLDA9PT10aGlzLl9hbGxEYXRhW2VdLnRvLmxlbmd0aCYmKG49dGhpcy5fYWxsT3V0cHV0SW5kaWNlcy5pbmRleE9mKGUrdCksLTEhPT1uJiYodGhpcy5fYWxsT3V0cHV0SW5kaWNlc1tuXT1lKSl9fWVsc2UgdCsrLHRoaXMuX2FsbERhdGEuc3BsaWNlKGUsMSksZS0tfWRlbGV0ZU5vZGUodCl7Y29uc3QgZT10aGlzLl9ub2Rlc1t0XTtpZihlLm91dHB1dHMubGVuZ3RoPjEpZm9yKGxldCB0PTE7dDxlLm91dHB1dHMubGVuZ3RoO3QrKylpZih0aGlzLl9hbGxEYXRhW2Uub3V0cHV0c1t0XV0udG8ubGVuZ3RoPjApdGhyb3cgbmV3IEVycm9yKFwiTm9kZSBkZWxldGlvbiB3aXRoIG1vcmUgdGhhbiBvbmUgb3V0cHV0IGNvbm5lY3RlZCB0byBvdGhlciBub2RlcyBpcyBub3Qgc3VwcG9ydGVkLiBcIik7ZS5leGVjdXRlTm9kZT0hMTtjb25zdCBuPWUuaW5wdXRzWzBdLHI9ZS5vdXRwdXRzWzBdLGk9dGhpcy5fYWxsRGF0YVtyXS50byxvPXRoaXMuX2FsbERhdGFbbl0udG8uaW5kZXhPZih0KTtpZigtMT09PW8pdGhyb3cgbmV3IEVycm9yKFwiVGhlIFZhbHVlIG9iamVjdCBkb2Vzbid0IGhhdmUgdGhlIGN1cnJlbnQgTm9kZSBpbiBpdCdzICd0bycgcHJvcGVydHkgXCIpO3RoaXMuX2FsbERhdGFbbl0udG8uc3BsaWNlKG8sMSksdGhpcy5fYWxsRGF0YVtyXS5fdG89W107Y29uc3QgYT10aGlzLl9hbGxPdXRwdXRJbmRpY2VzLmluZGV4T2Yocik7aWYoLTEhPT1hJiYodGhpcy5fYWxsT3V0cHV0SW5kaWNlc1thXT1uKSxpJiZpLmxlbmd0aD4wKWZvcihjb25zdCB0IG9mIGkpe2NvbnN0IGU9dGhpcy5fbm9kZXNbdF0uaW5wdXRzLmluZGV4T2Yocik7aWYoLTE9PT1lKXRocm93IG5ldyBFcnJvcihcIlRoZSBOb2RlIG9iamVjdCBkb2Vzbid0IGhhdmUgdGhlIG91dHB1dCBWYWx1ZSBpbiBpdCdzICdpbnB1dHMnIHByb3BlcnR5IFwiKTt0aGlzLl9ub2Rlc1t0XS5pbnB1dHNbZV09bix0aGlzLl9hbGxEYXRhW25dLnRvLnB1c2godCl9fXJlbW92ZUFsbERyb3BvdXROb2Rlcygpe2xldCB0PTA7Zm9yKGNvbnN0IGUgb2YgdGhpcy5fbm9kZXMpe2lmKFwiRHJvcG91dFwiPT09ZS5vcFR5cGUpe2lmKDEhPT1lLmlucHV0cy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiRHJvcG91dCBub2RlcyBzaG91bGQgb25seSBjb250YWluIG9uZSBpbnB1dC4gXCIpO2lmKDEhPT1lLm91dHB1dHMubGVuZ3RoJiYyIT09ZS5vdXRwdXRzLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJEcm9wb3V0IG5vZGVzIHNob3VsZCBjb250YWluIGVpdGhlciAxIG9yIDIgb3V0cHV0KHMpXCIpO2lmKDI9PT1lLm91dHB1dHMubGVuZ3RoJiYwIT09dGhpcy5fYWxsRGF0YVtlLm91dHB1dHNbMV1dLl90by5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiRHJvcG91dCBub2RlcydzIHNlY29uZCBvdXRwdXQgc2hvdWxkIG5vdCBiZSByZWZlcmVuY2VkIGJ5IG90aGVyIG5vZGVzXCIpO3RoaXMuZGVsZXRlTm9kZSh0KX10Kyt9fXJlbW92ZUFsbElkZW50aXR5Tm9kZXMoKXtsZXQgdD0wO2Zvcihjb25zdCBlIG9mIHRoaXMuX25vZGVzKVwiSWRlbnRpdHlcIj09PWUub3BUeXBlJiZ0aGlzLmRlbGV0ZU5vZGUodCksdCsrfWlzQWN0aXZhdGlvbih0KXtzd2l0Y2godC5vcFR5cGUpe2Nhc2VcIlJlbHVcIjpjYXNlXCJTaWdtb2lkXCI6Y2FzZVwiQ2xpcFwiOnJldHVybiEwO2RlZmF1bHQ6cmV0dXJuITF9fWZ1c2VDb252QWN0aXZhdGlvbk5vZGVzKCl7Zm9yKGNvbnN0IHQgb2YgdGhpcy5fbm9kZXMpaWYoXCJDb252XCI9PT10Lm9wVHlwZSl7Y29uc3QgZT10aGlzLl9hbGxEYXRhW3Qub3V0cHV0c1swXV0uX3RvO2lmKDE9PT1lLmxlbmd0aCYmdGhpcy5pc0FjdGl2YXRpb24odGhpcy5fbm9kZXNbZVswXV0pKXtjb25zdCBuPXRoaXMuX25vZGVzW2VbMF1dO2lmKFwiQ2xpcFwiPT09bi5vcFR5cGUpaWYoMT09PW4uaW5wdXRzLmxlbmd0aCl0cnl7dC5hdHRyaWJ1dGVzLnNldChcImFjdGl2YXRpb25fcGFyYW1zXCIsXCJmbG9hdHNcIixbbi5hdHRyaWJ1dGVzLmdldEZsb2F0KFwibWluXCIpLG4uYXR0cmlidXRlcy5nZXRGbG9hdChcIm1heFwiKV0pfWNhdGNoKGUpe3QuYXR0cmlidXRlcy5zZXQoXCJhY3RpdmF0aW9uX3BhcmFtc1wiLFwiZmxvYXRzXCIsW3MuTUlOX0NMSVAscy5NQVhfQ0xJUF0pfWVsc2V7aWYoIShuLmlucHV0cy5sZW5ndGg+PTMmJnZvaWQgMCE9PXRoaXMuX2FsbERhdGFbbi5pbnB1dHNbMV1dLnRlbnNvciYmdm9pZCAwIT09dGhpcy5fYWxsRGF0YVtuLmlucHV0c1syXV0udGVuc29yKSljb250aW51ZTt0LmF0dHJpYnV0ZXMuc2V0KFwiYWN0aXZhdGlvbl9wYXJhbXNcIixcImZsb2F0c1wiLFt0aGlzLl9hbGxEYXRhW24uaW5wdXRzWzFdXS50ZW5zb3IuZmxvYXREYXRhWzBdLHRoaXMuX2FsbERhdGFbbi5pbnB1dHNbMl1dLnRlbnNvci5mbG9hdERhdGFbMF1dKX10LmF0dHJpYnV0ZXMuc2V0KFwiYWN0aXZhdGlvblwiLFwic3RyaW5nXCIsbi5vcFR5cGUpLHRoaXMuZGVsZXRlTm9kZShlWzBdKX19fX19LDM2OTQ6KHQsZSk9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLm5vdz1lLlByb2ZpbGVyPWUuTG9nZ2VyPXZvaWQgMDtjb25zdCBuPXt2ZXJib3NlOjFlMyxpbmZvOjJlMyx3YXJuaW5nOjRlMyxlcnJvcjo1ZTMsZmF0YWw6NmUzfSxyPXtub25lOm5ldyBjbGFzc3tsb2codCxlLG4pe319LGNvbnNvbGU6bmV3IGNsYXNze2xvZyh0LGUsbil7Y29uc29sZS5sb2coYCR7dGhpcy5jb2xvcih0KX0gJHtuP1wiXHUwMDFiWzM1bVwiK24rXCJcdTAwMWJbMG0gXCI6XCJcIn0ke2V9YCl9Y29sb3IodCl7c3dpdGNoKHQpe2Nhc2VcInZlcmJvc2VcIjpyZXR1cm5cIlx1MDAxYlszNDs0MG12XHUwMDFiWzBtXCI7Y2FzZVwiaW5mb1wiOnJldHVyblwiXHUwMDFiWzMybWlcdTAwMWJbMG1cIjtjYXNlXCJ3YXJuaW5nXCI6cmV0dXJuXCJcdTAwMWJbMzA7NDNtd1x1MDAxYlswbVwiO2Nhc2VcImVycm9yXCI6cmV0dXJuXCJcdTAwMWJbMzE7NDBtZVx1MDAxYlswbVwiO2Nhc2VcImZhdGFsXCI6cmV0dXJuXCJcdTAwMWJbMTAxbWZcdTAwMWJbMG1cIjtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgc2V2ZXJpdHk6ICR7dH1gKX19fX0saT17cHJvdmlkZXI6XCJjb25zb2xlXCIsbWluaW1hbFNldmVyaXR5Olwid2FybmluZ1wiLGxvZ0RhdGVUaW1lOiEwLGxvZ1NvdXJjZUxvY2F0aW9uOiExfTtsZXQgbz17XCJcIjppfTtmdW5jdGlvbiBhKHQsZSxuLHIpe2lmKHZvaWQgMD09PWUpcmV0dXJuIGk9dCx7dmVyYm9zZTphLnZlcmJvc2UuYmluZChudWxsLGkpLGluZm86YS5pbmZvLmJpbmQobnVsbCxpKSx3YXJuaW5nOmEud2FybmluZy5iaW5kKG51bGwsaSksZXJyb3I6YS5lcnJvci5iaW5kKG51bGwsaSksZmF0YWw6YS5mYXRhbC5iaW5kKG51bGwsaSl9O2lmKHZvaWQgMD09PW4pcyh0LGUpO2Vsc2UgaWYoXCJudW1iZXJcIj09dHlwZW9mIG4mJnZvaWQgMD09PXIpcyh0LGUpO2Vsc2UgaWYoXCJzdHJpbmdcIj09dHlwZW9mIG4mJnZvaWQgMD09PXIpcyh0LG4sMCxlKTtlbHNle2lmKFwic3RyaW5nXCIhPXR5cGVvZiBufHxcIm51bWJlclwiIT10eXBlb2Ygcil0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW5wdXQgaXMgdmFsaWRcIik7cyh0LG4sMCxlKX12YXIgaX1mdW5jdGlvbiBzKHQsZSxpLGEpe2NvbnN0IHM9b1thfHxcIlwiXXx8b1tcIlwiXTtuW3RdPG5bcy5taW5pbWFsU2V2ZXJpdHldfHwocy5sb2dEYXRlVGltZSYmKGU9YCR7KG5ldyBEYXRlKS50b0lTT1N0cmluZygpfXwke2V9YCkscy5sb2dTb3VyY2VMb2NhdGlvbixyW3MucHJvdmlkZXJdLmxvZyh0LGUsYSkpfSFmdW5jdGlvbih0KXtmdW5jdGlvbiBlKHQpe289e30sbihcIlwiLHR8fHt9KX1mdW5jdGlvbiBuKHQsbil7aWYoXCIqXCI9PT10KWUobik7ZWxzZXtjb25zdCBlPW9bdF18fGk7b1t0XT17cHJvdmlkZXI6bi5wcm92aWRlcnx8ZS5wcm92aWRlcixtaW5pbWFsU2V2ZXJpdHk6bi5taW5pbWFsU2V2ZXJpdHl8fGUubWluaW1hbFNldmVyaXR5LGxvZ0RhdGVUaW1lOnZvaWQgMD09PW4ubG9nRGF0ZVRpbWU/ZS5sb2dEYXRlVGltZTpuLmxvZ0RhdGVUaW1lLGxvZ1NvdXJjZUxvY2F0aW9uOnZvaWQgMD09PW4ubG9nU291cmNlTG9jYXRpb24/ZS5sb2dTb3VyY2VMb2NhdGlvbjpuLmxvZ1NvdXJjZUxvY2F0aW9ufX19dC52ZXJib3NlPWZ1bmN0aW9uKGUsbil7dChcInZlcmJvc2VcIixlLG4pfSx0LmluZm89ZnVuY3Rpb24oZSxuKXt0KFwiaW5mb1wiLGUsbil9LHQud2FybmluZz1mdW5jdGlvbihlLG4pe3QoXCJ3YXJuaW5nXCIsZSxuKX0sdC5lcnJvcj1mdW5jdGlvbihlLG4pe3QoXCJlcnJvclwiLGUsbil9LHQuZmF0YWw9ZnVuY3Rpb24oZSxuKXt0KFwiZmF0YWxcIixlLG4pfSx0LnJlc2V0PWUsdC5zZXQ9bix0LnNldFdpdGhFbnY9ZnVuY3Rpb24odCl7Y29uc3QgZT17fTt0LmxvZ0xldmVsJiYoZS5taW5pbWFsU2V2ZXJpdHk9dC5sb2dMZXZlbCksbihcIlwiLGUpfX0oYXx8KGE9e30pKSxlLkxvZ2dlcj1hO2NsYXNzIHV7Y29uc3RydWN0b3IodCxlLG4scixpLG8pe3RoaXMuY2F0ZWdvcnk9dCx0aGlzLm5hbWU9ZSx0aGlzLnN0YXJ0VGltZT1uLHRoaXMuZW5kQ2FsbGJhY2s9cix0aGlzLnRpbWVyPWksdGhpcy5jdHg9b31lbmQoKXtyZXR1cm4gdGhpcy5lbmRDYWxsYmFjayh0aGlzKX1hc3luYyBjaGVja1RpbWVyKCl7aWYodm9pZCAwPT09dGhpcy5jdHh8fHZvaWQgMD09PXRoaXMudGltZXIpdGhyb3cgbmV3IEVycm9yKFwiTm8gd2ViZ2wgdGltZXIgZm91bmRcIik7cmV0dXJuIHRoaXMuY3R4LmVuZFRpbWVyKCksdGhpcy5jdHgud2FpdEZvclF1ZXJ5QW5kR2V0VGltZSh0aGlzLnRpbWVyKX19Y2xhc3MgY3tjb25zdHJ1Y3Rvcih0LGUsbixyKXt0aGlzLmNhdGVnb3J5PXQsdGhpcy5uYW1lPWUsdGhpcy5zdGFydFRpbWU9bix0aGlzLmVuZFRpbWU9cn19ZS5Qcm9maWxlcj1jbGFzc3tzdGF0aWMgY3JlYXRlKHQpe3JldHVybiB2b2lkIDA9PT10P25ldyB0aGlzOm5ldyB0aGlzKHQubWF4TnVtYmVyRXZlbnRzLHQuZmx1c2hCYXRjaFNpemUsdC5mbHVzaEludGVydmFsSW5NaWxsaXNlY29uZHMpfWNvbnN0cnVjdG9yKHQsZSxuKXt0aGlzLl9zdGFydGVkPSExLHRoaXMuX2ZsdXNoUG9pbnRlcj0wLHRoaXMuX3N0YXJ0ZWQ9ITEsdGhpcy5fbWF4TnVtYmVyRXZlbnRzPXZvaWQgMD09PXQ/MWU0OnQsdGhpcy5fZmx1c2hCYXRjaFNpemU9dm9pZCAwPT09ZT8xMDplLHRoaXMuX2ZsdXNoSW50ZXJ2YWxJbk1pbGxpc2Vjb25kcz12b2lkIDA9PT1uPzVlMzpufXN0YXJ0KCl7dGhpcy5fc3RhcnRlZD0hMCx0aGlzLl90aW1pbmdFdmVudHM9W10sdGhpcy5fZmx1c2hUaW1lPSgwLGUubm93KSgpLHRoaXMuX2ZsdXNoUG9pbnRlcj0wfXN0b3AoKXtmb3IodGhpcy5fc3RhcnRlZD0hMTt0aGlzLl9mbHVzaFBvaW50ZXI8dGhpcy5fdGltaW5nRXZlbnRzLmxlbmd0aDt0aGlzLl9mbHVzaFBvaW50ZXIrKyl0aGlzLmxvZ09uZUV2ZW50KHRoaXMuX3RpbWluZ0V2ZW50c1t0aGlzLl9mbHVzaFBvaW50ZXJdKX1ldmVudCh0LGUsbixyKXtjb25zdCBpPXRoaXMuX3N0YXJ0ZWQ/dGhpcy5iZWdpbih0LGUscik6dm9pZCAwO2xldCBvPSExO2NvbnN0IGE9bigpO2lmKGEmJlwiZnVuY3Rpb25cIj09dHlwZW9mIGEudGhlbilyZXR1cm4gbz0hMCxuZXcgUHJvbWlzZSgoKHQsZSk9PnthLnRoZW4oKGFzeW5jIGU9PntpJiZhd2FpdCBpLmVuZCgpLHQoZSl9KSwoYXN5bmMgdD0+e2kmJmF3YWl0IGkuZW5kKCksZSh0KX0pKX0pKTtpZighbyYmaSl7Y29uc3QgdD1pLmVuZCgpO2lmKHQmJlwiZnVuY3Rpb25cIj09dHlwZW9mIHQudGhlbilyZXR1cm4gbmV3IFByb21pc2UoKChlLG4pPT57dC50aGVuKCgoKT0+e2UoYSl9KSwodD0+e24odCl9KSl9KSl9cmV0dXJuIGF9YmVnaW4odCxuLHIpe2lmKCF0aGlzLl9zdGFydGVkKXRocm93IG5ldyBFcnJvcihcInByb2ZpbGVyIGlzIG5vdCBzdGFydGVkIHlldFwiKTtpZih2b2lkIDA9PT1yKXtjb25zdCByPSgwLGUubm93KSgpO3JldHVybiB0aGlzLmZsdXNoKHIpLG5ldyB1KHQsbixyLCh0PT50aGlzLmVuZFN5bmModCkpKX17Y29uc3QgZT1yLmJlZ2luVGltZXIoKTtyZXR1cm4gbmV3IHUodCxuLDAsKGFzeW5jIHQ9PnRoaXMuZW5kKHQpKSxlLHIpfX1hc3luYyBlbmQodCl7Y29uc3QgZT1hd2FpdCB0LmNoZWNrVGltZXIoKTt0aGlzLl90aW1pbmdFdmVudHMubGVuZ3RoPHRoaXMuX21heE51bWJlckV2ZW50cyYmKHRoaXMuX3RpbWluZ0V2ZW50cy5wdXNoKG5ldyBjKHQuY2F0ZWdvcnksdC5uYW1lLHQuc3RhcnRUaW1lLGUpKSx0aGlzLmZsdXNoKGUpKX1lbmRTeW5jKHQpe2NvbnN0IG49KDAsZS5ub3cpKCk7dGhpcy5fdGltaW5nRXZlbnRzLmxlbmd0aDx0aGlzLl9tYXhOdW1iZXJFdmVudHMmJih0aGlzLl90aW1pbmdFdmVudHMucHVzaChuZXcgYyh0LmNhdGVnb3J5LHQubmFtZSx0LnN0YXJ0VGltZSxuKSksdGhpcy5mbHVzaChuKSl9bG9nT25lRXZlbnQodCl7ZS5Mb2dnZXIudmVyYm9zZShgUHJvZmlsZXIuJHt0LmNhdGVnb3J5fWAsYCR7KHQuZW5kVGltZS10LnN0YXJ0VGltZSkudG9GaXhlZCgyKX1tcyBvbiBldmVudCAnJHt0Lm5hbWV9JyBhdCAke3QuZW5kVGltZS50b0ZpeGVkKDIpfWApfWZsdXNoKHQpe2lmKHRoaXMuX3RpbWluZ0V2ZW50cy5sZW5ndGgtdGhpcy5fZmx1c2hQb2ludGVyPj10aGlzLl9mbHVzaEJhdGNoU2l6ZXx8dC10aGlzLl9mbHVzaFRpbWU+PXRoaXMuX2ZsdXNoSW50ZXJ2YWxJbk1pbGxpc2Vjb25kcyl7Zm9yKGNvbnN0IHQ9dGhpcy5fZmx1c2hQb2ludGVyO3RoaXMuX2ZsdXNoUG9pbnRlcjx0K3RoaXMuX2ZsdXNoQmF0Y2hTaXplJiZ0aGlzLl9mbHVzaFBvaW50ZXI8dGhpcy5fdGltaW5nRXZlbnRzLmxlbmd0aDt0aGlzLl9mbHVzaFBvaW50ZXIrKyl0aGlzLmxvZ09uZUV2ZW50KHRoaXMuX3RpbWluZ0V2ZW50c1t0aGlzLl9mbHVzaFBvaW50ZXJdKTt0aGlzLl9mbHVzaFRpbWU9KDAsZS5ub3cpKCl9fWdldCBzdGFydGVkKCl7cmV0dXJuIHRoaXMuX3N0YXJ0ZWR9fSxlLm5vdz1cInVuZGVmaW5lZFwiIT10eXBlb2YgcGVyZm9ybWFuY2UmJnBlcmZvcm1hbmNlLm5vdz8oKT0+cGVyZm9ybWFuY2Uubm93KCk6RGF0ZS5ub3d9LDI2NDQ6KHQsZSxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUuTW9kZWw9dm9pZCAwO2NvbnN0IHI9big1Njg2KSxpPW4oMTQ0Niksbz1uKDcwNzApLGE9big5Mzk1KSxzPW4oMjUxNyk7dmFyIHU9YS5vbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzO2UuTW9kZWw9Y2xhc3N7Y29uc3RydWN0b3IoKXt9bG9hZCh0LGUsbil7aWYoIW4pdHJ5e3JldHVybiB2b2lkIHRoaXMubG9hZEZyb21Pbm54Rm9ybWF0KHQsZSl9Y2F0Y2godCl7aWYodm9pZCAwIT09bil0aHJvdyB0fXRoaXMubG9hZEZyb21PcnRGb3JtYXQodCxlKX1sb2FkRnJvbU9ubnhGb3JtYXQodCxlKXtjb25zdCBuPWkub25ueC5Nb2RlbFByb3RvLmRlY29kZSh0KTtpZihzLkxvbmdVdGlsLmxvbmdUb051bWJlcihuLmlyVmVyc2lvbik8Myl0aHJvdyBuZXcgRXJyb3IoXCJvbmx5IHN1cHBvcnQgT05OWCBtb2RlbCB3aXRoIElSX1ZFUlNJT04+PTNcIik7dGhpcy5fb3BzZXRzPW4ub3BzZXRJbXBvcnQubWFwKCh0PT4oe2RvbWFpbjp0LmRvbWFpbix2ZXJzaW9uOnMuTG9uZ1V0aWwubG9uZ1RvTnVtYmVyKHQudmVyc2lvbil9KSkpLHRoaXMuX2dyYXBoPW8uR3JhcGguZnJvbShuLmdyYXBoLGUpfWxvYWRGcm9tT3J0Rm9ybWF0KHQsZSl7Y29uc3Qgbj1uZXcgci5mbGF0YnVmZmVycy5CeXRlQnVmZmVyKHQpLGk9dS5JbmZlcmVuY2VTZXNzaW9uLmdldFJvb3RBc0luZmVyZW5jZVNlc3Npb24obikubW9kZWwoKTtpZihzLkxvbmdVdGlsLmxvbmdUb051bWJlcihpLmlyVmVyc2lvbigpKTwzKXRocm93IG5ldyBFcnJvcihcIm9ubHkgc3VwcG9ydCBPTk5YIG1vZGVsIHdpdGggSVJfVkVSU0lPTj49M1wiKTt0aGlzLl9vcHNldHM9W107Zm9yKGxldCB0PTA7dDxpLm9wc2V0SW1wb3J0TGVuZ3RoKCk7dCsrKXtjb25zdCBlPWkub3BzZXRJbXBvcnQodCk7dGhpcy5fb3BzZXRzLnB1c2goe2RvbWFpbjpudWxsPT1lP3ZvaWQgMDplLmRvbWFpbigpLHZlcnNpb246cy5Mb25nVXRpbC5sb25nVG9OdW1iZXIoZS52ZXJzaW9uKCkpfSl9dGhpcy5fZ3JhcGg9by5HcmFwaC5mcm9tKGkuZ3JhcGgoKSxlKX1nZXQgZ3JhcGgoKXtyZXR1cm4gdGhpcy5fZ3JhcGh9Z2V0IG9wc2V0cygpe3JldHVybiB0aGlzLl9vcHNldHN9fX0sNzgyOih0LGUpPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5GTE9BVF9UWVBFUz1lLklOVF9UWVBFUz1lLk5VTUJFUl9UWVBFUz12b2lkIDAsZS5OVU1CRVJfVFlQRVM9W1wiZmxvYXQzMlwiLFwiZmxvYXQ2NFwiLFwiaW50MzJcIixcImludDE2XCIsXCJpbnQ4XCIsXCJ1aW50MTZcIixcInVpbnQzMlwiLFwidWludDhcIl0sZS5JTlRfVFlQRVM9W1wiaW50MzJcIixcImludDE2XCIsXCJpbnQ4XCIsXCJ1aW50MTZcIixcInVpbnQzMlwiLFwidWludDhcIl0sZS5GTE9BVF9UWVBFUz1bXCJmbG9hdDMyXCIsXCJmbG9hdDY0XCJdfSwxMDQ3Oih0LGUpPT57XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gbih0LGUpe2lmKGUuZW5kc1dpdGgoXCIrXCIpKXtjb25zdCBuPU51bWJlci5wYXJzZUludChlLnN1YnN0cmluZygwLGUubGVuZ3RoLTEpLDEwKTtyZXR1cm4haXNOYU4obikmJm48PXR9aWYoMj09PWUuc3BsaXQoXCItXCIpLmxlbmd0aCl7Y29uc3Qgbj1lLnNwbGl0KFwiLVwiKSxyPU51bWJlci5wYXJzZUludChuWzBdLDEwKSxpPU51bWJlci5wYXJzZUludChuWzFdLDEwKTtyZXR1cm4haXNOYU4ocikmJiFpc05hTihpKSYmcjw9dCYmdDw9aX1yZXR1cm4gTnVtYmVyLnBhcnNlSW50KGUsMTApPT09dH1PYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLnJlc29sdmVPcGVyYXRvcj12b2lkIDAsZS5yZXNvbHZlT3BlcmF0b3I9ZnVuY3Rpb24odCxlLHIpe2Zvcihjb25zdCBpIG9mIHIpe2NvbnN0IHI9aVswXSxvPWlbMV0sYT1pWzJdLHM9aVszXSx1PWlbNF07aWYodC5vcFR5cGU9PT1yKWZvcihjb25zdCB0IG9mIGUpaWYoKHQuZG9tYWluPT09b3x8XCJhaS5vbm54XCI9PT10LmRvbWFpbiYmXCJcIj09PW8pJiZuKHQudmVyc2lvbixhKSlyZXR1cm57b3BJbXBsOnMsb3BJbml0OnV9fXRocm93IG5ldyBUeXBlRXJyb3IoYGNhbm5vdCByZXNvbHZlIG9wZXJhdG9yICcke3Qub3BUeXBlfScgd2l0aCBvcHNldHM6ICR7ZS5tYXAoKHQ9PmAke3QuZG9tYWlufHxcImFpLm9ubnhcIn0gdiR7dC52ZXJzaW9ufWApKS5qb2luKFwiLCBcIil9YCl9fSw5Mzk1Oih0LGUsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLm9ubnhydW50aW1lPXZvaWQgMDtjb25zdCByPW4oNTY4Nik7dmFyIGksbztpPWUub25ueHJ1bnRpbWV8fChlLm9ubnhydW50aW1lPXt9KSxmdW5jdGlvbih0KXtsZXQgZTshZnVuY3Rpb24odCl7dFt0LlVOREVGSU5FRD0wXT1cIlVOREVGSU5FRFwiLHRbdC5GTE9BVD0xXT1cIkZMT0FUXCIsdFt0LklOVD0yXT1cIklOVFwiLHRbdC5TVFJJTkc9M109XCJTVFJJTkdcIix0W3QuVEVOU09SPTRdPVwiVEVOU09SXCIsdFt0LkdSQVBIPTVdPVwiR1JBUEhcIix0W3QuRkxPQVRTPTZdPVwiRkxPQVRTXCIsdFt0LklOVFM9N109XCJJTlRTXCIsdFt0LlNUUklOR1M9OF09XCJTVFJJTkdTXCIsdFt0LlRFTlNPUlM9OV09XCJURU5TT1JTXCIsdFt0LkdSQVBIUz0xMF09XCJHUkFQSFNcIix0W3QuU1BBUlNFX1RFTlNPUj0xMV09XCJTUEFSU0VfVEVOU09SXCIsdFt0LlNQQVJTRV9URU5TT1JTPTEyXT1cIlNQQVJTRV9URU5TT1JTXCJ9KGU9dC5BdHRyaWJ1dGVUeXBlfHwodC5BdHRyaWJ1dGVUeXBlPXt9KSl9KChvPWkuZXhwZXJpbWVudGFsfHwoaS5leHBlcmltZW50YWw9e30pKS5mYnN8fChvLmZicz17fSkpLGZ1bmN0aW9uKHQpeyFmdW5jdGlvbih0KXshZnVuY3Rpb24odCl7bGV0IGU7IWZ1bmN0aW9uKHQpe3RbdC5VTktOT1dOPTBdPVwiVU5LTk9XTlwiLHRbdC5WQUxVRT0xXT1cIlZBTFVFXCIsdFt0LlBBUkFNPTJdPVwiUEFSQU1cIn0oZT10LkRpbWVuc2lvblZhbHVlVHlwZXx8KHQuRGltZW5zaW9uVmFsdWVUeXBlPXt9KSl9KHQuZmJzfHwodC5mYnM9e30pKX0odC5leHBlcmltZW50YWx8fCh0LmV4cGVyaW1lbnRhbD17fSkpfShlLm9ubnhydW50aW1lfHwoZS5vbm54cnVudGltZT17fSkpLGZ1bmN0aW9uKHQpeyFmdW5jdGlvbih0KXshZnVuY3Rpb24odCl7bGV0IGU7IWZ1bmN0aW9uKHQpe3RbdC5VTkRFRklORUQ9MF09XCJVTkRFRklORURcIix0W3QuRkxPQVQ9MV09XCJGTE9BVFwiLHRbdC5VSU5UOD0yXT1cIlVJTlQ4XCIsdFt0LklOVDg9M109XCJJTlQ4XCIsdFt0LlVJTlQxNj00XT1cIlVJTlQxNlwiLHRbdC5JTlQxNj01XT1cIklOVDE2XCIsdFt0LklOVDMyPTZdPVwiSU5UMzJcIix0W3QuSU5UNjQ9N109XCJJTlQ2NFwiLHRbdC5TVFJJTkc9OF09XCJTVFJJTkdcIix0W3QuQk9PTD05XT1cIkJPT0xcIix0W3QuRkxPQVQxNj0xMF09XCJGTE9BVDE2XCIsdFt0LkRPVUJMRT0xMV09XCJET1VCTEVcIix0W3QuVUlOVDMyPTEyXT1cIlVJTlQzMlwiLHRbdC5VSU5UNjQ9MTNdPVwiVUlOVDY0XCIsdFt0LkNPTVBMRVg2ND0xNF09XCJDT01QTEVYNjRcIix0W3QuQ09NUExFWDEyOD0xNV09XCJDT01QTEVYMTI4XCIsdFt0LkJGTE9BVDE2PTE2XT1cIkJGTE9BVDE2XCJ9KGU9dC5UZW5zb3JEYXRhVHlwZXx8KHQuVGVuc29yRGF0YVR5cGU9e30pKX0odC5mYnN8fCh0LmZicz17fSkpfSh0LmV4cGVyaW1lbnRhbHx8KHQuZXhwZXJpbWVudGFsPXt9KSl9KGUub25ueHJ1bnRpbWV8fChlLm9ubnhydW50aW1lPXt9KSksZnVuY3Rpb24odCl7IWZ1bmN0aW9uKHQpeyFmdW5jdGlvbih0KXtsZXQgZTshZnVuY3Rpb24odCl7dFt0LlByaW1pdGl2ZT0wXT1cIlByaW1pdGl2ZVwiLHRbdC5GdXNlZD0xXT1cIkZ1c2VkXCJ9KGU9dC5Ob2RlVHlwZXx8KHQuTm9kZVR5cGU9e30pKX0odC5mYnN8fCh0LmZicz17fSkpfSh0LmV4cGVyaW1lbnRhbHx8KHQuZXhwZXJpbWVudGFsPXt9KSl9KGUub25ueHJ1bnRpbWV8fChlLm9ubnhydW50aW1lPXt9KSksZnVuY3Rpb24odCl7IWZ1bmN0aW9uKHQpeyFmdW5jdGlvbih0KXtsZXQgZTshZnVuY3Rpb24odCl7dFt0Lk5PTkU9MF09XCJOT05FXCIsdFt0LnRlbnNvcl90eXBlPTFdPVwidGVuc29yX3R5cGVcIix0W3Quc2VxdWVuY2VfdHlwZT0yXT1cInNlcXVlbmNlX3R5cGVcIix0W3QubWFwX3R5cGU9M109XCJtYXBfdHlwZVwifShlPXQuVHlwZUluZm9WYWx1ZXx8KHQuVHlwZUluZm9WYWx1ZT17fSkpfSh0LmZic3x8KHQuZmJzPXt9KSl9KHQuZXhwZXJpbWVudGFsfHwodC5leHBlcmltZW50YWw9e30pKX0oZS5vbm54cnVudGltZXx8KGUub25ueHJ1bnRpbWU9e30pKSxmdW5jdGlvbih0KXshZnVuY3Rpb24oZSl7IWZ1bmN0aW9uKGUpe2NsYXNzIG57Y29uc3RydWN0b3IoKXt0aGlzLmJiPW51bGwsdGhpcy5iYl9wb3M9MH1fX2luaXQodCxlKXtyZXR1cm4gdGhpcy5iYl9wb3M9dCx0aGlzLmJiPWUsdGhpc31zdGF0aWMgZ2V0Um9vdEFzU2hhcGUodCxlKXtyZXR1cm4oZXx8bmV3IG4pLl9faW5pdCh0LnJlYWRJbnQzMih0LnBvc2l0aW9uKCkpK3QucG9zaXRpb24oKSx0KX1zdGF0aWMgZ2V0U2l6ZVByZWZpeGVkUm9vdEFzU2hhcGUodCxlKXtyZXR1cm4gdC5zZXRQb3NpdGlvbih0LnBvc2l0aW9uKCkrci5mbGF0YnVmZmVycy5TSVpFX1BSRUZJWF9MRU5HVEgpLChlfHxuZXcgbikuX19pbml0KHQucmVhZEludDMyKHQucG9zaXRpb24oKSkrdC5wb3NpdGlvbigpLHQpfWRpbShlLG4pe2xldCByPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNCk7cmV0dXJuIHI/KG58fG5ldyB0LmV4cGVyaW1lbnRhbC5mYnMuRGltZW5zaW9uKS5fX2luaXQodGhpcy5iYi5fX2luZGlyZWN0KHRoaXMuYmIuX192ZWN0b3IodGhpcy5iYl9wb3MrcikrNCplKSx0aGlzLmJiKTpudWxsfWRpbUxlbmd0aCgpe2xldCB0PXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNCk7cmV0dXJuIHQ/dGhpcy5iYi5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MrdCk6MH1zdGF0aWMgc3RhcnRTaGFwZSh0KXt0LnN0YXJ0T2JqZWN0KDEpfXN0YXRpYyBhZGREaW0odCxlKXt0LmFkZEZpZWxkT2Zmc2V0KDAsZSwwKX1zdGF0aWMgY3JlYXRlRGltVmVjdG9yKHQsZSl7dC5zdGFydFZlY3Rvcig0LGUubGVuZ3RoLDQpO2ZvcihsZXQgbj1lLmxlbmd0aC0xO24+PTA7bi0tKXQuYWRkT2Zmc2V0KGVbbl0pO3JldHVybiB0LmVuZFZlY3RvcigpfXN0YXRpYyBzdGFydERpbVZlY3Rvcih0LGUpe3Quc3RhcnRWZWN0b3IoNCxlLDQpfXN0YXRpYyBlbmRTaGFwZSh0KXtyZXR1cm4gdC5lbmRPYmplY3QoKX1zdGF0aWMgY3JlYXRlU2hhcGUodCxlKXtyZXR1cm4gbi5zdGFydFNoYXBlKHQpLG4uYWRkRGltKHQsZSksbi5lbmRTaGFwZSh0KX19ZS5TaGFwZT1ufShlLmZic3x8KGUuZmJzPXt9KSl9KHQuZXhwZXJpbWVudGFsfHwodC5leHBlcmltZW50YWw9e30pKX0oZS5vbm54cnVudGltZXx8KGUub25ueHJ1bnRpbWU9e30pKSxmdW5jdGlvbih0KXshZnVuY3Rpb24oZSl7IWZ1bmN0aW9uKGUpe2NsYXNzIG57Y29uc3RydWN0b3IoKXt0aGlzLmJiPW51bGwsdGhpcy5iYl9wb3M9MH1fX2luaXQodCxlKXtyZXR1cm4gdGhpcy5iYl9wb3M9dCx0aGlzLmJiPWUsdGhpc31zdGF0aWMgZ2V0Um9vdEFzRGltZW5zaW9uKHQsZSl7cmV0dXJuKGV8fG5ldyBuKS5fX2luaXQodC5yZWFkSW50MzIodC5wb3NpdGlvbigpKSt0LnBvc2l0aW9uKCksdCl9c3RhdGljIGdldFNpemVQcmVmaXhlZFJvb3RBc0RpbWVuc2lvbih0LGUpe3JldHVybiB0LnNldFBvc2l0aW9uKHQucG9zaXRpb24oKStyLmZsYXRidWZmZXJzLlNJWkVfUFJFRklYX0xFTkdUSCksKGV8fG5ldyBuKS5fX2luaXQodC5yZWFkSW50MzIodC5wb3NpdGlvbigpKSt0LnBvc2l0aW9uKCksdCl9dmFsdWUoZSl7bGV0IG49dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw0KTtyZXR1cm4gbj8oZXx8bmV3IHQuZXhwZXJpbWVudGFsLmZicy5EaW1lbnNpb25WYWx1ZSkuX19pbml0KHRoaXMuYmIuX19pbmRpcmVjdCh0aGlzLmJiX3BvcytuKSx0aGlzLmJiKTpudWxsfWRlbm90YXRpb24odCl7bGV0IGU9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw2KTtyZXR1cm4gZT90aGlzLmJiLl9fc3RyaW5nKHRoaXMuYmJfcG9zK2UsdCk6bnVsbH1zdGF0aWMgc3RhcnREaW1lbnNpb24odCl7dC5zdGFydE9iamVjdCgyKX1zdGF0aWMgYWRkVmFsdWUodCxlKXt0LmFkZEZpZWxkT2Zmc2V0KDAsZSwwKX1zdGF0aWMgYWRkRGVub3RhdGlvbih0LGUpe3QuYWRkRmllbGRPZmZzZXQoMSxlLDApfXN0YXRpYyBlbmREaW1lbnNpb24odCl7cmV0dXJuIHQuZW5kT2JqZWN0KCl9c3RhdGljIGNyZWF0ZURpbWVuc2lvbih0LGUscil7cmV0dXJuIG4uc3RhcnREaW1lbnNpb24odCksbi5hZGRWYWx1ZSh0LGUpLG4uYWRkRGVub3RhdGlvbih0LHIpLG4uZW5kRGltZW5zaW9uKHQpfX1lLkRpbWVuc2lvbj1ufShlLmZic3x8KGUuZmJzPXt9KSl9KHQuZXhwZXJpbWVudGFsfHwodC5leHBlcmltZW50YWw9e30pKX0oZS5vbm54cnVudGltZXx8KGUub25ueHJ1bnRpbWU9e30pKSxmdW5jdGlvbih0KXshZnVuY3Rpb24oZSl7IWZ1bmN0aW9uKGUpe2NsYXNzIG57Y29uc3RydWN0b3IoKXt0aGlzLmJiPW51bGwsdGhpcy5iYl9wb3M9MH1fX2luaXQodCxlKXtyZXR1cm4gdGhpcy5iYl9wb3M9dCx0aGlzLmJiPWUsdGhpc31zdGF0aWMgZ2V0Um9vdEFzRGltZW5zaW9uVmFsdWUodCxlKXtyZXR1cm4oZXx8bmV3IG4pLl9faW5pdCh0LnJlYWRJbnQzMih0LnBvc2l0aW9uKCkpK3QucG9zaXRpb24oKSx0KX1zdGF0aWMgZ2V0U2l6ZVByZWZpeGVkUm9vdEFzRGltZW5zaW9uVmFsdWUodCxlKXtyZXR1cm4gdC5zZXRQb3NpdGlvbih0LnBvc2l0aW9uKCkrci5mbGF0YnVmZmVycy5TSVpFX1BSRUZJWF9MRU5HVEgpLChlfHxuZXcgbikuX19pbml0KHQucmVhZEludDMyKHQucG9zaXRpb24oKSkrdC5wb3NpdGlvbigpLHQpfWRpbVR5cGUoKXtsZXQgZT10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDQpO3JldHVybiBlP3RoaXMuYmIucmVhZEludDgodGhpcy5iYl9wb3MrZSk6dC5leHBlcmltZW50YWwuZmJzLkRpbWVuc2lvblZhbHVlVHlwZS5VTktOT1dOfWRpbVZhbHVlKCl7bGV0IHQ9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw2KTtyZXR1cm4gdD90aGlzLmJiLnJlYWRJbnQ2NCh0aGlzLmJiX3Bvcyt0KTp0aGlzLmJiLmNyZWF0ZUxvbmcoMCwwKX1kaW1QYXJhbSh0KXtsZXQgZT10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDgpO3JldHVybiBlP3RoaXMuYmIuX19zdHJpbmcodGhpcy5iYl9wb3MrZSx0KTpudWxsfXN0YXRpYyBzdGFydERpbWVuc2lvblZhbHVlKHQpe3Quc3RhcnRPYmplY3QoMyl9c3RhdGljIGFkZERpbVR5cGUoZSxuKXtlLmFkZEZpZWxkSW50OCgwLG4sdC5leHBlcmltZW50YWwuZmJzLkRpbWVuc2lvblZhbHVlVHlwZS5VTktOT1dOKX1zdGF0aWMgYWRkRGltVmFsdWUodCxlKXt0LmFkZEZpZWxkSW50NjQoMSxlLHQuY3JlYXRlTG9uZygwLDApKX1zdGF0aWMgYWRkRGltUGFyYW0odCxlKXt0LmFkZEZpZWxkT2Zmc2V0KDIsZSwwKX1zdGF0aWMgZW5kRGltZW5zaW9uVmFsdWUodCl7cmV0dXJuIHQuZW5kT2JqZWN0KCl9c3RhdGljIGNyZWF0ZURpbWVuc2lvblZhbHVlKHQsZSxyLGkpe3JldHVybiBuLnN0YXJ0RGltZW5zaW9uVmFsdWUodCksbi5hZGREaW1UeXBlKHQsZSksbi5hZGREaW1WYWx1ZSh0LHIpLG4uYWRkRGltUGFyYW0odCxpKSxuLmVuZERpbWVuc2lvblZhbHVlKHQpfX1lLkRpbWVuc2lvblZhbHVlPW59KGUuZmJzfHwoZS5mYnM9e30pKX0odC5leHBlcmltZW50YWx8fCh0LmV4cGVyaW1lbnRhbD17fSkpfShlLm9ubnhydW50aW1lfHwoZS5vbm54cnVudGltZT17fSkpLGZ1bmN0aW9uKHQpeyFmdW5jdGlvbihlKXshZnVuY3Rpb24oZSl7Y2xhc3Mgbntjb25zdHJ1Y3Rvcigpe3RoaXMuYmI9bnVsbCx0aGlzLmJiX3Bvcz0wfV9faW5pdCh0LGUpe3JldHVybiB0aGlzLmJiX3Bvcz10LHRoaXMuYmI9ZSx0aGlzfXN0YXRpYyBnZXRSb290QXNUZW5zb3JUeXBlQW5kU2hhcGUodCxlKXtyZXR1cm4oZXx8bmV3IG4pLl9faW5pdCh0LnJlYWRJbnQzMih0LnBvc2l0aW9uKCkpK3QucG9zaXRpb24oKSx0KX1zdGF0aWMgZ2V0U2l6ZVByZWZpeGVkUm9vdEFzVGVuc29yVHlwZUFuZFNoYXBlKHQsZSl7cmV0dXJuIHQuc2V0UG9zaXRpb24odC5wb3NpdGlvbigpK3IuZmxhdGJ1ZmZlcnMuU0laRV9QUkVGSVhfTEVOR1RIKSwoZXx8bmV3IG4pLl9faW5pdCh0LnJlYWRJbnQzMih0LnBvc2l0aW9uKCkpK3QucG9zaXRpb24oKSx0KX1lbGVtVHlwZSgpe2xldCBlPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNCk7cmV0dXJuIGU/dGhpcy5iYi5yZWFkSW50MzIodGhpcy5iYl9wb3MrZSk6dC5leHBlcmltZW50YWwuZmJzLlRlbnNvckRhdGFUeXBlLlVOREVGSU5FRH1zaGFwZShlKXtsZXQgbj10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDYpO3JldHVybiBuPyhlfHxuZXcgdC5leHBlcmltZW50YWwuZmJzLlNoYXBlKS5fX2luaXQodGhpcy5iYi5fX2luZGlyZWN0KHRoaXMuYmJfcG9zK24pLHRoaXMuYmIpOm51bGx9c3RhdGljIHN0YXJ0VGVuc29yVHlwZUFuZFNoYXBlKHQpe3Quc3RhcnRPYmplY3QoMil9c3RhdGljIGFkZEVsZW1UeXBlKGUsbil7ZS5hZGRGaWVsZEludDMyKDAsbix0LmV4cGVyaW1lbnRhbC5mYnMuVGVuc29yRGF0YVR5cGUuVU5ERUZJTkVEKX1zdGF0aWMgYWRkU2hhcGUodCxlKXt0LmFkZEZpZWxkT2Zmc2V0KDEsZSwwKX1zdGF0aWMgZW5kVGVuc29yVHlwZUFuZFNoYXBlKHQpe3JldHVybiB0LmVuZE9iamVjdCgpfXN0YXRpYyBjcmVhdGVUZW5zb3JUeXBlQW5kU2hhcGUodCxlLHIpe3JldHVybiBuLnN0YXJ0VGVuc29yVHlwZUFuZFNoYXBlKHQpLG4uYWRkRWxlbVR5cGUodCxlKSxuLmFkZFNoYXBlKHQsciksbi5lbmRUZW5zb3JUeXBlQW5kU2hhcGUodCl9fWUuVGVuc29yVHlwZUFuZFNoYXBlPW59KGUuZmJzfHwoZS5mYnM9e30pKX0odC5leHBlcmltZW50YWx8fCh0LmV4cGVyaW1lbnRhbD17fSkpfShlLm9ubnhydW50aW1lfHwoZS5vbm54cnVudGltZT17fSkpLGZ1bmN0aW9uKHQpeyFmdW5jdGlvbihlKXshZnVuY3Rpb24oZSl7Y2xhc3Mgbntjb25zdHJ1Y3Rvcigpe3RoaXMuYmI9bnVsbCx0aGlzLmJiX3Bvcz0wfV9faW5pdCh0LGUpe3JldHVybiB0aGlzLmJiX3Bvcz10LHRoaXMuYmI9ZSx0aGlzfXN0YXRpYyBnZXRSb290QXNNYXBUeXBlKHQsZSl7cmV0dXJuKGV8fG5ldyBuKS5fX2luaXQodC5yZWFkSW50MzIodC5wb3NpdGlvbigpKSt0LnBvc2l0aW9uKCksdCl9c3RhdGljIGdldFNpemVQcmVmaXhlZFJvb3RBc01hcFR5cGUodCxlKXtyZXR1cm4gdC5zZXRQb3NpdGlvbih0LnBvc2l0aW9uKCkrci5mbGF0YnVmZmVycy5TSVpFX1BSRUZJWF9MRU5HVEgpLChlfHxuZXcgbikuX19pbml0KHQucmVhZEludDMyKHQucG9zaXRpb24oKSkrdC5wb3NpdGlvbigpLHQpfWtleVR5cGUoKXtsZXQgZT10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDQpO3JldHVybiBlP3RoaXMuYmIucmVhZEludDMyKHRoaXMuYmJfcG9zK2UpOnQuZXhwZXJpbWVudGFsLmZicy5UZW5zb3JEYXRhVHlwZS5VTkRFRklORUR9dmFsdWVUeXBlKGUpe2xldCBuPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNik7cmV0dXJuIG4/KGV8fG5ldyB0LmV4cGVyaW1lbnRhbC5mYnMuVHlwZUluZm8pLl9faW5pdCh0aGlzLmJiLl9faW5kaXJlY3QodGhpcy5iYl9wb3MrbiksdGhpcy5iYik6bnVsbH1zdGF0aWMgc3RhcnRNYXBUeXBlKHQpe3Quc3RhcnRPYmplY3QoMil9c3RhdGljIGFkZEtleVR5cGUoZSxuKXtlLmFkZEZpZWxkSW50MzIoMCxuLHQuZXhwZXJpbWVudGFsLmZicy5UZW5zb3JEYXRhVHlwZS5VTkRFRklORUQpfXN0YXRpYyBhZGRWYWx1ZVR5cGUodCxlKXt0LmFkZEZpZWxkT2Zmc2V0KDEsZSwwKX1zdGF0aWMgZW5kTWFwVHlwZSh0KXtyZXR1cm4gdC5lbmRPYmplY3QoKX1zdGF0aWMgY3JlYXRlTWFwVHlwZSh0LGUscil7cmV0dXJuIG4uc3RhcnRNYXBUeXBlKHQpLG4uYWRkS2V5VHlwZSh0LGUpLG4uYWRkVmFsdWVUeXBlKHQsciksbi5lbmRNYXBUeXBlKHQpfX1lLk1hcFR5cGU9bn0oZS5mYnN8fChlLmZicz17fSkpfSh0LmV4cGVyaW1lbnRhbHx8KHQuZXhwZXJpbWVudGFsPXt9KSl9KGUub25ueHJ1bnRpbWV8fChlLm9ubnhydW50aW1lPXt9KSksZnVuY3Rpb24odCl7IWZ1bmN0aW9uKGUpeyFmdW5jdGlvbihlKXtjbGFzcyBue2NvbnN0cnVjdG9yKCl7dGhpcy5iYj1udWxsLHRoaXMuYmJfcG9zPTB9X19pbml0KHQsZSl7cmV0dXJuIHRoaXMuYmJfcG9zPXQsdGhpcy5iYj1lLHRoaXN9c3RhdGljIGdldFJvb3RBc1NlcXVlbmNlVHlwZSh0LGUpe3JldHVybihlfHxuZXcgbikuX19pbml0KHQucmVhZEludDMyKHQucG9zaXRpb24oKSkrdC5wb3NpdGlvbigpLHQpfXN0YXRpYyBnZXRTaXplUHJlZml4ZWRSb290QXNTZXF1ZW5jZVR5cGUodCxlKXtyZXR1cm4gdC5zZXRQb3NpdGlvbih0LnBvc2l0aW9uKCkrci5mbGF0YnVmZmVycy5TSVpFX1BSRUZJWF9MRU5HVEgpLChlfHxuZXcgbikuX19pbml0KHQucmVhZEludDMyKHQucG9zaXRpb24oKSkrdC5wb3NpdGlvbigpLHQpfWVsZW1UeXBlKGUpe2xldCBuPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNCk7cmV0dXJuIG4/KGV8fG5ldyB0LmV4cGVyaW1lbnRhbC5mYnMuVHlwZUluZm8pLl9faW5pdCh0aGlzLmJiLl9faW5kaXJlY3QodGhpcy5iYl9wb3MrbiksdGhpcy5iYik6bnVsbH1zdGF0aWMgc3RhcnRTZXF1ZW5jZVR5cGUodCl7dC5zdGFydE9iamVjdCgxKX1zdGF0aWMgYWRkRWxlbVR5cGUodCxlKXt0LmFkZEZpZWxkT2Zmc2V0KDAsZSwwKX1zdGF0aWMgZW5kU2VxdWVuY2VUeXBlKHQpe3JldHVybiB0LmVuZE9iamVjdCgpfXN0YXRpYyBjcmVhdGVTZXF1ZW5jZVR5cGUodCxlKXtyZXR1cm4gbi5zdGFydFNlcXVlbmNlVHlwZSh0KSxuLmFkZEVsZW1UeXBlKHQsZSksbi5lbmRTZXF1ZW5jZVR5cGUodCl9fWUuU2VxdWVuY2VUeXBlPW59KGUuZmJzfHwoZS5mYnM9e30pKX0odC5leHBlcmltZW50YWx8fCh0LmV4cGVyaW1lbnRhbD17fSkpfShlLm9ubnhydW50aW1lfHwoZS5vbm54cnVudGltZT17fSkpLGZ1bmN0aW9uKHQpeyFmdW5jdGlvbih0KXsodC5mYnN8fCh0LmZicz17fSkpLkVkZ2VFbmQ9Y2xhc3N7Y29uc3RydWN0b3IoKXt0aGlzLmJiPW51bGwsdGhpcy5iYl9wb3M9MH1fX2luaXQodCxlKXtyZXR1cm4gdGhpcy5iYl9wb3M9dCx0aGlzLmJiPWUsdGhpc31ub2RlSW5kZXgoKXtyZXR1cm4gdGhpcy5iYi5yZWFkVWludDMyKHRoaXMuYmJfcG9zKX1zcmNBcmdJbmRleCgpe3JldHVybiB0aGlzLmJiLnJlYWRJbnQzMih0aGlzLmJiX3Bvcys0KX1kc3RBcmdJbmRleCgpe3JldHVybiB0aGlzLmJiLnJlYWRJbnQzMih0aGlzLmJiX3Bvcys4KX1zdGF0aWMgY3JlYXRlRWRnZUVuZCh0LGUsbixyKXtyZXR1cm4gdC5wcmVwKDQsMTIpLHQud3JpdGVJbnQzMihyKSx0LndyaXRlSW50MzIobiksdC53cml0ZUludDMyKGUpLHQub2Zmc2V0KCl9fX0odC5leHBlcmltZW50YWx8fCh0LmV4cGVyaW1lbnRhbD17fSkpfShlLm9ubnhydW50aW1lfHwoZS5vbm54cnVudGltZT17fSkpLGZ1bmN0aW9uKHQpeyFmdW5jdGlvbihlKXshZnVuY3Rpb24oZSl7Y2xhc3Mgbntjb25zdHJ1Y3Rvcigpe3RoaXMuYmI9bnVsbCx0aGlzLmJiX3Bvcz0wfV9faW5pdCh0LGUpe3JldHVybiB0aGlzLmJiX3Bvcz10LHRoaXMuYmI9ZSx0aGlzfXN0YXRpYyBnZXRSb290QXNOb2RlRWRnZSh0LGUpe3JldHVybihlfHxuZXcgbikuX19pbml0KHQucmVhZEludDMyKHQucG9zaXRpb24oKSkrdC5wb3NpdGlvbigpLHQpfXN0YXRpYyBnZXRTaXplUHJlZml4ZWRSb290QXNOb2RlRWRnZSh0LGUpe3JldHVybiB0LnNldFBvc2l0aW9uKHQucG9zaXRpb24oKStyLmZsYXRidWZmZXJzLlNJWkVfUFJFRklYX0xFTkdUSCksKGV8fG5ldyBuKS5fX2luaXQodC5yZWFkSW50MzIodC5wb3NpdGlvbigpKSt0LnBvc2l0aW9uKCksdCl9bm9kZUluZGV4KCl7bGV0IHQ9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw0KTtyZXR1cm4gdD90aGlzLmJiLnJlYWRVaW50MzIodGhpcy5iYl9wb3MrdCk6MH1pbnB1dEVkZ2VzKGUsbil7bGV0IHI9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw2KTtyZXR1cm4gcj8obnx8bmV3IHQuZXhwZXJpbWVudGFsLmZicy5FZGdlRW5kKS5fX2luaXQodGhpcy5iYi5fX3ZlY3Rvcih0aGlzLmJiX3BvcytyKSsxMiplLHRoaXMuYmIpOm51bGx9aW5wdXRFZGdlc0xlbmd0aCgpe2xldCB0PXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNik7cmV0dXJuIHQ/dGhpcy5iYi5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MrdCk6MH1vdXRwdXRFZGdlcyhlLG4pe2xldCByPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsOCk7cmV0dXJuIHI/KG58fG5ldyB0LmV4cGVyaW1lbnRhbC5mYnMuRWRnZUVuZCkuX19pbml0KHRoaXMuYmIuX192ZWN0b3IodGhpcy5iYl9wb3MrcikrMTIqZSx0aGlzLmJiKTpudWxsfW91dHB1dEVkZ2VzTGVuZ3RoKCl7bGV0IHQ9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw4KTtyZXR1cm4gdD90aGlzLmJiLl9fdmVjdG9yX2xlbih0aGlzLmJiX3Bvcyt0KTowfXN0YXRpYyBzdGFydE5vZGVFZGdlKHQpe3Quc3RhcnRPYmplY3QoMyl9c3RhdGljIGFkZE5vZGVJbmRleCh0LGUpe3QuYWRkRmllbGRJbnQzMigwLGUsMCl9c3RhdGljIGFkZElucHV0RWRnZXModCxlKXt0LmFkZEZpZWxkT2Zmc2V0KDEsZSwwKX1zdGF0aWMgc3RhcnRJbnB1dEVkZ2VzVmVjdG9yKHQsZSl7dC5zdGFydFZlY3RvcigxMixlLDQpfXN0YXRpYyBhZGRPdXRwdXRFZGdlcyh0LGUpe3QuYWRkRmllbGRPZmZzZXQoMixlLDApfXN0YXRpYyBzdGFydE91dHB1dEVkZ2VzVmVjdG9yKHQsZSl7dC5zdGFydFZlY3RvcigxMixlLDQpfXN0YXRpYyBlbmROb2RlRWRnZSh0KXtyZXR1cm4gdC5lbmRPYmplY3QoKX1zdGF0aWMgY3JlYXRlTm9kZUVkZ2UodCxlLHIsaSl7cmV0dXJuIG4uc3RhcnROb2RlRWRnZSh0KSxuLmFkZE5vZGVJbmRleCh0LGUpLG4uYWRkSW5wdXRFZGdlcyh0LHIpLG4uYWRkT3V0cHV0RWRnZXModCxpKSxuLmVuZE5vZGVFZGdlKHQpfX1lLk5vZGVFZGdlPW59KGUuZmJzfHwoZS5mYnM9e30pKX0odC5leHBlcmltZW50YWx8fCh0LmV4cGVyaW1lbnRhbD17fSkpfShlLm9ubnhydW50aW1lfHwoZS5vbm54cnVudGltZT17fSkpLGZ1bmN0aW9uKHQpeyFmdW5jdGlvbihlKXshZnVuY3Rpb24oZSl7Y2xhc3Mgbntjb25zdHJ1Y3Rvcigpe3RoaXMuYmI9bnVsbCx0aGlzLmJiX3Bvcz0wfV9faW5pdCh0LGUpe3JldHVybiB0aGlzLmJiX3Bvcz10LHRoaXMuYmI9ZSx0aGlzfXN0YXRpYyBnZXRSb290QXNOb2RlKHQsZSl7cmV0dXJuKGV8fG5ldyBuKS5fX2luaXQodC5yZWFkSW50MzIodC5wb3NpdGlvbigpKSt0LnBvc2l0aW9uKCksdCl9c3RhdGljIGdldFNpemVQcmVmaXhlZFJvb3RBc05vZGUodCxlKXtyZXR1cm4gdC5zZXRQb3NpdGlvbih0LnBvc2l0aW9uKCkrci5mbGF0YnVmZmVycy5TSVpFX1BSRUZJWF9MRU5HVEgpLChlfHxuZXcgbikuX19pbml0KHQucmVhZEludDMyKHQucG9zaXRpb24oKSkrdC5wb3NpdGlvbigpLHQpfW5hbWUodCl7bGV0IGU9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw0KTtyZXR1cm4gZT90aGlzLmJiLl9fc3RyaW5nKHRoaXMuYmJfcG9zK2UsdCk6bnVsbH1kb2NTdHJpbmcodCl7bGV0IGU9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw2KTtyZXR1cm4gZT90aGlzLmJiLl9fc3RyaW5nKHRoaXMuYmJfcG9zK2UsdCk6bnVsbH1kb21haW4odCl7bGV0IGU9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw4KTtyZXR1cm4gZT90aGlzLmJiLl9fc3RyaW5nKHRoaXMuYmJfcG9zK2UsdCk6bnVsbH1zaW5jZVZlcnNpb24oKXtsZXQgdD10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDEwKTtyZXR1cm4gdD90aGlzLmJiLnJlYWRJbnQzMih0aGlzLmJiX3Bvcyt0KTowfWluZGV4KCl7bGV0IHQ9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywxMik7cmV0dXJuIHQ/dGhpcy5iYi5yZWFkVWludDMyKHRoaXMuYmJfcG9zK3QpOjB9b3BUeXBlKHQpe2xldCBlPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsMTQpO3JldHVybiBlP3RoaXMuYmIuX19zdHJpbmcodGhpcy5iYl9wb3MrZSx0KTpudWxsfXR5cGUoKXtsZXQgZT10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDE2KTtyZXR1cm4gZT90aGlzLmJiLnJlYWRJbnQzMih0aGlzLmJiX3BvcytlKTp0LmV4cGVyaW1lbnRhbC5mYnMuTm9kZVR5cGUuUHJpbWl0aXZlfWV4ZWN1dGlvblByb3ZpZGVyVHlwZSh0KXtsZXQgZT10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDE4KTtyZXR1cm4gZT90aGlzLmJiLl9fc3RyaW5nKHRoaXMuYmJfcG9zK2UsdCk6bnVsbH1pbnB1dHModCxlKXtsZXQgbj10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDIwKTtyZXR1cm4gbj90aGlzLmJiLl9fc3RyaW5nKHRoaXMuYmIuX192ZWN0b3IodGhpcy5iYl9wb3MrbikrNCp0LGUpOm51bGx9aW5wdXRzTGVuZ3RoKCl7bGV0IHQ9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywyMCk7cmV0dXJuIHQ/dGhpcy5iYi5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MrdCk6MH1vdXRwdXRzKHQsZSl7bGV0IG49dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywyMik7cmV0dXJuIG4/dGhpcy5iYi5fX3N0cmluZyh0aGlzLmJiLl9fdmVjdG9yKHRoaXMuYmJfcG9zK24pKzQqdCxlKTpudWxsfW91dHB1dHNMZW5ndGgoKXtsZXQgdD10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDIyKTtyZXR1cm4gdD90aGlzLmJiLl9fdmVjdG9yX2xlbih0aGlzLmJiX3Bvcyt0KTowfWF0dHJpYnV0ZXMoZSxuKXtsZXQgcj10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDI0KTtyZXR1cm4gcj8obnx8bmV3IHQuZXhwZXJpbWVudGFsLmZicy5BdHRyaWJ1dGUpLl9faW5pdCh0aGlzLmJiLl9faW5kaXJlY3QodGhpcy5iYi5fX3ZlY3Rvcih0aGlzLmJiX3BvcytyKSs0KmUpLHRoaXMuYmIpOm51bGx9YXR0cmlidXRlc0xlbmd0aCgpe2xldCB0PXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsMjQpO3JldHVybiB0P3RoaXMuYmIuX192ZWN0b3JfbGVuKHRoaXMuYmJfcG9zK3QpOjB9aW5wdXRBcmdDb3VudHModCl7bGV0IGU9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywyNik7cmV0dXJuIGU/dGhpcy5iYi5yZWFkSW50MzIodGhpcy5iYi5fX3ZlY3Rvcih0aGlzLmJiX3BvcytlKSs0KnQpOjB9aW5wdXRBcmdDb3VudHNMZW5ndGgoKXtsZXQgdD10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDI2KTtyZXR1cm4gdD90aGlzLmJiLl9fdmVjdG9yX2xlbih0aGlzLmJiX3Bvcyt0KTowfWlucHV0QXJnQ291bnRzQXJyYXkoKXtsZXQgdD10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDI2KTtyZXR1cm4gdD9uZXcgSW50MzJBcnJheSh0aGlzLmJiLmJ5dGVzKCkuYnVmZmVyLHRoaXMuYmIuYnl0ZXMoKS5ieXRlT2Zmc2V0K3RoaXMuYmIuX192ZWN0b3IodGhpcy5iYl9wb3MrdCksdGhpcy5iYi5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MrdCkpOm51bGx9aW1wbGljaXRJbnB1dHModCxlKXtsZXQgbj10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDI4KTtyZXR1cm4gbj90aGlzLmJiLl9fc3RyaW5nKHRoaXMuYmIuX192ZWN0b3IodGhpcy5iYl9wb3MrbikrNCp0LGUpOm51bGx9aW1wbGljaXRJbnB1dHNMZW5ndGgoKXtsZXQgdD10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDI4KTtyZXR1cm4gdD90aGlzLmJiLl9fdmVjdG9yX2xlbih0aGlzLmJiX3Bvcyt0KTowfXN0YXRpYyBzdGFydE5vZGUodCl7dC5zdGFydE9iamVjdCgxMyl9c3RhdGljIGFkZE5hbWUodCxlKXt0LmFkZEZpZWxkT2Zmc2V0KDAsZSwwKX1zdGF0aWMgYWRkRG9jU3RyaW5nKHQsZSl7dC5hZGRGaWVsZE9mZnNldCgxLGUsMCl9c3RhdGljIGFkZERvbWFpbih0LGUpe3QuYWRkRmllbGRPZmZzZXQoMixlLDApfXN0YXRpYyBhZGRTaW5jZVZlcnNpb24odCxlKXt0LmFkZEZpZWxkSW50MzIoMyxlLDApfXN0YXRpYyBhZGRJbmRleCh0LGUpe3QuYWRkRmllbGRJbnQzMig0LGUsMCl9c3RhdGljIGFkZE9wVHlwZSh0LGUpe3QuYWRkRmllbGRPZmZzZXQoNSxlLDApfXN0YXRpYyBhZGRUeXBlKGUsbil7ZS5hZGRGaWVsZEludDMyKDYsbix0LmV4cGVyaW1lbnRhbC5mYnMuTm9kZVR5cGUuUHJpbWl0aXZlKX1zdGF0aWMgYWRkRXhlY3V0aW9uUHJvdmlkZXJUeXBlKHQsZSl7dC5hZGRGaWVsZE9mZnNldCg3LGUsMCl9c3RhdGljIGFkZElucHV0cyh0LGUpe3QuYWRkRmllbGRPZmZzZXQoOCxlLDApfXN0YXRpYyBjcmVhdGVJbnB1dHNWZWN0b3IodCxlKXt0LnN0YXJ0VmVjdG9yKDQsZS5sZW5ndGgsNCk7Zm9yKGxldCBuPWUubGVuZ3RoLTE7bj49MDtuLS0pdC5hZGRPZmZzZXQoZVtuXSk7cmV0dXJuIHQuZW5kVmVjdG9yKCl9c3RhdGljIHN0YXJ0SW5wdXRzVmVjdG9yKHQsZSl7dC5zdGFydFZlY3Rvcig0LGUsNCl9c3RhdGljIGFkZE91dHB1dHModCxlKXt0LmFkZEZpZWxkT2Zmc2V0KDksZSwwKX1zdGF0aWMgY3JlYXRlT3V0cHV0c1ZlY3Rvcih0LGUpe3Quc3RhcnRWZWN0b3IoNCxlLmxlbmd0aCw0KTtmb3IobGV0IG49ZS5sZW5ndGgtMTtuPj0wO24tLSl0LmFkZE9mZnNldChlW25dKTtyZXR1cm4gdC5lbmRWZWN0b3IoKX1zdGF0aWMgc3RhcnRPdXRwdXRzVmVjdG9yKHQsZSl7dC5zdGFydFZlY3Rvcig0LGUsNCl9c3RhdGljIGFkZEF0dHJpYnV0ZXModCxlKXt0LmFkZEZpZWxkT2Zmc2V0KDEwLGUsMCl9c3RhdGljIGNyZWF0ZUF0dHJpYnV0ZXNWZWN0b3IodCxlKXt0LnN0YXJ0VmVjdG9yKDQsZS5sZW5ndGgsNCk7Zm9yKGxldCBuPWUubGVuZ3RoLTE7bj49MDtuLS0pdC5hZGRPZmZzZXQoZVtuXSk7cmV0dXJuIHQuZW5kVmVjdG9yKCl9c3RhdGljIHN0YXJ0QXR0cmlidXRlc1ZlY3Rvcih0LGUpe3Quc3RhcnRWZWN0b3IoNCxlLDQpfXN0YXRpYyBhZGRJbnB1dEFyZ0NvdW50cyh0LGUpe3QuYWRkRmllbGRPZmZzZXQoMTEsZSwwKX1zdGF0aWMgY3JlYXRlSW5wdXRBcmdDb3VudHNWZWN0b3IodCxlKXt0LnN0YXJ0VmVjdG9yKDQsZS5sZW5ndGgsNCk7Zm9yKGxldCBuPWUubGVuZ3RoLTE7bj49MDtuLS0pdC5hZGRJbnQzMihlW25dKTtyZXR1cm4gdC5lbmRWZWN0b3IoKX1zdGF0aWMgc3RhcnRJbnB1dEFyZ0NvdW50c1ZlY3Rvcih0LGUpe3Quc3RhcnRWZWN0b3IoNCxlLDQpfXN0YXRpYyBhZGRJbXBsaWNpdElucHV0cyh0LGUpe3QuYWRkRmllbGRPZmZzZXQoMTIsZSwwKX1zdGF0aWMgY3JlYXRlSW1wbGljaXRJbnB1dHNWZWN0b3IodCxlKXt0LnN0YXJ0VmVjdG9yKDQsZS5sZW5ndGgsNCk7Zm9yKGxldCBuPWUubGVuZ3RoLTE7bj49MDtuLS0pdC5hZGRPZmZzZXQoZVtuXSk7cmV0dXJuIHQuZW5kVmVjdG9yKCl9c3RhdGljIHN0YXJ0SW1wbGljaXRJbnB1dHNWZWN0b3IodCxlKXt0LnN0YXJ0VmVjdG9yKDQsZSw0KX1zdGF0aWMgZW5kTm9kZSh0KXtyZXR1cm4gdC5lbmRPYmplY3QoKX1zdGF0aWMgY3JlYXRlTm9kZSh0LGUscixpLG8sYSxzLHUsYyxsLHAsZixkLGgpe3JldHVybiBuLnN0YXJ0Tm9kZSh0KSxuLmFkZE5hbWUodCxlKSxuLmFkZERvY1N0cmluZyh0LHIpLG4uYWRkRG9tYWluKHQsaSksbi5hZGRTaW5jZVZlcnNpb24odCxvKSxuLmFkZEluZGV4KHQsYSksbi5hZGRPcFR5cGUodCxzKSxuLmFkZFR5cGUodCx1KSxuLmFkZEV4ZWN1dGlvblByb3ZpZGVyVHlwZSh0LGMpLG4uYWRkSW5wdXRzKHQsbCksbi5hZGRPdXRwdXRzKHQscCksbi5hZGRBdHRyaWJ1dGVzKHQsZiksbi5hZGRJbnB1dEFyZ0NvdW50cyh0LGQpLG4uYWRkSW1wbGljaXRJbnB1dHModCxoKSxuLmVuZE5vZGUodCl9fWUuTm9kZT1ufShlLmZic3x8KGUuZmJzPXt9KSl9KHQuZXhwZXJpbWVudGFsfHwodC5leHBlcmltZW50YWw9e30pKX0oZS5vbm54cnVudGltZXx8KGUub25ueHJ1bnRpbWU9e30pKSxmdW5jdGlvbih0KXshZnVuY3Rpb24oZSl7IWZ1bmN0aW9uKGUpe2NsYXNzIG57Y29uc3RydWN0b3IoKXt0aGlzLmJiPW51bGwsdGhpcy5iYl9wb3M9MH1fX2luaXQodCxlKXtyZXR1cm4gdGhpcy5iYl9wb3M9dCx0aGlzLmJiPWUsdGhpc31zdGF0aWMgZ2V0Um9vdEFzVmFsdWVJbmZvKHQsZSl7cmV0dXJuKGV8fG5ldyBuKS5fX2luaXQodC5yZWFkSW50MzIodC5wb3NpdGlvbigpKSt0LnBvc2l0aW9uKCksdCl9c3RhdGljIGdldFNpemVQcmVmaXhlZFJvb3RBc1ZhbHVlSW5mbyh0LGUpe3JldHVybiB0LnNldFBvc2l0aW9uKHQucG9zaXRpb24oKStyLmZsYXRidWZmZXJzLlNJWkVfUFJFRklYX0xFTkdUSCksKGV8fG5ldyBuKS5fX2luaXQodC5yZWFkSW50MzIodC5wb3NpdGlvbigpKSt0LnBvc2l0aW9uKCksdCl9bmFtZSh0KXtsZXQgZT10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDQpO3JldHVybiBlP3RoaXMuYmIuX19zdHJpbmcodGhpcy5iYl9wb3MrZSx0KTpudWxsfWRvY1N0cmluZyh0KXtsZXQgZT10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDYpO3JldHVybiBlP3RoaXMuYmIuX19zdHJpbmcodGhpcy5iYl9wb3MrZSx0KTpudWxsfXR5cGUoZSl7bGV0IG49dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw4KTtyZXR1cm4gbj8oZXx8bmV3IHQuZXhwZXJpbWVudGFsLmZicy5UeXBlSW5mbykuX19pbml0KHRoaXMuYmIuX19pbmRpcmVjdCh0aGlzLmJiX3BvcytuKSx0aGlzLmJiKTpudWxsfXN0YXRpYyBzdGFydFZhbHVlSW5mbyh0KXt0LnN0YXJ0T2JqZWN0KDMpfXN0YXRpYyBhZGROYW1lKHQsZSl7dC5hZGRGaWVsZE9mZnNldCgwLGUsMCl9c3RhdGljIGFkZERvY1N0cmluZyh0LGUpe3QuYWRkRmllbGRPZmZzZXQoMSxlLDApfXN0YXRpYyBhZGRUeXBlKHQsZSl7dC5hZGRGaWVsZE9mZnNldCgyLGUsMCl9c3RhdGljIGVuZFZhbHVlSW5mbyh0KXtyZXR1cm4gdC5lbmRPYmplY3QoKX1zdGF0aWMgY3JlYXRlVmFsdWVJbmZvKHQsZSxyLGkpe3JldHVybiBuLnN0YXJ0VmFsdWVJbmZvKHQpLG4uYWRkTmFtZSh0LGUpLG4uYWRkRG9jU3RyaW5nKHQsciksbi5hZGRUeXBlKHQsaSksbi5lbmRWYWx1ZUluZm8odCl9fWUuVmFsdWVJbmZvPW59KGUuZmJzfHwoZS5mYnM9e30pKX0odC5leHBlcmltZW50YWx8fCh0LmV4cGVyaW1lbnRhbD17fSkpfShlLm9ubnhydW50aW1lfHwoZS5vbm54cnVudGltZT17fSkpLGZ1bmN0aW9uKHQpeyFmdW5jdGlvbihlKXshZnVuY3Rpb24oZSl7Y2xhc3Mgbntjb25zdHJ1Y3Rvcigpe3RoaXMuYmI9bnVsbCx0aGlzLmJiX3Bvcz0wfV9faW5pdCh0LGUpe3JldHVybiB0aGlzLmJiX3Bvcz10LHRoaXMuYmI9ZSx0aGlzfXN0YXRpYyBnZXRSb290QXNUeXBlSW5mbyh0LGUpe3JldHVybihlfHxuZXcgbikuX19pbml0KHQucmVhZEludDMyKHQucG9zaXRpb24oKSkrdC5wb3NpdGlvbigpLHQpfXN0YXRpYyBnZXRTaXplUHJlZml4ZWRSb290QXNUeXBlSW5mbyh0LGUpe3JldHVybiB0LnNldFBvc2l0aW9uKHQucG9zaXRpb24oKStyLmZsYXRidWZmZXJzLlNJWkVfUFJFRklYX0xFTkdUSCksKGV8fG5ldyBuKS5fX2luaXQodC5yZWFkSW50MzIodC5wb3NpdGlvbigpKSt0LnBvc2l0aW9uKCksdCl9ZGVub3RhdGlvbih0KXtsZXQgZT10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDQpO3JldHVybiBlP3RoaXMuYmIuX19zdHJpbmcodGhpcy5iYl9wb3MrZSx0KTpudWxsfXZhbHVlVHlwZSgpe2xldCBlPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNik7cmV0dXJuIGU/dGhpcy5iYi5yZWFkVWludDgodGhpcy5iYl9wb3MrZSk6dC5leHBlcmltZW50YWwuZmJzLlR5cGVJbmZvVmFsdWUuTk9ORX12YWx1ZSh0KXtsZXQgZT10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDgpO3JldHVybiBlP3RoaXMuYmIuX191bmlvbih0LHRoaXMuYmJfcG9zK2UpOm51bGx9c3RhdGljIHN0YXJ0VHlwZUluZm8odCl7dC5zdGFydE9iamVjdCgzKX1zdGF0aWMgYWRkRGVub3RhdGlvbih0LGUpe3QuYWRkRmllbGRPZmZzZXQoMCxlLDApfXN0YXRpYyBhZGRWYWx1ZVR5cGUoZSxuKXtlLmFkZEZpZWxkSW50OCgxLG4sdC5leHBlcmltZW50YWwuZmJzLlR5cGVJbmZvVmFsdWUuTk9ORSl9c3RhdGljIGFkZFZhbHVlKHQsZSl7dC5hZGRGaWVsZE9mZnNldCgyLGUsMCl9c3RhdGljIGVuZFR5cGVJbmZvKHQpe3JldHVybiB0LmVuZE9iamVjdCgpfXN0YXRpYyBjcmVhdGVUeXBlSW5mbyh0LGUscixpKXtyZXR1cm4gbi5zdGFydFR5cGVJbmZvKHQpLG4uYWRkRGVub3RhdGlvbih0LGUpLG4uYWRkVmFsdWVUeXBlKHQsciksbi5hZGRWYWx1ZSh0LGkpLG4uZW5kVHlwZUluZm8odCl9fWUuVHlwZUluZm89bn0oZS5mYnN8fChlLmZicz17fSkpfSh0LmV4cGVyaW1lbnRhbHx8KHQuZXhwZXJpbWVudGFsPXt9KSl9KGUub25ueHJ1bnRpbWV8fChlLm9ubnhydW50aW1lPXt9KSksZnVuY3Rpb24odCl7IWZ1bmN0aW9uKHQpeyFmdW5jdGlvbih0KXtjbGFzcyBle2NvbnN0cnVjdG9yKCl7dGhpcy5iYj1udWxsLHRoaXMuYmJfcG9zPTB9X19pbml0KHQsZSl7cmV0dXJuIHRoaXMuYmJfcG9zPXQsdGhpcy5iYj1lLHRoaXN9c3RhdGljIGdldFJvb3RBc09wZXJhdG9yU2V0SWQodCxuKXtyZXR1cm4obnx8bmV3IGUpLl9faW5pdCh0LnJlYWRJbnQzMih0LnBvc2l0aW9uKCkpK3QucG9zaXRpb24oKSx0KX1zdGF0aWMgZ2V0U2l6ZVByZWZpeGVkUm9vdEFzT3BlcmF0b3JTZXRJZCh0LG4pe3JldHVybiB0LnNldFBvc2l0aW9uKHQucG9zaXRpb24oKStyLmZsYXRidWZmZXJzLlNJWkVfUFJFRklYX0xFTkdUSCksKG58fG5ldyBlKS5fX2luaXQodC5yZWFkSW50MzIodC5wb3NpdGlvbigpKSt0LnBvc2l0aW9uKCksdCl9ZG9tYWluKHQpe2xldCBlPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNCk7cmV0dXJuIGU/dGhpcy5iYi5fX3N0cmluZyh0aGlzLmJiX3BvcytlLHQpOm51bGx9dmVyc2lvbigpe2xldCB0PXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNik7cmV0dXJuIHQ/dGhpcy5iYi5yZWFkSW50NjQodGhpcy5iYl9wb3MrdCk6dGhpcy5iYi5jcmVhdGVMb25nKDAsMCl9c3RhdGljIHN0YXJ0T3BlcmF0b3JTZXRJZCh0KXt0LnN0YXJ0T2JqZWN0KDIpfXN0YXRpYyBhZGREb21haW4odCxlKXt0LmFkZEZpZWxkT2Zmc2V0KDAsZSwwKX1zdGF0aWMgYWRkVmVyc2lvbih0LGUpe3QuYWRkRmllbGRJbnQ2NCgxLGUsdC5jcmVhdGVMb25nKDAsMCkpfXN0YXRpYyBlbmRPcGVyYXRvclNldElkKHQpe3JldHVybiB0LmVuZE9iamVjdCgpfXN0YXRpYyBjcmVhdGVPcGVyYXRvclNldElkKHQsbixyKXtyZXR1cm4gZS5zdGFydE9wZXJhdG9yU2V0SWQodCksZS5hZGREb21haW4odCxuKSxlLmFkZFZlcnNpb24odCxyKSxlLmVuZE9wZXJhdG9yU2V0SWQodCl9fXQuT3BlcmF0b3JTZXRJZD1lfSh0LmZic3x8KHQuZmJzPXt9KSl9KHQuZXhwZXJpbWVudGFsfHwodC5leHBlcmltZW50YWw9e30pKX0oZS5vbm54cnVudGltZXx8KGUub25ueHJ1bnRpbWU9e30pKSxmdW5jdGlvbih0KXshZnVuY3Rpb24oZSl7IWZ1bmN0aW9uKGUpe2NsYXNzIG57Y29uc3RydWN0b3IoKXt0aGlzLmJiPW51bGwsdGhpcy5iYl9wb3M9MH1fX2luaXQodCxlKXtyZXR1cm4gdGhpcy5iYl9wb3M9dCx0aGlzLmJiPWUsdGhpc31zdGF0aWMgZ2V0Um9vdEFzVGVuc29yKHQsZSl7cmV0dXJuKGV8fG5ldyBuKS5fX2luaXQodC5yZWFkSW50MzIodC5wb3NpdGlvbigpKSt0LnBvc2l0aW9uKCksdCl9c3RhdGljIGdldFNpemVQcmVmaXhlZFJvb3RBc1RlbnNvcih0LGUpe3JldHVybiB0LnNldFBvc2l0aW9uKHQucG9zaXRpb24oKStyLmZsYXRidWZmZXJzLlNJWkVfUFJFRklYX0xFTkdUSCksKGV8fG5ldyBuKS5fX2luaXQodC5yZWFkSW50MzIodC5wb3NpdGlvbigpKSt0LnBvc2l0aW9uKCksdCl9bmFtZSh0KXtsZXQgZT10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDQpO3JldHVybiBlP3RoaXMuYmIuX19zdHJpbmcodGhpcy5iYl9wb3MrZSx0KTpudWxsfWRvY1N0cmluZyh0KXtsZXQgZT10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDYpO3JldHVybiBlP3RoaXMuYmIuX19zdHJpbmcodGhpcy5iYl9wb3MrZSx0KTpudWxsfWRpbXModCl7bGV0IGU9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw4KTtyZXR1cm4gZT90aGlzLmJiLnJlYWRJbnQ2NCh0aGlzLmJiLl9fdmVjdG9yKHRoaXMuYmJfcG9zK2UpKzgqdCk6dGhpcy5iYi5jcmVhdGVMb25nKDAsMCl9ZGltc0xlbmd0aCgpe2xldCB0PXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsOCk7cmV0dXJuIHQ/dGhpcy5iYi5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MrdCk6MH1kYXRhVHlwZSgpe2xldCBlPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsMTApO3JldHVybiBlP3RoaXMuYmIucmVhZEludDMyKHRoaXMuYmJfcG9zK2UpOnQuZXhwZXJpbWVudGFsLmZicy5UZW5zb3JEYXRhVHlwZS5VTkRFRklORUR9cmF3RGF0YSh0KXtsZXQgZT10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDEyKTtyZXR1cm4gZT90aGlzLmJiLnJlYWRVaW50OCh0aGlzLmJiLl9fdmVjdG9yKHRoaXMuYmJfcG9zK2UpK3QpOjB9cmF3RGF0YUxlbmd0aCgpe2xldCB0PXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsMTIpO3JldHVybiB0P3RoaXMuYmIuX192ZWN0b3JfbGVuKHRoaXMuYmJfcG9zK3QpOjB9cmF3RGF0YUFycmF5KCl7bGV0IHQ9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywxMik7cmV0dXJuIHQ/bmV3IFVpbnQ4QXJyYXkodGhpcy5iYi5ieXRlcygpLmJ1ZmZlcix0aGlzLmJiLmJ5dGVzKCkuYnl0ZU9mZnNldCt0aGlzLmJiLl9fdmVjdG9yKHRoaXMuYmJfcG9zK3QpLHRoaXMuYmIuX192ZWN0b3JfbGVuKHRoaXMuYmJfcG9zK3QpKTpudWxsfXN0cmluZ0RhdGEodCxlKXtsZXQgbj10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDE0KTtyZXR1cm4gbj90aGlzLmJiLl9fc3RyaW5nKHRoaXMuYmIuX192ZWN0b3IodGhpcy5iYl9wb3MrbikrNCp0LGUpOm51bGx9c3RyaW5nRGF0YUxlbmd0aCgpe2xldCB0PXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsMTQpO3JldHVybiB0P3RoaXMuYmIuX192ZWN0b3JfbGVuKHRoaXMuYmJfcG9zK3QpOjB9c3RhdGljIHN0YXJ0VGVuc29yKHQpe3Quc3RhcnRPYmplY3QoNil9c3RhdGljIGFkZE5hbWUodCxlKXt0LmFkZEZpZWxkT2Zmc2V0KDAsZSwwKX1zdGF0aWMgYWRkRG9jU3RyaW5nKHQsZSl7dC5hZGRGaWVsZE9mZnNldCgxLGUsMCl9c3RhdGljIGFkZERpbXModCxlKXt0LmFkZEZpZWxkT2Zmc2V0KDIsZSwwKX1zdGF0aWMgY3JlYXRlRGltc1ZlY3Rvcih0LGUpe3Quc3RhcnRWZWN0b3IoOCxlLmxlbmd0aCw4KTtmb3IobGV0IG49ZS5sZW5ndGgtMTtuPj0wO24tLSl0LmFkZEludDY0KGVbbl0pO3JldHVybiB0LmVuZFZlY3RvcigpfXN0YXRpYyBzdGFydERpbXNWZWN0b3IodCxlKXt0LnN0YXJ0VmVjdG9yKDgsZSw4KX1zdGF0aWMgYWRkRGF0YVR5cGUoZSxuKXtlLmFkZEZpZWxkSW50MzIoMyxuLHQuZXhwZXJpbWVudGFsLmZicy5UZW5zb3JEYXRhVHlwZS5VTkRFRklORUQpfXN0YXRpYyBhZGRSYXdEYXRhKHQsZSl7dC5hZGRGaWVsZE9mZnNldCg0LGUsMCl9c3RhdGljIGNyZWF0ZVJhd0RhdGFWZWN0b3IodCxlKXt0LnN0YXJ0VmVjdG9yKDEsZS5sZW5ndGgsMSk7Zm9yKGxldCBuPWUubGVuZ3RoLTE7bj49MDtuLS0pdC5hZGRJbnQ4KGVbbl0pO3JldHVybiB0LmVuZFZlY3RvcigpfXN0YXRpYyBzdGFydFJhd0RhdGFWZWN0b3IodCxlKXt0LnN0YXJ0VmVjdG9yKDEsZSwxKX1zdGF0aWMgYWRkU3RyaW5nRGF0YSh0LGUpe3QuYWRkRmllbGRPZmZzZXQoNSxlLDApfXN0YXRpYyBjcmVhdGVTdHJpbmdEYXRhVmVjdG9yKHQsZSl7dC5zdGFydFZlY3Rvcig0LGUubGVuZ3RoLDQpO2ZvcihsZXQgbj1lLmxlbmd0aC0xO24+PTA7bi0tKXQuYWRkT2Zmc2V0KGVbbl0pO3JldHVybiB0LmVuZFZlY3RvcigpfXN0YXRpYyBzdGFydFN0cmluZ0RhdGFWZWN0b3IodCxlKXt0LnN0YXJ0VmVjdG9yKDQsZSw0KX1zdGF0aWMgZW5kVGVuc29yKHQpe3JldHVybiB0LmVuZE9iamVjdCgpfXN0YXRpYyBjcmVhdGVUZW5zb3IodCxlLHIsaSxvLGEscyl7cmV0dXJuIG4uc3RhcnRUZW5zb3IodCksbi5hZGROYW1lKHQsZSksbi5hZGREb2NTdHJpbmcodCxyKSxuLmFkZERpbXModCxpKSxuLmFkZERhdGFUeXBlKHQsbyksbi5hZGRSYXdEYXRhKHQsYSksbi5hZGRTdHJpbmdEYXRhKHQscyksbi5lbmRUZW5zb3IodCl9fWUuVGVuc29yPW59KGUuZmJzfHwoZS5mYnM9e30pKX0odC5leHBlcmltZW50YWx8fCh0LmV4cGVyaW1lbnRhbD17fSkpfShlLm9ubnhydW50aW1lfHwoZS5vbm54cnVudGltZT17fSkpLGZ1bmN0aW9uKHQpeyFmdW5jdGlvbihlKXshZnVuY3Rpb24oZSl7Y2xhc3Mgbntjb25zdHJ1Y3Rvcigpe3RoaXMuYmI9bnVsbCx0aGlzLmJiX3Bvcz0wfV9faW5pdCh0LGUpe3JldHVybiB0aGlzLmJiX3Bvcz10LHRoaXMuYmI9ZSx0aGlzfXN0YXRpYyBnZXRSb290QXNTcGFyc2VUZW5zb3IodCxlKXtyZXR1cm4oZXx8bmV3IG4pLl9faW5pdCh0LnJlYWRJbnQzMih0LnBvc2l0aW9uKCkpK3QucG9zaXRpb24oKSx0KX1zdGF0aWMgZ2V0U2l6ZVByZWZpeGVkUm9vdEFzU3BhcnNlVGVuc29yKHQsZSl7cmV0dXJuIHQuc2V0UG9zaXRpb24odC5wb3NpdGlvbigpK3IuZmxhdGJ1ZmZlcnMuU0laRV9QUkVGSVhfTEVOR1RIKSwoZXx8bmV3IG4pLl9faW5pdCh0LnJlYWRJbnQzMih0LnBvc2l0aW9uKCkpK3QucG9zaXRpb24oKSx0KX12YWx1ZXMoZSl7bGV0IG49dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw0KTtyZXR1cm4gbj8oZXx8bmV3IHQuZXhwZXJpbWVudGFsLmZicy5UZW5zb3IpLl9faW5pdCh0aGlzLmJiLl9faW5kaXJlY3QodGhpcy5iYl9wb3MrbiksdGhpcy5iYik6bnVsbH1pbmRpY2VzKGUpe2xldCBuPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNik7cmV0dXJuIG4/KGV8fG5ldyB0LmV4cGVyaW1lbnRhbC5mYnMuVGVuc29yKS5fX2luaXQodGhpcy5iYi5fX2luZGlyZWN0KHRoaXMuYmJfcG9zK24pLHRoaXMuYmIpOm51bGx9ZGltcyh0KXtsZXQgZT10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDgpO3JldHVybiBlP3RoaXMuYmIucmVhZEludDY0KHRoaXMuYmIuX192ZWN0b3IodGhpcy5iYl9wb3MrZSkrOCp0KTp0aGlzLmJiLmNyZWF0ZUxvbmcoMCwwKX1kaW1zTGVuZ3RoKCl7bGV0IHQ9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw4KTtyZXR1cm4gdD90aGlzLmJiLl9fdmVjdG9yX2xlbih0aGlzLmJiX3Bvcyt0KTowfXN0YXRpYyBzdGFydFNwYXJzZVRlbnNvcih0KXt0LnN0YXJ0T2JqZWN0KDMpfXN0YXRpYyBhZGRWYWx1ZXModCxlKXt0LmFkZEZpZWxkT2Zmc2V0KDAsZSwwKX1zdGF0aWMgYWRkSW5kaWNlcyh0LGUpe3QuYWRkRmllbGRPZmZzZXQoMSxlLDApfXN0YXRpYyBhZGREaW1zKHQsZSl7dC5hZGRGaWVsZE9mZnNldCgyLGUsMCl9c3RhdGljIGNyZWF0ZURpbXNWZWN0b3IodCxlKXt0LnN0YXJ0VmVjdG9yKDgsZS5sZW5ndGgsOCk7Zm9yKGxldCBuPWUubGVuZ3RoLTE7bj49MDtuLS0pdC5hZGRJbnQ2NChlW25dKTtyZXR1cm4gdC5lbmRWZWN0b3IoKX1zdGF0aWMgc3RhcnREaW1zVmVjdG9yKHQsZSl7dC5zdGFydFZlY3Rvcig4LGUsOCl9c3RhdGljIGVuZFNwYXJzZVRlbnNvcih0KXtyZXR1cm4gdC5lbmRPYmplY3QoKX1zdGF0aWMgY3JlYXRlU3BhcnNlVGVuc29yKHQsZSxyLGkpe3JldHVybiBuLnN0YXJ0U3BhcnNlVGVuc29yKHQpLG4uYWRkVmFsdWVzKHQsZSksbi5hZGRJbmRpY2VzKHQsciksbi5hZGREaW1zKHQsaSksbi5lbmRTcGFyc2VUZW5zb3IodCl9fWUuU3BhcnNlVGVuc29yPW59KGUuZmJzfHwoZS5mYnM9e30pKX0odC5leHBlcmltZW50YWx8fCh0LmV4cGVyaW1lbnRhbD17fSkpfShlLm9ubnhydW50aW1lfHwoZS5vbm54cnVudGltZT17fSkpLGZ1bmN0aW9uKHQpeyFmdW5jdGlvbihlKXshZnVuY3Rpb24oZSl7Y2xhc3Mgbntjb25zdHJ1Y3Rvcigpe3RoaXMuYmI9bnVsbCx0aGlzLmJiX3Bvcz0wfV9faW5pdCh0LGUpe3JldHVybiB0aGlzLmJiX3Bvcz10LHRoaXMuYmI9ZSx0aGlzfXN0YXRpYyBnZXRSb290QXNBdHRyaWJ1dGUodCxlKXtyZXR1cm4oZXx8bmV3IG4pLl9faW5pdCh0LnJlYWRJbnQzMih0LnBvc2l0aW9uKCkpK3QucG9zaXRpb24oKSx0KX1zdGF0aWMgZ2V0U2l6ZVByZWZpeGVkUm9vdEFzQXR0cmlidXRlKHQsZSl7cmV0dXJuIHQuc2V0UG9zaXRpb24odC5wb3NpdGlvbigpK3IuZmxhdGJ1ZmZlcnMuU0laRV9QUkVGSVhfTEVOR1RIKSwoZXx8bmV3IG4pLl9faW5pdCh0LnJlYWRJbnQzMih0LnBvc2l0aW9uKCkpK3QucG9zaXRpb24oKSx0KX1uYW1lKHQpe2xldCBlPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNCk7cmV0dXJuIGU/dGhpcy5iYi5fX3N0cmluZyh0aGlzLmJiX3BvcytlLHQpOm51bGx9ZG9jU3RyaW5nKHQpe2xldCBlPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNik7cmV0dXJuIGU/dGhpcy5iYi5fX3N0cmluZyh0aGlzLmJiX3BvcytlLHQpOm51bGx9dHlwZSgpe2xldCBlPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsOCk7cmV0dXJuIGU/dGhpcy5iYi5yZWFkSW50MzIodGhpcy5iYl9wb3MrZSk6dC5leHBlcmltZW50YWwuZmJzLkF0dHJpYnV0ZVR5cGUuVU5ERUZJTkVEfWYoKXtsZXQgdD10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDEwKTtyZXR1cm4gdD90aGlzLmJiLnJlYWRGbG9hdDMyKHRoaXMuYmJfcG9zK3QpOjB9aSgpe2xldCB0PXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsMTIpO3JldHVybiB0P3RoaXMuYmIucmVhZEludDY0KHRoaXMuYmJfcG9zK3QpOnRoaXMuYmIuY3JlYXRlTG9uZygwLDApfXModCl7bGV0IGU9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywxNCk7cmV0dXJuIGU/dGhpcy5iYi5fX3N0cmluZyh0aGlzLmJiX3BvcytlLHQpOm51bGx9dChlKXtsZXQgbj10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDE2KTtyZXR1cm4gbj8oZXx8bmV3IHQuZXhwZXJpbWVudGFsLmZicy5UZW5zb3IpLl9faW5pdCh0aGlzLmJiLl9faW5kaXJlY3QodGhpcy5iYl9wb3MrbiksdGhpcy5iYik6bnVsbH1nKGUpe2xldCBuPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsMTgpO3JldHVybiBuPyhlfHxuZXcgdC5leHBlcmltZW50YWwuZmJzLkdyYXBoKS5fX2luaXQodGhpcy5iYi5fX2luZGlyZWN0KHRoaXMuYmJfcG9zK24pLHRoaXMuYmIpOm51bGx9ZmxvYXRzKHQpe2xldCBlPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsMjApO3JldHVybiBlP3RoaXMuYmIucmVhZEZsb2F0MzIodGhpcy5iYi5fX3ZlY3Rvcih0aGlzLmJiX3BvcytlKSs0KnQpOjB9ZmxvYXRzTGVuZ3RoKCl7bGV0IHQ9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywyMCk7cmV0dXJuIHQ/dGhpcy5iYi5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MrdCk6MH1mbG9hdHNBcnJheSgpe2xldCB0PXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsMjApO3JldHVybiB0P25ldyBGbG9hdDMyQXJyYXkodGhpcy5iYi5ieXRlcygpLmJ1ZmZlcix0aGlzLmJiLmJ5dGVzKCkuYnl0ZU9mZnNldCt0aGlzLmJiLl9fdmVjdG9yKHRoaXMuYmJfcG9zK3QpLHRoaXMuYmIuX192ZWN0b3JfbGVuKHRoaXMuYmJfcG9zK3QpKTpudWxsfWludHModCl7bGV0IGU9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywyMik7cmV0dXJuIGU/dGhpcy5iYi5yZWFkSW50NjQodGhpcy5iYi5fX3ZlY3Rvcih0aGlzLmJiX3BvcytlKSs4KnQpOnRoaXMuYmIuY3JlYXRlTG9uZygwLDApfWludHNMZW5ndGgoKXtsZXQgdD10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDIyKTtyZXR1cm4gdD90aGlzLmJiLl9fdmVjdG9yX2xlbih0aGlzLmJiX3Bvcyt0KTowfXN0cmluZ3ModCxlKXtsZXQgbj10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDI0KTtyZXR1cm4gbj90aGlzLmJiLl9fc3RyaW5nKHRoaXMuYmIuX192ZWN0b3IodGhpcy5iYl9wb3MrbikrNCp0LGUpOm51bGx9c3RyaW5nc0xlbmd0aCgpe2xldCB0PXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsMjQpO3JldHVybiB0P3RoaXMuYmIuX192ZWN0b3JfbGVuKHRoaXMuYmJfcG9zK3QpOjB9dGVuc29ycyhlLG4pe2xldCByPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsMjYpO3JldHVybiByPyhufHxuZXcgdC5leHBlcmltZW50YWwuZmJzLlRlbnNvcikuX19pbml0KHRoaXMuYmIuX19pbmRpcmVjdCh0aGlzLmJiLl9fdmVjdG9yKHRoaXMuYmJfcG9zK3IpKzQqZSksdGhpcy5iYik6bnVsbH10ZW5zb3JzTGVuZ3RoKCl7bGV0IHQ9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywyNik7cmV0dXJuIHQ/dGhpcy5iYi5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MrdCk6MH1ncmFwaHMoZSxuKXtsZXQgcj10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDI4KTtyZXR1cm4gcj8obnx8bmV3IHQuZXhwZXJpbWVudGFsLmZicy5HcmFwaCkuX19pbml0KHRoaXMuYmIuX19pbmRpcmVjdCh0aGlzLmJiLl9fdmVjdG9yKHRoaXMuYmJfcG9zK3IpKzQqZSksdGhpcy5iYik6bnVsbH1ncmFwaHNMZW5ndGgoKXtsZXQgdD10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDI4KTtyZXR1cm4gdD90aGlzLmJiLl9fdmVjdG9yX2xlbih0aGlzLmJiX3Bvcyt0KTowfXN0YXRpYyBzdGFydEF0dHJpYnV0ZSh0KXt0LnN0YXJ0T2JqZWN0KDEzKX1zdGF0aWMgYWRkTmFtZSh0LGUpe3QuYWRkRmllbGRPZmZzZXQoMCxlLDApfXN0YXRpYyBhZGREb2NTdHJpbmcodCxlKXt0LmFkZEZpZWxkT2Zmc2V0KDEsZSwwKX1zdGF0aWMgYWRkVHlwZShlLG4pe2UuYWRkRmllbGRJbnQzMigyLG4sdC5leHBlcmltZW50YWwuZmJzLkF0dHJpYnV0ZVR5cGUuVU5ERUZJTkVEKX1zdGF0aWMgYWRkRih0LGUpe3QuYWRkRmllbGRGbG9hdDMyKDMsZSwwKX1zdGF0aWMgYWRkSSh0LGUpe3QuYWRkRmllbGRJbnQ2NCg0LGUsdC5jcmVhdGVMb25nKDAsMCkpfXN0YXRpYyBhZGRTKHQsZSl7dC5hZGRGaWVsZE9mZnNldCg1LGUsMCl9c3RhdGljIGFkZFQodCxlKXt0LmFkZEZpZWxkT2Zmc2V0KDYsZSwwKX1zdGF0aWMgYWRkRyh0LGUpe3QuYWRkRmllbGRPZmZzZXQoNyxlLDApfXN0YXRpYyBhZGRGbG9hdHModCxlKXt0LmFkZEZpZWxkT2Zmc2V0KDgsZSwwKX1zdGF0aWMgY3JlYXRlRmxvYXRzVmVjdG9yKHQsZSl7dC5zdGFydFZlY3Rvcig0LGUubGVuZ3RoLDQpO2ZvcihsZXQgbj1lLmxlbmd0aC0xO24+PTA7bi0tKXQuYWRkRmxvYXQzMihlW25dKTtyZXR1cm4gdC5lbmRWZWN0b3IoKX1zdGF0aWMgc3RhcnRGbG9hdHNWZWN0b3IodCxlKXt0LnN0YXJ0VmVjdG9yKDQsZSw0KX1zdGF0aWMgYWRkSW50cyh0LGUpe3QuYWRkRmllbGRPZmZzZXQoOSxlLDApfXN0YXRpYyBjcmVhdGVJbnRzVmVjdG9yKHQsZSl7dC5zdGFydFZlY3Rvcig4LGUubGVuZ3RoLDgpO2ZvcihsZXQgbj1lLmxlbmd0aC0xO24+PTA7bi0tKXQuYWRkSW50NjQoZVtuXSk7cmV0dXJuIHQuZW5kVmVjdG9yKCl9c3RhdGljIHN0YXJ0SW50c1ZlY3Rvcih0LGUpe3Quc3RhcnRWZWN0b3IoOCxlLDgpfXN0YXRpYyBhZGRTdHJpbmdzKHQsZSl7dC5hZGRGaWVsZE9mZnNldCgxMCxlLDApfXN0YXRpYyBjcmVhdGVTdHJpbmdzVmVjdG9yKHQsZSl7dC5zdGFydFZlY3Rvcig0LGUubGVuZ3RoLDQpO2ZvcihsZXQgbj1lLmxlbmd0aC0xO24+PTA7bi0tKXQuYWRkT2Zmc2V0KGVbbl0pO3JldHVybiB0LmVuZFZlY3RvcigpfXN0YXRpYyBzdGFydFN0cmluZ3NWZWN0b3IodCxlKXt0LnN0YXJ0VmVjdG9yKDQsZSw0KX1zdGF0aWMgYWRkVGVuc29ycyh0LGUpe3QuYWRkRmllbGRPZmZzZXQoMTEsZSwwKX1zdGF0aWMgY3JlYXRlVGVuc29yc1ZlY3Rvcih0LGUpe3Quc3RhcnRWZWN0b3IoNCxlLmxlbmd0aCw0KTtmb3IobGV0IG49ZS5sZW5ndGgtMTtuPj0wO24tLSl0LmFkZE9mZnNldChlW25dKTtyZXR1cm4gdC5lbmRWZWN0b3IoKX1zdGF0aWMgc3RhcnRUZW5zb3JzVmVjdG9yKHQsZSl7dC5zdGFydFZlY3Rvcig0LGUsNCl9c3RhdGljIGFkZEdyYXBocyh0LGUpe3QuYWRkRmllbGRPZmZzZXQoMTIsZSwwKX1zdGF0aWMgY3JlYXRlR3JhcGhzVmVjdG9yKHQsZSl7dC5zdGFydFZlY3Rvcig0LGUubGVuZ3RoLDQpO2ZvcihsZXQgbj1lLmxlbmd0aC0xO24+PTA7bi0tKXQuYWRkT2Zmc2V0KGVbbl0pO3JldHVybiB0LmVuZFZlY3RvcigpfXN0YXRpYyBzdGFydEdyYXBoc1ZlY3Rvcih0LGUpe3Quc3RhcnRWZWN0b3IoNCxlLDQpfXN0YXRpYyBlbmRBdHRyaWJ1dGUodCl7cmV0dXJuIHQuZW5kT2JqZWN0KCl9c3RhdGljIGNyZWF0ZUF0dHJpYnV0ZSh0LGUscixpLG8sYSxzLHUsYyxsLHAsZixkLGgpe3JldHVybiBuLnN0YXJ0QXR0cmlidXRlKHQpLG4uYWRkTmFtZSh0LGUpLG4uYWRkRG9jU3RyaW5nKHQsciksbi5hZGRUeXBlKHQsaSksbi5hZGRGKHQsbyksbi5hZGRJKHQsYSksbi5hZGRTKHQscyksbi5hZGRUKHQsdSksbi5hZGRHKHQsYyksbi5hZGRGbG9hdHModCxsKSxuLmFkZEludHModCxwKSxuLmFkZFN0cmluZ3ModCxmKSxuLmFkZFRlbnNvcnModCxkKSxuLmFkZEdyYXBocyh0LGgpLG4uZW5kQXR0cmlidXRlKHQpfX1lLkF0dHJpYnV0ZT1ufShlLmZic3x8KGUuZmJzPXt9KSl9KHQuZXhwZXJpbWVudGFsfHwodC5leHBlcmltZW50YWw9e30pKX0oZS5vbm54cnVudGltZXx8KGUub25ueHJ1bnRpbWU9e30pKSxmdW5jdGlvbih0KXshZnVuY3Rpb24oZSl7IWZ1bmN0aW9uKGUpe2NsYXNzIG57Y29uc3RydWN0b3IoKXt0aGlzLmJiPW51bGwsdGhpcy5iYl9wb3M9MH1fX2luaXQodCxlKXtyZXR1cm4gdGhpcy5iYl9wb3M9dCx0aGlzLmJiPWUsdGhpc31zdGF0aWMgZ2V0Um9vdEFzR3JhcGgodCxlKXtyZXR1cm4oZXx8bmV3IG4pLl9faW5pdCh0LnJlYWRJbnQzMih0LnBvc2l0aW9uKCkpK3QucG9zaXRpb24oKSx0KX1zdGF0aWMgZ2V0U2l6ZVByZWZpeGVkUm9vdEFzR3JhcGgodCxlKXtyZXR1cm4gdC5zZXRQb3NpdGlvbih0LnBvc2l0aW9uKCkrci5mbGF0YnVmZmVycy5TSVpFX1BSRUZJWF9MRU5HVEgpLChlfHxuZXcgbikuX19pbml0KHQucmVhZEludDMyKHQucG9zaXRpb24oKSkrdC5wb3NpdGlvbigpLHQpfWluaXRpYWxpemVycyhlLG4pe2xldCByPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNCk7cmV0dXJuIHI/KG58fG5ldyB0LmV4cGVyaW1lbnRhbC5mYnMuVGVuc29yKS5fX2luaXQodGhpcy5iYi5fX2luZGlyZWN0KHRoaXMuYmIuX192ZWN0b3IodGhpcy5iYl9wb3MrcikrNCplKSx0aGlzLmJiKTpudWxsfWluaXRpYWxpemVyc0xlbmd0aCgpe2xldCB0PXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNCk7cmV0dXJuIHQ/dGhpcy5iYi5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MrdCk6MH1ub2RlQXJncyhlLG4pe2xldCByPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNik7cmV0dXJuIHI/KG58fG5ldyB0LmV4cGVyaW1lbnRhbC5mYnMuVmFsdWVJbmZvKS5fX2luaXQodGhpcy5iYi5fX2luZGlyZWN0KHRoaXMuYmIuX192ZWN0b3IodGhpcy5iYl9wb3MrcikrNCplKSx0aGlzLmJiKTpudWxsfW5vZGVBcmdzTGVuZ3RoKCl7bGV0IHQ9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw2KTtyZXR1cm4gdD90aGlzLmJiLl9fdmVjdG9yX2xlbih0aGlzLmJiX3Bvcyt0KTowfW5vZGVzKGUsbil7bGV0IHI9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw4KTtyZXR1cm4gcj8obnx8bmV3IHQuZXhwZXJpbWVudGFsLmZicy5Ob2RlKS5fX2luaXQodGhpcy5iYi5fX2luZGlyZWN0KHRoaXMuYmIuX192ZWN0b3IodGhpcy5iYl9wb3MrcikrNCplKSx0aGlzLmJiKTpudWxsfW5vZGVzTGVuZ3RoKCl7bGV0IHQ9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw4KTtyZXR1cm4gdD90aGlzLmJiLl9fdmVjdG9yX2xlbih0aGlzLmJiX3Bvcyt0KTowfW1heE5vZGVJbmRleCgpe2xldCB0PXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsMTApO3JldHVybiB0P3RoaXMuYmIucmVhZFVpbnQzMih0aGlzLmJiX3Bvcyt0KTowfW5vZGVFZGdlcyhlLG4pe2xldCByPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsMTIpO3JldHVybiByPyhufHxuZXcgdC5leHBlcmltZW50YWwuZmJzLk5vZGVFZGdlKS5fX2luaXQodGhpcy5iYi5fX2luZGlyZWN0KHRoaXMuYmIuX192ZWN0b3IodGhpcy5iYl9wb3MrcikrNCplKSx0aGlzLmJiKTpudWxsfW5vZGVFZGdlc0xlbmd0aCgpe2xldCB0PXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsMTIpO3JldHVybiB0P3RoaXMuYmIuX192ZWN0b3JfbGVuKHRoaXMuYmJfcG9zK3QpOjB9aW5wdXRzKHQsZSl7bGV0IG49dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywxNCk7cmV0dXJuIG4/dGhpcy5iYi5fX3N0cmluZyh0aGlzLmJiLl9fdmVjdG9yKHRoaXMuYmJfcG9zK24pKzQqdCxlKTpudWxsfWlucHV0c0xlbmd0aCgpe2xldCB0PXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsMTQpO3JldHVybiB0P3RoaXMuYmIuX192ZWN0b3JfbGVuKHRoaXMuYmJfcG9zK3QpOjB9b3V0cHV0cyh0LGUpe2xldCBuPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsMTYpO3JldHVybiBuP3RoaXMuYmIuX19zdHJpbmcodGhpcy5iYi5fX3ZlY3Rvcih0aGlzLmJiX3BvcytuKSs0KnQsZSk6bnVsbH1vdXRwdXRzTGVuZ3RoKCl7bGV0IHQ9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywxNik7cmV0dXJuIHQ/dGhpcy5iYi5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MrdCk6MH1zcGFyc2VJbml0aWFsaXplcnMoZSxuKXtsZXQgcj10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDE4KTtyZXR1cm4gcj8obnx8bmV3IHQuZXhwZXJpbWVudGFsLmZicy5TcGFyc2VUZW5zb3IpLl9faW5pdCh0aGlzLmJiLl9faW5kaXJlY3QodGhpcy5iYi5fX3ZlY3Rvcih0aGlzLmJiX3BvcytyKSs0KmUpLHRoaXMuYmIpOm51bGx9c3BhcnNlSW5pdGlhbGl6ZXJzTGVuZ3RoKCl7bGV0IHQ9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywxOCk7cmV0dXJuIHQ/dGhpcy5iYi5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MrdCk6MH1zdGF0aWMgc3RhcnRHcmFwaCh0KXt0LnN0YXJ0T2JqZWN0KDgpfXN0YXRpYyBhZGRJbml0aWFsaXplcnModCxlKXt0LmFkZEZpZWxkT2Zmc2V0KDAsZSwwKX1zdGF0aWMgY3JlYXRlSW5pdGlhbGl6ZXJzVmVjdG9yKHQsZSl7dC5zdGFydFZlY3Rvcig0LGUubGVuZ3RoLDQpO2ZvcihsZXQgbj1lLmxlbmd0aC0xO24+PTA7bi0tKXQuYWRkT2Zmc2V0KGVbbl0pO3JldHVybiB0LmVuZFZlY3RvcigpfXN0YXRpYyBzdGFydEluaXRpYWxpemVyc1ZlY3Rvcih0LGUpe3Quc3RhcnRWZWN0b3IoNCxlLDQpfXN0YXRpYyBhZGROb2RlQXJncyh0LGUpe3QuYWRkRmllbGRPZmZzZXQoMSxlLDApfXN0YXRpYyBjcmVhdGVOb2RlQXJnc1ZlY3Rvcih0LGUpe3Quc3RhcnRWZWN0b3IoNCxlLmxlbmd0aCw0KTtmb3IobGV0IG49ZS5sZW5ndGgtMTtuPj0wO24tLSl0LmFkZE9mZnNldChlW25dKTtyZXR1cm4gdC5lbmRWZWN0b3IoKX1zdGF0aWMgc3RhcnROb2RlQXJnc1ZlY3Rvcih0LGUpe3Quc3RhcnRWZWN0b3IoNCxlLDQpfXN0YXRpYyBhZGROb2Rlcyh0LGUpe3QuYWRkRmllbGRPZmZzZXQoMixlLDApfXN0YXRpYyBjcmVhdGVOb2Rlc1ZlY3Rvcih0LGUpe3Quc3RhcnRWZWN0b3IoNCxlLmxlbmd0aCw0KTtmb3IobGV0IG49ZS5sZW5ndGgtMTtuPj0wO24tLSl0LmFkZE9mZnNldChlW25dKTtyZXR1cm4gdC5lbmRWZWN0b3IoKX1zdGF0aWMgc3RhcnROb2Rlc1ZlY3Rvcih0LGUpe3Quc3RhcnRWZWN0b3IoNCxlLDQpfXN0YXRpYyBhZGRNYXhOb2RlSW5kZXgodCxlKXt0LmFkZEZpZWxkSW50MzIoMyxlLDApfXN0YXRpYyBhZGROb2RlRWRnZXModCxlKXt0LmFkZEZpZWxkT2Zmc2V0KDQsZSwwKX1zdGF0aWMgY3JlYXRlTm9kZUVkZ2VzVmVjdG9yKHQsZSl7dC5zdGFydFZlY3Rvcig0LGUubGVuZ3RoLDQpO2ZvcihsZXQgbj1lLmxlbmd0aC0xO24+PTA7bi0tKXQuYWRkT2Zmc2V0KGVbbl0pO3JldHVybiB0LmVuZFZlY3RvcigpfXN0YXRpYyBzdGFydE5vZGVFZGdlc1ZlY3Rvcih0LGUpe3Quc3RhcnRWZWN0b3IoNCxlLDQpfXN0YXRpYyBhZGRJbnB1dHModCxlKXt0LmFkZEZpZWxkT2Zmc2V0KDUsZSwwKX1zdGF0aWMgY3JlYXRlSW5wdXRzVmVjdG9yKHQsZSl7dC5zdGFydFZlY3Rvcig0LGUubGVuZ3RoLDQpO2ZvcihsZXQgbj1lLmxlbmd0aC0xO24+PTA7bi0tKXQuYWRkT2Zmc2V0KGVbbl0pO3JldHVybiB0LmVuZFZlY3RvcigpfXN0YXRpYyBzdGFydElucHV0c1ZlY3Rvcih0LGUpe3Quc3RhcnRWZWN0b3IoNCxlLDQpfXN0YXRpYyBhZGRPdXRwdXRzKHQsZSl7dC5hZGRGaWVsZE9mZnNldCg2LGUsMCl9c3RhdGljIGNyZWF0ZU91dHB1dHNWZWN0b3IodCxlKXt0LnN0YXJ0VmVjdG9yKDQsZS5sZW5ndGgsNCk7Zm9yKGxldCBuPWUubGVuZ3RoLTE7bj49MDtuLS0pdC5hZGRPZmZzZXQoZVtuXSk7cmV0dXJuIHQuZW5kVmVjdG9yKCl9c3RhdGljIHN0YXJ0T3V0cHV0c1ZlY3Rvcih0LGUpe3Quc3RhcnRWZWN0b3IoNCxlLDQpfXN0YXRpYyBhZGRTcGFyc2VJbml0aWFsaXplcnModCxlKXt0LmFkZEZpZWxkT2Zmc2V0KDcsZSwwKX1zdGF0aWMgY3JlYXRlU3BhcnNlSW5pdGlhbGl6ZXJzVmVjdG9yKHQsZSl7dC5zdGFydFZlY3Rvcig0LGUubGVuZ3RoLDQpO2ZvcihsZXQgbj1lLmxlbmd0aC0xO24+PTA7bi0tKXQuYWRkT2Zmc2V0KGVbbl0pO3JldHVybiB0LmVuZFZlY3RvcigpfXN0YXRpYyBzdGFydFNwYXJzZUluaXRpYWxpemVyc1ZlY3Rvcih0LGUpe3Quc3RhcnRWZWN0b3IoNCxlLDQpfXN0YXRpYyBlbmRHcmFwaCh0KXtyZXR1cm4gdC5lbmRPYmplY3QoKX1zdGF0aWMgY3JlYXRlR3JhcGgodCxlLHIsaSxvLGEscyx1LGMpe3JldHVybiBuLnN0YXJ0R3JhcGgodCksbi5hZGRJbml0aWFsaXplcnModCxlKSxuLmFkZE5vZGVBcmdzKHQsciksbi5hZGROb2Rlcyh0LGkpLG4uYWRkTWF4Tm9kZUluZGV4KHQsbyksbi5hZGROb2RlRWRnZXModCxhKSxuLmFkZElucHV0cyh0LHMpLG4uYWRkT3V0cHV0cyh0LHUpLG4uYWRkU3BhcnNlSW5pdGlhbGl6ZXJzKHQsYyksbi5lbmRHcmFwaCh0KX19ZS5HcmFwaD1ufShlLmZic3x8KGUuZmJzPXt9KSl9KHQuZXhwZXJpbWVudGFsfHwodC5leHBlcmltZW50YWw9e30pKX0oZS5vbm54cnVudGltZXx8KGUub25ueHJ1bnRpbWU9e30pKSxmdW5jdGlvbih0KXshZnVuY3Rpb24oZSl7IWZ1bmN0aW9uKGUpe2NsYXNzIG57Y29uc3RydWN0b3IoKXt0aGlzLmJiPW51bGwsdGhpcy5iYl9wb3M9MH1fX2luaXQodCxlKXtyZXR1cm4gdGhpcy5iYl9wb3M9dCx0aGlzLmJiPWUsdGhpc31zdGF0aWMgZ2V0Um9vdEFzTW9kZWwodCxlKXtyZXR1cm4oZXx8bmV3IG4pLl9faW5pdCh0LnJlYWRJbnQzMih0LnBvc2l0aW9uKCkpK3QucG9zaXRpb24oKSx0KX1zdGF0aWMgZ2V0U2l6ZVByZWZpeGVkUm9vdEFzTW9kZWwodCxlKXtyZXR1cm4gdC5zZXRQb3NpdGlvbih0LnBvc2l0aW9uKCkrci5mbGF0YnVmZmVycy5TSVpFX1BSRUZJWF9MRU5HVEgpLChlfHxuZXcgbikuX19pbml0KHQucmVhZEludDMyKHQucG9zaXRpb24oKSkrdC5wb3NpdGlvbigpLHQpfWlyVmVyc2lvbigpe2xldCB0PXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNCk7cmV0dXJuIHQ/dGhpcy5iYi5yZWFkSW50NjQodGhpcy5iYl9wb3MrdCk6dGhpcy5iYi5jcmVhdGVMb25nKDAsMCl9b3BzZXRJbXBvcnQoZSxuKXtsZXQgcj10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDYpO3JldHVybiByPyhufHxuZXcgdC5leHBlcmltZW50YWwuZmJzLk9wZXJhdG9yU2V0SWQpLl9faW5pdCh0aGlzLmJiLl9faW5kaXJlY3QodGhpcy5iYi5fX3ZlY3Rvcih0aGlzLmJiX3BvcytyKSs0KmUpLHRoaXMuYmIpOm51bGx9b3BzZXRJbXBvcnRMZW5ndGgoKXtsZXQgdD10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDYpO3JldHVybiB0P3RoaXMuYmIuX192ZWN0b3JfbGVuKHRoaXMuYmJfcG9zK3QpOjB9cHJvZHVjZXJOYW1lKHQpe2xldCBlPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsOCk7cmV0dXJuIGU/dGhpcy5iYi5fX3N0cmluZyh0aGlzLmJiX3BvcytlLHQpOm51bGx9cHJvZHVjZXJWZXJzaW9uKHQpe2xldCBlPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsMTApO3JldHVybiBlP3RoaXMuYmIuX19zdHJpbmcodGhpcy5iYl9wb3MrZSx0KTpudWxsfWRvbWFpbih0KXtsZXQgZT10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDEyKTtyZXR1cm4gZT90aGlzLmJiLl9fc3RyaW5nKHRoaXMuYmJfcG9zK2UsdCk6bnVsbH1tb2RlbFZlcnNpb24oKXtsZXQgdD10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDE0KTtyZXR1cm4gdD90aGlzLmJiLnJlYWRJbnQ2NCh0aGlzLmJiX3Bvcyt0KTp0aGlzLmJiLmNyZWF0ZUxvbmcoMCwwKX1kb2NTdHJpbmcodCl7bGV0IGU9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywxNik7cmV0dXJuIGU/dGhpcy5iYi5fX3N0cmluZyh0aGlzLmJiX3BvcytlLHQpOm51bGx9Z3JhcGgoZSl7bGV0IG49dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywxOCk7cmV0dXJuIG4/KGV8fG5ldyB0LmV4cGVyaW1lbnRhbC5mYnMuR3JhcGgpLl9faW5pdCh0aGlzLmJiLl9faW5kaXJlY3QodGhpcy5iYl9wb3MrbiksdGhpcy5iYik6bnVsbH1ncmFwaERvY1N0cmluZyh0KXtsZXQgZT10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDIwKTtyZXR1cm4gZT90aGlzLmJiLl9fc3RyaW5nKHRoaXMuYmJfcG9zK2UsdCk6bnVsbH1zdGF0aWMgc3RhcnRNb2RlbCh0KXt0LnN0YXJ0T2JqZWN0KDkpfXN0YXRpYyBhZGRJclZlcnNpb24odCxlKXt0LmFkZEZpZWxkSW50NjQoMCxlLHQuY3JlYXRlTG9uZygwLDApKX1zdGF0aWMgYWRkT3BzZXRJbXBvcnQodCxlKXt0LmFkZEZpZWxkT2Zmc2V0KDEsZSwwKX1zdGF0aWMgY3JlYXRlT3BzZXRJbXBvcnRWZWN0b3IodCxlKXt0LnN0YXJ0VmVjdG9yKDQsZS5sZW5ndGgsNCk7Zm9yKGxldCBuPWUubGVuZ3RoLTE7bj49MDtuLS0pdC5hZGRPZmZzZXQoZVtuXSk7cmV0dXJuIHQuZW5kVmVjdG9yKCl9c3RhdGljIHN0YXJ0T3BzZXRJbXBvcnRWZWN0b3IodCxlKXt0LnN0YXJ0VmVjdG9yKDQsZSw0KX1zdGF0aWMgYWRkUHJvZHVjZXJOYW1lKHQsZSl7dC5hZGRGaWVsZE9mZnNldCgyLGUsMCl9c3RhdGljIGFkZFByb2R1Y2VyVmVyc2lvbih0LGUpe3QuYWRkRmllbGRPZmZzZXQoMyxlLDApfXN0YXRpYyBhZGREb21haW4odCxlKXt0LmFkZEZpZWxkT2Zmc2V0KDQsZSwwKX1zdGF0aWMgYWRkTW9kZWxWZXJzaW9uKHQsZSl7dC5hZGRGaWVsZEludDY0KDUsZSx0LmNyZWF0ZUxvbmcoMCwwKSl9c3RhdGljIGFkZERvY1N0cmluZyh0LGUpe3QuYWRkRmllbGRPZmZzZXQoNixlLDApfXN0YXRpYyBhZGRHcmFwaCh0LGUpe3QuYWRkRmllbGRPZmZzZXQoNyxlLDApfXN0YXRpYyBhZGRHcmFwaERvY1N0cmluZyh0LGUpe3QuYWRkRmllbGRPZmZzZXQoOCxlLDApfXN0YXRpYyBlbmRNb2RlbCh0KXtyZXR1cm4gdC5lbmRPYmplY3QoKX1zdGF0aWMgY3JlYXRlTW9kZWwodCxlLHIsaSxvLGEscyx1LGMsbCl7cmV0dXJuIG4uc3RhcnRNb2RlbCh0KSxuLmFkZElyVmVyc2lvbih0LGUpLG4uYWRkT3BzZXRJbXBvcnQodCxyKSxuLmFkZFByb2R1Y2VyTmFtZSh0LGkpLG4uYWRkUHJvZHVjZXJWZXJzaW9uKHQsbyksbi5hZGREb21haW4odCxhKSxuLmFkZE1vZGVsVmVyc2lvbih0LHMpLG4uYWRkRG9jU3RyaW5nKHQsdSksbi5hZGRHcmFwaCh0LGMpLG4uYWRkR3JhcGhEb2NTdHJpbmcodCxsKSxuLmVuZE1vZGVsKHQpfX1lLk1vZGVsPW59KGUuZmJzfHwoZS5mYnM9e30pKX0odC5leHBlcmltZW50YWx8fCh0LmV4cGVyaW1lbnRhbD17fSkpfShlLm9ubnhydW50aW1lfHwoZS5vbm54cnVudGltZT17fSkpLGZ1bmN0aW9uKHQpeyFmdW5jdGlvbih0KXshZnVuY3Rpb24odCl7Y2xhc3MgZXtjb25zdHJ1Y3Rvcigpe3RoaXMuYmI9bnVsbCx0aGlzLmJiX3Bvcz0wfV9faW5pdCh0LGUpe3JldHVybiB0aGlzLmJiX3Bvcz10LHRoaXMuYmI9ZSx0aGlzfXN0YXRpYyBnZXRSb290QXNLZXJuZWxDcmVhdGVJbmZvcyh0LG4pe3JldHVybihufHxuZXcgZSkuX19pbml0KHQucmVhZEludDMyKHQucG9zaXRpb24oKSkrdC5wb3NpdGlvbigpLHQpfXN0YXRpYyBnZXRTaXplUHJlZml4ZWRSb290QXNLZXJuZWxDcmVhdGVJbmZvcyh0LG4pe3JldHVybiB0LnNldFBvc2l0aW9uKHQucG9zaXRpb24oKStyLmZsYXRidWZmZXJzLlNJWkVfUFJFRklYX0xFTkdUSCksKG58fG5ldyBlKS5fX2luaXQodC5yZWFkSW50MzIodC5wb3NpdGlvbigpKSt0LnBvc2l0aW9uKCksdCl9bm9kZUluZGljZXModCl7bGV0IGU9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw0KTtyZXR1cm4gZT90aGlzLmJiLnJlYWRVaW50MzIodGhpcy5iYi5fX3ZlY3Rvcih0aGlzLmJiX3BvcytlKSs0KnQpOjB9bm9kZUluZGljZXNMZW5ndGgoKXtsZXQgdD10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDQpO3JldHVybiB0P3RoaXMuYmIuX192ZWN0b3JfbGVuKHRoaXMuYmJfcG9zK3QpOjB9bm9kZUluZGljZXNBcnJheSgpe2xldCB0PXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNCk7cmV0dXJuIHQ/bmV3IFVpbnQzMkFycmF5KHRoaXMuYmIuYnl0ZXMoKS5idWZmZXIsdGhpcy5iYi5ieXRlcygpLmJ5dGVPZmZzZXQrdGhpcy5iYi5fX3ZlY3Rvcih0aGlzLmJiX3Bvcyt0KSx0aGlzLmJiLl9fdmVjdG9yX2xlbih0aGlzLmJiX3Bvcyt0KSk6bnVsbH1rZXJuZWxEZWZIYXNoZXModCl7bGV0IGU9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw2KTtyZXR1cm4gZT90aGlzLmJiLnJlYWRVaW50NjQodGhpcy5iYi5fX3ZlY3Rvcih0aGlzLmJiX3BvcytlKSs4KnQpOnRoaXMuYmIuY3JlYXRlTG9uZygwLDApfWtlcm5lbERlZkhhc2hlc0xlbmd0aCgpe2xldCB0PXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNik7cmV0dXJuIHQ/dGhpcy5iYi5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MrdCk6MH1zdGF0aWMgc3RhcnRLZXJuZWxDcmVhdGVJbmZvcyh0KXt0LnN0YXJ0T2JqZWN0KDIpfXN0YXRpYyBhZGROb2RlSW5kaWNlcyh0LGUpe3QuYWRkRmllbGRPZmZzZXQoMCxlLDApfXN0YXRpYyBjcmVhdGVOb2RlSW5kaWNlc1ZlY3Rvcih0LGUpe3Quc3RhcnRWZWN0b3IoNCxlLmxlbmd0aCw0KTtmb3IobGV0IG49ZS5sZW5ndGgtMTtuPj0wO24tLSl0LmFkZEludDMyKGVbbl0pO3JldHVybiB0LmVuZFZlY3RvcigpfXN0YXRpYyBzdGFydE5vZGVJbmRpY2VzVmVjdG9yKHQsZSl7dC5zdGFydFZlY3Rvcig0LGUsNCl9c3RhdGljIGFkZEtlcm5lbERlZkhhc2hlcyh0LGUpe3QuYWRkRmllbGRPZmZzZXQoMSxlLDApfXN0YXRpYyBjcmVhdGVLZXJuZWxEZWZIYXNoZXNWZWN0b3IodCxlKXt0LnN0YXJ0VmVjdG9yKDgsZS5sZW5ndGgsOCk7Zm9yKGxldCBuPWUubGVuZ3RoLTE7bj49MDtuLS0pdC5hZGRJbnQ2NChlW25dKTtyZXR1cm4gdC5lbmRWZWN0b3IoKX1zdGF0aWMgc3RhcnRLZXJuZWxEZWZIYXNoZXNWZWN0b3IodCxlKXt0LnN0YXJ0VmVjdG9yKDgsZSw4KX1zdGF0aWMgZW5kS2VybmVsQ3JlYXRlSW5mb3ModCl7cmV0dXJuIHQuZW5kT2JqZWN0KCl9c3RhdGljIGNyZWF0ZUtlcm5lbENyZWF0ZUluZm9zKHQsbixyKXtyZXR1cm4gZS5zdGFydEtlcm5lbENyZWF0ZUluZm9zKHQpLGUuYWRkTm9kZUluZGljZXModCxuKSxlLmFkZEtlcm5lbERlZkhhc2hlcyh0LHIpLGUuZW5kS2VybmVsQ3JlYXRlSW5mb3ModCl9fXQuS2VybmVsQ3JlYXRlSW5mb3M9ZX0odC5mYnN8fCh0LmZicz17fSkpfSh0LmV4cGVyaW1lbnRhbHx8KHQuZXhwZXJpbWVudGFsPXt9KSl9KGUub25ueHJ1bnRpbWV8fChlLm9ubnhydW50aW1lPXt9KSksZnVuY3Rpb24odCl7IWZ1bmN0aW9uKGUpeyFmdW5jdGlvbihlKXtjbGFzcyBue2NvbnN0cnVjdG9yKCl7dGhpcy5iYj1udWxsLHRoaXMuYmJfcG9zPTB9X19pbml0KHQsZSl7cmV0dXJuIHRoaXMuYmJfcG9zPXQsdGhpcy5iYj1lLHRoaXN9c3RhdGljIGdldFJvb3RBc1N1YkdyYXBoU2Vzc2lvblN0YXRlKHQsZSl7cmV0dXJuKGV8fG5ldyBuKS5fX2luaXQodC5yZWFkSW50MzIodC5wb3NpdGlvbigpKSt0LnBvc2l0aW9uKCksdCl9c3RhdGljIGdldFNpemVQcmVmaXhlZFJvb3RBc1N1YkdyYXBoU2Vzc2lvblN0YXRlKHQsZSl7cmV0dXJuIHQuc2V0UG9zaXRpb24odC5wb3NpdGlvbigpK3IuZmxhdGJ1ZmZlcnMuU0laRV9QUkVGSVhfTEVOR1RIKSwoZXx8bmV3IG4pLl9faW5pdCh0LnJlYWRJbnQzMih0LnBvc2l0aW9uKCkpK3QucG9zaXRpb24oKSx0KX1ncmFwaElkKHQpe2xldCBlPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNCk7cmV0dXJuIGU/dGhpcy5iYi5fX3N0cmluZyh0aGlzLmJiX3BvcytlLHQpOm51bGx9c2Vzc2lvblN0YXRlKGUpe2xldCBuPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNik7cmV0dXJuIG4/KGV8fG5ldyB0LmV4cGVyaW1lbnRhbC5mYnMuU2Vzc2lvblN0YXRlKS5fX2luaXQodGhpcy5iYi5fX2luZGlyZWN0KHRoaXMuYmJfcG9zK24pLHRoaXMuYmIpOm51bGx9c3RhdGljIHN0YXJ0U3ViR3JhcGhTZXNzaW9uU3RhdGUodCl7dC5zdGFydE9iamVjdCgyKX1zdGF0aWMgYWRkR3JhcGhJZCh0LGUpe3QuYWRkRmllbGRPZmZzZXQoMCxlLDApfXN0YXRpYyBhZGRTZXNzaW9uU3RhdGUodCxlKXt0LmFkZEZpZWxkT2Zmc2V0KDEsZSwwKX1zdGF0aWMgZW5kU3ViR3JhcGhTZXNzaW9uU3RhdGUodCl7bGV0IGU9dC5lbmRPYmplY3QoKTtyZXR1cm4gdC5yZXF1aXJlZEZpZWxkKGUsNCksZX1zdGF0aWMgY3JlYXRlU3ViR3JhcGhTZXNzaW9uU3RhdGUodCxlLHIpe3JldHVybiBuLnN0YXJ0U3ViR3JhcGhTZXNzaW9uU3RhdGUodCksbi5hZGRHcmFwaElkKHQsZSksbi5hZGRTZXNzaW9uU3RhdGUodCxyKSxuLmVuZFN1YkdyYXBoU2Vzc2lvblN0YXRlKHQpfX1lLlN1YkdyYXBoU2Vzc2lvblN0YXRlPW59KGUuZmJzfHwoZS5mYnM9e30pKX0odC5leHBlcmltZW50YWx8fCh0LmV4cGVyaW1lbnRhbD17fSkpfShlLm9ubnhydW50aW1lfHwoZS5vbm54cnVudGltZT17fSkpLGZ1bmN0aW9uKHQpeyFmdW5jdGlvbihlKXshZnVuY3Rpb24oZSl7Y2xhc3Mgbntjb25zdHJ1Y3Rvcigpe3RoaXMuYmI9bnVsbCx0aGlzLmJiX3Bvcz0wfV9faW5pdCh0LGUpe3JldHVybiB0aGlzLmJiX3Bvcz10LHRoaXMuYmI9ZSx0aGlzfXN0YXRpYyBnZXRSb290QXNTZXNzaW9uU3RhdGUodCxlKXtyZXR1cm4oZXx8bmV3IG4pLl9faW5pdCh0LnJlYWRJbnQzMih0LnBvc2l0aW9uKCkpK3QucG9zaXRpb24oKSx0KX1zdGF0aWMgZ2V0U2l6ZVByZWZpeGVkUm9vdEFzU2Vzc2lvblN0YXRlKHQsZSl7cmV0dXJuIHQuc2V0UG9zaXRpb24odC5wb3NpdGlvbigpK3IuZmxhdGJ1ZmZlcnMuU0laRV9QUkVGSVhfTEVOR1RIKSwoZXx8bmV3IG4pLl9faW5pdCh0LnJlYWRJbnQzMih0LnBvc2l0aW9uKCkpK3QucG9zaXRpb24oKSx0KX1rZXJuZWxzKGUpe2xldCBuPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNCk7cmV0dXJuIG4/KGV8fG5ldyB0LmV4cGVyaW1lbnRhbC5mYnMuS2VybmVsQ3JlYXRlSW5mb3MpLl9faW5pdCh0aGlzLmJiLl9faW5kaXJlY3QodGhpcy5iYl9wb3MrbiksdGhpcy5iYik6bnVsbH1zdWJHcmFwaFNlc3Npb25TdGF0ZXMoZSxuKXtsZXQgcj10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDYpO3JldHVybiByPyhufHxuZXcgdC5leHBlcmltZW50YWwuZmJzLlN1YkdyYXBoU2Vzc2lvblN0YXRlKS5fX2luaXQodGhpcy5iYi5fX2luZGlyZWN0KHRoaXMuYmIuX192ZWN0b3IodGhpcy5iYl9wb3MrcikrNCplKSx0aGlzLmJiKTpudWxsfXN1YkdyYXBoU2Vzc2lvblN0YXRlc0xlbmd0aCgpe2xldCB0PXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNik7cmV0dXJuIHQ/dGhpcy5iYi5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MrdCk6MH1zdGF0aWMgc3RhcnRTZXNzaW9uU3RhdGUodCl7dC5zdGFydE9iamVjdCgyKX1zdGF0aWMgYWRkS2VybmVscyh0LGUpe3QuYWRkRmllbGRPZmZzZXQoMCxlLDApfXN0YXRpYyBhZGRTdWJHcmFwaFNlc3Npb25TdGF0ZXModCxlKXt0LmFkZEZpZWxkT2Zmc2V0KDEsZSwwKX1zdGF0aWMgY3JlYXRlU3ViR3JhcGhTZXNzaW9uU3RhdGVzVmVjdG9yKHQsZSl7dC5zdGFydFZlY3Rvcig0LGUubGVuZ3RoLDQpO2ZvcihsZXQgbj1lLmxlbmd0aC0xO24+PTA7bi0tKXQuYWRkT2Zmc2V0KGVbbl0pO3JldHVybiB0LmVuZFZlY3RvcigpfXN0YXRpYyBzdGFydFN1YkdyYXBoU2Vzc2lvblN0YXRlc1ZlY3Rvcih0LGUpe3Quc3RhcnRWZWN0b3IoNCxlLDQpfXN0YXRpYyBlbmRTZXNzaW9uU3RhdGUodCl7cmV0dXJuIHQuZW5kT2JqZWN0KCl9c3RhdGljIGNyZWF0ZVNlc3Npb25TdGF0ZSh0LGUscil7cmV0dXJuIG4uc3RhcnRTZXNzaW9uU3RhdGUodCksbi5hZGRLZXJuZWxzKHQsZSksbi5hZGRTdWJHcmFwaFNlc3Npb25TdGF0ZXModCxyKSxuLmVuZFNlc3Npb25TdGF0ZSh0KX19ZS5TZXNzaW9uU3RhdGU9bn0oZS5mYnN8fChlLmZicz17fSkpfSh0LmV4cGVyaW1lbnRhbHx8KHQuZXhwZXJpbWVudGFsPXt9KSl9KGUub25ueHJ1bnRpbWV8fChlLm9ubnhydW50aW1lPXt9KSksZnVuY3Rpb24odCl7IWZ1bmN0aW9uKGUpeyFmdW5jdGlvbihlKXtjbGFzcyBue2NvbnN0cnVjdG9yKCl7dGhpcy5iYj1udWxsLHRoaXMuYmJfcG9zPTB9X19pbml0KHQsZSl7cmV0dXJuIHRoaXMuYmJfcG9zPXQsdGhpcy5iYj1lLHRoaXN9c3RhdGljIGdldFJvb3RBc0luZmVyZW5jZVNlc3Npb24odCxlKXtyZXR1cm4oZXx8bmV3IG4pLl9faW5pdCh0LnJlYWRJbnQzMih0LnBvc2l0aW9uKCkpK3QucG9zaXRpb24oKSx0KX1zdGF0aWMgZ2V0U2l6ZVByZWZpeGVkUm9vdEFzSW5mZXJlbmNlU2Vzc2lvbih0LGUpe3JldHVybiB0LnNldFBvc2l0aW9uKHQucG9zaXRpb24oKStyLmZsYXRidWZmZXJzLlNJWkVfUFJFRklYX0xFTkdUSCksKGV8fG5ldyBuKS5fX2luaXQodC5yZWFkSW50MzIodC5wb3NpdGlvbigpKSt0LnBvc2l0aW9uKCksdCl9c3RhdGljIGJ1ZmZlckhhc0lkZW50aWZpZXIodCl7cmV0dXJuIHQuX19oYXNfaWRlbnRpZmllcihcIk9SVE1cIil9b3J0VmVyc2lvbih0KXtsZXQgZT10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDQpO3JldHVybiBlP3RoaXMuYmIuX19zdHJpbmcodGhpcy5iYl9wb3MrZSx0KTpudWxsfW1vZGVsKGUpe2xldCBuPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNik7cmV0dXJuIG4/KGV8fG5ldyB0LmV4cGVyaW1lbnRhbC5mYnMuTW9kZWwpLl9faW5pdCh0aGlzLmJiLl9faW5kaXJlY3QodGhpcy5iYl9wb3MrbiksdGhpcy5iYik6bnVsbH1zZXNzaW9uU3RhdGUoZSl7bGV0IG49dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw4KTtyZXR1cm4gbj8oZXx8bmV3IHQuZXhwZXJpbWVudGFsLmZicy5TZXNzaW9uU3RhdGUpLl9faW5pdCh0aGlzLmJiLl9faW5kaXJlY3QodGhpcy5iYl9wb3MrbiksdGhpcy5iYik6bnVsbH1zdGF0aWMgc3RhcnRJbmZlcmVuY2VTZXNzaW9uKHQpe3Quc3RhcnRPYmplY3QoMyl9c3RhdGljIGFkZE9ydFZlcnNpb24odCxlKXt0LmFkZEZpZWxkT2Zmc2V0KDAsZSwwKX1zdGF0aWMgYWRkTW9kZWwodCxlKXt0LmFkZEZpZWxkT2Zmc2V0KDEsZSwwKX1zdGF0aWMgYWRkU2Vzc2lvblN0YXRlKHQsZSl7dC5hZGRGaWVsZE9mZnNldCgyLGUsMCl9c3RhdGljIGVuZEluZmVyZW5jZVNlc3Npb24odCl7cmV0dXJuIHQuZW5kT2JqZWN0KCl9c3RhdGljIGZpbmlzaEluZmVyZW5jZVNlc3Npb25CdWZmZXIodCxlKXt0LmZpbmlzaChlLFwiT1JUTVwiKX1zdGF0aWMgZmluaXNoU2l6ZVByZWZpeGVkSW5mZXJlbmNlU2Vzc2lvbkJ1ZmZlcih0LGUpe3QuZmluaXNoKGUsXCJPUlRNXCIsITApfXN0YXRpYyBjcmVhdGVJbmZlcmVuY2VTZXNzaW9uKHQsZSxyLGkpe3JldHVybiBuLnN0YXJ0SW5mZXJlbmNlU2Vzc2lvbih0KSxuLmFkZE9ydFZlcnNpb24odCxlKSxuLmFkZE1vZGVsKHQsciksbi5hZGRTZXNzaW9uU3RhdGUodCxpKSxuLmVuZEluZmVyZW5jZVNlc3Npb24odCl9fWUuSW5mZXJlbmNlU2Vzc2lvbj1ufShlLmZic3x8KGUuZmJzPXt9KSl9KHQuZXhwZXJpbWVudGFsfHwodC5leHBlcmltZW50YWw9e30pKX0oZS5vbm54cnVudGltZXx8KGUub25ueHJ1bnRpbWU9e30pKX0sNzQ0ODoodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5Pbm54anNTZXNzaW9uSGFuZGxlcj12b2lkIDA7Y29uc3Qgcj1uKDYyMDcpLGk9big5MTYyKTtlLk9ubnhqc1Nlc3Npb25IYW5kbGVyPWNsYXNze2NvbnN0cnVjdG9yKHQpe3RoaXMuc2Vzc2lvbj10LHRoaXMuaW5wdXROYW1lcz10aGlzLnNlc3Npb24uaW5wdXROYW1lcyx0aGlzLm91dHB1dE5hbWVzPXRoaXMuc2Vzc2lvbi5vdXRwdXROYW1lc31hc3luYyBkaXNwb3NlKCl7fWFzeW5jIHJ1bih0LGUsbil7Y29uc3Qgbz1uZXcgTWFwO2Zvcihjb25zdCBlIGluIHQpaWYoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwodCxlKSl7Y29uc3Qgbj10W2VdO28uc2V0KGUsbmV3IGkuVGVuc29yKG4uZGltcyxuLnR5cGUsdm9pZCAwLHZvaWQgMCxuLmRhdGEpKX1jb25zdCBhPWF3YWl0IHRoaXMuc2Vzc2lvbi5ydW4obykscz17fTtyZXR1cm4gYS5mb3JFYWNoKCgodCxlKT0+e3NbZV09bmV3IHIuVGVuc29yKHQudHlwZSx0LmRhdGEsdC5kaW1zKX0pKSxzfXN0YXJ0UHJvZmlsaW5nKCl7dGhpcy5zZXNzaW9uLnN0YXJ0UHJvZmlsaW5nKCl9ZW5kUHJvZmlsaW5nKCl7dGhpcy5zZXNzaW9uLmVuZFByb2ZpbGluZygpfX19LDY5MTk6KHQsZSxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUuU2Vzc2lvbj12b2lkIDA7Y29uc3Qgcj1uKDYyMzEpLGk9big2NDY0KSxvPW4oNzA5MSksYT1uKDEwMzYpLHM9bigzNjk0KSx1PW4oMjY0NCk7ZS5TZXNzaW9uPWNsYXNze2NvbnN0cnVjdG9yKHQ9e30pe3RoaXMuX2luaXRpYWxpemVkPSExLHRoaXMuYmFja2VuZEhpbnQ9dC5iYWNrZW5kSGludCx0aGlzLnByb2ZpbGVyPXMuUHJvZmlsZXIuY3JlYXRlKHQucHJvZmlsZXIpLHRoaXMuY29udGV4dD17cHJvZmlsZXI6dGhpcy5wcm9maWxlcixncmFwaElucHV0VHlwZXM6W10sZ3JhcGhJbnB1dERpbXM6W119fWdldCBpbnB1dE5hbWVzKCl7cmV0dXJuIHRoaXMuX21vZGVsLmdyYXBoLmdldElucHV0TmFtZXMoKX1nZXQgb3V0cHV0TmFtZXMoKXtyZXR1cm4gdGhpcy5fbW9kZWwuZ3JhcGguZ2V0T3V0cHV0TmFtZXMoKX1zdGFydFByb2ZpbGluZygpe3RoaXMucHJvZmlsZXIuc3RhcnQoKX1lbmRQcm9maWxpbmcoKXt0aGlzLnByb2ZpbGVyLnN0b3AoKX1hc3luYyBsb2FkTW9kZWwodCxlLG4pe2F3YWl0IHRoaXMucHJvZmlsZXIuZXZlbnQoXCJzZXNzaW9uXCIsXCJTZXNzaW9uLmxvYWRNb2RlbFwiLChhc3luYygpPT57Y29uc3QgYT1hd2FpdCgwLG8ucmVzb2x2ZUJhY2tlbmQpKHRoaXMuYmFja2VuZEhpbnQpO2lmKHRoaXMuc2Vzc2lvbkhhbmRsZXI9YS5jcmVhdGVTZXNzaW9uSGFuZGxlcih0aGlzLmNvbnRleHQpLHRoaXMuX21vZGVsPW5ldyB1Lk1vZGVsLFwic3RyaW5nXCI9PXR5cGVvZiB0KXtjb25zdCBlPXQuZW5kc1dpdGgoXCIub3J0XCIpO2lmKFwidW5kZWZpbmVkXCI9PXR5cGVvZiBmZXRjaCl7Y29uc3Qgbj1hd2FpdCgwLGkucHJvbWlzaWZ5KShyLnJlYWRGaWxlKSh0KTt0aGlzLmluaXRpYWxpemUobixlKX1lbHNle2NvbnN0IG49YXdhaXQgZmV0Y2godCkscj1hd2FpdCBuLmFycmF5QnVmZmVyKCk7dGhpcy5pbml0aWFsaXplKG5ldyBVaW50OEFycmF5KHIpLGUpfX1lbHNlIGlmKEFycmF5QnVmZmVyLmlzVmlldyh0KSl0aGlzLmluaXRpYWxpemUodCk7ZWxzZXtjb25zdCByPW5ldyBVaW50OEFycmF5KHQsZXx8MCxufHx0LmJ5dGVMZW5ndGgpO3RoaXMuaW5pdGlhbGl6ZShyKX19KSl9aW5pdGlhbGl6ZSh0LGUpe2lmKHRoaXMuX2luaXRpYWxpemVkKXRocm93IG5ldyBFcnJvcihcImFscmVhZHkgaW5pdGlhbGl6ZWRcIik7dGhpcy5wcm9maWxlci5ldmVudChcInNlc3Npb25cIixcIlNlc3Npb24uaW5pdGlhbGl6ZVwiLCgoKT0+e2NvbnN0IG49dGhpcy5zZXNzaW9uSGFuZGxlci50cmFuc2Zvcm1HcmFwaD90aGlzLnNlc3Npb25IYW5kbGVyOnZvaWQgMDt0aGlzLl9tb2RlbC5sb2FkKHQsbixlKSx0aGlzLnNlc3Npb25IYW5kbGVyLm9uR3JhcGhJbml0aWFsaXplZCYmdGhpcy5zZXNzaW9uSGFuZGxlci5vbkdyYXBoSW5pdGlhbGl6ZWQodGhpcy5fbW9kZWwuZ3JhcGgpLHRoaXMuaW5pdGlhbGl6ZU9wcyh0aGlzLl9tb2RlbC5ncmFwaCksdGhpcy5fZXhlY3V0aW9uUGxhbj1uZXcgYS5FeGVjdXRpb25QbGFuKHRoaXMuX21vZGVsLmdyYXBoLHRoaXMuX29wcyx0aGlzLnByb2ZpbGVyKX0pKSx0aGlzLl9pbml0aWFsaXplZD0hMH1hc3luYyBydW4odCl7aWYoIXRoaXMuX2luaXRpYWxpemVkKXRocm93IG5ldyBFcnJvcihcInNlc3Npb24gbm90IGluaXRpYWxpemVkIHlldFwiKTtyZXR1cm4gdGhpcy5wcm9maWxlci5ldmVudChcInNlc3Npb25cIixcIlNlc3Npb24ucnVuXCIsKGFzeW5jKCk9Pntjb25zdCBlPXRoaXMubm9ybWFsaXplQW5kVmFsaWRhdGVJbnB1dHModCksbj1hd2FpdCB0aGlzLl9leGVjdXRpb25QbGFuLmV4ZWN1dGUodGhpcy5zZXNzaW9uSGFuZGxlcixlKTtyZXR1cm4gdGhpcy5jcmVhdGVPdXRwdXQobil9KSl9bm9ybWFsaXplQW5kVmFsaWRhdGVJbnB1dHModCl7Y29uc3QgZT10aGlzLl9tb2RlbC5ncmFwaC5nZXRJbnB1dE5hbWVzKCk7aWYoQXJyYXkuaXNBcnJheSh0KSl7aWYodC5sZW5ndGghPT1lLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoYGluY29ycmVjdCBpbnB1dCBhcnJheSBsZW5ndGg6IGV4cGVjdGVkICR7ZS5sZW5ndGh9IGJ1dCBnb3QgJHt0Lmxlbmd0aH1gKX1lbHNle2lmKHQuc2l6ZSE9PWUubGVuZ3RoKXRocm93IG5ldyBFcnJvcihgaW5jb3JyZWN0IGlucHV0IG1hcCBzaXplOiBleHBlY3RlZCAke2UubGVuZ3RofSBidXQgZ290ICR7dC5zaXplfWApO2NvbnN0IG49bmV3IEFycmF5KHQuc2l6ZSk7bGV0IHI9MDtmb3IobGV0IGk9MDtpPGUubGVuZ3RoOysraSl7Y29uc3Qgbz10LmdldChlW2ldKTtpZighbyl0aHJvdyBuZXcgRXJyb3IoYG1pc3NpbmcgaW5wdXQgdGVuc29yIGZvcjogJyR7bmFtZX0nYCk7bltyKytdPW99dD1ufWlmKHRoaXMuY29udGV4dC5ncmFwaElucHV0VHlwZXMmJjAhPT10aGlzLmNvbnRleHQuZ3JhcGhJbnB1dFR5cGVzLmxlbmd0aCYmdGhpcy5jb250ZXh0LmdyYXBoSW5wdXREaW1zJiYwIT09dGhpcy5jb250ZXh0LmdyYXBoSW5wdXREaW1zLmxlbmd0aCl0aGlzLnZhbGlkYXRlSW5wdXRUZW5zb3JEaW1zKHRoaXMuY29udGV4dC5ncmFwaElucHV0RGltcyx0LCExKTtlbHNle2NvbnN0IGU9dGhpcy5fbW9kZWwuZ3JhcGguZ2V0SW5wdXRJbmRpY2VzKCksbj10aGlzLl9tb2RlbC5ncmFwaC5nZXRWYWx1ZXMoKSxyPW5ldyBBcnJheShlLmxlbmd0aCk7Zm9yKGxldCBpPTA7aTxlLmxlbmd0aDsrK2kpe2NvbnN0IG89bltlW2ldXTtyW2ldPW8udHlwZS5zaGFwZS5kaW1zLHRoaXMuY29udGV4dC5ncmFwaElucHV0VHlwZXMucHVzaChvLnR5cGUudGVuc29yVHlwZSksdGhpcy5jb250ZXh0LmdyYXBoSW5wdXREaW1zLnB1c2godFtpXS5kaW1zKX10aGlzLnZhbGlkYXRlSW5wdXRUZW5zb3JEaW1zKHIsdCwhMCl9cmV0dXJuIHRoaXMudmFsaWRhdGVJbnB1dFRlbnNvclR5cGVzKHRoaXMuY29udGV4dC5ncmFwaElucHV0VHlwZXMsdCksdH12YWxpZGF0ZUlucHV0VGVuc29yVHlwZXModCxlKXtmb3IobGV0IG49MDtuPGUubGVuZ3RoO24rKyl7Y29uc3Qgcj10W25dLGk9ZVtuXS50eXBlO2lmKHIhPT1pKXRocm93IG5ldyBFcnJvcihgaW5wdXQgdGVuc29yWyR7bn1dIGNoZWNrIGZhaWxlZDogZXhwZWN0ZWQgdHlwZSAnJHtyfScgYnV0IGdvdCAke2l9YCl9fXZhbGlkYXRlSW5wdXRUZW5zb3JEaW1zKHQsZSxuKXtmb3IobGV0IHI9MDtyPGUubGVuZ3RoO3IrKyl7Y29uc3QgaT10W3JdLG89ZVtyXS5kaW1zO2lmKCF0aGlzLmNvbXBhcmVUZW5zb3JEaW1zKGksbyxuKSl0aHJvdyBuZXcgRXJyb3IoYGlucHV0IHRlbnNvclske3J9XSBjaGVjayBmYWlsZWQ6IGV4cGVjdGVkIHNoYXBlICdbJHtpLmpvaW4oXCIsXCIpfV0nIGJ1dCBnb3QgWyR7by5qb2luKFwiLFwiKX1dYCl9fWNvbXBhcmVUZW5zb3JEaW1zKHQsZSxuKXtpZih0Lmxlbmd0aCE9PWUubGVuZ3RoKXJldHVybiExO2ZvcihsZXQgcj0wO3I8dC5sZW5ndGg7KytyKWlmKHRbcl0hPT1lW3JdJiYoIW58fDAhPT10W3JdKSlyZXR1cm4hMTtyZXR1cm4hMH1jcmVhdGVPdXRwdXQodCl7Y29uc3QgZT10aGlzLl9tb2RlbC5ncmFwaC5nZXRPdXRwdXROYW1lcygpO2lmKHQubGVuZ3RoIT09ZS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiZXhwZWN0ZWQgbnVtYmVyIG9mIG91dHB1dHMgZG8gbm90IG1hdGNoIG51bWJlciBvZiBnZW5lcmF0ZWQgb3V0cHV0c1wiKTtjb25zdCBuPW5ldyBNYXA7Zm9yKGxldCByPTA7cjxlLmxlbmd0aDsrK3Ipbi5zZXQoZVtyXSx0W3JdKTtyZXR1cm4gbn1pbml0aWFsaXplT3BzKHQpe2NvbnN0IGU9dC5nZXROb2RlcygpO3RoaXMuX29wcz1uZXcgQXJyYXkoZS5sZW5ndGgpO2ZvcihsZXQgbj0wO248ZS5sZW5ndGg7bisrKXRoaXMuX29wc1tuXT10aGlzLnNlc3Npb25IYW5kbGVyLnJlc29sdmUoZVtuXSx0aGlzLl9tb2RlbC5vcHNldHMsdCl9fX0sOTE2MjpmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7dmFyIHI9dGhpcyYmdGhpcy5fX2ltcG9ydERlZmF1bHR8fGZ1bmN0aW9uKHQpe3JldHVybiB0JiZ0Ll9fZXNNb2R1bGU/dDp7ZGVmYXVsdDp0fX07T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5UZW5zb3I9dm9pZCAwO2NvbnN0IGk9bigzNDQyKSxvPXIobigzNzIwKSksYT1uKDE0NDYpLHM9big5Mzk1KSx1PW4oMjUxNyk7dmFyIGM9cy5vbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzO2NsYXNzIGx7Z2V0IGRhdGEoKXtpZih2b2lkIDA9PT10aGlzLmNhY2hlKXtjb25zdCB0PXRoaXMuZGF0YVByb3ZpZGVyKHRoaXMuZGF0YUlkKTtpZih0Lmxlbmd0aCE9PXRoaXMuc2l6ZSl0aHJvdyBuZXcgRXJyb3IoXCJMZW5ndGggb2YgZGF0YSBwcm92aWRlZCBieSB0aGUgRGF0YSBQcm92aWRlciBpcyBpbmNvbnNpc3RlbnQgd2l0aCB0aGUgZGltcyBvZiB0aGlzIFRlbnNvci5cIik7dGhpcy5jYWNoZT10fXJldHVybiB0aGlzLmNhY2hlfWdldCBzdHJpbmdEYXRhKCl7aWYoXCJzdHJpbmdcIiE9PXRoaXMudHlwZSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiZGF0YSB0eXBlIGlzIG5vdCBzdHJpbmdcIik7cmV0dXJuIHRoaXMuZGF0YX1nZXQgaW50ZWdlckRhdGEoKXtzd2l0Y2godGhpcy50eXBlKXtjYXNlXCJ1aW50OFwiOmNhc2VcImludDhcIjpjYXNlXCJ1aW50MTZcIjpjYXNlXCJpbnQxNlwiOmNhc2VcImludDMyXCI6Y2FzZVwidWludDMyXCI6Y2FzZVwiYm9vbFwiOnJldHVybiB0aGlzLmRhdGE7ZGVmYXVsdDp0aHJvdyBuZXcgVHlwZUVycm9yKFwiZGF0YSB0eXBlIGlzIG5vdCBpbnRlZ2VyICh1aW50OCwgaW50OCwgdWludDE2LCBpbnQxNiwgaW50MzIsIHVpbnQzMiwgYm9vbClcIil9fWdldCBmbG9hdERhdGEoKXtzd2l0Y2godGhpcy50eXBlKXtjYXNlXCJmbG9hdDMyXCI6Y2FzZVwiZmxvYXQ2NFwiOnJldHVybiB0aGlzLmRhdGE7ZGVmYXVsdDp0aHJvdyBuZXcgVHlwZUVycm9yKFwiZGF0YSB0eXBlIGlzIG5vdCBmbG9hdCAoZmxvYXQzMiwgZmxvYXQ2NClcIil9fWdldCBudW1iZXJEYXRhKCl7aWYoXCJzdHJpbmdcIiE9PXRoaXMudHlwZSlyZXR1cm4gdGhpcy5kYXRhO3Rocm93IG5ldyBUeXBlRXJyb3IoXCJ0eXBlIGNhbm5vdCBiZSBub24tbnVtYmVyIChzdHJpbmcpXCIpfWdldCh0KXtyZXR1cm4gdGhpcy5kYXRhW3UuU2hhcGVVdGlsLmluZGljZXNUb09mZnNldCh0LHRoaXMuc3RyaWRlcyldfXNldCh0LGUpe3RoaXMuZGF0YVt1LlNoYXBlVXRpbC5pbmRpY2VzVG9PZmZzZXQodCx0aGlzLnN0cmlkZXMpXT1lfWFzeW5jIGdldERhdGEoKXtyZXR1cm4gdm9pZCAwPT09dGhpcy5jYWNoZSYmKHRoaXMuY2FjaGU9YXdhaXQgdGhpcy5hc3luY0RhdGFQcm92aWRlcih0aGlzLmRhdGFJZCkpLHRoaXMuY2FjaGV9Z2V0IHN0cmlkZXMoKXtyZXR1cm4gdGhpcy5fc3RyaWRlc3x8KHRoaXMuX3N0cmlkZXM9dS5TaGFwZVV0aWwuY29tcHV0ZVN0cmlkZXModGhpcy5kaW1zKSksdGhpcy5fc3RyaWRlc31jb25zdHJ1Y3Rvcih0LGUsbixyLG8sYT1pLkd1aWQuY3JlYXRlKCkpe3RoaXMuZGltcz10LHRoaXMudHlwZT1lLHRoaXMuZGF0YVByb3ZpZGVyPW4sdGhpcy5hc3luY0RhdGFQcm92aWRlcj1yLHRoaXMuY2FjaGU9byx0aGlzLmRhdGFJZD1hLHRoaXMuc2l6ZT11LlNoYXBlVXRpbC52YWxpZGF0ZURpbXNBbmRDYWxjU2l6ZSh0KTtjb25zdCBzPXRoaXMuc2l6ZSxjPXZvaWQgMD09PW4mJnZvaWQgMD09PXImJnZvaWQgMD09PW87aWYodm9pZCAwIT09byYmby5sZW5ndGghPT1zKXRocm93IG5ldyBSYW5nZUVycm9yKFwiSW5wdXQgZGltcyBkb2Vzbid0IG1hdGNoIGRhdGEgbGVuZ3RoLlwiKTtpZihcInN0cmluZ1wiPT09ZSl7aWYoISh2b2lkIDA9PT1vfHxBcnJheS5pc0FycmF5KG8pJiZvLmV2ZXJ5KCh0PT5cInN0cmluZ1wiPT10eXBlb2YgdCkpKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiY2FjaGUgc2hvdWxkIGJlIGEgc3RyaW5nIGFycmF5XCIpO2MmJih0aGlzLmNhY2hlPW5ldyBBcnJheShzKSl9ZWxzZXtpZih2b2lkIDAhPT1vKXtjb25zdCB0PWYoZSk7aWYoIShvIGluc3RhbmNlb2YgdCkpdGhyb3cgbmV3IFR5cGVFcnJvcihgY2FjaGUgc2hvdWxkIGJlIHR5cGUgJHt0Lm5hbWV9YCl9aWYoYyl7Y29uc3QgdD1uZXcgQXJyYXlCdWZmZXIocypmdW5jdGlvbih0KXtzd2l0Y2godCl7Y2FzZVwiYm9vbFwiOmNhc2VcImludDhcIjpjYXNlXCJ1aW50OFwiOnJldHVybiAxO2Nhc2VcImludDE2XCI6Y2FzZVwidWludDE2XCI6cmV0dXJuIDI7Y2FzZVwiaW50MzJcIjpjYXNlXCJ1aW50MzJcIjpjYXNlXCJmbG9hdDMyXCI6cmV0dXJuIDQ7Y2FzZVwiZmxvYXQ2NFwiOnJldHVybiA4O2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBjYW5ub3QgY2FsY3VsYXRlIHNpemVvZigpIG9uIHR5cGUgJHt0fWApfX0oZSkpO3RoaXMuY2FjaGU9ZnVuY3Rpb24odCxlKXtyZXR1cm4gbmV3KGYoZSkpKHQpfSh0LGUpfX19c3RhdGljIGZyb21Qcm90byh0KXtpZighdCl0aHJvdyBuZXcgRXJyb3IoXCJjYW5ub3QgY29uc3RydWN0IFZhbHVlIGZyb20gYW4gZW1wdHkgdGVuc29yXCIpO2NvbnN0IGU9dS5Qcm90b1V0aWwudGVuc29yRGF0YVR5cGVGcm9tUHJvdG8odC5kYXRhVHlwZSksbj11LlByb3RvVXRpbC50ZW5zb3JEaW1zRnJvbVByb3RvKHQuZGltcykscj1uZXcgbChuLGUpO2lmKFwic3RyaW5nXCI9PT1lKXQuc3RyaW5nRGF0YS5mb3JFYWNoKCgodCxlKT0+e3IuZGF0YVtlXT0oMCx1LmRlY29kZVV0ZjhTdHJpbmcpKHQpfSkpO2Vsc2UgaWYodC5yYXdEYXRhJiZcIm51bWJlclwiPT10eXBlb2YgdC5yYXdEYXRhLmJ5dGVMZW5ndGgmJnQucmF3RGF0YS5ieXRlTGVuZ3RoPjApe2NvbnN0IGU9ci5kYXRhLG49bmV3IERhdGFWaWV3KHQucmF3RGF0YS5idWZmZXIsdC5yYXdEYXRhLmJ5dGVPZmZzZXQsdC5yYXdEYXRhLmJ5dGVMZW5ndGgpLGk9cCh0LmRhdGFUeXBlKSxvPXQucmF3RGF0YS5ieXRlTGVuZ3RoL2k7aWYodC5yYXdEYXRhLmJ5dGVMZW5ndGglaSE9MCl0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGJ1ZmZlciBsZW5ndGhcIik7aWYoZS5sZW5ndGghPT1vKXRocm93IG5ldyBFcnJvcihcImJ1ZmZlciBsZW5ndGggbWlzbWF0Y2hcIik7Zm9yKGxldCByPTA7cjxvO3IrKyl7Y29uc3Qgbz1oKG4sdC5kYXRhVHlwZSxyKmkpO2Vbcl09b319ZWxzZXtsZXQgZTtzd2l0Y2godC5kYXRhVHlwZSl7Y2FzZSBhLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuRkxPQVQ6ZT10LmZsb2F0RGF0YTticmVhaztjYXNlIGEub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5JTlQzMjpjYXNlIGEub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5JTlQxNjpjYXNlIGEub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5VSU5UMTY6Y2FzZSBhLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuSU5UODpjYXNlIGEub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5VSU5UODpjYXNlIGEub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5CT09MOmU9dC5pbnQzMkRhdGE7YnJlYWs7Y2FzZSBhLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuSU5UNjQ6ZT10LmludDY0RGF0YTticmVhaztjYXNlIGEub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5ET1VCTEU6ZT10LmRvdWJsZURhdGE7YnJlYWs7Y2FzZSBhLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuVUlOVDMyOmNhc2UgYS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLlVJTlQ2NDplPXQudWludDY0RGF0YTticmVhaztkZWZhdWx0OnRocm93IG5ldyBFcnJvcihcInVuc3BlY2lmaWMgZXJyb3JcIil9aWYobnVsbD09ZSl0aHJvdyBuZXcgRXJyb3IoXCJmYWlsZWQgdG8gcG9wdWxhdGUgZGF0YSBmcm9tIGEgdGVuc29ycHJvdG8gdmFsdWVcIik7Y29uc3Qgbj1yLmRhdGE7aWYobi5sZW5ndGghPT1lLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJhcnJheSBsZW5ndGggbWlzbWF0Y2hcIik7Zm9yKGxldCByPTA7cjxlLmxlbmd0aDtyKyspe2NvbnN0IGk9ZVtyXTtvLmRlZmF1bHQuaXNMb25nKGkpP25bcl09ZChpLHQuZGF0YVR5cGUpOm5bcl09aX19cmV0dXJuIHJ9c3RhdGljIGZyb21EYXRhKHQsZSxuKXtyZXR1cm4gbmV3IGwoZSxuLHZvaWQgMCx2b2lkIDAsdCl9c3RhdGljIGZyb21PcnRUZW5zb3IodCl7aWYoIXQpdGhyb3cgbmV3IEVycm9yKFwiY2Fubm90IGNvbnN0cnVjdCBWYWx1ZSBmcm9tIGFuIGVtcHR5IHRlbnNvclwiKTtjb25zdCBlPXUuUHJvdG9VdGlsLnRlbnNvckRpbXNGcm9tT1JURm9ybWF0KHQpLG49dS5Qcm90b1V0aWwudGVuc29yRGF0YVR5cGVGcm9tUHJvdG8odC5kYXRhVHlwZSgpKSxyPW5ldyBsKGUsbik7aWYoXCJzdHJpbmdcIj09PW4pZm9yKGxldCBlPTA7ZTx0LnN0cmluZ0RhdGFMZW5ndGgoKTtlKyspci5kYXRhW2VdPXQuc3RyaW5nRGF0YShlKTtlbHNlIGlmKHQucmF3RGF0YUFycmF5KCkmJlwibnVtYmVyXCI9PXR5cGVvZiB0LnJhd0RhdGFMZW5ndGgoKSYmdC5yYXdEYXRhTGVuZ3RoKCk+MCl7Y29uc3QgZT1yLmRhdGEsbj1uZXcgRGF0YVZpZXcodC5yYXdEYXRhQXJyYXkoKS5idWZmZXIsdC5yYXdEYXRhQXJyYXkoKS5ieXRlT2Zmc2V0LHQucmF3RGF0YUxlbmd0aCgpKSxpPXAodC5kYXRhVHlwZSgpKSxvPXQucmF3RGF0YUxlbmd0aCgpL2k7aWYodC5yYXdEYXRhTGVuZ3RoKCklaSE9MCl0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGJ1ZmZlciBsZW5ndGhcIik7aWYoZS5sZW5ndGghPT1vKXRocm93IG5ldyBFcnJvcihcImJ1ZmZlciBsZW5ndGggbWlzbWF0Y2hcIik7Zm9yKGxldCByPTA7cjxvO3IrKyl7Y29uc3Qgbz1oKG4sdC5kYXRhVHlwZSgpLHIqaSk7ZVtyXT1vfX1yZXR1cm4gcn19ZnVuY3Rpb24gcCh0KXtzd2l0Y2godCl7Y2FzZSBhLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuVUlOVDg6Y2FzZSBhLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuSU5UODpjYXNlIGEub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5CT09MOnJldHVybiAxO2Nhc2UgYS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLlVJTlQxNjpjYXNlIGEub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5JTlQxNjpyZXR1cm4gMjtjYXNlIGEub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5GTE9BVDpjYXNlIGEub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5JTlQzMjpjYXNlIGEub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5VSU5UMzI6cmV0dXJuIDQ7Y2FzZSBhLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuSU5UNjQ6Y2FzZSBhLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuRE9VQkxFOmNhc2UgYS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLlVJTlQ2NDpyZXR1cm4gODtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgY2Fubm90IGNhbGN1bGF0ZSBzaXplb2YoKSBvbiB0eXBlICR7YS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlW3RdfWApfX1mdW5jdGlvbiBmKHQpe3N3aXRjaCh0KXtjYXNlXCJib29sXCI6Y2FzZVwidWludDhcIjpyZXR1cm4gVWludDhBcnJheTtjYXNlXCJpbnQ4XCI6cmV0dXJuIEludDhBcnJheTtjYXNlXCJpbnQxNlwiOnJldHVybiBJbnQxNkFycmF5O2Nhc2VcInVpbnQxNlwiOnJldHVybiBVaW50MTZBcnJheTtjYXNlXCJpbnQzMlwiOnJldHVybiBJbnQzMkFycmF5O2Nhc2VcInVpbnQzMlwiOnJldHVybiBVaW50MzJBcnJheTtjYXNlXCJmbG9hdDMyXCI6cmV0dXJuIEZsb2F0MzJBcnJheTtjYXNlXCJmbG9hdDY0XCI6cmV0dXJuIEZsb2F0NjRBcnJheTtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihcInVuc3BlY2lmaWVkIGVycm9yXCIpfX1mdW5jdGlvbiBkKHQsZSl7aWYoZT09PWEub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5JTlQ2NHx8ZT09PWMuVGVuc29yRGF0YVR5cGUuSU5UNjQpe2lmKHQuZ3JlYXRlclRoYW5PckVxdWFsKDIxNDc0ODM2NDgpfHx0Lmxlc3NUaGFuKC0yMTQ3NDgzNjQ4KSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW50NjQgaXMgbm90IHN1cHBvcnRlZFwiKX1lbHNle2lmKGUhPT1hLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuVUlOVDMyJiZlIT09Yy5UZW5zb3JEYXRhVHlwZS5VSU5UMzImJmUhPT1hLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuVUlOVDY0JiZlIT09Yy5UZW5zb3JEYXRhVHlwZS5VSU5UNjQpdGhyb3cgbmV3IFR5cGVFcnJvcihgbm90IGEgTE9ORyB0eXBlOiAke2Eub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZVtlXX1gKTtpZih0LmdyZWF0ZXJUaGFuT3JFcXVhbCg0Mjk0OTY3Mjk2KXx8dC5sZXNzVGhhbigwKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwidWludDY0IGlzIG5vdCBzdXBwb3J0ZWRcIil9cmV0dXJuIHQudG9OdW1iZXIoKX1mdW5jdGlvbiBoKHQsZSxuKXtzd2l0Y2goZSl7Y2FzZSBhLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuQk9PTDpjYXNlIGEub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5VSU5UODpyZXR1cm4gdC5nZXRVaW50OChuKTtjYXNlIGEub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5JTlQ4OnJldHVybiB0LmdldEludDgobik7Y2FzZSBhLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuVUlOVDE2OnJldHVybiB0LmdldFVpbnQxNihuLCEwKTtjYXNlIGEub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5JTlQxNjpyZXR1cm4gdC5nZXRJbnQxNihuLCEwKTtjYXNlIGEub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5GTE9BVDpyZXR1cm4gdC5nZXRGbG9hdDMyKG4sITApO2Nhc2UgYS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLklOVDMyOnJldHVybiB0LmdldEludDMyKG4sITApO2Nhc2UgYS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLlVJTlQzMjpyZXR1cm4gdC5nZXRVaW50MzIobiwhMCk7Y2FzZSBhLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuSU5UNjQ6cmV0dXJuIGQoby5kZWZhdWx0LmZyb21CaXRzKHQuZ2V0VWludDMyKG4sITApLHQuZ2V0VWludDMyKG4rNCwhMCksITEpLGUpO2Nhc2UgYS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLkRPVUJMRTpyZXR1cm4gdC5nZXRGbG9hdDY0KG4sITApO2Nhc2UgYS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLlVJTlQ2NDpyZXR1cm4gZChvLmRlZmF1bHQuZnJvbUJpdHModC5nZXRVaW50MzIobiwhMCksdC5nZXRVaW50MzIobis0LCEwKSwhMCksZSk7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYGNhbm5vdCByZWFkIGZyb20gRGF0YVZpZXcgZm9yIHR5cGUgJHthLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGVbZV19YCl9fWUuVGVuc29yPWx9LDI1MTc6ZnVuY3Rpb24odCxlLG4pe1widXNlIHN0cmljdFwiO3ZhciByPXRoaXMmJnRoaXMuX19pbXBvcnREZWZhdWx0fHxmdW5jdGlvbih0KXtyZXR1cm4gdCYmdC5fX2VzTW9kdWxlP3Q6e2RlZmF1bHQ6dH19O09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUuZGVjb2RlVXRmOFN0cmluZz1lLk1BWF9DTElQPWUuTUlOX0NMSVA9ZS5Qb29sQ29udlV0aWw9ZS5SZWR1Y2VVdGlsPWUuU3BsaXRVdGlsPWUuTWF0aFV0aWw9ZS5TaGFwZVV0aWw9ZS5Mb25nVXRpbD1lLlByb3RvVXRpbD1lLkdlbW1VdGlsPWUuYXJyYXlDb3B5SGVscGVyPWUuQnJvYWRjYXN0VXRpbD1lLk1hdE11bFV0aWw9ZS5BcnJheVV0aWw9ZS5hc3NlcnQ9ZS5jaGVja0lucHV0c1NoYXBlPXZvaWQgMDtjb25zdCBpPW4oNTY4Niksbz1yKG4oMzcyMCkpLGE9bigxNDQ2KSxzPW4oOTE2Mik7ZS5jaGVja0lucHV0c1NoYXBlPWZ1bmN0aW9uKHQsLi4uZSl7aWYoIXR8fHQubGVuZ3RoIT09ZS5sZW5ndGgpcmV0dXJuITE7Zm9yKGxldCBuPTA7bjx0Lmxlbmd0aDtuKyspaWYoIXRbbl0uZGltc3x8dFtuXS5kaW1zLmxlbmd0aCE9PWVbbl0pcmV0dXJuITE7cmV0dXJuITB9LGUuYXNzZXJ0PWZ1bmN0aW9uKHQsZSl7aWYoIXQpdGhyb3cgbmV3IEVycm9yKFwic3RyaW5nXCI9PXR5cGVvZiBlP2U6ZSgpKX0sZS5BcnJheVV0aWw9Y2xhc3N7c3RhdGljIGFycmF5c0VxdWFsKHQsZSl7aWYodC5sZW5ndGghPT1lLmxlbmd0aClyZXR1cm4hMTtmb3IobGV0IG49MDtuPHQubGVuZ3RoO24rKylpZih0W25dIT09ZVtuXSlyZXR1cm4hMTtyZXR1cm4hMH19O2NsYXNzIHV7c3RhdGljIHByZXByb2Nlc3NJbnB1dFNoYXBlcyh0LGUpe3JldHVyblsxPT09dC5sZW5ndGg/WzEsdFswXV06dCwxPT09ZS5sZW5ndGg/W2VbMF0sMV06ZV19c3RhdGljIHBvc3Rwcm9jZXNzT3V0cHV0U2hhcGUodCxlLG4pezE9PT1lJiZ0LnNwbGljZSh0Lmxlbmd0aC0yLDEpLDE9PT1uJiZ0LnBvcCgpfXN0YXRpYyBjYWxjTWF0TXVsU2hhcGUodCxlKXtyZXR1cm4gdFsxXSE9PWVbMF0/dm9pZCAwOlt0WzBdLGVbMV1dfX1lLk1hdE11bFV0aWw9dTtjbGFzcyBje3N0YXRpYyBjYWxjU2hhcGUodCxlLG49ITEpe2NvbnN0IHI9dC5sZW5ndGgsaT1lLmxlbmd0aDtpZigwPT09cilyZXR1cm4gZTtpZigwPT09aSlyZXR1cm4gdDtjb25zdCBvPU1hdGgubWF4KHQubGVuZ3RoLGUubGVuZ3RoKSxhPW5ldyBBcnJheShvKTtpZihuKXtpZihyPDJ8fGk8MilyZXR1cm47Y29uc3Qgbj11LmNhbGNNYXRNdWxTaGFwZShbdFtyLTJdLHRbci0xXV0sW2VbaS0yXSxlW2ktMV1dKTtpZih2b2lkIDA9PT1uKXJldHVybjtbYVtvLTJdLGFbby0xXV09bn1mb3IobGV0IHM9bj8zOjE7czw9bztzKyspe2NvbnN0IG49ci1zPDA/MTp0W3Itc10sdT1pLXM8MD8xOmVbaS1zXTtpZihuIT09dSYmbj4xJiZ1PjEpcmV0dXJuO2Fbby1zXT1NYXRoLm1heChuLHUpfXJldHVybiBhfXN0YXRpYyBpbmRleCh0LGUpe2NvbnN0IG49bmV3IEFycmF5KGUubGVuZ3RoKTtyZXR1cm4gYy5maWxsSW5kZXgodCxlLG4pLG59c3RhdGljIGZpbGxJbmRleCh0LGUsbil7Y29uc3Qgcj10Lmxlbmd0aC1lLmxlbmd0aDtmb3IobGV0IGk9MDtpPGUubGVuZ3RoO2krKyluW2ldPXRbcitpXSVlW2ldfXN0YXRpYyBjYWxjKHQsZSxuLHIsaSl7Y29uc3Qgbz1jLmNhbGNTaGFwZSh0LmRpbXMsZS5kaW1zKTtpZihvKXtpZihyJiYhZi5hcmVFcXVhbChvLHQuZGltcykpcmV0dXJuO2NvbnN0IGE9Zi5zaXplKG8pLHU9cj90Om5ldyBzLlRlbnNvcihvLGl8fHQudHlwZSk7aWYoMD09PW8ubGVuZ3RoKXUuc2V0KFtdLG4odC5nZXQoW10pLGUuZ2V0KFtdKSkpO2Vsc2V7Y29uc3Qgcj1uZXcgQXJyYXkoby5sZW5ndGgpLGk9bmV3IEFycmF5KHQuZGltcy5sZW5ndGgpLHM9bmV3IEFycmF5KGUuZGltcy5sZW5ndGgpO2xldCBsLHA9MCxmPTAsZD0hMSxoPSExOzA9PT10LmRpbXMubGVuZ3RoJiYocD10LmdldChbXSksZD0hMCksMD09PWUuZGltcy5sZW5ndGgmJihmPWUuZ2V0KFtdKSxoPSEwKTtmb3IobGV0IGc9MDtnPGE7ZysrKXtsPWc7Zm9yKGxldCB0PW8ubGVuZ3RoLTE7dD49MDt0LS0pclt0XT1sJW9bdF0sbD1NYXRoLmZsb29yKGwvb1t0XSk7ZHx8KGMuZmlsbEluZGV4KHIsdC5kaW1zLGkpLHA9dC5nZXQoaSkpLGh8fChjLmZpbGxJbmRleChyLGUuZGltcyxzKSxmPWUuZ2V0KHMpKSx1LnNldChyLG4ocCxmKSl9fXJldHVybiB1fX1zdGF0aWMgaXNWYWxpZEJyb2FkY2FzdCh0LGUpe2NvbnN0IG49dC5sZW5ndGgscj1lLmxlbmd0aDtpZihuPnIpcmV0dXJuITE7Zm9yKGxldCBpPTE7aTw9bjtpKyspaWYoMSE9PXRbbi1pXSYmdFtuLWldIT09ZVtyLWldKXJldHVybiExO3JldHVybiEwfXN0YXRpYyBnZXRCcm9hZGNhc3REaW1zKHQsZSl7Y29uc3Qgbj10Lmxlbmd0aCxyPVtdO2ZvcihsZXQgaT0wO2k8bjtpKyspe2NvbnN0IG89bi0xLWksYT10W29dfHwxOyhlW2UubGVuZ3RoLTEtaV18fDEpPjEmJjE9PT1hJiZyLnVuc2hpZnQobyl9cmV0dXJuIHJ9fWUuQnJvYWRjYXN0VXRpbD1jLGUuYXJyYXlDb3B5SGVscGVyPWZ1bmN0aW9uKHQsZSxuLHIsaSl7aWYocjwwfHxyPj1lLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJzb3VyY2VJbmRleCBvdXQgb2YgYm91bmRzXCIpO2lmKG48MHx8bj49dC5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwidGFyZ2V0SW5kZXggb3V0IG9mIGJvdW5kc1wiKTtpZihyK2k+ZS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwic291cmNlIGluZGljZXMgdG8gYmUgY29waWVkIGFyZSBvdXRzaWRlIGJvdW5kc1wiKTtpZihuK2k+dC5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwidGFyZ2V0IGFycmF5IGlzIHRvbyBzbWFsbCB0byBob2xkIHJlc3VsdFwiKTtmb3IobGV0IG89MDtvPGk7bysrKXRbbitvXT1lW3Irb119LGUuR2VtbVV0aWw9Y2xhc3N7c3RhdGljIGdldFNoYXBlT2ZHZW1tUmVzdWx0KHQsZSxuLHIsaSl7aWYoMiE9PXQubGVuZ3RofHwyIT09bi5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwic2hhcGUgbmVlZCB0byBiZSBvZiBzaXplIDJcIik7bGV0IG8sYSxzO2U/KG89dFsxXSxhPXRbMF0pOihvPXRbMF0sYT10WzFdKTtsZXQgdT0tMTtpZihyPyhzPW5bMF0sdT0xKToocz1uWzFdLHU9MCksblt1XSE9PWEpdGhyb3cgbmV3IEVycm9yKFwiZGltZW5zaW9uIG1pc21hdGNoXCIpO2lmKG88PTB8fHM8PTB8fGE8PTApdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBzaGFwZSBzcGVjaWZpZWRcIik7aWYoaSYmIWMuaXNWYWxpZEJyb2FkY2FzdChpLFtvLHNdKSl0aHJvdyBuZXcgRXJyb3IoXCJnZW1tOiBpbnZhbGlkIGJpYXMgc2hhcGUgZm9yIGJyb2FkY2FzdFwiKTtyZXR1cm5bbyxzLGFdfX07Y2xhc3MgbHtzdGF0aWMgdGVuc29yRGF0YVR5cGVGcm9tUHJvdG8odCl7c3dpdGNoKHQpe2Nhc2UgYS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLklOVDg6cmV0dXJuXCJpbnQ4XCI7Y2FzZSBhLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuVUlOVDg6cmV0dXJuXCJ1aW50OFwiO2Nhc2UgYS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLkJPT0w6cmV0dXJuXCJib29sXCI7Y2FzZSBhLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuSU5UMTY6cmV0dXJuXCJpbnQxNlwiO2Nhc2UgYS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLlVJTlQxNjpyZXR1cm5cInVpbnQxNlwiO2Nhc2UgYS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLklOVDMyOnJldHVyblwiaW50MzJcIjtjYXNlIGEub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5VSU5UMzI6cmV0dXJuXCJ1aW50MzJcIjtjYXNlIGEub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5GTE9BVDpyZXR1cm5cImZsb2F0MzJcIjtjYXNlIGEub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5ET1VCTEU6cmV0dXJuXCJmbG9hdDY0XCI7Y2FzZSBhLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuU1RSSU5HOnJldHVyblwic3RyaW5nXCI7Y2FzZSBhLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuSU5UNjQ6cmV0dXJuXCJpbnQzMlwiO2Nhc2UgYS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLlVJTlQ2NDpyZXR1cm5cInVpbnQzMlwiO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCBkYXRhIHR5cGU6ICR7YS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlW3RdfWApfX1zdGF0aWMgdGVuc29yRGF0YVR5cGVTdHJpbmdUb0VudW0odCl7c3dpdGNoKHQpe2Nhc2VcImludDhcIjpyZXR1cm4gYS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLklOVDg7Y2FzZVwidWludDhcIjpyZXR1cm4gYS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLlVJTlQ4O2Nhc2VcImJvb2xcIjpyZXR1cm4gYS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLkJPT0w7Y2FzZVwiaW50MTZcIjpyZXR1cm4gYS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLklOVDE2O2Nhc2VcInVpbnQxNlwiOnJldHVybiBhLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuVUlOVDE2O2Nhc2VcImludDMyXCI6cmV0dXJuIGEub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5JTlQzMjtjYXNlXCJ1aW50MzJcIjpyZXR1cm4gYS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLlVJTlQzMjtjYXNlXCJmbG9hdDMyXCI6cmV0dXJuIGEub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5GTE9BVDtjYXNlXCJmbG9hdDY0XCI6cmV0dXJuIGEub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5ET1VCTEU7Y2FzZVwic3RyaW5nXCI6cmV0dXJuIGEub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5TVFJJTkc7Y2FzZVwiaW50NjRcIjpyZXR1cm4gYS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLklOVDY0O2Nhc2VcInVpbnQ2NFwiOnJldHVybiBhLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuVUlOVDY0O2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCBkYXRhIHR5cGU6ICR7dH1gKX19c3RhdGljIHRlbnNvckRpbXNGcm9tUHJvdG8odCl7cmV0dXJuIHQubWFwKCh0PT5vLmRlZmF1bHQuaXNMb25nKHQpP3QudG9OdW1iZXIoKTp0KSl9c3RhdGljIHRlbnNvclZhbHVlVHlwZUZyb21Qcm90byh0KXtyZXR1cm57dGVuc29yVHlwZTpsLnRlbnNvckRhdGFUeXBlRnJvbVByb3RvKHQuZWxlbVR5cGUpLHNoYXBlOntkaW1zOmwudGVuc29yRGltc0Zyb21Qcm90byh0LnNoYXBlLmRpbS5tYXAoKHQ9PnQuZGltVmFsdWUpKSl9fX1zdGF0aWMgdGVuc29yRGltc0Zyb21PUlRGb3JtYXQodCl7Y29uc3QgZT1bXTtmb3IobGV0IG49MDtuPHQuZGltc0xlbmd0aCgpO24rKyllLnB1c2gocC5sb25nVG9OdW1iZXIodC5kaW1zKG4pKSk7cmV0dXJuIGV9c3RhdGljIHRlbnNvckF0dHJpYnV0ZXNGcm9tT1JURm9ybWF0KHQpe2NvbnN0IGU9W107Zm9yKGxldCBuPTA7bjx0LmF0dHJpYnV0ZXNMZW5ndGgoKTtuKyspZS5wdXNoKHQuYXR0cmlidXRlcyhuKSk7cmV0dXJuIGV9fWUuUHJvdG9VdGlsPWw7Y2xhc3MgcHtzdGF0aWMgbG9uZ1RvTnVtYmVyKHQsZSl7cmV0dXJuIG8uZGVmYXVsdC5pc0xvbmcodCk/dC50b051bWJlcigpOnQgaW5zdGFuY2VvZiBpLmZsYXRidWZmZXJzLkxvbmc/by5kZWZhdWx0LmZyb21WYWx1ZSh7bG93OnQubG93LGhpZ2g6dC5oaWdoLHVuc2lnbmVkOm51bGwhPWUmJmV9KS50b051bWJlcigpOnR9c3RhdGljIGlzTG9uZyh0KXtyZXR1cm4gby5kZWZhdWx0LmlzTG9uZyh0KXx8dCBpbnN0YW5jZW9mIGkuZmxhdGJ1ZmZlcnMuTG9uZ319ZS5Mb25nVXRpbD1wO2NsYXNzIGZ7c3RhdGljIHNpemUodCl7cmV0dXJuIGYuZ2V0U2l6ZUZyb21EaW1lbnNpb25SYW5nZSh0LDAsdC5sZW5ndGgpfXN0YXRpYyBzaXplRnJvbURpbWVuc2lvbih0LGUpe2lmKGU8MHx8ZT50Lmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgZGltZW5zaW9uIG9mICR7ZX0gZm9yIHNpemVGcm9tRGltZW5zaW9uIGFzIFRlbnNvciBoYXMgJHt0Lmxlbmd0aH0gZGltZW5zaW9ucy5gKTtyZXR1cm4gZi5nZXRTaXplRnJvbURpbWVuc2lvblJhbmdlKHQsZSx0Lmxlbmd0aCl9c3RhdGljIHNpemVUb0RpbWVuc2lvbih0LGUpe2lmKGU8MHx8ZT50Lmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgZGltZW5zaW9uIG9mICR7ZX0gZm9yIHNpemVUb0RpbWVuc2lvbiBhcyBUZW5zb3IgaGFzICR7dC5sZW5ndGh9IGRpbWVuc2lvbnMuYCk7cmV0dXJuIGYuZ2V0U2l6ZUZyb21EaW1lbnNpb25SYW5nZSh0LDAsZSl9c3RhdGljIGdldFNpemVGcm9tRGltZW5zaW9uUmFuZ2UodCxlLG4pe2xldCByPTE7Zm9yKGxldCBpPWU7aTxuO2krKyl7aWYodFtpXTw9MCl0aHJvdyBuZXcgRXJyb3IoXCJjYW5ub3QgZ2V0IHZhbGlkIHNpemUgZnJvbSBzcGVjaWZpZWQgZGltZW5zaW9uIHJhbmdlLiBNb3N0IGxpa2VseSB0aGUgcmFuZ2UgY29udGFpbnMgMCBvciBuZWdhdGl2ZSB2YWx1ZXMgaW4gdGhlbS5cIik7cio9dFtpXX1yZXR1cm4gcn1zdGF0aWMgY29tcHV0ZVN0cmlkZXModCl7Y29uc3QgZT10Lmxlbmd0aDtpZigwPT09ZSlyZXR1cm5bXTtpZigxPT09ZSlyZXR1cm5bMV07Y29uc3Qgbj1uZXcgQXJyYXkoZSk7bltlLTFdPTEsbltlLTJdPXRbZS0xXTtmb3IobGV0IHI9ZS0zO3I+PTA7LS1yKW5bcl09bltyKzFdKnRbcisxXTtyZXR1cm4gbn1zdGF0aWMgdHJhbnNwb3NlKHQpe3JldHVybiB0LnNsaWNlKCkucmV2ZXJzZSgpfXN0YXRpYyBpbmRpY2VzVG9PZmZzZXQodCxlLG4pe3ZvaWQgMD09PW4mJihuPXQubGVuZ3RoKTtsZXQgcj0wO2ZvcihsZXQgaT0wO2k8bjsrK2kpcis9ZVtpXSp0W2ldO3JldHVybiByfXN0YXRpYyBvZmZzZXRUb0luZGljZXModCxlKXtjb25zdCBuPWUubGVuZ3RoO2lmKDA9PT1uKXJldHVybltdO2lmKDE9PT1uKXJldHVyblt0KmVbMF1dO2NvbnN0IHI9bmV3IEFycmF5KGUubGVuZ3RoKTtmb3IobGV0IG49MDtuPHIubGVuZ3RoLTE7KytuKXJbbl09TWF0aC5mbG9vcih0L2Vbbl0pLHQtPXJbbl0qZVtuXTtyZXR1cm4gcltyLmxlbmd0aC0xXT10LHJ9c3RhdGljIG5vcm1hbGl6ZUF4aXModCxlKXtpZih0PC1lJiZ0Pj1lKXRocm93IG5ldyBFcnJvcihcInVuc3VwcG9ydGVkIGF4aXMgZm9yIHRoaXMgb3BlcmF0aW9uLlwiKTtyZXR1cm4gdDwwP3QrZTp0fXN0YXRpYyBub3JtYWxpemVBeGVzKHQsZSl7cmV0dXJuIHQubWFwKCh0PT50aGlzLm5vcm1hbGl6ZUF4aXModCxlKSkpfXN0YXRpYyBpbmNyZW1lbnRJbmRleCh0LGUsbil7aWYoMD09PWUubGVuZ3RofHwwPT09dC5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiSW5kZXggaW5jcmVtZW50aW5nIHVuc3VwcG9ydGVkIGZvciBzY2FsYXIgVGVuc29yXCIpO2lmKHZvaWQgMD09PW4pbj1lLmxlbmd0aDtlbHNlIGlmKG48PTB8fG4+ZS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiSW5jb3JyZWN0IGF4aXMgdG8gaW5jcmVtZW50IG9uXCIpO2ZvcihsZXQgcj1uLTE7cj49MCYmKHRbcl0rKywhKHRbcl08ZVtyXSkpOy0tcil0W3JdPTB9c3RhdGljIGNhbGN1bGF0ZVJlc2hhcGVkRGltcyh0LGUpe2lmKDA9PT1lLmxlbmd0aCl7aWYoMD09PXQubGVuZ3RofHwxPT09Zi5zaXplKHQpKXJldHVybltdO3Rocm93IG5ldyBFcnJvcihcImNhbm5vdCByZXNoYXBlIHRvIGEgc2NhbGFyIFRlbnNvclwiKX1jb25zdCBuPWUubGVuZ3RoLHI9bmV3IEFycmF5KG4pO2xldCBpPS0xLG89MTtmb3IobGV0IGE9MDthPG47YSsrKXtpZihlW2FdPC0xKXRocm93IG5ldyBFcnJvcihcImEgZGltZW5zaW9uIGluIHNoYXBlIGhpbnRzIGNhbm5vdCBiZSBsZXNzIHRoYW4gLTFcIik7aWYoLTE9PT1lW2FdKXtpZigtMSE9PWkpdGhyb3cgbmV3IEVycm9yKFwiYXQgbW9zdCBvbmUgZGltZW5zaW9uIGluIHNoYXBlIGhpbnRzIGNhbiBiZSAtMVwiKTtpPWF9ZWxzZXtpZigwPT09ZVthXSl7aWYoYT49dC5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwidGhlIGRpbWVuc2lvbiB3aXRoIHZhbHVlIHplcm8gZXhjZWVkcyB0aGUgZGltZW5zaW9uIHNpemUgb2YgdGhlIGlucHV0IHRlbnNvclwiKTtyW2FdPXRbYV19ZWxzZSByW2FdPWVbYV07byo9clthXX19Y29uc3QgYT1mLnNpemUodCk7aWYoLTEhPT1pKXtpZihhJW8hPTApdGhyb3cgbmV3IEVycm9yKGB0aGUgaW5wdXQgdGVuc29yIGNhbm5vdCBiZSByZXNoYXBlZCB0byB0aGUgcmVxdWVzdGVkIHNoYXBlLiBJbnB1dCBzaGFwZTogWyR7dH1dIE91dHB1dCBzaGFwZTogWyR7ZX1dYCk7cltpXT1hL299ZWxzZSBpZihvIT09YSl0aHJvdyBuZXcgRXJyb3IoXCJyZXNoYXBlZERpbXMgYW5kIG9yaWdpbmFsRGltcyBkb24ndCBoYXZlIG1hdGNoaW5nIHNpemVzXCIpO3JldHVybiByfXN0YXRpYyBzb3J0QmFzZWRPblBlcm0odCxlKXtyZXR1cm4gZT9lLm1hcCgoZT0+dFtlXSkpOnQuc2xpY2UoKS5yZXZlcnNlKCl9c3RhdGljIHBhZFNoYXBlKHQsZSl7Y29uc3Qgbj10Lmxlbmd0aDtyZXR1cm4gdC5tYXAoKCh0LHIpPT50K2Vbcl0rZVtyK25dKSl9c3RhdGljIGFyZUVxdWFsKHQsZSl7cmV0dXJuIHQubGVuZ3RoPT09ZS5sZW5ndGgmJnQuZXZlcnkoKCh0LG4pPT50PT09ZVtuXSkpfXN0YXRpYyB2YWxpZGF0ZURpbXNBbmRDYWxjU2l6ZSh0KXtpZih0Lmxlbmd0aD42KXRocm93IG5ldyBUeXBlRXJyb3IoXCJPbmx5IHJhbmsgMCB0byA2IGlzIHN1cHBvcnRlZCBmb3IgdGVuc29yIHNoYXBlLlwiKTtsZXQgZT0xO2Zvcihjb25zdCBuIG9mIHQpe2lmKCFOdW1iZXIuaXNJbnRlZ2VyKG4pKXRocm93IG5ldyBUeXBlRXJyb3IoYEludmFsaWQgc2hhcGU6ICR7bn0gaXMgbm90IGFuIGludGVnZXJgKTtpZihuPDB8fG4+MjE0NzQ4MzY0Nyl0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIHNoYXBlOiBsZW5ndGggJHtufSBpcyBub3QgYWxsb3dlZGApO2UqPW59cmV0dXJuIGV9c3RhdGljIGZsYXR0ZW5TaGFwZSh0LGUpe2U8MCYmKGUrPXQubGVuZ3RoKTtjb25zdCBuPXQucmVkdWNlKCgodCxlKT0+dCplKSwxKSxyPXQuc2xpY2UoZSkucmVkdWNlKCgodCxlKT0+dCplKSwxKTtyZXR1cm5bbi9yLHJdfXN0YXRpYyBzcXVlZXplU2hhcGUodCxlKXtjb25zdCBuPW5ldyBBcnJheTtlPWYubm9ybWFsaXplQXhlcyhlLHQubGVuZ3RoKTtmb3IobGV0IHI9MDtyPHQubGVuZ3RoO3IrKyl7Y29uc3QgaT1lLmluZGV4T2Yocik+PTA7aWYoaSYmMSE9PXRbcl0pdGhyb3cgbmV3IEVycm9yKFwic3F1ZWV6ZSBhbiBheGlzIG9mIHNpemUgZGlmZmVyZW50IHRoYW4gMVwiKTsoMD09PWUubGVuZ3RoJiZ0W3JdPjF8fGUubGVuZ3RoPjAmJiFpKSYmbi5wdXNoKHRbcl0pfXJldHVybiBufXN0YXRpYyB1bnNxdWVlemVTaGFwZSh0LGUpe2NvbnN0IG49bmV3IEFycmF5KHQubGVuZ3RoK2UubGVuZ3RoKTtuLmZpbGwoMCk7Zm9yKGxldCB0PTA7dDxlLmxlbmd0aDt0Kyspe2NvbnN0IHI9Zi5ub3JtYWxpemVBeGlzKGVbdF0sbi5sZW5ndGgpO2lmKHI+PW4ubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIidheGVzJyBoYXMgYW4gb3V0IG9mIHJhbmdlIGF4aXNcIik7aWYoMCE9PW5bcl0pdGhyb3cgbmV3IEVycm9yKFwiJ2F4ZXMnIGhhcyBhIGR1cGxpY2F0ZSBheGlzXCIpO25bcl09MX1sZXQgcj0wO2ZvcihsZXQgZT0wO2U8bi5sZW5ndGg7ZSsrKTA9PT1uW2VdJiYobltlXT10W3IrK10pO2lmKHIhPT10Lmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJ0aGUgdW5zcXVlZXplZCBkaW1lbnNpb24gY291bGQgbm90IGJlIGVzdGFibGlzaGVkXCIpO3JldHVybiBufX1lLlNoYXBlVXRpbD1mLGUuTWF0aFV0aWw9Y2xhc3N7c3RhdGljIHNxcih0LGUsbixyLGkpe2lmKHI8MHx8cj49ZS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwic291cmNlSW5kZXggb3V0IG9mIGJvdW5kc1wiKTtpZihuPDB8fG4+PXQubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcInRhcmdldEluZGV4IG91dCBvZiBib3VuZHNcIik7aWYocitpPmUubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcInNvdXJjZSBpbmRpY2VzIHRvIGJlIGNvcGllZCBhcmUgb3V0c2lkZSBib3VuZHNcIik7aWYobitpPnQubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcInRhcmdldCBhcnJheSBpcyB0b28gc21hbGwgdG8gaG9sZCByZXN1bHRcIik7Zm9yKGxldCBvPTA7bzxpO28rKyl0W24rb10rPU1hdGgucG93KGVbcitvXSwyKX1zdGF0aWMgYXhweSh0LGUsbixyLGksbyl7aWYocjwwfHxyPj1lLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJzb3VyY2VJbmRleCBvdXQgb2YgYm91bmRzXCIpO2lmKG48MHx8bj49dC5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwidGFyZ2V0SW5kZXggb3V0IG9mIGJvdW5kc1wiKTtpZihyK2k+ZS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwic291cmNlIGluZGljZXMgdG8gYmUgY29waWVkIGFyZSBvdXRzaWRlIGJvdW5kc1wiKTtpZihuK2k+dC5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwidGFyZ2V0IGFycmF5IGlzIHRvbyBzbWFsbCB0byBob2xkIHJlc3VsdFwiKTtmb3IobGV0IGE9MDthPGk7YSsrKXRbbithXSs9byplW3IrYV19c3RhdGljIHBvd3godCxlLG4scixpLG8pe2lmKHI8MHx8cj49ZS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwic291cmNlSW5kZXggb3V0IG9mIGJvdW5kc1wiKTtpZihuPDB8fG4+PXQubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcInRhcmdldEluZGV4IG91dCBvZiBib3VuZHNcIik7aWYocitpPmUubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcInNvdXJjZSBpbmRpY2VzIHRvIGJlIGNvcGllZCBhcmUgb3V0c2lkZSBib3VuZHNcIik7aWYobitpPnQubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcInRhcmdldCBhcnJheSBpcyB0b28gc21hbGwgdG8gaG9sZCByZXN1bHRcIik7Zm9yKGxldCBhPTA7YTxpO2ErKyl0W24rYV09TWF0aC5wb3coZVtyK2FdLG8pfXN0YXRpYyBtdWwodCxlLG4scixpKXtpZihyPDB8fHI+PWUubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcInNvdXJjZUluZGV4IG91dCBvZiBib3VuZHNcIik7aWYobjwwfHxuPj10Lmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJ0YXJnZXRJbmRleCBvdXQgb2YgYm91bmRzXCIpO2lmKHIraT5lLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJzb3VyY2UgaW5kaWNlcyB0byBiZSBjb3BpZWQgYXJlIG91dHNpZGUgYm91bmRzXCIpO2lmKG4raT50Lmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJ0YXJnZXQgYXJyYXkgaXMgdG9vIHNtYWxsIHRvIGhvbGQgcmVzdWx0XCIpO2ZvcihsZXQgbz0wO288aTtvKyspdFtuK29dPWVbcitvXSp0W24rb119fTtjbGFzcyBke3N0YXRpYyBzcGxpdFNoYXBlKHQsZSxuLHIpe2lmKDA9PT1uLmxlbmd0aCl7aWYoIXIpdGhyb3cgbmV3IEVycm9yKFwibmVlZCB0byBrbm93IG51bWJlciBvZiBvdXRwdXRzIHdoZW4gdGhlICdzcGxpdCcgYXR0cmlidXRlIGlzIG5vdCBzcGVjaWZpZWRcIik7ZC5kZXRlcm1pbmVTcGxpdCh0W2VdLHIsbil9Y29uc3QgaT1bXSxvPVswXTtmb3IobGV0IHI9MDtyPG4ubGVuZ3RoOysrcil7MCE9PXImJm8ucHVzaChvW3ItMV0rbltyLTFdKTtjb25zdCBhPXQuc2xpY2UoKTthW2VdPW5bcl0saS5wdXNoKGEpfXJldHVybltpLG9dfXN0YXRpYyBkZXRlcm1pbmVTcGxpdCh0LGUsbil7aWYodCVlIT0wKXRocm93IG5ldyBFcnJvcihcImNhbm5vdCBzcGxpdCB0ZW5zb3IgdG8gZXF1YWwgc2l6ZWQgcGFydHNcIik7Zm9yKGxldCByPTA7cjxlOysrciluLnB1c2godC9lKX19ZS5TcGxpdFV0aWw9ZDtjbGFzcyBoe3N0YXRpYyBjYWxjUmVkdWNlKHQsZSxuLHIsaSl7Y29uc3Qgbz10LmRpbXMuc2xpY2UoMCk7MD09PWUubGVuZ3RoJiZvLmZvckVhY2goKCh0LG4pPT5lLnB1c2gobikpKTtjb25zdCBhPWguY2FsY1JlZHVjZVNoYXBlKG8sZSwhMCksdT1mLnNpemUoYSksbD1uZXcgcy5UZW5zb3IoYSx0LnR5cGUpLHA9Zi5jb21wdXRlU3RyaWRlcyhhKSxkPWYuY29tcHV0ZVN0cmlkZXMobyksZz1uZXcgQXJyYXkoby5sZW5ndGgpO2ZvcihsZXQgbj0wO248dTtuKyspe2NvbnN0IGE9Zi5vZmZzZXRUb0luZGljZXMobixwKTtjLmZpbGxJbmRleChhLG8sZyksbC5zZXQoYSxoLmNhbGNSZWR1Y2VCeUF4aXModC5udW1iZXJEYXRhLGUsbywwLGYuaW5kaWNlc1RvT2Zmc2V0KGcsZCkscixpKSl9cmV0dXJuIG4/bDpuZXcgcy5UZW5zb3IoaC5jYWxjUmVkdWNlU2hhcGUobyxlLG4pLGwudHlwZSx2b2lkIDAsdm9pZCAwLGwuZGF0YSxsLmRhdGFJZCl9c3RhdGljIGNhbGNSZWR1Y2VCeUF4aXModCxlLG4scixpLG8sYSl7bGV0IHM9MDtpZihyPj1lLmxlbmd0aClyZXR1cm4gbyh0W2ldKTtjb25zdCB1PWVbcl0sYz11Pj1uLmxlbmd0aD8xOmYuc2l6ZShuLnNsaWNlKHUrMSkpO2ZvcihsZXQgbD0wO2w8blt1XTtsKyspcz0wPT09bD9oLmNhbGNSZWR1Y2VCeUF4aXModCxlLG4scisxLGksbyxhKTphKHMsaC5jYWxjUmVkdWNlQnlBeGlzKHQsZSxuLHIrMSxpLG8sYSkpLGkrPWM7cmV0dXJuIHN9c3RhdGljIGNhbGNSZWR1Y2VTaGFwZSh0LGUsbil7Y29uc3Qgcj10LnNsaWNlKCk7Zm9yKGxldCB0PTA7dDxlLmxlbmd0aDt0KyspcltlW3RdXT1uPzE6MDtyZXR1cm4gci5maWx0ZXIoKHQ9PjAhPT10KSl9fWUuUmVkdWNlVXRpbD1oO2NsYXNzIGd7c3RhdGljIGFkanVzdFBvb2xBdHRyaWJ1dGVzKHQsZSxuLHIsaSxvKXtpZighdCYmbi5sZW5ndGghPT1lLmxlbmd0aC0yKXRocm93IG5ldyBFcnJvcihcImxlbmd0aCBvZiBzcGVjaWZpZWQga2VybmVsIHNoYXBlcyBzaG91bGQgYmUgMiBsZXNzIHRoYW4gbGVuZ3RoIG9mIGlucHV0IGRpbWVuc2lvbnNcIik7aWYodClmb3IobGV0IHQ9MDt0PGUubGVuZ3RoLTI7dCsrKXQ+PW4ubGVuZ3RoP24ucHVzaChlW3QrMl0pOm5bdF09ZVt0KzJdO2ZvcihsZXQgdD0wO3Q8bi5sZW5ndGg7dCsrKWlmKHQ8ci5sZW5ndGgpe2lmKHJbdF08MCl0aHJvdyBuZXcgRXJyb3IoXCJzdHJpZGVzIHNob3VsZCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMVwiKX1lbHNlIHIucHVzaCgxKTtmb3IobGV0IHQ9MDt0PG4ubGVuZ3RoO3QrKylpZih0PGkubGVuZ3RoKXtpZihpW3RdPDApdGhyb3cgbmV3IEVycm9yKFwiZGlsYXRpb25zIHNob3VsZCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMVwiKX1lbHNlIGkucHVzaCgxKTtmb3IobGV0IHQ9MDt0PDIqbi5sZW5ndGg7dCsrKWlmKHQ8by5sZW5ndGgpe2lmKG9bdF08MCl0aHJvdyBuZXcgRXJyb3IoXCJwYWQgc2hvdWxkIGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAxXCIpfWVsc2Ugby5wdXNoKDApO2ZvcihsZXQgdD0wO3Q8bi5sZW5ndGg7dCsrKXtpZihuW3RdPD0wKXRocm93IG5ldyBFcnJvcihcImtlcm5lbCBzaGFwZXMgbmVlZCB0byBiZSBncmVhdGVyIHRoYW4gMFwiKTtpZihvW3RdPj1uW3RdfHxvW3Qrbi5sZW5ndGhdPj1uW3RdKXRocm93IG5ldyBFcnJvcihcInBhZHMgc2hvdWxkIGJlIHNtYWxsZXIgdGhhbiBrZXJuZWxcIil9fXN0YXRpYyBhZGp1c3RQYWRzQmFzZWRPbkF1dG9QYWQodCxlLG4scixpLG8pe2lmKG8pe2lmKGkubGVuZ3RoIT09MioodC5sZW5ndGgtMikpdGhyb3cgbmV3IEVycm9yKFwibGVuZ3RoIG9mIHBhZHMgc2hvdWxkIGJlIHR3aWNlIHRoZSBsZW5ndGggb2YgZGF0YSBkaW1lbnNpb25zXCIpO2lmKGUubGVuZ3RoIT09dC5sZW5ndGgtMil0aHJvdyBuZXcgRXJyb3IoXCJsZW5ndGggb2Ygc3RyaWRlcyBzaG91bGQgYmUgdGhlIGxlbmd0aCBvZiBkYXRhIGRpbWVuc2lvbnNcIik7aWYoci5sZW5ndGghPT10Lmxlbmd0aC0yKXRocm93IG5ldyBFcnJvcihcImxlbmd0aCBvZiBrZXJuZWwgc2hhcGVzIHNob3VsZCBiZSB0aGUgbGVuZ3RoIG9mIGRhdGEgZGltZW5zaW9uc1wiKTtmb3IobGV0IGE9MDthPHQubGVuZ3RoLTI7YSsrKWcuYWRqdXN0UGFkQW5kUmV0dXJuU2hhcGUodFthKzJdLGVbYV0sblthXSxyW2FdLGksYSxhK3QubGVuZ3RoLTIsbyl9fXN0YXRpYyBjb21wdXRlUG9vbE91dHB1dFNoYXBlKHQsZSxuLHIsaSxvLGEpe2lmKGUubGVuZ3RoPD0wKXRocm93IG5ldyBFcnJvcihcImlucHV0IHNoYXBlIG11c3QgYmUgb2Ygc2l6ZSBncmVhdGVyIHRoYW4gMFwiKTtjb25zdCBzPVtlWzBdLGVbMV1dO3JldHVybiBnLmNvbXB1dGVTaGFwZUhlbHBlcih0LGUscyxuLHIsaSxvLGEpLHN9c3RhdGljIGNvbXB1dGVDb252T3V0cHV0U2hhcGUodCxlLG4scixpLG8sYSl7aWYodC5sZW5ndGg8PTB8fGUubGVuZ3RoPD0wKXRocm93IG5ldyBFcnJvcihcImludmFsaWQgaW5wdXQgdGVuc29yIGRpbXMgb3IgaW52YWxpZCBmaWx0ZXIgdGVuc29yIGRpbXNcIik7Y29uc3Qgcz1bdFswXSxlWzBdXTtyZXR1cm4gZy5jb21wdXRlU2hhcGVIZWxwZXIoITEsdCxzLG4scixpLG8sYSksc31zdGF0aWMgY29tcHV0ZVNoYXBlSGVscGVyKHQsZSxuLHIsaSxvLGEscyl7aWYodClmb3IobGV0IHQ9MDt0PGUubGVuZ3RoLTI7dCsrKW4ucHVzaCgxKTtlbHNlIGZvcihsZXQgdD0wO3Q8ZS5sZW5ndGgtMjt0Kyspbi5wdXNoKGcuYWRqdXN0UGFkQW5kUmV0dXJuU2hhcGUoZVt0KzJdLHJbdF0saVt0XSxvW3RdLGEsdCx0K2UubGVuZ3RoLTIscykpfXN0YXRpYyBhZGp1c3RQYWRBbmRSZXR1cm5TaGFwZSh0LGUsbixyLGksbyxhLHMpe2NvbnN0IHU9biooci0xKSsxO2lmKCFzfHxcIk5PVFNFVFwiPT09cylyZXR1cm4gTWF0aC5mbG9vcigodCtpW29dK2lbYV0tdSkvZSsxKTtzd2l0Y2gocyl7Y2FzZVwiVkFMSURcIjpyZXR1cm4gaVtvXT0wLGlbYV09MCxNYXRoLmZsb29yKCh0LXUpL2UrMSk7Y2FzZVwiU0FNRV9MT1dFUlwiOmNhc2VcIlNBTUVfVVBQRVJcIjppZigxIT09bil0aHJvdyBuZXcgRXJyb3IoXCJEaWxhdGlvbiBub3Qgc3VwcG9ydGVkIGZvciBTQU1FX1VQUEVSIG9yIFNBTUVfTE9XRVJcIik7e2NvbnN0IG49KCh0K2UtMSkvZS0xKSplK3ItdDtyZXR1cm4gaVtvXT1cIlNBTUVfTE9XRVJcIj09PXM/TWF0aC5mbG9vcigobisxKS8yKTpNYXRoLmZsb29yKG4vMiksaVthXT1uLWlbb10sTWF0aC5mbG9vcigodCtuLXIpL2UrMSl9ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCBBdXRvUGFkIHR5cGVcIil9fX1lLlBvb2xDb252VXRpbD1nLGUuTUlOX0NMSVA9LTM0MDI4MjM0NjYzODUyODg2ZTIyLGUuTUFYX0NMSVA9MzQwMjgyMzQ2NjM4NTI4ODZlMjIsZS5kZWNvZGVVdGY4U3RyaW5nPWZ1bmN0aW9uKHQpe3JldHVybihuZXcgVGV4dERlY29kZXIpLmRlY29kZSh0KX19LDc5Njc6KHQsZSk9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLml0ZXJhdGVFeHRyYU9wdGlvbnM9dm9pZCAwLGUuaXRlcmF0ZUV4dHJhT3B0aW9ucz0odCxuLHIsaSk9PntpZihcIm9iamVjdFwiPT10eXBlb2YgdCYmbnVsbCE9PXQpe2lmKHIuaGFzKHQpKXRocm93IG5ldyBFcnJvcihcIkNpcmN1bGFyIHJlZmVyZW5jZSBpbiBvcHRpb25zXCIpO3IuYWRkKHQpfU9iamVjdC5lbnRyaWVzKHQpLmZvckVhY2goKChbdCxvXSk9Pntjb25zdCBhPW4/bit0OnQ7aWYoXCJvYmplY3RcIj09dHlwZW9mIG8pKDAsZS5pdGVyYXRlRXh0cmFPcHRpb25zKShvLGErXCIuXCIscixpKTtlbHNlIGlmKFwic3RyaW5nXCI9PXR5cGVvZiBvfHxcIm51bWJlclwiPT10eXBlb2YgbylpKGEsby50b1N0cmluZygpKTtlbHNle2lmKFwiYm9vbGVhblwiIT10eXBlb2Ygbyl0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBoYW5kbGUgZXh0cmEgY29uZmlnIHR5cGU6IFwiK3R5cGVvZiBvKTtpKGEsbz9cIjFcIjpcIjBcIil9fSkpfX0sMjE1NzpmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7dmFyIHIsaT10aGlzJiZ0aGlzLl9fY3JlYXRlQmluZGluZ3x8KE9iamVjdC5jcmVhdGU/ZnVuY3Rpb24odCxlLG4scil7dm9pZCAwPT09ciYmKHI9bik7dmFyIGk9T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLG4pO2kmJiEoXCJnZXRcImluIGk/IWUuX19lc01vZHVsZTppLndyaXRhYmxlfHxpLmNvbmZpZ3VyYWJsZSl8fChpPXtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBlW25dfX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LHIsaSl9OmZ1bmN0aW9uKHQsZSxuLHIpe3ZvaWQgMD09PXImJihyPW4pLHRbcl09ZVtuXX0pLG89dGhpcyYmdGhpcy5fX3NldE1vZHVsZURlZmF1bHR8fChPYmplY3QuY3JlYXRlP2Z1bmN0aW9uKHQsZSl7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJkZWZhdWx0XCIse2VudW1lcmFibGU6ITAsdmFsdWU6ZX0pfTpmdW5jdGlvbih0LGUpe3QuZGVmYXVsdD1lfSksYT10aGlzJiZ0aGlzLl9faW1wb3J0U3Rhcnx8ZnVuY3Rpb24odCl7aWYodCYmdC5fX2VzTW9kdWxlKXJldHVybiB0O3ZhciBlPXt9O2lmKG51bGwhPXQpZm9yKHZhciBuIGluIHQpXCJkZWZhdWx0XCIhPT1uJiZPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCxuKSYmaShlLHQsbik7cmV0dXJuIG8oZSx0KSxlfTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLmVuZFByb2ZpbGluZz1lLnJ1bj1lLnJlbGVhc2VTZXNzaW9uPWUuY3JlYXRlU2Vzc2lvbj1lLmNyZWF0ZVNlc3Npb25GaW5hbGl6ZT1lLmNyZWF0ZVNlc3Npb25BbGxvY2F0ZT1lLmluaXRPcnQ9ZS5pbml0V2FzbT12b2lkIDA7Y29uc3Qgcz1uKDYyMDcpLHU9YShuKDM0OSkpLGM9big2MzYxKSxsPSgpPT4hIXMuZW52Lndhc20ucHJveHkmJlwidW5kZWZpbmVkXCIhPXR5cGVvZiBkb2N1bWVudDtsZXQgcCxmLGQsaD0hMSxnPSExLGI9ITE7Y29uc3QgbT1bXSx5PVtdLF89W10sdj1bXSx3PVtdLHg9W10sVD0oKT0+e2lmKGh8fCFnfHxifHwhcCl0aHJvdyBuZXcgRXJyb3IoXCJ3b3JrZXIgbm90IHJlYWR5XCIpfSxTPXQ9Pntzd2l0Y2godC5kYXRhLnR5cGUpe2Nhc2VcImluaXQtd2FzbVwiOmg9ITEsdC5kYXRhLmVycj8oYj0hMCxmWzFdKHQuZGF0YS5lcnIpKTooZz0hMCxmWzBdKCkpO2JyZWFrO2Nhc2VcImluaXQtb3J0XCI6dC5kYXRhLmVycj9kWzFdKHQuZGF0YS5lcnIpOmRbMF0oKTticmVhaztjYXNlXCJjcmVhdGVfYWxsb2NhdGVcIjp0LmRhdGEuZXJyP20uc2hpZnQoKVsxXSh0LmRhdGEuZXJyKTptLnNoaWZ0KClbMF0odC5kYXRhLm91dCk7YnJlYWs7Y2FzZVwiY3JlYXRlX2ZpbmFsaXplXCI6dC5kYXRhLmVycj95LnNoaWZ0KClbMV0odC5kYXRhLmVycik6eS5zaGlmdCgpWzBdKHQuZGF0YS5vdXQpO2JyZWFrO2Nhc2VcImNyZWF0ZVwiOnQuZGF0YS5lcnI/Xy5zaGlmdCgpWzFdKHQuZGF0YS5lcnIpOl8uc2hpZnQoKVswXSh0LmRhdGEub3V0KTticmVhaztjYXNlXCJyZWxlYXNlXCI6dC5kYXRhLmVycj92LnNoaWZ0KClbMV0odC5kYXRhLmVycik6di5zaGlmdCgpWzBdKCk7YnJlYWs7Y2FzZVwicnVuXCI6dC5kYXRhLmVycj93LnNoaWZ0KClbMV0odC5kYXRhLmVycik6dy5zaGlmdCgpWzBdKHQuZGF0YS5vdXQpO2JyZWFrO2Nhc2VcImVuZC1wcm9maWxpbmdcIjp0LmRhdGEuZXJyP3guc2hpZnQoKVsxXSh0LmRhdGEuZXJyKTp4LnNoaWZ0KClbMF0oKX19LE89XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGRvY3VtZW50P251bGw9PT0ocj1udWxsPT09ZG9jdW1lbnR8fHZvaWQgMD09PWRvY3VtZW50P3ZvaWQgMDpkb2N1bWVudC5jdXJyZW50U2NyaXB0KXx8dm9pZCAwPT09cj92b2lkIDA6ci5zcmM6dm9pZCAwO2UuaW5pdFdhc209YXN5bmMoKT0+e2lmKGwoKSl7aWYoZylyZXR1cm47aWYoaCl0aHJvdyBuZXcgRXJyb3IoXCJtdWx0aXBsZSBjYWxscyB0byAnaW5pdFdhc20oKScgZGV0ZWN0ZWQuXCIpO2lmKGIpdGhyb3cgbmV3IEVycm9yKFwicHJldmlvdXMgY2FsbCB0byAnaW5pdFdhc20oKScgZmFpbGVkLlwiKTtyZXR1cm4gaD0hMCx2b2lkIDA9PT1zLmVudi53YXNtLndhc21QYXRocyYmTyYmMCE9PU8uaW5kZXhPZihcImJsb2I6XCIpJiYocy5lbnYud2FzbS53YXNtUGF0aHM9Ty5zdWJzdHIoMCwrTy5sYXN0SW5kZXhPZihcIi9cIikrMSkpLG5ldyBQcm9taXNlKCgodCxlKT0+e251bGw9PXB8fHAudGVybWluYXRlKCkscD1uKDk3MTApLlooKSxwLm9ubWVzc2FnZT1TLGY9W3QsZV07Y29uc3Qgcj17dHlwZTpcImluaXQtd2FzbVwiLGluOnMuZW52Lndhc219O3AucG9zdE1lc3NhZ2Uocil9KSl9cmV0dXJuKDAsYy5pbml0aWFsaXplV2ViQXNzZW1ibHkpKHMuZW52Lndhc20pfSxlLmluaXRPcnQ9YXN5bmModCxlKT0+e2lmKGwoKSlyZXR1cm4gVCgpLG5ldyBQcm9taXNlKCgobixyKT0+e2Q9W24scl07Y29uc3QgaT17dHlwZTpcImluaXQtb3J0XCIsaW46e251bVRocmVhZHM6dCxsb2dnaW5nTGV2ZWw6ZX19O3AucG9zdE1lc3NhZ2UoaSl9KSk7dS5pbml0T3J0KHQsZSl9LGUuY3JlYXRlU2Vzc2lvbkFsbG9jYXRlPWFzeW5jIHQ9PmwoKT8oVCgpLG5ldyBQcm9taXNlKCgoZSxuKT0+e20ucHVzaChbZSxuXSk7Y29uc3Qgcj17dHlwZTpcImNyZWF0ZV9hbGxvY2F0ZVwiLGluOnttb2RlbDp0fX07cC5wb3N0TWVzc2FnZShyLFt0LmJ1ZmZlcl0pfSkpKTp1LmNyZWF0ZVNlc3Npb25BbGxvY2F0ZSh0KSxlLmNyZWF0ZVNlc3Npb25GaW5hbGl6ZT1hc3luYyh0LGUpPT5sKCk/KFQoKSxuZXcgUHJvbWlzZSgoKG4scik9Pnt5LnB1c2goW24scl0pO2NvbnN0IGk9e3R5cGU6XCJjcmVhdGVfZmluYWxpemVcIixpbjp7bW9kZWxkYXRhOnQsb3B0aW9uczplfX07cC5wb3N0TWVzc2FnZShpKX0pKSk6dS5jcmVhdGVTZXNzaW9uRmluYWxpemUodCxlKSxlLmNyZWF0ZVNlc3Npb249YXN5bmModCxlKT0+bCgpPyhUKCksbmV3IFByb21pc2UoKChuLHIpPT57Xy5wdXNoKFtuLHJdKTtjb25zdCBpPXt0eXBlOlwiY3JlYXRlXCIsaW46e21vZGVsOnQsb3B0aW9uczplfX07cC5wb3N0TWVzc2FnZShpLFt0LmJ1ZmZlcl0pfSkpKTp1LmNyZWF0ZVNlc3Npb24odCxlKSxlLnJlbGVhc2VTZXNzaW9uPWFzeW5jIHQ9PntpZihsKCkpcmV0dXJuIFQoKSxuZXcgUHJvbWlzZSgoKGUsbik9Pnt2LnB1c2goW2Usbl0pO2NvbnN0IHI9e3R5cGU6XCJyZWxlYXNlXCIsaW46dH07cC5wb3N0TWVzc2FnZShyKX0pKTt1LnJlbGVhc2VTZXNzaW9uKHQpfSxlLnJ1bj1hc3luYyh0LGUsbixyLGkpPT5sKCk/KFQoKSxuZXcgUHJvbWlzZSgoKG8sYSk9Pnt3LnB1c2goW28sYV0pO2NvbnN0IHM9e3R5cGU6XCJydW5cIixpbjp7c2Vzc2lvbklkOnQsaW5wdXRJbmRpY2VzOmUsaW5wdXRzOm4sb3V0cHV0SW5kaWNlczpyLG9wdGlvbnM6aX19O3AucG9zdE1lc3NhZ2Uocyx1LmV4dHJhY3RUcmFuc2ZlcmFibGVCdWZmZXJzKG4pKX0pKSk6dS5ydW4odCxlLG4scixpKSxlLmVuZFByb2ZpbGluZz1hc3luYyB0PT57aWYobCgpKXJldHVybiBUKCksbmV3IFByb21pc2UoKChlLG4pPT57eC5wdXNoKFtlLG5dKTtjb25zdCByPXt0eXBlOlwiZW5kLXByb2ZpbGluZ1wiLGluOnR9O3AucG9zdE1lc3NhZ2Uocil9KSk7dS5lbmRQcm9maWxpbmcodCl9fSw1ODY6KHQsZSxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUuc2V0UnVuT3B0aW9ucz12b2lkIDA7Y29uc3Qgcj1uKDc5NjcpLGk9big0OTgzKSxvPW4oNjM2MSk7ZS5zZXRSdW5PcHRpb25zPXQ9Pntjb25zdCBlPSgwLG8uZ2V0SW5zdGFuY2UpKCk7bGV0IG49MDtjb25zdCBhPVtdLHM9dHx8e307dHJ5e2lmKHZvaWQgMD09PShudWxsPT10P3ZvaWQgMDp0LmxvZ1NldmVyaXR5TGV2ZWwpKXMubG9nU2V2ZXJpdHlMZXZlbD0yO2Vsc2UgaWYoXCJudW1iZXJcIiE9dHlwZW9mIHQubG9nU2V2ZXJpdHlMZXZlbHx8IU51bWJlci5pc0ludGVnZXIodC5sb2dTZXZlcml0eUxldmVsKXx8dC5sb2dTZXZlcml0eUxldmVsPDB8fHQubG9nU2V2ZXJpdHlMZXZlbD40KXRocm93IG5ldyBFcnJvcihgbG9nIHNlcnZlcml0eSBsZXZlbCBpcyBub3QgdmFsaWQ6ICR7dC5sb2dTZXZlcml0eUxldmVsfWApO2lmKHZvaWQgMD09PShudWxsPT10P3ZvaWQgMDp0LmxvZ1ZlcmJvc2l0eUxldmVsKSlzLmxvZ1ZlcmJvc2l0eUxldmVsPTA7ZWxzZSBpZihcIm51bWJlclwiIT10eXBlb2YgdC5sb2dWZXJib3NpdHlMZXZlbHx8IU51bWJlci5pc0ludGVnZXIodC5sb2dWZXJib3NpdHlMZXZlbCkpdGhyb3cgbmV3IEVycm9yKGBsb2cgdmVyYm9zaXR5IGxldmVsIGlzIG5vdCB2YWxpZDogJHt0LmxvZ1ZlcmJvc2l0eUxldmVsfWApO3ZvaWQgMD09PShudWxsPT10P3ZvaWQgMDp0LnRlcm1pbmF0ZSkmJihzLnRlcm1pbmF0ZT0hMSk7bGV0IG89MDtpZih2b2lkIDAhPT0obnVsbD09dD92b2lkIDA6dC50YWcpJiYobz0oMCxpLmFsbG9jV2FzbVN0cmluZykodC50YWcsYSkpLG49ZS5fT3J0Q3JlYXRlUnVuT3B0aW9ucyhzLmxvZ1NldmVyaXR5TGV2ZWwscy5sb2dWZXJib3NpdHlMZXZlbCwhIXMudGVybWluYXRlLG8pLDA9PT1uKXRocm93IG5ldyBFcnJvcihcIkNhbid0IGNyZWF0ZSBydW4gb3B0aW9uc1wiKTtyZXR1cm4gdm9pZCAwIT09KG51bGw9PXQ/dm9pZCAwOnQuZXh0cmEpJiYoMCxyLml0ZXJhdGVFeHRyYU9wdGlvbnMpKHQuZXh0cmEsXCJcIixuZXcgV2Vha1NldCwoKHQscik9Pntjb25zdCBvPSgwLGkuYWxsb2NXYXNtU3RyaW5nKSh0LGEpLHM9KDAsaS5hbGxvY1dhc21TdHJpbmcpKHIsYSk7aWYoMCE9PWUuX09ydEFkZFJ1bkNvbmZpZ0VudHJ5KG4sbyxzKSl0aHJvdyBuZXcgRXJyb3IoYENhbid0IHNldCBhIHJ1biBjb25maWcgZW50cnk6ICR7dH0gLSAke3J9YCl9KSksW24sYV19Y2F0Y2godCl7dGhyb3cgMCE9PW4mJmUuX09ydFJlbGVhc2VSdW5PcHRpb25zKG4pLGEuZm9yRWFjaChlLl9mcmVlKSx0fX19LDIzMDY6KHQsZSxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUuT25ueHJ1bnRpbWVXZWJBc3NlbWJseVNlc3Npb25IYW5kbGVyPXZvaWQgMDtjb25zdCByPW4oNjIzMSksaT1uKDYyMDcpLG89big2NDY0KSxhPW4oMjE1Nyk7bGV0IHM7ZS5Pbm54cnVudGltZVdlYkFzc2VtYmx5U2Vzc2lvbkhhbmRsZXI9Y2xhc3N7YXN5bmMgY3JlYXRlU2Vzc2lvbkFsbG9jYXRlKHQpe2NvbnN0IGU9YXdhaXQgZmV0Y2godCksbj1hd2FpdCBlLmFycmF5QnVmZmVyKCk7cmV0dXJuKDAsYS5jcmVhdGVTZXNzaW9uQWxsb2NhdGUpKG5ldyBVaW50OEFycmF5KG4pKX1hc3luYyBsb2FkTW9kZWwodCxlKXtpZihzfHwoYXdhaXQoMCxhLmluaXRPcnQpKGkuZW52Lndhc20ubnVtVGhyZWFkcywodD0+e3N3aXRjaCh0KXtjYXNlXCJ2ZXJib3NlXCI6cmV0dXJuIDA7Y2FzZVwiaW5mb1wiOnJldHVybiAxO2Nhc2VcIndhcm5pbmdcIjpyZXR1cm4gMjtjYXNlXCJlcnJvclwiOnJldHVybiAzO2Nhc2VcImZhdGFsXCI6cmV0dXJuIDQ7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIGxvZ2dpbmcgbGV2ZWw6ICR7dH1gKX19KShpLmVudi5sb2dMZXZlbCkpLHM9ITApLFwic3RyaW5nXCI9PXR5cGVvZiB0KWlmKFwidW5kZWZpbmVkXCI9PXR5cGVvZiBmZXRjaCl7Y29uc3Qgbj1hd2FpdCgwLG8ucHJvbWlzaWZ5KShyLnJlYWRGaWxlKSh0KTtbdGhpcy5zZXNzaW9uSWQsdGhpcy5pbnB1dE5hbWVzLHRoaXMub3V0cHV0TmFtZXNdPWF3YWl0KDAsYS5jcmVhdGVTZXNzaW9uKShuLGUpfWVsc2V7Y29uc3Qgbj1hd2FpdCB0aGlzLmNyZWF0ZVNlc3Npb25BbGxvY2F0ZSh0KTtbdGhpcy5zZXNzaW9uSWQsdGhpcy5pbnB1dE5hbWVzLHRoaXMub3V0cHV0TmFtZXNdPWF3YWl0KDAsYS5jcmVhdGVTZXNzaW9uRmluYWxpemUpKG4sZSl9ZWxzZVt0aGlzLnNlc3Npb25JZCx0aGlzLmlucHV0TmFtZXMsdGhpcy5vdXRwdXROYW1lc109YXdhaXQoMCxhLmNyZWF0ZVNlc3Npb24pKHQsZSl9YXN5bmMgZGlzcG9zZSgpe3JldHVybigwLGEucmVsZWFzZVNlc3Npb24pKHRoaXMuc2Vzc2lvbklkKX1hc3luYyBydW4odCxlLG4pe2NvbnN0IHI9W10sbz1bXTtPYmplY3QuZW50cmllcyh0KS5mb3JFYWNoKCh0PT57Y29uc3QgZT10WzBdLG49dFsxXSxpPXRoaXMuaW5wdXROYW1lcy5pbmRleE9mKGUpO2lmKC0xPT09aSl0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgaW5wdXQgJyR7ZX0nYCk7ci5wdXNoKG4pLG8ucHVzaChpKX0pKTtjb25zdCBzPVtdO09iamVjdC5lbnRyaWVzKGUpLmZvckVhY2goKHQ9Pntjb25zdCBlPXRbMF0sbj10aGlzLm91dHB1dE5hbWVzLmluZGV4T2YoZSk7aWYoLTE9PT1uKXRocm93IG5ldyBFcnJvcihgaW52YWxpZCBvdXRwdXQgJyR7ZX0nYCk7cy5wdXNoKG4pfSkpO2NvbnN0IHU9YXdhaXQoMCxhLnJ1bikodGhpcy5zZXNzaW9uSWQsbyxyLm1hcCgodD0+W3QudHlwZSx0LmRpbXMsdC5kYXRhXSkpLHMsbiksYz17fTtmb3IobGV0IHQ9MDt0PHUubGVuZ3RoO3QrKyljW3RoaXMub3V0cHV0TmFtZXNbc1t0XV1dPW5ldyBpLlRlbnNvcih1W3RdWzBdLHVbdF1bMl0sdVt0XVsxXSk7cmV0dXJuIGN9c3RhcnRQcm9maWxpbmcoKXt9ZW5kUHJvZmlsaW5nKCl7KDAsYS5lbmRQcm9maWxpbmcpKHRoaXMuc2Vzc2lvbklkKX19fSw0OTE5Oih0LGUsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLnNldFNlc3Npb25PcHRpb25zPXZvaWQgMDtjb25zdCByPW4oNzk2NyksaT1uKDQ5ODMpLG89big2MzYxKTtlLnNldFNlc3Npb25PcHRpb25zPXQ9Pntjb25zdCBlPSgwLG8uZ2V0SW5zdGFuY2UpKCk7bGV0IG49MDtjb25zdCBhPVtdLHM9dHx8e307KHQ9Pnt0LmV4dHJhfHwodC5leHRyYT17fSksdC5leHRyYS5zZXNzaW9ufHwodC5leHRyYS5zZXNzaW9uPXt9KTtjb25zdCBlPXQuZXh0cmEuc2Vzc2lvbjtlLnVzZV9vcnRfbW9kZWxfYnl0ZXNfZGlyZWN0bHl8fChlLnVzZV9vcnRfbW9kZWxfYnl0ZXNfZGlyZWN0bHk9XCIxXCIpfSkocyk7dHJ5e3ZvaWQgMD09PShudWxsPT10P3ZvaWQgMDp0LmdyYXBoT3B0aW1pemF0aW9uTGV2ZWwpJiYocy5ncmFwaE9wdGltaXphdGlvbkxldmVsPVwiYWxsXCIpO2NvbnN0IHU9KHQ9Pntzd2l0Y2godCl7Y2FzZVwiZGlzYWJsZWRcIjpyZXR1cm4gMDtjYXNlXCJiYXNpY1wiOnJldHVybiAxO2Nhc2VcImV4dGVuZGVkXCI6cmV0dXJuIDI7Y2FzZVwiYWxsXCI6cmV0dXJuIDk5O2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCBncmFwaCBvcHRpbWl6YXRpb24gbGV2ZWw6ICR7dH1gKX19KShzLmdyYXBoT3B0aW1pemF0aW9uTGV2ZWwpO3ZvaWQgMD09PShudWxsPT10P3ZvaWQgMDp0LmVuYWJsZUNwdU1lbUFyZW5hKSYmKHMuZW5hYmxlQ3B1TWVtQXJlbmE9ITApLHZvaWQgMD09PShudWxsPT10P3ZvaWQgMDp0LmVuYWJsZU1lbVBhdHRlcm4pJiYocy5lbmFibGVNZW1QYXR0ZXJuPSEwKSx2b2lkIDA9PT0obnVsbD09dD92b2lkIDA6dC5leGVjdXRpb25Nb2RlKSYmKHMuZXhlY3V0aW9uTW9kZT1cInNlcXVlbnRpYWxcIik7Y29uc3QgYz0odD0+e3N3aXRjaCh0KXtjYXNlXCJzZXF1ZW50aWFsXCI6cmV0dXJuIDA7Y2FzZVwicGFyYWxsZWxcIjpyZXR1cm4gMTtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgZXhlY3V0aW9uIG1vZGU6ICR7dH1gKX19KShzLmV4ZWN1dGlvbk1vZGUpO2xldCBsPTA7aWYodm9pZCAwIT09KG51bGw9PXQ/dm9pZCAwOnQubG9nSWQpJiYobD0oMCxpLmFsbG9jV2FzbVN0cmluZykodC5sb2dJZCxhKSksdm9pZCAwPT09KG51bGw9PXQ/dm9pZCAwOnQubG9nU2V2ZXJpdHlMZXZlbCkpcy5sb2dTZXZlcml0eUxldmVsPTI7ZWxzZSBpZihcIm51bWJlclwiIT10eXBlb2YgdC5sb2dTZXZlcml0eUxldmVsfHwhTnVtYmVyLmlzSW50ZWdlcih0LmxvZ1NldmVyaXR5TGV2ZWwpfHx0LmxvZ1NldmVyaXR5TGV2ZWw8MHx8dC5sb2dTZXZlcml0eUxldmVsPjQpdGhyb3cgbmV3IEVycm9yKGBsb2cgc2VydmVyaXR5IGxldmVsIGlzIG5vdCB2YWxpZDogJHt0LmxvZ1NldmVyaXR5TGV2ZWx9YCk7aWYodm9pZCAwPT09KG51bGw9PXQ/dm9pZCAwOnQubG9nVmVyYm9zaXR5TGV2ZWwpKXMubG9nVmVyYm9zaXR5TGV2ZWw9MDtlbHNlIGlmKFwibnVtYmVyXCIhPXR5cGVvZiB0LmxvZ1ZlcmJvc2l0eUxldmVsfHwhTnVtYmVyLmlzSW50ZWdlcih0LmxvZ1ZlcmJvc2l0eUxldmVsKSl0aHJvdyBuZXcgRXJyb3IoYGxvZyB2ZXJib3NpdHkgbGV2ZWwgaXMgbm90IHZhbGlkOiAke3QubG9nVmVyYm9zaXR5TGV2ZWx9YCk7aWYodm9pZCAwPT09KG51bGw9PXQ/dm9pZCAwOnQuZW5hYmxlUHJvZmlsaW5nKSYmKHMuZW5hYmxlUHJvZmlsaW5nPSExKSxuPWUuX09ydENyZWF0ZVNlc3Npb25PcHRpb25zKHUsISFzLmVuYWJsZUNwdU1lbUFyZW5hLCEhcy5lbmFibGVNZW1QYXR0ZXJuLGMsISFzLmVuYWJsZVByb2ZpbGluZywwLGwscy5sb2dTZXZlcml0eUxldmVsLHMubG9nVmVyYm9zaXR5TGV2ZWwpLDA9PT1uKXRocm93IG5ldyBFcnJvcihcIkNhbid0IGNyZWF0ZSBzZXNzaW9uIG9wdGlvbnNcIik7cmV0dXJuKG51bGw9PXQ/dm9pZCAwOnQuZXhlY3V0aW9uUHJvdmlkZXJzKSYmKCh0LGUsbik9Pntmb3IoY29uc3QgciBvZiBlKXtsZXQgZT1cInN0cmluZ1wiPT10eXBlb2Ygcj9yOnIubmFtZTtzd2l0Y2goZSl7Y2FzZVwieG5ucGFja1wiOmU9XCJYTk5QQUNLXCI7YnJlYWs7Y2FzZVwid2FzbVwiOmNhc2VcImNwdVwiOmNvbnRpbnVlO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBub3Qgc3VwcG9ydGVkIEVQOiAke2V9YCl9Y29uc3QgYT0oMCxpLmFsbG9jV2FzbVN0cmluZykoZSxuKTtpZigwIT09KDAsby5nZXRJbnN0YW5jZSkoKS5fT3J0QXBwZW5kRXhlY3V0aW9uUHJvdmlkZXIodCxhKSl0aHJvdyBuZXcgRXJyb3IoYENhbid0IGFwcGVuZCBleGVjdXRpb24gcHJvdmlkZXI6ICR7ZX1gKX19KShuLHQuZXhlY3V0aW9uUHJvdmlkZXJzLGEpLHZvaWQgMCE9PShudWxsPT10P3ZvaWQgMDp0LmV4dHJhKSYmKDAsci5pdGVyYXRlRXh0cmFPcHRpb25zKSh0LmV4dHJhLFwiXCIsbmV3IFdlYWtTZXQsKCh0LHIpPT57Y29uc3Qgbz0oMCxpLmFsbG9jV2FzbVN0cmluZykodCxhKSxzPSgwLGkuYWxsb2NXYXNtU3RyaW5nKShyLGEpO2lmKDAhPT1lLl9PcnRBZGRTZXNzaW9uQ29uZmlnRW50cnkobixvLHMpKXRocm93IG5ldyBFcnJvcihgQ2FuJ3Qgc2V0IGEgc2Vzc2lvbiBjb25maWcgZW50cnk6ICR7dH0gLSAke3J9YCl9KSksW24sYV19Y2F0Y2godCl7dGhyb3cgMCE9PW4mJmUuX09ydFJlbGVhc2VTZXNzaW9uT3B0aW9ucyhuKSxhLmZvckVhY2goZS5fZnJlZSksdH19fSw0OTgzOih0LGUsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLmFsbG9jV2FzbVN0cmluZz12b2lkIDA7Y29uc3Qgcj1uKDYzNjEpO2UuYWxsb2NXYXNtU3RyaW5nPSh0LGUpPT57Y29uc3Qgbj0oMCxyLmdldEluc3RhbmNlKSgpLGk9bi5sZW5ndGhCeXRlc1VURjgodCkrMSxvPW4uX21hbGxvYyhpKTtyZXR1cm4gbi5zdHJpbmdUb1VURjgodCxvLGkpLGUucHVzaChvKSxvfX0sMzQ5Oih0LGUsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLmV4dHJhY3RUcmFuc2ZlcmFibGVCdWZmZXJzPWUuZW5kUHJvZmlsaW5nPWUucnVuPWUucmVsZWFzZVNlc3Npb249ZS5jcmVhdGVTZXNzaW9uPWUuY3JlYXRlU2Vzc2lvbkZpbmFsaXplPWUuY3JlYXRlU2Vzc2lvbkFsbG9jYXRlPWUuaW5pdE9ydD12b2lkIDA7Y29uc3Qgcj1uKDU4NiksaT1uKDQ5MTkpLG89big0OTgzKSxhPW4oNjM2MSk7ZS5pbml0T3J0PSh0LGUpPT57Y29uc3Qgbj0oMCxhLmdldEluc3RhbmNlKSgpLl9PcnRJbml0KHQsZSk7aWYoMCE9PW4pdGhyb3cgbmV3IEVycm9yKGBDYW4ndCBpbml0aWFsaXplIG9ubnhydW50aW1lLiBlcnJvciBjb2RlID0gJHtufWApfTtjb25zdCBzPW5ldyBNYXA7ZS5jcmVhdGVTZXNzaW9uQWxsb2NhdGU9dD0+e2NvbnN0IGU9KDAsYS5nZXRJbnN0YW5jZSkoKSxuPWUuX21hbGxvYyh0LmJ5dGVMZW5ndGgpO3JldHVybiBlLkhFQVBVOC5zZXQodCxuKSxbbix0LmJ5dGVMZW5ndGhdfSxlLmNyZWF0ZVNlc3Npb25GaW5hbGl6ZT0odCxlKT0+e2NvbnN0IG49KDAsYS5nZXRJbnN0YW5jZSkoKTtsZXQgcj0wLG89MCx1PVtdO3RyeXtpZihbbyx1XT0oMCxpLnNldFNlc3Npb25PcHRpb25zKShlKSxyPW4uX09ydENyZWF0ZVNlc3Npb24odFswXSx0WzFdLG8pLDA9PT1yKXRocm93IG5ldyBFcnJvcihcIkNhbid0IGNyZWF0ZSBhIHNlc3Npb25cIil9ZmluYWxseXtuLl9mcmVlKHRbMF0pLG4uX09ydFJlbGVhc2VTZXNzaW9uT3B0aW9ucyhvKSx1LmZvckVhY2gobi5fZnJlZSl9Y29uc3QgYz1uLl9PcnRHZXRJbnB1dENvdW50KHIpLGw9bi5fT3J0R2V0T3V0cHV0Q291bnQocikscD1bXSxmPVtdLGQ9W10saD1bXTtmb3IobGV0IHQ9MDt0PGM7dCsrKXtjb25zdCBlPW4uX09ydEdldElucHV0TmFtZShyLHQpO2lmKDA9PT1lKXRocm93IG5ldyBFcnJvcihcIkNhbid0IGdldCBhbiBpbnB1dCBuYW1lXCIpO2YucHVzaChlKSxwLnB1c2gobi5VVEY4VG9TdHJpbmcoZSkpfWZvcihsZXQgdD0wO3Q8bDt0Kyspe2NvbnN0IGU9bi5fT3J0R2V0T3V0cHV0TmFtZShyLHQpO2lmKDA9PT1lKXRocm93IG5ldyBFcnJvcihcIkNhbid0IGdldCBhbiBvdXRwdXQgbmFtZVwiKTtoLnB1c2goZSksZC5wdXNoKG4uVVRGOFRvU3RyaW5nKGUpKX1yZXR1cm4gcy5zZXQocixbcixmLGhdKSxbcixwLGRdfSxlLmNyZWF0ZVNlc3Npb249KHQsbik9Pntjb25zdCByPSgwLGUuY3JlYXRlU2Vzc2lvbkFsbG9jYXRlKSh0KTtyZXR1cm4oMCxlLmNyZWF0ZVNlc3Npb25GaW5hbGl6ZSkocixuKX0sZS5yZWxlYXNlU2Vzc2lvbj10PT57Y29uc3QgZT0oMCxhLmdldEluc3RhbmNlKSgpLG49cy5nZXQodCk7aWYoIW4pdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBzZXNzaW9uIGlkXCIpO2NvbnN0IHI9blswXSxpPW5bMV0sbz1uWzJdO2kuZm9yRWFjaChlLl9PcnRGcmVlKSxvLmZvckVhY2goZS5fT3J0RnJlZSksZS5fT3J0UmVsZWFzZVNlc3Npb24ocikscy5kZWxldGUodCl9O2NvbnN0IHU9dD0+e3N3aXRjaCh0KXtjYXNlXCJpbnQ4XCI6cmV0dXJuIDM7Y2FzZVwidWludDhcIjpyZXR1cm4gMjtjYXNlXCJib29sXCI6cmV0dXJuIDk7Y2FzZVwiaW50MTZcIjpyZXR1cm4gNTtjYXNlXCJ1aW50MTZcIjpyZXR1cm4gNDtjYXNlXCJpbnQzMlwiOnJldHVybiA2O2Nhc2VcInVpbnQzMlwiOnJldHVybiAxMjtjYXNlXCJmbG9hdDMyXCI6cmV0dXJuIDE7Y2FzZVwiZmxvYXQ2NFwiOnJldHVybiAxMTtjYXNlXCJzdHJpbmdcIjpyZXR1cm4gODtjYXNlXCJpbnQ2NFwiOnJldHVybiA3O2Nhc2VcInVpbnQ2NFwiOnJldHVybiAxMztkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgZGF0YSB0eXBlOiAke3R9YCl9fSxjPXQ9Pntzd2l0Y2godCl7Y2FzZSAzOnJldHVyblwiaW50OFwiO2Nhc2UgMjpyZXR1cm5cInVpbnQ4XCI7Y2FzZSA5OnJldHVyblwiYm9vbFwiO2Nhc2UgNTpyZXR1cm5cImludDE2XCI7Y2FzZSA0OnJldHVyblwidWludDE2XCI7Y2FzZSA2OnJldHVyblwiaW50MzJcIjtjYXNlIDEyOnJldHVyblwidWludDMyXCI7Y2FzZSAxOnJldHVyblwiZmxvYXQzMlwiO2Nhc2UgMTE6cmV0dXJuXCJmbG9hdDY0XCI7Y2FzZSA4OnJldHVyblwic3RyaW5nXCI7Y2FzZSA3OnJldHVyblwiaW50NjRcIjtjYXNlIDEzOnJldHVyblwidWludDY0XCI7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIGRhdGEgdHlwZTogJHt0fWApfX0sbD10PT57c3dpdGNoKHQpe2Nhc2VcImZsb2F0MzJcIjpyZXR1cm4gRmxvYXQzMkFycmF5O2Nhc2VcInVpbnQ4XCI6Y2FzZVwiYm9vbFwiOnJldHVybiBVaW50OEFycmF5O2Nhc2VcImludDhcIjpyZXR1cm4gSW50OEFycmF5O2Nhc2VcInVpbnQxNlwiOnJldHVybiBVaW50MTZBcnJheTtjYXNlXCJpbnQxNlwiOnJldHVybiBJbnQxNkFycmF5O2Nhc2VcImludDMyXCI6cmV0dXJuIEludDMyQXJyYXk7Y2FzZVwiZmxvYXQ2NFwiOnJldHVybiBGbG9hdDY0QXJyYXk7Y2FzZVwidWludDMyXCI6cmV0dXJuIFVpbnQzMkFycmF5O2Nhc2VcImludDY0XCI6cmV0dXJuIEJpZ0ludDY0QXJyYXk7Y2FzZVwidWludDY0XCI6cmV0dXJuIEJpZ1VpbnQ2NEFycmF5O2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCB0eXBlOiAke3R9YCl9fTtlLnJ1bj0odCxlLG4saSxwKT0+e2NvbnN0IGY9KDAsYS5nZXRJbnN0YW5jZSkoKSxkPXMuZ2V0KHQpO2lmKCFkKXRocm93IG5ldyBFcnJvcihcImludmFsaWQgc2Vzc2lvbiBpZFwiKTtjb25zdCBoPWRbMF0sZz1kWzFdLGI9ZFsyXSxtPWUubGVuZ3RoLHk9aS5sZW5ndGg7bGV0IF89MCx2PVtdO2NvbnN0IHc9W10seD1bXTt0cnl7W18sdl09KDAsci5zZXRSdW5PcHRpb25zKShwKTtmb3IobGV0IHQ9MDt0PG07dCsrKXtjb25zdCBlPW5bdF1bMF0scj1uW3RdWzFdLGk9blt0XVsyXTtsZXQgYSxzO2lmKEFycmF5LmlzQXJyYXkoaSkpe3M9NCppLmxlbmd0aCxhPWYuX21hbGxvYyhzKSx4LnB1c2goYSk7bGV0IHQ9YS80O2ZvcihsZXQgZT0wO2U8aS5sZW5ndGg7ZSsrKXtpZihcInN0cmluZ1wiIT10eXBlb2YgaVtlXSl0aHJvdyBuZXcgVHlwZUVycm9yKGB0ZW5zb3IgZGF0YSBhdCBpbmRleCAke2V9IGlzIG5vdCBhIHN0cmluZ2ApO2YuSEVBUFUzMlt0KytdPSgwLG8uYWxsb2NXYXNtU3RyaW5nKShpW2VdLHgpfX1lbHNlIHM9aS5ieXRlTGVuZ3RoLGE9Zi5fbWFsbG9jKHMpLHgucHVzaChhKSxmLkhFQVBVOC5zZXQobmV3IFVpbnQ4QXJyYXkoaS5idWZmZXIsaS5ieXRlT2Zmc2V0LHMpLGEpO2NvbnN0IGM9Zi5zdGFja1NhdmUoKSxsPWYuc3RhY2tBbGxvYyg0KnIubGVuZ3RoKTt0cnl7bGV0IHQ9bC80O3IuZm9yRWFjaCgoZT0+Zi5IRUFQMzJbdCsrXT1lKSk7Y29uc3Qgbj1mLl9PcnRDcmVhdGVUZW5zb3IodShlKSxhLHMsbCxyLmxlbmd0aCk7aWYoMD09PW4pdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgY3JlYXRlIGEgdGVuc29yXCIpO3cucHVzaChuKX1maW5hbGx5e2Yuc3RhY2tSZXN0b3JlKGMpfX1jb25zdCB0PWYuc3RhY2tTYXZlKCksYT1mLnN0YWNrQWxsb2MoNCptKSxzPWYuc3RhY2tBbGxvYyg0Km0pLGQ9Zi5zdGFja0FsbG9jKDQqeSksVD1mLnN0YWNrQWxsb2MoNCp5KTt0cnl7bGV0IG49YS80LHI9cy80LG89ZC80LHU9VC80O2ZvcihsZXQgdD0wO3Q8bTt0KyspZi5IRUFQVTMyW24rK109d1t0XSxmLkhFQVBVMzJbcisrXT1nW2VbdF1dO2ZvcihsZXQgdD0wO3Q8eTt0KyspZi5IRUFQVTMyW28rK109MCxmLkhFQVBVMzJbdSsrXT1iW2lbdF1dO2xldCBwPWYuX09ydFJ1bihoLHMsYSxtLFQseSxkLF8pO2NvbnN0IHY9W107aWYoMD09PXApZm9yKGxldCB0PTA7dDx5O3QrKyl7Y29uc3QgZT1mLkhFQVBVMzJbZC80K3RdLG49Zi5zdGFja1NhdmUoKSxyPWYuc3RhY2tBbGxvYygxNik7bGV0IGksbz0wO3RyeXtpZihwPWYuX09ydEdldFRlbnNvckRhdGEoZSxyLHIrNCxyKzgscisxMiksMCE9PXApdGhyb3cgbmV3IEVycm9yKGBDYW4ndCBhY2Nlc3Mgb3V0cHV0IHRlbnNvciBkYXRhLiBlcnJvciBjb2RlID0gJHtwfWApO2xldCB0PXIvNDtjb25zdCBhPWYuSEVBUFUzMlt0KytdO289Zi5IRUFQVTMyW3QrK107Y29uc3Qgcz1mLkhFQVBVMzJbdCsrXSx1PWYuSEVBUFUzMlt0KytdLGQ9W107Zm9yKGxldCB0PTA7dDx1O3QrKylkLnB1c2goZi5IRUFQVTMyW3MvNCt0XSk7Zi5fT3J0RnJlZShzKTtjb25zdCBoPTA9PT1kLmxlbmd0aD8xOmQucmVkdWNlKCgodCxlKT0+dCplKSk7aWYoaT1jKGEpLFwic3RyaW5nXCI9PT1pKXtjb25zdCB0PVtdO2xldCBlPW8vNDtmb3IobGV0IG49MDtuPGg7bisrKXtjb25zdCByPWYuSEVBUFUzMltlKytdLGk9bj09PWgtMT92b2lkIDA6Zi5IRUFQVTMyW2VdLXI7dC5wdXNoKGYuVVRGOFRvU3RyaW5nKHIsaSkpfXYucHVzaChbaSxkLHRdKX1lbHNle2NvbnN0IHQ9bmV3KGwoaSkpKGgpO25ldyBVaW50OEFycmF5KHQuYnVmZmVyLHQuYnl0ZU9mZnNldCx0LmJ5dGVMZW5ndGgpLnNldChmLkhFQVBVOC5zdWJhcnJheShvLG8rdC5ieXRlTGVuZ3RoKSksdi5wdXNoKFtpLGQsdF0pfX1maW5hbGx5e2Yuc3RhY2tSZXN0b3JlKG4pLFwic3RyaW5nXCI9PT1pJiZvJiZmLl9mcmVlKG8pLGYuX09ydFJlbGVhc2VUZW5zb3IoZSl9fWlmKDA9PT1wKXJldHVybiB2O3Rocm93IG5ldyBFcnJvcihgZmFpbGVkIHRvIGNhbGwgT3J0UnVuKCkuIGVycm9yIGNvZGUgPSAke3B9LmApfWZpbmFsbHl7Zi5zdGFja1Jlc3RvcmUodCl9fWZpbmFsbHl7dy5mb3JFYWNoKGYuX09ydFJlbGVhc2VUZW5zb3IpLHguZm9yRWFjaChmLl9mcmVlKSxmLl9PcnRSZWxlYXNlUnVuT3B0aW9ucyhfKSx2LmZvckVhY2goZi5fZnJlZSl9fSxlLmVuZFByb2ZpbGluZz10PT57Y29uc3QgZT0oMCxhLmdldEluc3RhbmNlKSgpLG49cy5nZXQodCk7aWYoIW4pdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBzZXNzaW9uIGlkXCIpO2NvbnN0IHI9blswXSxpPWUuX09ydEVuZFByb2ZpbGluZyhyKTtpZigwPT09aSl0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBnZXQgYW4gcHJvZmlsZSBmaWxlIG5hbWVcIik7ZS5fT3J0RnJlZShpKX0sZS5leHRyYWN0VHJhbnNmZXJhYmxlQnVmZmVycz10PT57Y29uc3QgZT1bXTtmb3IoY29uc3QgbiBvZiB0KXtjb25zdCB0PW5bMl07IUFycmF5LmlzQXJyYXkodCkmJnQuYnVmZmVyJiZlLnB1c2godC5idWZmZXIpfXJldHVybiBlfX0sNjM2MTpmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7dmFyIHI9dGhpcyYmdGhpcy5fX2NyZWF0ZUJpbmRpbmd8fChPYmplY3QuY3JlYXRlP2Z1bmN0aW9uKHQsZSxuLHIpe3ZvaWQgMD09PXImJihyPW4pO3ZhciBpPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSxuKTtpJiYhKFwiZ2V0XCJpbiBpPyFlLl9fZXNNb2R1bGU6aS53cml0YWJsZXx8aS5jb25maWd1cmFibGUpfHwoaT17ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gZVtuXX19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCxyLGkpfTpmdW5jdGlvbih0LGUsbixyKXt2b2lkIDA9PT1yJiYocj1uKSx0W3JdPWVbbl19KSxpPXRoaXMmJnRoaXMuX19zZXRNb2R1bGVEZWZhdWx0fHwoT2JqZWN0LmNyZWF0ZT9mdW5jdGlvbih0LGUpe09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiZGVmYXVsdFwiLHtlbnVtZXJhYmxlOiEwLHZhbHVlOmV9KX06ZnVuY3Rpb24odCxlKXt0LmRlZmF1bHQ9ZX0pLG89dGhpcyYmdGhpcy5fX2ltcG9ydFN0YXJ8fGZ1bmN0aW9uKHQpe2lmKHQmJnQuX19lc01vZHVsZSlyZXR1cm4gdDt2YXIgZT17fTtpZihudWxsIT10KWZvcih2YXIgbiBpbiB0KVwiZGVmYXVsdFwiIT09biYmT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQsbikmJnIoZSx0LG4pO3JldHVybiBpKGUsdCksZX0sYT10aGlzJiZ0aGlzLl9faW1wb3J0RGVmYXVsdHx8ZnVuY3Rpb24odCl7cmV0dXJuIHQmJnQuX19lc01vZHVsZT90OntkZWZhdWx0OnR9fTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLmRpc3Bvc2U9ZS5nZXRJbnN0YW5jZT1lLmluaXRpYWxpemVXZWJBc3NlbWJseT12b2lkIDA7Y29uc3Qgcz1vKG4oMTQyMykpLHU9YShuKDkzMikpLGM9bigzNDc0KTtsZXQgbCxwPSExLGY9ITEsZD0hMTtjb25zdCBoPSh0LGUpPT5lP3Q/XCJvcnQtd2FzbS1zaW1kLXRocmVhZGVkLndhc21cIjpcIm9ydC13YXNtLXRocmVhZGVkLndhc21cIjp0P1wib3J0LXdhc20tc2ltZC53YXNtXCI6XCJvcnQtd2FzbS53YXNtXCI7ZS5pbml0aWFsaXplV2ViQXNzZW1ibHk9YXN5bmMgdD0+e2lmKHApcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO2lmKGYpdGhyb3cgbmV3IEVycm9yKFwibXVsdGlwbGUgY2FsbHMgdG8gJ2luaXRpYWxpemVXZWJBc3NlbWJseSgpJyBkZXRlY3RlZC5cIik7aWYoZCl0aHJvdyBuZXcgRXJyb3IoXCJwcmV2aW91cyBjYWxsIHRvICdpbml0aWFsaXplV2ViQXNzZW1ibHkoKScgZmFpbGVkLlwiKTtmPSEwO2NvbnN0IGU9dC5pbml0VGltZW91dCxyPXQubnVtVGhyZWFkcyxpPXQuc2ltZCxvPXI+MSYmKCgpPT57dHJ5e3JldHVyblwidW5kZWZpbmVkXCIhPXR5cGVvZiBTaGFyZWRBcnJheUJ1ZmZlciYmKFwidW5kZWZpbmVkXCIhPXR5cGVvZiBNZXNzYWdlQ2hhbm5lbCYmKG5ldyBNZXNzYWdlQ2hhbm5lbCkucG9ydDEucG9zdE1lc3NhZ2UobmV3IFNoYXJlZEFycmF5QnVmZmVyKDEpKSxXZWJBc3NlbWJseS52YWxpZGF0ZShuZXcgVWludDhBcnJheShbMCw5NywxMTUsMTA5LDEsMCwwLDAsMSw0LDEsOTYsMCwwLDMsMiwxLDAsNSw0LDEsMywxLDEsMTAsMTEsMSw5LDAsNjUsMCwyNTQsMTYsMiwwLDI2LDExXSkpKX1jYXRjaCh0KXtyZXR1cm4hMX19KSgpLGE9aSYmKCgpPT57dHJ5e3JldHVybiBXZWJBc3NlbWJseS52YWxpZGF0ZShuZXcgVWludDhBcnJheShbMCw5NywxMTUsMTA5LDEsMCwwLDAsMSw0LDEsOTYsMCwwLDMsMiwxLDAsMTAsMzAsMSwyOCwwLDY1LDAsMjUzLDE1LDI1MywxMiwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDI1MywxODYsMSwyNiwxMV0pKX1jYXRjaCh0KXtyZXR1cm4hMX19KSgpLGc9XCJzdHJpbmdcIj09dHlwZW9mIHQud2FzbVBhdGhzP3Qud2FzbVBhdGhzOnZvaWQgMCxiPWgoITEsbyksbT1oKGEsbykseT1cIm9iamVjdFwiPT10eXBlb2YgdC53YXNtUGF0aHM/dC53YXNtUGF0aHNbbV06dm9pZCAwO2xldCBfPSExO2NvbnN0IHY9W107aWYoZT4wJiZ2LnB1c2gobmV3IFByb21pc2UoKHQ9PntzZXRUaW1lb3V0KCgoKT0+e189ITAsdCgpfSksZSl9KSkpLHYucHVzaChuZXcgUHJvbWlzZSgoKHQsZSk9Pntjb25zdCByPW8/Yzp1LmRlZmF1bHQsaT17bG9jYXRlRmlsZToodCxlKT0+byYmdC5lbmRzV2l0aChcIi53b3JrZXIuanNcIikmJlwidW5kZWZpbmVkXCIhPXR5cGVvZiBCbG9iP1VSTC5jcmVhdGVPYmplY3RVUkwobmV3IEJsb2IoW24oNDE1NCldLHt0eXBlOlwidGV4dC9qYXZhc2NyaXB0XCJ9KSk6dD09PWI/bnVsbCE9eT95OihudWxsIT1nP2c6ZSkrbTplK3R9O2lmKG8paWYoXCJ1bmRlZmluZWRcIj09dHlwZW9mIEJsb2IpaS5tYWluU2NyaXB0VXJsT3JCbG9iPXMuam9pbihfX2Rpcm5hbWUsXCJvcnQtd2FzbS10aHJlYWRlZC5qc1wiKTtlbHNle2NvbnN0IHQ9YHZhciBvcnRXYXNtVGhyZWFkZWQ9KGZ1bmN0aW9uKCl7dmFyIF9zY3JpcHREaXI7cmV0dXJuICR7ci50b1N0cmluZygpfX0pKCk7YDtpLm1haW5TY3JpcHRVcmxPckJsb2I9bmV3IEJsb2IoW3RdLHt0eXBlOlwidGV4dC9qYXZhc2NyaXB0XCJ9KX1yKGkpLnRoZW4oKGU9PntmPSExLHA9ITAsbD1lLHQoKX0pLCh0PT57Zj0hMSxkPSEwLGUodCl9KSl9KSkpLGF3YWl0IFByb21pc2UucmFjZSh2KSxfKXRocm93IG5ldyBFcnJvcihgV2ViQXNzZW1ibHkgYmFja2VuZCBpbml0aWFsaXppbmcgZmFpbGVkIGR1ZSB0byB0aW1lb3V0OiAke2V9bXNgKX0sZS5nZXRJbnN0YW5jZT0oKT0+e2lmKHAmJmwpcmV0dXJuIGw7dGhyb3cgbmV3IEVycm9yKFwiV2ViQXNzZW1ibHkgaXMgbm90IGluaXRpYWxpemVkIHlldC5cIil9LGUuZGlzcG9zZT0oKT0+e3ZhciB0OyFwfHxmfHxkfHwoZj0hMCxudWxsPT09KHQ9bC5QVGhyZWFkKXx8dm9pZCAwPT09dHx8dC50ZXJtaW5hdGVBbGxUaHJlYWRzKCksbD12b2lkIDAsZj0hMSxwPSExLGQ9ITApfX0sOTcxMDoodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7bi5kKGUse1o6KCk9Pm99KTt2YXIgcj1uKDQ3NyksaT1uLm4ocik7ZnVuY3Rpb24gbygpe3JldHVybiBpKCkoJy8qIVxcbiogT05OWCBSdW50aW1lIFdlYiB2MS4xNC4wXFxuKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cXG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cXG4qL1xcbigoKT0+e3ZhciB0PXs0NzQ6KHQsZSxuKT0+e3ZhciBfc2NyaXB0RGlyLHI9KF9zY3JpcHREaXI9KF9zY3JpcHREaXI9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGRvY3VtZW50JiZkb2N1bWVudC5jdXJyZW50U2NyaXB0P2RvY3VtZW50LmN1cnJlbnRTY3JpcHQuc3JjOnZvaWQgMCl8fF9fZmlsZW5hbWUsZnVuY3Rpb24odCl7ZnVuY3Rpb24gZSgpe3JldHVybiBrLmJ1ZmZlciE9RCYmTihrLmJ1ZmZlciksUH1mdW5jdGlvbiByKCl7cmV0dXJuIGsuYnVmZmVyIT1EJiZOKGsuYnVmZmVyKSxVfWZ1bmN0aW9uIGEoKXtyZXR1cm4gay5idWZmZXIhPUQmJk4oay5idWZmZXIpLEZ9ZnVuY3Rpb24gaSgpe3JldHVybiBrLmJ1ZmZlciE9RCYmTihrLmJ1ZmZlciksSX1mdW5jdGlvbiBvKCl7cmV0dXJuIGsuYnVmZmVyIT1EJiZOKGsuYnVmZmVyKSxXfXZhciB1LHMsYzt0PXR8fHt9LHV8fCh1PXZvaWQgMCE9PXQ/dDp7fSksdS5yZWFkeT1uZXcgUHJvbWlzZSgoZnVuY3Rpb24odCxlKXtzPXQsYz1lfSkpO3ZhciBsLGYscCxoLGQseSxiPU9iamVjdC5hc3NpZ24oe30sdSksbT1cIi4vdGhpcy5wcm9ncmFtXCIsZz0odCxlKT0+e3Rocm93IGV9LHY9XCJvYmplY3RcIj09dHlwZW9mIHdpbmRvdyxfPVwiZnVuY3Rpb25cIj09dHlwZW9mIGltcG9ydFNjcmlwdHMsdz1cIm9iamVjdFwiPT10eXBlb2YgcHJvY2VzcyYmXCJvYmplY3RcIj09dHlwZW9mIHByb2Nlc3MudmVyc2lvbnMmJlwic3RyaW5nXCI9PXR5cGVvZiBwcm9jZXNzLnZlcnNpb25zLm5vZGUsTz11LkVOVklST05NRU5UX0lTX1BUSFJFQUR8fCExLEE9XCJcIjtmdW5jdGlvbiBTKHQpe3JldHVybiB1LmxvY2F0ZUZpbGU/dS5sb2NhdGVGaWxlKHQsQSk6QSt0fWlmKHcpe2xldCBlO0E9Xz9uKDE3KS5kaXJuYW1lKEEpK1wiL1wiOl9fZGlybmFtZStcIi9cIix5PSgpPT57ZHx8KGg9bigxNDcpLGQ9bigxNykpfSxsPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHkoKSx0PWQubm9ybWFsaXplKHQpLGgucmVhZEZpbGVTeW5jKHQsZT92b2lkIDA6XCJ1dGY4XCIpfSxwPXQ9PigodD1sKHQsITApKS5idWZmZXJ8fCh0PW5ldyBVaW50OEFycmF5KHQpKSx0KSxmPSh0LGUsbik9Pnt5KCksdD1kLm5vcm1hbGl6ZSh0KSxoLnJlYWRGaWxlKHQsKGZ1bmN0aW9uKHQscil7dD9uKHQpOmUoci5idWZmZXIpfSkpfSwxPHByb2Nlc3MuYXJndi5sZW5ndGgmJihtPXByb2Nlc3MuYXJndlsxXS5yZXBsYWNlKC9cXFxcXFxcXC9nLFwiL1wiKSkscHJvY2Vzcy5hcmd2LnNsaWNlKDIpLHByb2Nlc3Mub24oXCJ1bmNhdWdodEV4Y2VwdGlvblwiLChmdW5jdGlvbih0KXtpZighKHQgaW5zdGFuY2VvZiBzdCkpdGhyb3cgdH0pKSxwcm9jZXNzLm9uKFwidW5oYW5kbGVkUmVqZWN0aW9uXCIsKGZ1bmN0aW9uKHQpe3Rocm93IHR9KSksZz0odCxlKT0+e2lmKFEoKSl0aHJvdyBwcm9jZXNzLmV4aXRDb2RlPXQsZTtlIGluc3RhbmNlb2Ygc3R8fHgoXCJleGl0aW5nIGR1ZSB0byBleGNlcHRpb246IFwiK2UpLHByb2Nlc3MuZXhpdCh0KX0sdS5pbnNwZWN0PWZ1bmN0aW9uKCl7cmV0dXJuXCJbRW1zY3JpcHRlbiBNb2R1bGUgb2JqZWN0XVwifTt0cnl7ZT1uKDI2Nyl9Y2F0Y2godCl7dGhyb3cgY29uc29sZS5lcnJvcihcXCdUaGUgXCJ3b3JrZXJfdGhyZWFkc1wiIG1vZHVsZSBpcyBub3Qgc3VwcG9ydGVkIGluIHRoaXMgbm9kZS5qcyBidWlsZCAtIHBlcmhhcHMgYSBuZXdlciB2ZXJzaW9uIGlzIG5lZWRlZD9cXCcpLHR9Z2xvYmFsLldvcmtlcj1lLldvcmtlcn1lbHNlKHZ8fF8pJiYoXz9BPXNlbGYubG9jYXRpb24uaHJlZjpcInVuZGVmaW5lZFwiIT10eXBlb2YgZG9jdW1lbnQmJmRvY3VtZW50LmN1cnJlbnRTY3JpcHQmJihBPWRvY3VtZW50LmN1cnJlbnRTY3JpcHQuc3JjKSxfc2NyaXB0RGlyJiYoQT1fc2NyaXB0RGlyKSxBPTAhPT1BLmluZGV4T2YoXCJibG9iOlwiKT9BLnN1YnN0cigwLEEucmVwbGFjZSgvWz8jXS4qLyxcIlwiKS5sYXN0SW5kZXhPZihcIi9cIikrMSk6XCJcIix3fHwobD10PT57dmFyIGU9bmV3IFhNTEh0dHBSZXF1ZXN0O3JldHVybiBlLm9wZW4oXCJHRVRcIix0LCExKSxlLnNlbmQobnVsbCksZS5yZXNwb25zZVRleHR9LF8mJihwPXQ9Pnt2YXIgZT1uZXcgWE1MSHR0cFJlcXVlc3Q7cmV0dXJuIGUub3BlbihcIkdFVFwiLHQsITEpLGUucmVzcG9uc2VUeXBlPVwiYXJyYXlidWZmZXJcIixlLnNlbmQobnVsbCksbmV3IFVpbnQ4QXJyYXkoZS5yZXNwb25zZSl9KSxmPSh0LGUsbik9Pnt2YXIgcj1uZXcgWE1MSHR0cFJlcXVlc3Q7ci5vcGVuKFwiR0VUXCIsdCwhMCksci5yZXNwb25zZVR5cGU9XCJhcnJheWJ1ZmZlclwiLHIub25sb2FkPSgpPT57MjAwPT1yLnN0YXR1c3x8MD09ci5zdGF0dXMmJnIucmVzcG9uc2U/ZShyLnJlc3BvbnNlKTpuKCl9LHIub25lcnJvcj1uLHIuc2VuZChudWxsKX0pKTt3JiZcInVuZGVmaW5lZFwiPT10eXBlb2YgcGVyZm9ybWFuY2UmJihnbG9iYWwucGVyZm9ybWFuY2U9big3NCkucGVyZm9ybWFuY2UpO3ZhciBUPWNvbnNvbGUubG9nLmJpbmQoY29uc29sZSksRT1jb25zb2xlLndhcm4uYmluZChjb25zb2xlKTt3JiYoeSgpLFQ9dD0+aC53cml0ZVN5bmMoMSx0K1wiXFxcXG5cIiksRT10PT5oLndyaXRlU3luYygyLHQrXCJcXFxcblwiKSk7dmFyIE0sQz11LnByaW50fHxULHg9dS5wcmludEVycnx8RTtPYmplY3QuYXNzaWduKHUsYiksYj1udWxsLHUudGhpc1Byb2dyYW0mJihtPXUudGhpc1Byb2dyYW0pLHUucXVpdCYmKGc9dS5xdWl0KSx1Lndhc21CaW5hcnkmJihNPXUud2FzbUJpbmFyeSk7dmFyIFI9dS5ub0V4aXRSdW50aW1lfHwhMTtcIm9iamVjdFwiIT10eXBlb2YgV2ViQXNzZW1ibHkmJmF0KFwibm8gbmF0aXZlIHdhc20gc3VwcG9ydCBkZXRlY3RlZFwiKTt2YXIgayxqLEQsUCxVLEYsSSxXLEg9ITEsej1cInVuZGVmaW5lZFwiIT10eXBlb2YgVGV4dERlY29kZXI/bmV3IFRleHREZWNvZGVyKFwidXRmOFwiKTp2b2lkIDA7ZnVuY3Rpb24gTCh0LGUsbil7dmFyIHI9KGU+Pj49MCkrbjtmb3Iobj1lO3Rbbl0mJiEobj49cik7KSsrbjtpZigxNjxuLWUmJnQuYnVmZmVyJiZ6KXJldHVybiB6LmRlY29kZSh0LmJ1ZmZlciBpbnN0YW5jZW9mIFNoYXJlZEFycmF5QnVmZmVyP3Quc2xpY2UoZSxuKTp0LnN1YmFycmF5KGUsbikpO2ZvcihyPVwiXCI7ZTxuOyl7dmFyIGE9dFtlKytdO2lmKDEyOCZhKXt2YXIgaT02MyZ0W2UrK107aWYoMTkyPT0oMjI0JmEpKXIrPVN0cmluZy5mcm9tQ2hhckNvZGUoKDMxJmEpPDw2fGkpO2Vsc2V7dmFyIG89NjMmdFtlKytdOzY1NTM2PihhPTIyND09KDI0MCZhKT8oMTUmYSk8PDEyfGk8PDZ8bzooNyZhKTw8MTh8aTw8MTJ8bzw8Nnw2MyZ0W2UrK10pP3IrPVN0cmluZy5mcm9tQ2hhckNvZGUoYSk6KGEtPTY1NTM2LHIrPVN0cmluZy5mcm9tQ2hhckNvZGUoNTUyOTZ8YT4+MTAsNTYzMjB8MTAyMyZhKSl9fWVsc2Ugcis9U3RyaW5nLmZyb21DaGFyQ29kZShhKX1yZXR1cm4gcn1mdW5jdGlvbiBZKHQsZSl7cmV0dXJuKHQ+Pj49MCk/TChyKCksdCxlKTpcIlwifWZ1bmN0aW9uIEIodCxlLG4scil7aWYoISgwPHIpKXJldHVybiAwO3ZhciBhPW4+Pj49MDtyPW4rci0xO2Zvcih2YXIgaT0wO2k8dC5sZW5ndGg7KytpKXt2YXIgbz10LmNoYXJDb2RlQXQoaSk7aWYoNTUyOTY8PW8mJjU3MzQzPj1vJiYobz02NTUzNisoKDEwMjMmbyk8PDEwKXwxMDIzJnQuY2hhckNvZGVBdCgrK2kpKSwxMjc+PW8pe2lmKG4+PXIpYnJlYWs7ZVtuKys+Pj4wXT1vfWVsc2V7aWYoMjA0Nz49byl7aWYobisxPj1yKWJyZWFrO2VbbisrPj4+MF09MTkyfG8+PjZ9ZWxzZXtpZig2NTUzNT49byl7aWYobisyPj1yKWJyZWFrO2VbbisrPj4+MF09MjI0fG8+PjEyfWVsc2V7aWYobiszPj1yKWJyZWFrO2VbbisrPj4+MF09MjQwfG8+PjE4LGVbbisrPj4+MF09MTI4fG8+PjEyJjYzfWVbbisrPj4+MF09MTI4fG8+PjYmNjN9ZVtuKys+Pj4wXT0xMjh8NjMmb319cmV0dXJuIGVbbj4+PjBdPTAsbi1hfWZ1bmN0aW9uIEcodCl7Zm9yKHZhciBlPTAsbj0wO248dC5sZW5ndGg7KytuKXt2YXIgcj10LmNoYXJDb2RlQXQobik7MTI3Pj1yP2UrKzoyMDQ3Pj1yP2UrPTI6NTUyOTY8PXImJjU3MzQzPj1yPyhlKz00LCsrbik6ZSs9M31yZXR1cm4gZX1mdW5jdGlvbiBOKHQpe0Q9dCx1LkhFQVA4PVA9bmV3IEludDhBcnJheSh0KSx1LkhFQVAxNj1uZXcgSW50MTZBcnJheSh0KSx1LkhFQVAzMj1GPW5ldyBJbnQzMkFycmF5KHQpLHUuSEVBUFU4PVU9bmV3IFVpbnQ4QXJyYXkodCksdS5IRUFQVTE2PW5ldyBVaW50MTZBcnJheSh0KSx1LkhFQVBVMzI9ST1uZXcgVWludDMyQXJyYXkodCksdS5IRUFQRjMyPW5ldyBGbG9hdDMyQXJyYXkodCksdS5IRUFQRjY0PVc9bmV3IEZsb2F0NjRBcnJheSh0KX1PJiYoRD11LmJ1ZmZlcik7dmFyIFY9dS5JTklUSUFMX01FTU9SWXx8MTY3NzcyMTY7aWYoTylrPXUud2FzbU1lbW9yeSxEPXUuYnVmZmVyO2Vsc2UgaWYodS53YXNtTWVtb3J5KWs9dS53YXNtTWVtb3J5O2Vsc2UgaWYoISgoaz1uZXcgV2ViQXNzZW1ibHkuTWVtb3J5KHtpbml0aWFsOlYvNjU1MzYsbWF4aW11bTo2NTUzNixzaGFyZWQ6ITB9KSkuYnVmZmVyIGluc3RhbmNlb2YgU2hhcmVkQXJyYXlCdWZmZXIpKXRocm93IHgoXCJyZXF1ZXN0ZWQgYSBzaGFyZWQgV2ViQXNzZW1ibHkuTWVtb3J5IGJ1dCB0aGUgcmV0dXJuZWQgYnVmZmVyIGlzIG5vdCBhIFNoYXJlZEFycmF5QnVmZmVyLCBpbmRpY2F0aW5nIHRoYXQgd2hpbGUgdGhlIGJyb3dzZXIgaGFzIFNoYXJlZEFycmF5QnVmZmVyIGl0IGRvZXMgbm90IGhhdmUgV2ViQXNzZW1ibHkgdGhyZWFkcyBzdXBwb3J0IC0geW91IG1heSBuZWVkIHRvIHNldCBhIGZsYWdcIiksdyYmY29uc29sZS5sb2coXCIob24gbm9kZSB5b3UgbWF5IG5lZWQ6IC0tZXhwZXJpbWVudGFsLXdhc20tdGhyZWFkcyAtLWV4cGVyaW1lbnRhbC13YXNtLWJ1bGstbWVtb3J5IGFuZCBhbHNvIHVzZSBhIHJlY2VudCB2ZXJzaW9uKVwiKSxFcnJvcihcImJhZCBtZW1vcnlcIik7ayYmKEQ9ay5idWZmZXIpLFY9RC5ieXRlTGVuZ3RoLE4oRCk7dmFyIHEsJD1bXSxYPVtdLEo9W10sWj1bXTtmdW5jdGlvbiBRKCl7cmV0dXJuIFJ8fCExfWZ1bmN0aW9uIEsoKXt2YXIgdD11LnByZVJ1bi5zaGlmdCgpOyQudW5zaGlmdCh0KX12YXIgdHQsZXQ9MCxudD1udWxsLHJ0PW51bGw7ZnVuY3Rpb24gYXQodCl7dGhyb3cgTz9wb3N0TWVzc2FnZSh7Y21kOlwib25BYm9ydFwiLGFyZzp0fSk6dS5vbkFib3J0JiZ1Lm9uQWJvcnQodCkseCh0PVwiQWJvcnRlZChcIit0K1wiKVwiKSxIPSEwLHQ9bmV3IFdlYkFzc2VtYmx5LlJ1bnRpbWVFcnJvcih0K1wiLiBCdWlsZCB3aXRoIC1zQVNTRVJUSU9OUyBmb3IgbW9yZSBpbmZvLlwiKSxjKHQpLHR9ZnVuY3Rpb24gaXQoKXtyZXR1cm4gdHQuc3RhcnRzV2l0aChcImRhdGE6YXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtO2Jhc2U2NCxcIil9ZnVuY3Rpb24gb3QoKXt2YXIgdD10dDt0cnl7aWYodD09dHQmJk0pcmV0dXJuIG5ldyBVaW50OEFycmF5KE0pO2lmKHApcmV0dXJuIHAodCk7dGhyb3dcImJvdGggYXN5bmMgYW5kIHN5bmMgZmV0Y2hpbmcgb2YgdGhlIHdhc20gZmFpbGVkXCJ9Y2F0Y2godCl7YXQodCl9fXR0PVwib3J0LXdhc20tdGhyZWFkZWQud2FzbVwiLGl0KCl8fCh0dD1TKHR0KSk7dmFyIHV0PXt9O2Z1bmN0aW9uIHN0KHQpe3RoaXMubmFtZT1cIkV4aXRTdGF0dXNcIix0aGlzLm1lc3NhZ2U9XCJQcm9ncmFtIHRlcm1pbmF0ZWQgd2l0aCBleGl0KFwiK3QrXCIpXCIsdGhpcy5zdGF0dXM9dH1mdW5jdGlvbiBjdCh0KXsodD1odC5WYlt0XSl8fGF0KCksaHQubWModCl9ZnVuY3Rpb24gbHQodCl7dmFyIGU9aHQuQ2MoKTtpZighZSlyZXR1cm4gNjtodC5hYy5wdXNoKGUpLGh0LlZiW3QuVWJdPWUsZS5VYj10LlViO3ZhciBuPXtjbWQ6XCJydW5cIixzdGFydF9yb3V0aW5lOnQuSWMsYXJnOnQuemMscHRocmVhZF9wdHI6dC5VYn07cmV0dXJuIGUuJGI9KCk9PntuLnRpbWU9cGVyZm9ybWFuY2Uubm93KCksZS5wb3N0TWVzc2FnZShuLHQuTmMpfSxlLmxvYWRlZCYmKGUuJGIoKSxkZWxldGUgZS4kYiksMH1mdW5jdGlvbiBmdCh0KXtpZihPKXJldHVybiBxdCgxLDEsdCk7USgpfHwoaHQub2MoKSx1Lm9uRXhpdCYmdS5vbkV4aXQodCksSD0hMCksZyh0LG5ldyBzdCh0KSl9ZnVuY3Rpb24gcHQodCxlKXtpZighZSYmTyl0aHJvdyBidCh0KSxcInVud2luZFwiO1EoKXx8T3x8KG1lKCksZHQoSiksYmUoMCkscmVbMV0ubGVuZ3RoJiZhZSgxLDEwKSxyZVsyXS5sZW5ndGgmJmFlKDIsMTApLGh0Lm9jKCkpLGZ0KHQpfXZhciBodD17WWI6W10sYWM6W10scWM6W10sVmI6e30sZmM6ZnVuY3Rpb24oKXtPJiZodC5FYygpfSxQYzpmdW5jdGlvbigpe30sRWM6ZnVuY3Rpb24oKXtodC5yZWNlaXZlT2JqZWN0VHJhbnNmZXI9aHQuR2MsaHQudGhyZWFkSW5pdFRMUz1odC5wYyxodC5zZXRFeGl0U3RhdHVzPWh0Lm5jLFI9ITF9LG5jOmZ1bmN0aW9uKCl7fSxvYzpmdW5jdGlvbigpe2Zvcih2YXIgdCBvZiBPYmplY3QudmFsdWVzKGh0LlZiKSlodC5tYyh0KTtmb3IodCBvZiBodC5ZYil0LnRlcm1pbmF0ZSgpO2h0LlliPVtdfSxtYzpmdW5jdGlvbih0KXt2YXIgZT10LlViO2RlbGV0ZSBodC5WYltlXSxodC5ZYi5wdXNoKHQpLGh0LmFjLnNwbGljZShodC5hYy5pbmRleE9mKHQpLDEpLHQuVWI9MCxPZShlKX0sR2M6ZnVuY3Rpb24oKXt9LHBjOmZ1bmN0aW9uKCl7aHQucWMuZm9yRWFjaCgodD0+dCgpKSl9LEZjOmZ1bmN0aW9uKHQsZSl7dC5vbm1lc3NhZ2U9bj0+e3ZhciByPShuPW4uZGF0YSkuY21kO2lmKHQuVWImJihodC5CYz10LlViKSxuLnRhcmdldFRocmVhZCYmbi50YXJnZXRUaHJlYWQhPWhlKCkpe3ZhciBhPWh0LlZiW24uUWNdO2E/YS5wb3N0TWVzc2FnZShuLG4udHJhbnNmZXJMaXN0KTp4KFxcJ0ludGVybmFsIGVycm9yISBXb3JrZXIgc2VudCBhIG1lc3NhZ2UgXCJcXCcrcitcXCdcIiB0byB0YXJnZXQgcHRocmVhZCBcXCcrbi50YXJnZXRUaHJlYWQrXCIsIGJ1dCB0aGF0IHRocmVhZCBubyBsb25nZXIgZXhpc3RzIVwiKX1lbHNlXCJwcm9jZXNzUHJveHlpbmdRdWV1ZVwiPT09cj9MdChuLnF1ZXVlKTpcInNwYXduVGhyZWFkXCI9PT1yP2x0KG4pOlwiY2xlYW51cFRocmVhZFwiPT09cj9jdChuLnRocmVhZCk6XCJraWxsVGhyZWFkXCI9PT1yPyhuPW4udGhyZWFkLHI9aHQuVmJbbl0sZGVsZXRlIGh0LlZiW25dLHIudGVybWluYXRlKCksT2UobiksaHQuYWMuc3BsaWNlKGh0LmFjLmluZGV4T2YociksMSksci5VYj0wKTpcImNhbmNlbFRocmVhZFwiPT09cj9odC5WYltuLnRocmVhZF0ucG9zdE1lc3NhZ2Uoe2NtZDpcImNhbmNlbFwifSk6XCJsb2FkZWRcIj09PXI/KHQubG9hZGVkPSEwLGUmJmUodCksdC4kYiYmKHQuJGIoKSxkZWxldGUgdC4kYikpOlwicHJpbnRcIj09PXI/QyhcIlRocmVhZCBcIituLnRocmVhZElkK1wiOiBcIituLnRleHQpOlwicHJpbnRFcnJcIj09PXI/eChcIlRocmVhZCBcIituLnRocmVhZElkK1wiOiBcIituLnRleHQpOlwiYWxlcnRcIj09PXI/YWxlcnQoXCJUaHJlYWQgXCIrbi50aHJlYWRJZCtcIjogXCIrbi50ZXh0KTpcInNldGltbWVkaWF0ZVwiPT09bi50YXJnZXQ/dC5wb3N0TWVzc2FnZShuKTpcIm9uQWJvcnRcIj09PXI/dS5vbkFib3J0JiZ1Lm9uQWJvcnQobi5hcmcpOnImJngoXCJ3b3JrZXIgc2VudCBhbiB1bmtub3duIGNvbW1hbmQgXCIrcik7aHQuQmM9dm9pZCAwfSx0Lm9uZXJyb3I9dD0+e3Rocm93IHgoXCJ3b3JrZXIgc2VudCBhbiBlcnJvciEgXCIrdC5maWxlbmFtZStcIjpcIit0LmxpbmVubytcIjogXCIrdC5tZXNzYWdlKSx0fSx3JiYodC5vbihcIm1lc3NhZ2VcIiwoZnVuY3Rpb24oZSl7dC5vbm1lc3NhZ2Uoe2RhdGE6ZX0pfSkpLHQub24oXCJlcnJvclwiLChmdW5jdGlvbihlKXt0Lm9uZXJyb3IoZSl9KSksdC5vbihcImRldGFjaGVkRXhpdFwiLChmdW5jdGlvbigpe30pKSksdC5wb3N0TWVzc2FnZSh7Y21kOlwibG9hZFwiLHVybE9yQmxvYjp1Lm1haW5TY3JpcHRVcmxPckJsb2J8fF9zY3JpcHREaXIsd2FzbU1lbW9yeTprLHdhc21Nb2R1bGU6an0pfSx5YzpmdW5jdGlvbigpe3ZhciB0PVMoXCJvcnQtd2FzbS10aHJlYWRlZC53b3JrZXIuanNcIik7aHQuWWIucHVzaChuZXcgV29ya2VyKHQpKX0sQ2M6ZnVuY3Rpb24oKXtyZXR1cm4gMD09aHQuWWIubGVuZ3RoJiYoaHQueWMoKSxodC5GYyhodC5ZYlswXSkpLGh0LlliLnBvcCgpfX07ZnVuY3Rpb24gZHQodCl7Zm9yKDswPHQubGVuZ3RoOyl0LnNoaWZ0KCkodSl9ZnVuY3Rpb24geXQodCl7dmFyIGU9RWUoKTtyZXR1cm4gdD10KCksTWUoZSksdH1mdW5jdGlvbiBidCh0KXtpZihPKXJldHVybiBxdCgyLDAsdCk7dHJ5e3B0KHQpfWNhdGNoKHQpe3QgaW5zdGFuY2VvZiBzdHx8XCJ1bndpbmRcIj09dHx8ZygxLHQpfX11LlBUaHJlYWQ9aHQsdS5lc3RhYmxpc2hTdGFja1NwYWNlPWZ1bmN0aW9uKCl7dmFyIHQ9aGUoKSxlPWEoKVt0KzQ0Pj4yPj4+MF07dD1hKClbdCs0OD4+Mj4+PjBdLFRlKGUsZS10KSxNZShlKX07dmFyIG10PVtdO2Z1bmN0aW9uIGd0KHQpe3ZhciBlPW10W3RdO3JldHVybiBlfHwodD49bXQubGVuZ3RoJiYobXQubGVuZ3RoPXQrMSksbXRbdF09ZT1xLmdldCh0KSksZX11Lmludm9rZUVudHJ5UG9pbnQ9ZnVuY3Rpb24odCxlKXt0PWd0KHQpKGUpLFEoKT9odC5uYyh0KTpBZSh0KX07dmFyIHZ0LF90LHd0PVtdLE90PTAsQXQ9MDtmdW5jdGlvbiBTdCh0KXt0aGlzLlpiPXQsdGhpcy5TYj10LTI0LHRoaXMueGM9ZnVuY3Rpb24odCl7aSgpW3RoaXMuU2IrND4+Mj4+PjBdPXR9LHRoaXMuYmM9ZnVuY3Rpb24oKXtyZXR1cm4gaSgpW3RoaXMuU2IrND4+Mj4+PjBdfSx0aGlzLndjPWZ1bmN0aW9uKHQpe2koKVt0aGlzLlNiKzg+PjI+Pj4wXT10fSx0aGlzLkRjPWZ1bmN0aW9uKCl7cmV0dXJuIGkoKVt0aGlzLlNiKzg+PjI+Pj4wXX0sdGhpcy5yYz1mdW5jdGlvbigpe2EoKVt0aGlzLlNiPj4yPj4+MF09MH0sdGhpcy5oYz1mdW5jdGlvbih0KXt0PXQ/MTowLGUoKVt0aGlzLlNiKzEyPj4wPj4+MF09dH0sdGhpcy51Yz1mdW5jdGlvbigpe3JldHVybiAwIT1lKClbdGhpcy5TYisxMj4+MD4+PjBdfSx0aGlzLmljPWZ1bmN0aW9uKHQpe3Q9dD8xOjAsZSgpW3RoaXMuU2IrMTM+PjA+Pj4wXT10fSx0aGlzLmtjPWZ1bmN0aW9uKCl7cmV0dXJuIDAhPWUoKVt0aGlzLlNiKzEzPj4wPj4+MF19LHRoaXMuZmM9ZnVuY3Rpb24odCxlKXt0aGlzLmNjKDApLHRoaXMueGModCksdGhpcy53YyhlKSx0aGlzLnJjKCksdGhpcy5oYyghMSksdGhpcy5pYyghMSl9LHRoaXMuc2M9ZnVuY3Rpb24oKXtBdG9taWNzLmFkZChhKCksdGhpcy5TYj4+MiwxKX0sdGhpcy5IYz1mdW5jdGlvbigpe3JldHVybiAxPT09QXRvbWljcy5zdWIoYSgpLHRoaXMuU2I+PjIsMSl9LHRoaXMuY2M9ZnVuY3Rpb24odCl7aSgpW3RoaXMuU2IrMTY+PjI+Pj4wXT10fSx0aGlzLnRjPWZ1bmN0aW9uKCl7cmV0dXJuIGkoKVt0aGlzLlNiKzE2Pj4yPj4+MF19LHRoaXMudmM9ZnVuY3Rpb24oKXtpZihSZSh0aGlzLmJjKCkpKXJldHVybiBpKClbdGhpcy5aYj4+Mj4+PjBdO3ZhciB0PXRoaXMudGMoKTtyZXR1cm4gMCE9PXQ/dDp0aGlzLlpifX1mdW5jdGlvbiBUdCh0KXtyZXR1cm4geWUobmV3IFN0KHQpLlNiKX1mdW5jdGlvbiBFdCh0LGUsbixyKXtyZXR1cm4gTz9xdCgzLDEsdCxlLG4scik6TXQodCxlLG4scil9ZnVuY3Rpb24gTXQodCxlLG4scil7aWYoXCJ1bmRlZmluZWRcIj09dHlwZW9mIFNoYXJlZEFycmF5QnVmZmVyKXJldHVybiB4KFwiQ3VycmVudCBlbnZpcm9ubWVudCBkb2VzIG5vdCBzdXBwb3J0IFNoYXJlZEFycmF5QnVmZmVyLCBwdGhyZWFkcyBhcmUgbm90IGF2YWlsYWJsZSFcIiksNjt2YXIgYT1bXTtyZXR1cm4gTyYmMD09PWEubGVuZ3RoP0V0KHQsZSxuLHIpOih0PXtJYzpuLFViOnQsemM6cixOYzphfSxPPyh0Lk9jPVwic3Bhd25UaHJlYWRcIixwb3N0TWVzc2FnZSh0LGEpLDApOmx0KHQpKX1mdW5jdGlvbiBDdCh0LGUsbil7cmV0dXJuIE8/cXQoNCwxLHQsZSxuKTowfWZ1bmN0aW9uIHh0KHQsZSl7aWYoTylyZXR1cm4gcXQoNSwxLHQsZSl9ZnVuY3Rpb24gUnQodCxlKXtpZihPKXJldHVybiBxdCg2LDEsdCxlKX1mdW5jdGlvbiBrdCh0LGUsbil7aWYoTylyZXR1cm4gcXQoNywxLHQsZSxuKX1mdW5jdGlvbiBqdCh0LGUsbil7cmV0dXJuIE8/cXQoOCwxLHQsZSxuKTowfWZ1bmN0aW9uIER0KHQsZSl7aWYoTylyZXR1cm4gcXQoOSwxLHQsZSl9ZnVuY3Rpb24gUHQodCxlLG4pe2lmKE8pcmV0dXJuIHF0KDEwLDEsdCxlLG4pfWZ1bmN0aW9uIFV0KHQsZSxuLHIpe2lmKE8pcmV0dXJuIHF0KDExLDEsdCxlLG4scil9ZnVuY3Rpb24gRnQodCxlLG4scil7aWYoTylyZXR1cm4gcXQoMTIsMSx0LGUsbixyKX1mdW5jdGlvbiBJdCh0LGUsbixyKXtpZihPKXJldHVybiBxdCgxMywxLHQsZSxuLHIpfWZ1bmN0aW9uIFd0KHQpe2lmKE8pcmV0dXJuIHF0KDE0LDEsdCl9ZnVuY3Rpb24gSHQodCxlKXtpZihPKXJldHVybiBxdCgxNSwxLHQsZSl9ZnVuY3Rpb24genQodCxlLG4pe2lmKE8pcmV0dXJuIHF0KDE2LDEsdCxlLG4pfWZ1bmN0aW9uIEx0KHQpe0F0b21pY3Muc3RvcmUoYSgpLHQ+PjIsMSksaGUoKSYmd2UodCksQXRvbWljcy5jb21wYXJlRXhjaGFuZ2UoYSgpLHQ+PjIsMSwwKX1mdW5jdGlvbiBZdCh0KXtyZXR1cm4gaSgpW3Q+Pj4yXSs0Mjk0OTY3Mjk2KmEoKVt0KzQ+Pj4yXX1mdW5jdGlvbiBCdCh0LGUsbixyLGEsaSl7cmV0dXJuIE8/cXQoMTcsMSx0LGUsbixyLGEsaSk6LTUyfWZ1bmN0aW9uIEd0KHQsZSxuLHIsYSxpKXtpZihPKXJldHVybiBxdCgxOCwxLHQsZSxuLHIsYSxpKX1mdW5jdGlvbiBOdCh0KXt2YXIgbj1HKHQpKzEscj1kZShuKTtyZXR1cm4gciYmQih0LGUoKSxyLG4pLHJ9ZnVuY3Rpb24gVnQodCxlLG4pe2Z1bmN0aW9uIHIodCl7cmV0dXJuKHQ9dC50b1RpbWVTdHJpbmcoKS5tYXRjaCgvXFxcXCgoW0EtWmEteiBdKylcXFxcKSQvKSk/dFsxXTpcIkdNVFwifWlmKE8pcmV0dXJuIHF0KDE5LDEsdCxlLG4pO3ZhciBvPShuZXcgRGF0ZSkuZ2V0RnVsbFllYXIoKSx1PW5ldyBEYXRlKG8sMCwxKSxzPW5ldyBEYXRlKG8sNiwxKTtvPXUuZ2V0VGltZXpvbmVPZmZzZXQoKTt2YXIgYz1zLmdldFRpbWV6b25lT2Zmc2V0KCksbD1NYXRoLm1heChvLGMpO2EoKVt0Pj4yPj4+MF09NjAqbCxhKClbZT4+Mj4+PjBdPU51bWJlcihvIT1jKSx0PXIodSksZT1yKHMpLHQ9TnQodCksZT1OdChlKSxjPG8/KGkoKVtuPj4yPj4+MF09dCxpKClbbis0Pj4yPj4+MF09ZSk6KGkoKVtuPj4yPj4+MF09ZSxpKClbbis0Pj4yPj4+MF09dCl9ZnVuY3Rpb24gcXQodCxlKXt2YXIgbj1hcmd1bWVudHMubGVuZ3RoLTIscj1hcmd1bWVudHM7cmV0dXJuIHl0KCgoKT0+e2Zvcih2YXIgYT1DZSg4Km4pLGk9YT4+Myx1PTA7dTxuO3UrKyl7dmFyIHM9clsyK3VdO28oKVtpK3U+Pj4wXT1zfXJldHVybiBfZSh0LG4sYSxlKX0pKX11LmV4ZWN1dGVOb3RpZmllZFByb3h5aW5nUXVldWU9THQsX3Q9dz8oKT0+e3ZhciB0PXByb2Nlc3MuaHJ0aW1lKCk7cmV0dXJuIDFlMyp0WzBdK3RbMV0vMWU2fTpPPygpPT5wZXJmb3JtYW5jZS5ub3coKS11Ll9fcGVyZm9ybWFuY2Vfbm93X2Nsb2NrX2RyaWZ0OigpPT5wZXJmb3JtYW5jZS5ub3coKTt2YXIgJHQsWHQ9W10sSnQ9e307ZnVuY3Rpb24gWnQoKXtpZighJHQpe3ZhciB0LGU9e1VTRVI6XCJ3ZWJfdXNlclwiLExPR05BTUU6XCJ3ZWJfdXNlclwiLFBBVEg6XCIvXCIsUFdEOlwiL1wiLEhPTUU6XCIvaG9tZS93ZWJfdXNlclwiLExBTkc6KFwib2JqZWN0XCI9PXR5cGVvZiBuYXZpZ2F0b3ImJm5hdmlnYXRvci5sYW5ndWFnZXMmJm5hdmlnYXRvci5sYW5ndWFnZXNbMF18fFwiQ1wiKS5yZXBsYWNlKFwiLVwiLFwiX1wiKStcIi5VVEYtOFwiLF86bXx8XCIuL3RoaXMucHJvZ3JhbVwifTtmb3IodCBpbiBKdCl2b2lkIDA9PT1KdFt0XT9kZWxldGUgZVt0XTplW3RdPUp0W3RdO3ZhciBuPVtdO2Zvcih0IGluIGUpbi5wdXNoKHQrXCI9XCIrZVt0XSk7JHQ9bn1yZXR1cm4gJHR9ZnVuY3Rpb24gUXQodCxuKXtpZihPKXJldHVybiBxdCgyMCwxLHQsbik7dmFyIHI9MDtyZXR1cm4gWnQoKS5mb3JFYWNoKChmdW5jdGlvbihhLG8pe3ZhciB1PW4rcjtmb3Iobz1pKClbdCs0Km8+PjI+Pj4wXT11LHU9MDt1PGEubGVuZ3RoOysrdSllKClbbysrPj4wPj4+MF09YS5jaGFyQ29kZUF0KHUpO2UoKVtvPj4wPj4+MF09MCxyKz1hLmxlbmd0aCsxfSkpLDB9ZnVuY3Rpb24gS3QodCxlKXtpZihPKXJldHVybiBxdCgyMSwxLHQsZSk7dmFyIG49WnQoKTtpKClbdD4+Mj4+PjBdPW4ubGVuZ3RoO3ZhciByPTA7cmV0dXJuIG4uZm9yRWFjaCgoZnVuY3Rpb24odCl7cis9dC5sZW5ndGgrMX0pKSxpKClbZT4+Mj4+PjBdPXIsMH1mdW5jdGlvbiB0ZSh0KXtyZXR1cm4gTz9xdCgyMiwxLHQpOjUyfWZ1bmN0aW9uIGVlKHQsZSxuLHIpe3JldHVybiBPP3F0KDIzLDEsdCxlLG4scik6NTJ9ZnVuY3Rpb24gbmUodCxlLG4scixhKXtyZXR1cm4gTz9xdCgyNCwxLHQsZSxuLHIsYSk6NzB9dmFyIHJlPVtudWxsLFtdLFtdXTtmdW5jdGlvbiBhZSh0LGUpe3ZhciBuPXJlW3RdOzA9PT1lfHwxMD09PWU/KCgxPT09dD9DOngpKEwobiwwKSksbi5sZW5ndGg9MCk6bi5wdXNoKGUpfWZ1bmN0aW9uIGllKHQsZSxuLGEpe2lmKE8pcmV0dXJuIHF0KDI1LDEsdCxlLG4sYSk7Zm9yKHZhciBvPTAsdT0wO3U8bjt1Kyspe3ZhciBzPWkoKVtlPj4yPj4+MF0sYz1pKClbZSs0Pj4yPj4+MF07ZSs9ODtmb3IodmFyIGw9MDtsPGM7bCsrKWFlKHQscigpW3MrbD4+PjBdKTtvKz1jfXJldHVybiBpKClbYT4+Mj4+PjBdPW8sMH12YXIgb2U9MDtmdW5jdGlvbiB1ZSh0KXtyZXR1cm4gMD09dCU0JiYoMCE9dCUxMDB8fDA9PXQlNDAwKX12YXIgc2U9WzMxLDI5LDMxLDMwLDMxLDMwLDMxLDMxLDMwLDMxLDMwLDMxXSxjZT1bMzEsMjgsMzEsMzAsMzEsMzAsMzEsMzEsMzAsMzEsMzAsMzFdO2Z1bmN0aW9uIGxlKHQsbixyLGkpe2Z1bmN0aW9uIG8odCxlLG4pe2Zvcih0PVwibnVtYmVyXCI9PXR5cGVvZiB0P3QudG9TdHJpbmcoKTp0fHxcIlwiO3QubGVuZ3RoPGU7KXQ9blswXSt0O3JldHVybiB0fWZ1bmN0aW9uIHUodCxlKXtyZXR1cm4gbyh0LGUsXCIwXCIpfWZ1bmN0aW9uIHModCxlKXtmdW5jdGlvbiBuKHQpe3JldHVybiAwPnQ/LTE6MDx0PzE6MH12YXIgcjtyZXR1cm4gMD09PShyPW4odC5nZXRGdWxsWWVhcigpLWUuZ2V0RnVsbFllYXIoKSkpJiYwPT09KHI9bih0LmdldE1vbnRoKCktZS5nZXRNb250aCgpKSkmJihyPW4odC5nZXREYXRlKCktZS5nZXREYXRlKCkpKSxyfWZ1bmN0aW9uIGModCl7c3dpdGNoKHQuZ2V0RGF5KCkpe2Nhc2UgMDpyZXR1cm4gbmV3IERhdGUodC5nZXRGdWxsWWVhcigpLTEsMTEsMjkpO2Nhc2UgMTpyZXR1cm4gdDtjYXNlIDI6cmV0dXJuIG5ldyBEYXRlKHQuZ2V0RnVsbFllYXIoKSwwLDMpO2Nhc2UgMzpyZXR1cm4gbmV3IERhdGUodC5nZXRGdWxsWWVhcigpLDAsMik7Y2FzZSA0OnJldHVybiBuZXcgRGF0ZSh0LmdldEZ1bGxZZWFyKCksMCwxKTtjYXNlIDU6cmV0dXJuIG5ldyBEYXRlKHQuZ2V0RnVsbFllYXIoKS0xLDExLDMxKTtjYXNlIDY6cmV0dXJuIG5ldyBEYXRlKHQuZ2V0RnVsbFllYXIoKS0xLDExLDMwKX19ZnVuY3Rpb24gbCh0KXt2YXIgZT10LldiO2Zvcih0PW5ldyBEYXRlKG5ldyBEYXRlKHQuWGIrMTkwMCwwLDEpLmdldFRpbWUoKSk7MDxlOyl7dmFyIG49dC5nZXRNb250aCgpLHI9KHVlKHQuZ2V0RnVsbFllYXIoKSk/c2U6Y2UpW25dO2lmKCEoZT5yLXQuZ2V0RGF0ZSgpKSl7dC5zZXREYXRlKHQuZ2V0RGF0ZSgpK2UpO2JyZWFrfWUtPXItdC5nZXREYXRlKCkrMSx0LnNldERhdGUoMSksMTE+bj90LnNldE1vbnRoKG4rMSk6KHQuc2V0TW9udGgoMCksdC5zZXRGdWxsWWVhcih0LmdldEZ1bGxZZWFyKCkrMSkpfXJldHVybiBuPW5ldyBEYXRlKHQuZ2V0RnVsbFllYXIoKSsxLDAsNCksZT1jKG5ldyBEYXRlKHQuZ2V0RnVsbFllYXIoKSwwLDQpKSxuPWMobiksMD49cyhlLHQpPzA+PXMobix0KT90LmdldEZ1bGxZZWFyKCkrMTp0LmdldEZ1bGxZZWFyKCk6dC5nZXRGdWxsWWVhcigpLTF9dmFyIGY9YSgpW2krNDA+PjI+Pj4wXTtmb3IodmFyIHAgaW4gaT17TGM6YSgpW2k+PjI+Pj4wXSxLYzphKClbaSs0Pj4yPj4+MF0sZGM6YSgpW2krOD4+Mj4+PjBdLGpjOmEoKVtpKzEyPj4yPj4+MF0sZWM6YSgpW2krMTY+PjI+Pj4wXSxYYjphKClbaSsyMD4+Mj4+PjBdLFRiOmEoKVtpKzI0Pj4yPj4+MF0sV2I6YSgpW2krMjg+PjI+Pj4wXSxSYzphKClbaSszMj4+Mj4+PjBdLEpjOmEoKVtpKzM2Pj4yPj4+MF0sTWM6Zj9ZKGYpOlwiXCJ9LHI9WShyKSxmPXtcIiVjXCI6XCIlYSAlYiAlZCAlSDolTTolUyAlWVwiLFwiJURcIjpcIiVtLyVkLyV5XCIsXCIlRlwiOlwiJVktJW0tJWRcIixcIiVoXCI6XCIlYlwiLFwiJXJcIjpcIiVJOiVNOiVTICVwXCIsXCIlUlwiOlwiJUg6JU1cIixcIiVUXCI6XCIlSDolTTolU1wiLFwiJXhcIjpcIiVtLyVkLyV5XCIsXCIlWFwiOlwiJUg6JU06JVNcIixcIiVFY1wiOlwiJWNcIixcIiVFQ1wiOlwiJUNcIixcIiVFeFwiOlwiJW0vJWQvJXlcIixcIiVFWFwiOlwiJUg6JU06JVNcIixcIiVFeVwiOlwiJXlcIixcIiVFWVwiOlwiJVlcIixcIiVPZFwiOlwiJWRcIixcIiVPZVwiOlwiJWVcIixcIiVPSFwiOlwiJUhcIixcIiVPSVwiOlwiJUlcIixcIiVPbVwiOlwiJW1cIixcIiVPTVwiOlwiJU1cIixcIiVPU1wiOlwiJVNcIixcIiVPdVwiOlwiJXVcIixcIiVPVVwiOlwiJVVcIixcIiVPVlwiOlwiJVZcIixcIiVPd1wiOlwiJXdcIixcIiVPV1wiOlwiJVdcIixcIiVPeVwiOlwiJXlcIn0pcj1yLnJlcGxhY2UobmV3IFJlZ0V4cChwLFwiZ1wiKSxmW3BdKTt2YXIgaD1cIlN1bmRheSBNb25kYXkgVHVlc2RheSBXZWRuZXNkYXkgVGh1cnNkYXkgRnJpZGF5IFNhdHVyZGF5XCIuc3BsaXQoXCIgXCIpLGQ9XCJKYW51YXJ5IEZlYnJ1YXJ5IE1hcmNoIEFwcmlsIE1heSBKdW5lIEp1bHkgQXVndXN0IFNlcHRlbWJlciBPY3RvYmVyIE5vdmVtYmVyIERlY2VtYmVyXCIuc3BsaXQoXCIgXCIpO2ZvcihwIGluIGY9e1wiJWFcIjpmdW5jdGlvbih0KXtyZXR1cm4gaFt0LlRiXS5zdWJzdHJpbmcoMCwzKX0sXCIlQVwiOmZ1bmN0aW9uKHQpe3JldHVybiBoW3QuVGJdfSxcIiViXCI6ZnVuY3Rpb24odCl7cmV0dXJuIGRbdC5lY10uc3Vic3RyaW5nKDAsMyl9LFwiJUJcIjpmdW5jdGlvbih0KXtyZXR1cm4gZFt0LmVjXX0sXCIlQ1wiOmZ1bmN0aW9uKHQpe3JldHVybiB1KCh0LlhiKzE5MDApLzEwMHwwLDIpfSxcIiVkXCI6ZnVuY3Rpb24odCl7cmV0dXJuIHUodC5qYywyKX0sXCIlZVwiOmZ1bmN0aW9uKHQpe3JldHVybiBvKHQuamMsMixcIiBcIil9LFwiJWdcIjpmdW5jdGlvbih0KXtyZXR1cm4gbCh0KS50b1N0cmluZygpLnN1YnN0cmluZygyKX0sXCIlR1wiOmZ1bmN0aW9uKHQpe3JldHVybiBsKHQpfSxcIiVIXCI6ZnVuY3Rpb24odCl7cmV0dXJuIHUodC5kYywyKX0sXCIlSVwiOmZ1bmN0aW9uKHQpe3JldHVybiAwPT0odD10LmRjKT90PTEyOjEyPHQmJih0LT0xMiksdSh0LDIpfSxcIiVqXCI6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPTAsbj0wO248PXQuZWMtMTtlKz0odWUodC5YYisxOTAwKT9zZTpjZSlbbisrXSk7cmV0dXJuIHUodC5qYytlLDMpfSxcIiVtXCI6ZnVuY3Rpb24odCl7cmV0dXJuIHUodC5lYysxLDIpfSxcIiVNXCI6ZnVuY3Rpb24odCl7cmV0dXJuIHUodC5LYywyKX0sXCIlblwiOmZ1bmN0aW9uKCl7cmV0dXJuXCJcXFxcblwifSxcIiVwXCI6ZnVuY3Rpb24odCl7cmV0dXJuIDA8PXQuZGMmJjEyPnQuZGM/XCJBTVwiOlwiUE1cIn0sXCIlU1wiOmZ1bmN0aW9uKHQpe3JldHVybiB1KHQuTGMsMil9LFwiJXRcIjpmdW5jdGlvbigpe3JldHVyblwiXFxcXHRcIn0sXCIldVwiOmZ1bmN0aW9uKHQpe3JldHVybiB0LlRifHw3fSxcIiVVXCI6ZnVuY3Rpb24odCl7cmV0dXJuIHUoTWF0aC5mbG9vcigodC5XYis3LXQuVGIpLzcpLDIpfSxcIiVWXCI6ZnVuY3Rpb24odCl7dmFyIGU9TWF0aC5mbG9vcigodC5XYis3LSh0LlRiKzYpJTcpLzcpO2lmKDI+PSh0LlRiKzM3MS10LldiLTIpJTcmJmUrKyxlKTUzPT1lJiYoND09KG49KHQuVGIrMzcxLXQuV2IpJTcpfHwzPT1uJiZ1ZSh0LlhiKXx8KGU9MSkpO2Vsc2V7ZT01Mjt2YXIgbj0odC5UYis3LXQuV2ItMSklNzsoND09bnx8NT09biYmdWUodC5YYiU0MDAtMSkpJiZlKyt9cmV0dXJuIHUoZSwyKX0sXCIld1wiOmZ1bmN0aW9uKHQpe3JldHVybiB0LlRifSxcIiVXXCI6ZnVuY3Rpb24odCl7cmV0dXJuIHUoTWF0aC5mbG9vcigodC5XYis3LSh0LlRiKzYpJTcpLzcpLDIpfSxcIiV5XCI6ZnVuY3Rpb24odCl7cmV0dXJuKHQuWGIrMTkwMCkudG9TdHJpbmcoKS5zdWJzdHJpbmcoMil9LFwiJVlcIjpmdW5jdGlvbih0KXtyZXR1cm4gdC5YYisxOTAwfSxcIiV6XCI6ZnVuY3Rpb24odCl7dmFyIGU9MDw9KHQ9dC5KYyk7cmV0dXJuIHQ9TWF0aC5hYnModCkvNjAsKGU/XCIrXCI6XCItXCIpK1N0cmluZyhcIjAwMDBcIisodC82MCoxMDArdCU2MCkpLnNsaWNlKC00KX0sXCIlWlwiOmZ1bmN0aW9uKHQpe3JldHVybiB0Lk1jfSxcIiUlXCI6ZnVuY3Rpb24oKXtyZXR1cm5cIiVcIn19LHI9ci5yZXBsYWNlKC8lJS9nLFwiXFxcXDBcXFxcMFwiKSxmKXIuaW5jbHVkZXMocCkmJihyPXIucmVwbGFjZShuZXcgUmVnRXhwKHAsXCJnXCIpLGZbcF0oaSkpKTtyZXR1cm4gcD1mdW5jdGlvbih0KXt2YXIgZT1BcnJheShHKHQpKzEpO3JldHVybiBCKHQsZSwwLGUubGVuZ3RoKSxlfShyPXIucmVwbGFjZSgvXFxcXDBcXFxcMC9nLFwiJVwiKSkscC5sZW5ndGg+bj8wOihmdW5jdGlvbih0LG4pe2UoKS5zZXQodCxuPj4+MCl9KHAsdCkscC5sZW5ndGgtMSl9aHQuZmMoKTt2YXIgZmU9W251bGwsZnQsYnQsRXQsQ3QseHQsUnQsa3QsanQsRHQsUHQsVXQsRnQsSXQsV3QsSHQsenQsQnQsR3QsVnQsUXQsS3QsdGUsZWUsbmUsaWVdLHBlPXtiOmZ1bmN0aW9uKHQpe3JldHVybiBkZSh0KzI0KSsyNH0sbjpmdW5jdGlvbih0KXtyZXR1cm4odD1uZXcgU3QodCkpLnVjKCl8fCh0LmhjKCEwKSxPdC0tKSx0LmljKCExKSx3dC5wdXNoKHQpLHQuc2MoKSx0LnZjKCl9LG1hOmZ1bmN0aW9uKHQpe3Rocm93IHgoXCJVbmV4cGVjdGVkIGV4Y2VwdGlvbiB0aHJvd24sIHRoaXMgaXMgbm90IHByb3Blcmx5IHN1cHBvcnRlZCAtIGFib3J0aW5nXCIpLEg9ITAsdH0seDpmdW5jdGlvbigpe1NlKDApO3ZhciB0PXd0LnBvcCgpO2lmKHQuSGMoKSYmIXQua2MoKSl7dmFyIGU9dC5EYygpO2UmJmd0KGUpKHQuWmIpLFR0KHQuWmIpfUF0PTB9LGU6ZnVuY3Rpb24oKXt2YXIgdD1BdDtpZighdClyZXR1cm4gb2U9MDt2YXIgZT1uZXcgU3QodCk7ZS5jYyh0KTt2YXIgbj1lLmJjKCk7aWYoIW4pcmV0dXJuIG9lPTAsdDtmb3IodmFyIHI9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSxhPTA7YTxyLmxlbmd0aDthKyspe3ZhciBpPXJbYV07aWYoMD09PWl8fGk9PT1uKWJyZWFrO2lmKHhlKGksbixlLlNiKzE2KSlyZXR1cm4gb2U9aSx0fXJldHVybiBvZT1uLHR9LGw6ZnVuY3Rpb24oKXt2YXIgdD1BdDtpZighdClyZXR1cm4gb2U9MDt2YXIgZT1uZXcgU3QodCk7ZS5jYyh0KTt2YXIgbj1lLmJjKCk7aWYoIW4pcmV0dXJuIG9lPTAsdDtmb3IodmFyIHI9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSxhPTA7YTxyLmxlbmd0aDthKyspe3ZhciBpPXJbYV07aWYoMD09PWl8fGk9PT1uKWJyZWFrO2lmKHhlKGksbixlLlNiKzE2KSlyZXR1cm4gb2U9aSx0fXJldHVybiBvZT1uLHR9LGg6ZnVuY3Rpb24oKXt2YXIgdD1BdDtpZighdClyZXR1cm4gb2U9MDt2YXIgZT1uZXcgU3QodCk7ZS5jYyh0KTt2YXIgbj1lLmJjKCk7aWYoIW4pcmV0dXJuIG9lPTAsdDtmb3IodmFyIHI9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSxhPTA7YTxyLmxlbmd0aDthKyspe3ZhciBpPXJbYV07aWYoMD09PWl8fGk9PT1uKWJyZWFrO2lmKHhlKGksbixlLlNiKzE2KSlyZXR1cm4gb2U9aSx0fXJldHVybiBvZT1uLHR9LHQ6VHQsTTpmdW5jdGlvbigpe3ZhciB0PXd0LnBvcCgpO3R8fGF0KFwibm8gZXhjZXB0aW9uIHRvIHRocm93XCIpO3ZhciBlPXQuWmI7dGhyb3cgdC5rYygpfHwod3QucHVzaCh0KSx0LmljKCEwKSx0LmhjKCExKSxPdCsrKSxBdD1lLGV9LGM6ZnVuY3Rpb24odCxlLG4pe3Rocm93IG5ldyBTdCh0KS5mYyhlLG4pLEF0PXQsT3QrKyx0fSxwYTpmdW5jdGlvbigpe3JldHVybiBPdH0sRmE6ZnVuY3Rpb24odCl7Z2UodCwhXywxLCF2KSxodC5wYygpfSxUOmZ1bmN0aW9uKHQpe08/cG9zdE1lc3NhZ2Uoe2NtZDpcImNsZWFudXBUaHJlYWRcIix0aHJlYWQ6dH0pOmN0KHQpfSx4YTpNdCxqOmZ1bmN0aW9uKHQpe3Rocm93IEF0fHwoQXQ9dCksdH0sSDpDdCxNYTp4dCx1YTpSdCx3YTprdCxvYTpqdCxLYTpEdCxDYTpQdCxKYTpVdCxWOkZ0LHZhOkl0LHNhOld0LExhOkh0LHRhOnp0LFRhOmZ1bmN0aW9uKCl7fSxYOmZ1bmN0aW9uKCl7YXQoXCJUbyB1c2UgZGxvcGVuLCB5b3UgbmVlZCBlbmFibGUgZHluYW1pYyBsaW5raW5nLCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2Vtc2NyaXB0ZW4tY29yZS9lbXNjcmlwdGVuL3dpa2kvTGlua2luZ1wiKX0sVWE6ZnVuY3Rpb24oKXthdChcIlRvIHVzZSBkbG9wZW4sIHlvdSBuZWVkIGVuYWJsZSBkeW5hbWljIGxpbmtpbmcsIHNlZSBodHRwczovL2dpdGh1Yi5jb20vZW1zY3JpcHRlbi1jb3JlL2Vtc2NyaXB0ZW4vd2lraS9MaW5raW5nXCIpfSxXOmZ1bmN0aW9uKCl7cmV0dXJuIERhdGUubm93KCl9LHlhOmZ1bmN0aW9uKCl7cmV0dXJuIDIwOTcxNTJ9LE9hOmZ1bmN0aW9uKCl7cmV0dXJuITB9LHphOmZ1bmN0aW9uKHQsZSxuLHIpe2lmKHQ9PWUpc2V0VGltZW91dCgoKCk9Pkx0KHIpKSk7ZWxzZSBpZihPKXBvc3RNZXNzYWdlKHt0YXJnZXRUaHJlYWQ6dCxjbWQ6XCJwcm9jZXNzUHJveHlpbmdRdWV1ZVwiLHF1ZXVlOnJ9KTtlbHNle2lmKCEodD1odC5WYlt0XSkpcmV0dXJuO3QucG9zdE1lc3NhZ2Uoe2NtZDpcInByb2Nlc3NQcm94eWluZ1F1ZXVlXCIscXVldWU6cn0pfXJldHVybiAxfSxFYTpmdW5jdGlvbigpe3JldHVybi0xfSxQYTpmdW5jdGlvbih0LGUpe3Q9bmV3IERhdGUoMWUzKll0KHQpKSxhKClbZT4+Mj4+PjBdPXQuZ2V0VVRDU2Vjb25kcygpLGEoKVtlKzQ+PjI+Pj4wXT10LmdldFVUQ01pbnV0ZXMoKSxhKClbZSs4Pj4yPj4+MF09dC5nZXRVVENIb3VycygpLGEoKVtlKzEyPj4yPj4+MF09dC5nZXRVVENEYXRlKCksYSgpW2UrMTY+PjI+Pj4wXT10LmdldFVUQ01vbnRoKCksYSgpW2UrMjA+PjI+Pj4wXT10LmdldFVUQ0Z1bGxZZWFyKCktMTkwMCxhKClbZSsyND4+Mj4+PjBdPXQuZ2V0VVRDRGF5KCksdD0odC5nZXRUaW1lKCktRGF0ZS5VVEModC5nZXRVVENGdWxsWWVhcigpLDAsMSwwLDAsMCwwKSkvODY0ZTV8MCxhKClbZSsyOD4+Mj4+PjBdPXR9LFFhOmZ1bmN0aW9uKHQsZSl7dD1uZXcgRGF0ZSgxZTMqWXQodCkpLGEoKVtlPj4yPj4+MF09dC5nZXRTZWNvbmRzKCksYSgpW2UrND4+Mj4+PjBdPXQuZ2V0TWludXRlcygpLGEoKVtlKzg+PjI+Pj4wXT10LmdldEhvdXJzKCksYSgpW2UrMTI+PjI+Pj4wXT10LmdldERhdGUoKSxhKClbZSsxNj4+Mj4+PjBdPXQuZ2V0TW9udGgoKSxhKClbZSsyMD4+Mj4+PjBdPXQuZ2V0RnVsbFllYXIoKS0xOTAwLGEoKVtlKzI0Pj4yPj4+MF09dC5nZXREYXkoKTt2YXIgbj1uZXcgRGF0ZSh0LmdldEZ1bGxZZWFyKCksMCwxKSxyPSh0LmdldFRpbWUoKS1uLmdldFRpbWUoKSkvODY0ZTV8MDthKClbZSsyOD4+Mj4+PjBdPXIsYSgpW2UrMzY+PjI+Pj4wXT0tNjAqdC5nZXRUaW1lem9uZU9mZnNldCgpLHI9bmV3IERhdGUodC5nZXRGdWxsWWVhcigpLDYsMSkuZ2V0VGltZXpvbmVPZmZzZXQoKSx0PTB8KHIhPShuPW4uZ2V0VGltZXpvbmVPZmZzZXQoKSkmJnQuZ2V0VGltZXpvbmVPZmZzZXQoKT09TWF0aC5taW4obixyKSksYSgpW2UrMzI+PjI+Pj4wXT10fSxSYTpmdW5jdGlvbih0KXt2YXIgZT1uZXcgRGF0ZShhKClbdCsyMD4+Mj4+PjBdKzE5MDAsYSgpW3QrMTY+PjI+Pj4wXSxhKClbdCsxMj4+Mj4+PjBdLGEoKVt0Kzg+PjI+Pj4wXSxhKClbdCs0Pj4yPj4+MF0sYSgpW3Q+PjI+Pj4wXSwwKSxuPWEoKVt0KzMyPj4yPj4+MF0scj1lLmdldFRpbWV6b25lT2Zmc2V0KCksaT1uZXcgRGF0ZShlLmdldEZ1bGxZZWFyKCksMCwxKSxvPW5ldyBEYXRlKGUuZ2V0RnVsbFllYXIoKSw2LDEpLmdldFRpbWV6b25lT2Zmc2V0KCksdT1pLmdldFRpbWV6b25lT2Zmc2V0KCkscz1NYXRoLm1pbih1LG8pO3JldHVybiAwPm4/YSgpW3QrMzI+PjI+Pj4wXT1OdW1iZXIobyE9dSYmcz09cik6MDxuIT0ocz09cikmJihvPU1hdGgubWF4KHUsbyksZS5zZXRUaW1lKGUuZ2V0VGltZSgpKzZlNCooKDA8bj9zOm8pLXIpKSksYSgpW3QrMjQ+PjI+Pj4wXT1lLmdldERheSgpLG49KGUuZ2V0VGltZSgpLWkuZ2V0VGltZSgpKS84NjRlNXwwLGEoKVt0KzI4Pj4yPj4+MF09bixhKClbdD4+Mj4+PjBdPWUuZ2V0U2Vjb25kcygpLGEoKVt0KzQ+PjI+Pj4wXT1lLmdldE1pbnV0ZXMoKSxhKClbdCs4Pj4yPj4+MF09ZS5nZXRIb3VycygpLGEoKVt0KzEyPj4yPj4+MF09ZS5nZXREYXRlKCksYSgpW3QrMTY+PjI+Pj4wXT1lLmdldE1vbnRoKCksZS5nZXRUaW1lKCkvMWUzfDB9LEFhOkJ0LEJhOkd0LFNhOmZ1bmN0aW9uIHQoZSxuLHIpe3QuQWN8fCh0LkFjPSEwLFZ0KGUsbixyKSl9LHk6ZnVuY3Rpb24oKXthdChcIlwiKX0sVTpmdW5jdGlvbigpe2lmKCF3JiYhXyl7dmFyIHQ9XCJCbG9ja2luZyBvbiB0aGUgbWFpbiB0aHJlYWQgaXMgdmVyeSBkYW5nZXJvdXMsIHNlZSBodHRwczovL2Vtc2NyaXB0ZW4ub3JnL2RvY3MvcG9ydGluZy9wdGhyZWFkcy5odG1sI2Jsb2NraW5nLW9uLXRoZS1tYWluLWJyb3dzZXItdGhyZWFkXCI7dnR8fCh2dD17fSksdnRbdF18fCh2dFt0XT0xLHcmJih0PVwid2FybmluZzogXCIrdCkseCh0KSl9fSxyYTpmdW5jdGlvbigpe3JldHVybiA0Mjk0OTAxNzYwfSxCOl90LElhOmZ1bmN0aW9uKHQsZSxuKXtyKCkuY29weVdpdGhpbih0Pj4+MCxlPj4+MCxlK24+Pj4wKX0sRjpmdW5jdGlvbigpe3JldHVybiB3P24oMzcpLmNwdXMoKS5sZW5ndGg6bmF2aWdhdG9yLmhhcmR3YXJlQ29uY3VycmVuY3l9LERhOmZ1bmN0aW9uKHQsZSxuKXtYdC5sZW5ndGg9ZSxuPj49Mztmb3IodmFyIHI9MDtyPGU7cisrKVh0W3JdPW8oKVtuK3I+Pj4wXTtyZXR1cm4oMD50P3V0Wy10LTFdOmZlW3RdKS5hcHBseShudWxsLFh0KX0scWE6ZnVuY3Rpb24odCl7dmFyIGU9cigpLmxlbmd0aDtpZigodD4+Pj0wKTw9ZXx8NDI5NDkwMTc2MDx0KXJldHVybiExO2Zvcih2YXIgbj0xOzQ+PW47bio9Mil7dmFyIGE9ZSooMSsuMi9uKTthPU1hdGgubWluKGEsdCsxMDA2NjMyOTYpO3ZhciBpPU1hdGg7YT1NYXRoLm1heCh0LGEpLGk9aS5taW4uY2FsbChpLDQyOTQ5MDE3NjAsYSsoNjU1MzYtYSU2NTUzNiklNjU1MzYpO3Q6e3RyeXtrLmdyb3coaS1ELmJ5dGVMZW5ndGgrNjU1MzU+Pj4xNiksTihrLmJ1ZmZlcik7dmFyIG89MTticmVhayB0fWNhdGNoKHQpe31vPXZvaWQgMH1pZihvKXJldHVybiEwfXJldHVybiExfSxOYTpmdW5jdGlvbigpe3Rocm93XCJ1bndpbmRcIn0sR2E6UXQsSGE6S3QsSjpwdCxJOnRlLFM6ZWUsZ2E6bmUsUjppZSxkOmZ1bmN0aW9uKCl7cmV0dXJuIG9lfSxuYTpmdW5jdGlvbiB0KHIsYSl7dC5sY3x8KHQubGM9ZnVuY3Rpb24oKXtpZihcIm9iamVjdFwiPT10eXBlb2YgY3J5cHRvJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKXt2YXIgdD1uZXcgVWludDhBcnJheSgxKTtyZXR1cm4oKT0+KGNyeXB0by5nZXRSYW5kb21WYWx1ZXModCksdFswXSl9aWYodyl0cnl7dmFyIGU9bigxMTMpO3JldHVybigpPT5lLnJhbmRvbUJ5dGVzKDEpWzBdfWNhdGNoKHQpe31yZXR1cm4oKT0+YXQoXCJyYW5kb21EZXZpY2VcIil9KCkpO2Zvcih2YXIgaT0wO2k8YTtpKyspZSgpW3IraT4+MD4+PjBdPXQubGMoKTtyZXR1cm4gMH0saWE6ZnVuY3Rpb24odCxlLG4pe3ZhciByPUVlKCk7dHJ5e3JldHVybiBndCh0KShlLG4pfWNhdGNoKHQpe2lmKE1lKHIpLHQhPT10KzApdGhyb3cgdDtTZSgxLDApfX0samE6ZnVuY3Rpb24odCxlLG4pe3ZhciByPUVlKCk7dHJ5e3JldHVybiBndCh0KShlLG4pfWNhdGNoKHQpe2lmKE1lKHIpLHQhPT10KzApdGhyb3cgdDtTZSgxLDApfX0sSzpmdW5jdGlvbih0KXt2YXIgZT1FZSgpO3RyeXtyZXR1cm4gZ3QodCkoKX1jYXRjaCh0KXtpZihNZShlKSx0IT09dCswKXRocm93IHQ7U2UoMSwwKX19LGY6ZnVuY3Rpb24odCxlKXt2YXIgbj1FZSgpO3RyeXtyZXR1cm4gZ3QodCkoZSl9Y2F0Y2godCl7aWYoTWUobiksdCE9PXQrMCl0aHJvdyB0O1NlKDEsMCl9fSxQOmZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1FZSgpO3RyeXtyZXR1cm4gZ3QodCkoZSxuKX1jYXRjaCh0KXtpZihNZShyKSx0IT09dCswKXRocm93IHQ7U2UoMSwwKX19LFE6ZnVuY3Rpb24odCxlLG4pe3ZhciByPUVlKCk7dHJ5e3JldHVybiBndCh0KShlLG4pfWNhdGNoKHQpe2lmKE1lKHIpLHQhPT10KzApdGhyb3cgdDtTZSgxLDApfX0sazpmdW5jdGlvbih0LGUsbil7dmFyIHI9RWUoKTt0cnl7cmV0dXJuIGd0KHQpKGUsbil9Y2F0Y2godCl7aWYoTWUociksdCE9PXQrMCl0aHJvdyB0O1NlKDEsMCl9fSxwOmZ1bmN0aW9uKHQsZSxuLHIpe3ZhciBhPUVlKCk7dHJ5e3JldHVybiBndCh0KShlLG4scil9Y2F0Y2godCl7aWYoTWUoYSksdCE9PXQrMCl0aHJvdyB0O1NlKDEsMCl9fSxxOmZ1bmN0aW9uKHQsZSxuLHIsYSl7dmFyIGk9RWUoKTt0cnl7cmV0dXJuIGd0KHQpKGUsbixyLGEpfWNhdGNoKHQpe2lmKE1lKGkpLHQhPT10KzApdGhyb3cgdDtTZSgxLDApfX0sTjpmdW5jdGlvbih0LGUsbixyLGEsaSl7dmFyIG89RWUoKTt0cnl7cmV0dXJuIGd0KHQpKGUsbixyLGEsaSl9Y2F0Y2godCl7aWYoTWUobyksdCE9PXQrMCl0aHJvdyB0O1NlKDEsMCl9fSxzOmZ1bmN0aW9uKHQsZSxuLHIsYSxpKXt2YXIgbz1FZSgpO3RyeXtyZXR1cm4gZ3QodCkoZSxuLHIsYSxpKX1jYXRjaCh0KXtpZihNZShvKSx0IT09dCswKXRocm93IHQ7U2UoMSwwKX19LHc6ZnVuY3Rpb24odCxlLG4scixhLGksbyl7dmFyIHU9RWUoKTt0cnl7cmV0dXJuIGd0KHQpKGUsbixyLGEsaSxvKX1jYXRjaCh0KXtpZihNZSh1KSx0IT09dCswKXRocm93IHQ7U2UoMSwwKX19LEw6ZnVuY3Rpb24odCxlLG4scixhLGksbyx1KXt2YXIgcz1FZSgpO3RyeXtyZXR1cm4gZ3QodCkoZSxuLHIsYSxpLG8sdSl9Y2F0Y2godCl7aWYoTWUocyksdCE9PXQrMCl0aHJvdyB0O1NlKDEsMCl9fSxFOmZ1bmN0aW9uKHQsZSxuLHIsYSxpLG8sdSxzLGMsbCxmKXt2YXIgcD1FZSgpO3RyeXtyZXR1cm4gZ3QodCkoZSxuLHIsYSxpLG8sdSxzLGMsbCxmKX1jYXRjaCh0KXtpZihNZShwKSx0IT09dCswKXRocm93IHQ7U2UoMSwwKX19LGFhOmZ1bmN0aW9uKHQsZSxuLHIsYSxpLG8sdSl7dmFyIHM9RWUoKTt0cnl7cmV0dXJuIEhlKHQsZSxuLHIsYSxpLG8sdSl9Y2F0Y2godCl7aWYoTWUocyksdCE9PXQrMCl0aHJvdyB0O1NlKDEsMCl9fSxfOmZ1bmN0aW9uKHQsZSxuLHIsYSxpLG8pe3ZhciB1PUVlKCk7dHJ5e3JldHVybiBqZSh0LGUsbixyLGEsaSxvKX1jYXRjaCh0KXtpZihNZSh1KSx0IT09dCswKXRocm93IHQ7U2UoMSwwKX19LFo6ZnVuY3Rpb24odCxlLG4scixhKXt2YXIgaT1FZSgpO3RyeXtyZXR1cm4gemUodCxlLG4scixhKX1jYXRjaCh0KXtpZihNZShpKSx0IT09dCswKXRocm93IHQ7U2UoMSwwKX19LGNhOmZ1bmN0aW9uKHQsZSxuLHIpe3ZhciBhPUVlKCk7dHJ5e3JldHVybiBJZSh0LGUsbixyKX1jYXRjaCh0KXtpZihNZShhKSx0IT09dCswKXRocm93IHQ7U2UoMSwwKX19LCQ6ZnVuY3Rpb24odCl7dmFyIGU9RWUoKTt0cnl7cmV0dXJuIGtlKHQpfWNhdGNoKHQpe2lmKE1lKGUpLHQhPT10KzApdGhyb3cgdDtTZSgxLDApfX0sYmE6ZnVuY3Rpb24odCxlKXt2YXIgbj1FZSgpO3RyeXtyZXR1cm4gV2UodCxlKX1jYXRjaCh0KXtpZihNZShuKSx0IT09dCswKXRocm93IHQ7U2UoMSwwKX19LFk6ZnVuY3Rpb24odCxlLG4pe3ZhciByPUVlKCk7dHJ5e3JldHVybiBEZSh0LGUsbil9Y2F0Y2godCl7aWYoTWUociksdCE9PXQrMCl0aHJvdyB0O1NlKDEsMCl9fSxnOmZ1bmN0aW9uKHQpe3ZhciBlPUVlKCk7dHJ5e2d0KHQpKCl9Y2F0Y2godCl7aWYoTWUoZSksdCE9PXQrMCl0aHJvdyB0O1NlKDEsMCl9fSxyOmZ1bmN0aW9uKHQsZSl7dmFyIG49RWUoKTt0cnl7Z3QodCkoZSl9Y2F0Y2godCl7aWYoTWUobiksdCE9PXQrMCl0aHJvdyB0O1NlKDEsMCl9fSxpOmZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1FZSgpO3RyeXtndCh0KShlLG4pfWNhdGNoKHQpe2lmKE1lKHIpLHQhPT10KzApdGhyb3cgdDtTZSgxLDApfX0saGE6ZnVuY3Rpb24odCxlLG4scil7dmFyIGE9RWUoKTt0cnl7Z3QodCkoZSxuLHIpfWNhdGNoKHQpe2lmKE1lKGEpLHQhPT10KzApdGhyb3cgdDtTZSgxLDApfX0sbTpmdW5jdGlvbih0LGUsbixyKXt2YXIgYT1FZSgpO3RyeXtndCh0KShlLG4scil9Y2F0Y2godCl7aWYoTWUoYSksdCE9PXQrMCl0aHJvdyB0O1NlKDEsMCl9fSx2OmZ1bmN0aW9uKHQsZSxuLHIsYSl7dmFyIGk9RWUoKTt0cnl7Z3QodCkoZSxuLHIsYSl9Y2F0Y2godCl7aWYoTWUoaSksdCE9PXQrMCl0aHJvdyB0O1NlKDEsMCl9fSx1OmZ1bmN0aW9uKHQsZSxuLHIsYSxpKXt2YXIgbz1FZSgpO3RyeXtndCh0KShlLG4scixhLGkpfWNhdGNoKHQpe2lmKE1lKG8pLHQhPT10KzApdGhyb3cgdDtTZSgxLDApfX0sTzpmdW5jdGlvbih0LGUsbixyLGEsaSxvKXt2YXIgdT1FZSgpO3RyeXtndCh0KShlLG4scixhLGksbyl9Y2F0Y2godCl7aWYoTWUodSksdCE9PXQrMCl0aHJvdyB0O1NlKDEsMCl9fSxBOmZ1bmN0aW9uKHQsZSxuLHIsYSxpLG8sdSl7dmFyIHM9RWUoKTt0cnl7Z3QodCkoZSxuLHIsYSxpLG8sdSl9Y2F0Y2godCl7aWYoTWUocyksdCE9PXQrMCl0aHJvdyB0O1NlKDEsMCl9fSxrYTpmdW5jdGlvbih0LGUsbixyLGEsaSxvLHUscyl7dmFyIGM9RWUoKTt0cnl7Z3QodCkoZSxuLHIsYSxpLG8sdSxzKX1jYXRjaCh0KXtpZihNZShjKSx0IT09dCswKXRocm93IHQ7U2UoMSwwKX19LEM6ZnVuY3Rpb24odCxlLG4scixhLGksbyx1LHMsYyxsKXt2YXIgZj1FZSgpO3RyeXtndCh0KShlLG4scixhLGksbyx1LHMsYyxsKX1jYXRjaCh0KXtpZihNZShmKSx0IT09dCswKXRocm93IHQ7U2UoMSwwKX19LEQ6ZnVuY3Rpb24odCxlLG4scixhLGksbyx1LHMsYyxsLGYscCxoLGQseSl7dmFyIGI9RWUoKTt0cnl7Z3QodCkoZSxuLHIsYSxpLG8sdSxzLGMsbCxmLHAsaCxkLHkpfWNhdGNoKHQpe2lmKE1lKGIpLHQhPT10KzApdGhyb3cgdDtTZSgxLDApfX0sZmE6ZnVuY3Rpb24odCxlLG4scixhLGksbyx1KXt2YXIgcz1FZSgpO3RyeXtQZSh0LGUsbixyLGEsaSxvLHUpfWNhdGNoKHQpe2lmKE1lKHMpLHQhPT10KzApdGhyb3cgdDtTZSgxLDApfX0sZGE6ZnVuY3Rpb24odCxlLG4scixhLGksbyx1LHMsYyxsLGYpe3ZhciBwPUVlKCk7dHJ5e0ZlKHQsZSxuLHIsYSxpLG8sdSxzLGMsbCxmKX1jYXRjaCh0KXtpZihNZShwKSx0IT09dCswKXRocm93IHQ7U2UoMSwwKX19LGVhOmZ1bmN0aW9uKHQsZSxuLHIsYSxpKXt2YXIgbz1FZSgpO3RyeXtVZSh0LGUsbixyLGEsaSl9Y2F0Y2godCl7aWYoTWUobyksdCE9PXQrMCl0aHJvdyB0O1NlKDEsMCl9fSxvOmZ1bmN0aW9uKHQpe3JldHVybiB0fSxhOmt8fHUud2FzbU1lbW9yeSxHOmZ1bmN0aW9uKHQpe29lPXR9LGxhOmxlLHo6ZnVuY3Rpb24odCxlLG4scil7cmV0dXJuIGxlKHQsZSxuLHIpfX07IWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0LGUpe3UuYXNtPXQuZXhwb3J0cyxodC5xYy5wdXNoKHUuYXNtLnNiKSxxPXUuYXNtLnViLFgudW5zaGlmdCh1LmFzbS5WYSksaj1lLE98fChldC0tLHUubW9uaXRvclJ1bkRlcGVuZGVuY2llcyYmdS5tb25pdG9yUnVuRGVwZW5kZW5jaWVzKGV0KSwwPT1ldCYmKG51bGwhPT1udCYmKGNsZWFySW50ZXJ2YWwobnQpLG50PW51bGwpLHJ0JiYodD1ydCxydD1udWxsLHQoKSkpKX1mdW5jdGlvbiBlKGUpe3QoZS5pbnN0YW5jZSxlLm1vZHVsZSl9ZnVuY3Rpb24gbih0KXtyZXR1cm4gZnVuY3Rpb24oKXtpZighTSYmKHZ8fF8pKXtpZihcImZ1bmN0aW9uXCI9PXR5cGVvZiBmZXRjaCYmIXR0LnN0YXJ0c1dpdGgoXCJmaWxlOi8vXCIpKXJldHVybiBmZXRjaCh0dCx7Y3JlZGVudGlhbHM6XCJzYW1lLW9yaWdpblwifSkudGhlbigoZnVuY3Rpb24odCl7aWYoIXQub2spdGhyb3dcImZhaWxlZCB0byBsb2FkIHdhc20gYmluYXJ5IGZpbGUgYXQgXFwnXCIrdHQrXCJcXCdcIjtyZXR1cm4gdC5hcnJheUJ1ZmZlcigpfSkpLmNhdGNoKChmdW5jdGlvbigpe3JldHVybiBvdCgpfSkpO2lmKGYpcmV0dXJuIG5ldyBQcm9taXNlKChmdW5jdGlvbih0LGUpe2YodHQsKGZ1bmN0aW9uKGUpe3QobmV3IFVpbnQ4QXJyYXkoZSkpfSksZSl9KSl9cmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKGZ1bmN0aW9uKCl7cmV0dXJuIG90KCl9KSl9KCkudGhlbigoZnVuY3Rpb24odCl7cmV0dXJuIFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlKHQscil9KSkudGhlbigoZnVuY3Rpb24odCl7cmV0dXJuIHR9KSkudGhlbih0LChmdW5jdGlvbih0KXt4KFwiZmFpbGVkIHRvIGFzeW5jaHJvbm91c2x5IHByZXBhcmUgd2FzbTogXCIrdCksYXQodCl9KSl9dmFyIHI9e2E6cGV9O2lmKE98fChldCsrLHUubW9uaXRvclJ1bkRlcGVuZGVuY2llcyYmdS5tb25pdG9yUnVuRGVwZW5kZW5jaWVzKGV0KSksdS5pbnN0YW50aWF0ZVdhc20pdHJ5e3JldHVybiB1Lmluc3RhbnRpYXRlV2FzbShyLHQpfWNhdGNoKHQpe3JldHVybiB4KFwiTW9kdWxlLmluc3RhbnRpYXRlV2FzbSBjYWxsYmFjayBmYWlsZWQgd2l0aCBlcnJvcjogXCIrdCksITF9KE18fFwiZnVuY3Rpb25cIiE9dHlwZW9mIFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlU3RyZWFtaW5nfHxpdCgpfHx0dC5zdGFydHNXaXRoKFwiZmlsZTovL1wiKXx8d3x8XCJmdW5jdGlvblwiIT10eXBlb2YgZmV0Y2g/bihlKTpmZXRjaCh0dCx7Y3JlZGVudGlhbHM6XCJzYW1lLW9yaWdpblwifSkudGhlbigoZnVuY3Rpb24odCl7cmV0dXJuIFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlU3RyZWFtaW5nKHQscikudGhlbihlLChmdW5jdGlvbih0KXtyZXR1cm4geChcIndhc20gc3RyZWFtaW5nIGNvbXBpbGUgZmFpbGVkOiBcIit0KSx4KFwiZmFsbGluZyBiYWNrIHRvIEFycmF5QnVmZmVyIGluc3RhbnRpYXRpb25cIiksbihlKX0pKX0pKSkuY2F0Y2goYyl9KCksdS5fX193YXNtX2NhbGxfY3RvcnM9ZnVuY3Rpb24oKXtyZXR1cm4odS5fX193YXNtX2NhbGxfY3RvcnM9dS5hc20uVmEpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sdS5fT3J0SW5pdD1mdW5jdGlvbigpe3JldHVybih1Ll9PcnRJbml0PXUuYXNtLldhKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHUuX09ydENyZWF0ZVNlc3Npb25PcHRpb25zPWZ1bmN0aW9uKCl7cmV0dXJuKHUuX09ydENyZWF0ZVNlc3Npb25PcHRpb25zPXUuYXNtLlhhKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHUuX09ydEFwcGVuZEV4ZWN1dGlvblByb3ZpZGVyPWZ1bmN0aW9uKCl7cmV0dXJuKHUuX09ydEFwcGVuZEV4ZWN1dGlvblByb3ZpZGVyPXUuYXNtLllhKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHUuX09ydEFkZFNlc3Npb25Db25maWdFbnRyeT1mdW5jdGlvbigpe3JldHVybih1Ll9PcnRBZGRTZXNzaW9uQ29uZmlnRW50cnk9dS5hc20uWmEpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sdS5fT3J0UmVsZWFzZVNlc3Npb25PcHRpb25zPWZ1bmN0aW9uKCl7cmV0dXJuKHUuX09ydFJlbGVhc2VTZXNzaW9uT3B0aW9ucz11LmFzbS5fYSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSx1Ll9PcnRDcmVhdGVTZXNzaW9uPWZ1bmN0aW9uKCl7cmV0dXJuKHUuX09ydENyZWF0ZVNlc3Npb249dS5hc20uJGEpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sdS5fT3J0UmVsZWFzZVNlc3Npb249ZnVuY3Rpb24oKXtyZXR1cm4odS5fT3J0UmVsZWFzZVNlc3Npb249dS5hc20uYWIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sdS5fT3J0R2V0SW5wdXRDb3VudD1mdW5jdGlvbigpe3JldHVybih1Ll9PcnRHZXRJbnB1dENvdW50PXUuYXNtLmJiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHUuX09ydEdldE91dHB1dENvdW50PWZ1bmN0aW9uKCl7cmV0dXJuKHUuX09ydEdldE91dHB1dENvdW50PXUuYXNtLmNiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHUuX09ydEdldElucHV0TmFtZT1mdW5jdGlvbigpe3JldHVybih1Ll9PcnRHZXRJbnB1dE5hbWU9dS5hc20uZGIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sdS5fT3J0R2V0T3V0cHV0TmFtZT1mdW5jdGlvbigpe3JldHVybih1Ll9PcnRHZXRPdXRwdXROYW1lPXUuYXNtLmViKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHUuX09ydEZyZWU9ZnVuY3Rpb24oKXtyZXR1cm4odS5fT3J0RnJlZT11LmFzbS5mYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSx1Ll9PcnRDcmVhdGVUZW5zb3I9ZnVuY3Rpb24oKXtyZXR1cm4odS5fT3J0Q3JlYXRlVGVuc29yPXUuYXNtLmdiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHUuX09ydEdldFRlbnNvckRhdGE9ZnVuY3Rpb24oKXtyZXR1cm4odS5fT3J0R2V0VGVuc29yRGF0YT11LmFzbS5oYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSx1Ll9PcnRSZWxlYXNlVGVuc29yPWZ1bmN0aW9uKCl7cmV0dXJuKHUuX09ydFJlbGVhc2VUZW5zb3I9dS5hc20uaWIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sdS5fT3J0Q3JlYXRlUnVuT3B0aW9ucz1mdW5jdGlvbigpe3JldHVybih1Ll9PcnRDcmVhdGVSdW5PcHRpb25zPXUuYXNtLmpiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHUuX09ydEFkZFJ1bkNvbmZpZ0VudHJ5PWZ1bmN0aW9uKCl7cmV0dXJuKHUuX09ydEFkZFJ1bkNvbmZpZ0VudHJ5PXUuYXNtLmtiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHUuX09ydFJlbGVhc2VSdW5PcHRpb25zPWZ1bmN0aW9uKCl7cmV0dXJuKHUuX09ydFJlbGVhc2VSdW5PcHRpb25zPXUuYXNtLmxiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHUuX09ydFJ1bj1mdW5jdGlvbigpe3JldHVybih1Ll9PcnRSdW49dS5hc20ubWIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sdS5fT3J0RW5kUHJvZmlsaW5nPWZ1bmN0aW9uKCl7cmV0dXJuKHUuX09ydEVuZFByb2ZpbGluZz11LmFzbS5uYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfTt2YXIgaGU9dS5fcHRocmVhZF9zZWxmPWZ1bmN0aW9uKCl7cmV0dXJuKGhlPXUuX3B0aHJlYWRfc2VsZj11LmFzbS5vYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxkZT11Ll9tYWxsb2M9ZnVuY3Rpb24oKXtyZXR1cm4oZGU9dS5fbWFsbG9jPXUuYXNtLnBiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHllPXUuX2ZyZWU9ZnVuY3Rpb24oKXtyZXR1cm4oeWU9dS5fZnJlZT11LmFzbS5xYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxiZT11Ll9mZmx1c2g9ZnVuY3Rpb24oKXtyZXR1cm4oYmU9dS5fZmZsdXNoPXUuYXNtLnJiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O3UuX19lbXNjcmlwdGVuX3Rsc19pbml0PWZ1bmN0aW9uKCl7cmV0dXJuKHUuX19lbXNjcmlwdGVuX3Rsc19pbml0PXUuYXNtLnNiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O3ZhciBtZT11Ll9fX2Z1bmNzX29uX2V4aXQ9ZnVuY3Rpb24oKXtyZXR1cm4obWU9dS5fX19mdW5jc19vbl9leGl0PXUuYXNtLnRiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGdlPXUuX19lbXNjcmlwdGVuX3RocmVhZF9pbml0PWZ1bmN0aW9uKCl7cmV0dXJuKGdlPXUuX19lbXNjcmlwdGVuX3RocmVhZF9pbml0PXUuYXNtLnZiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O3UuX19lbXNjcmlwdGVuX3RocmVhZF9jcmFzaGVkPWZ1bmN0aW9uKCl7cmV0dXJuKHUuX19lbXNjcmlwdGVuX3RocmVhZF9jcmFzaGVkPXUuYXNtLndiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O3ZhciB2ZSxfZT11Ll9lbXNjcmlwdGVuX3J1bl9pbl9tYWluX3J1bnRpbWVfdGhyZWFkX2pzPWZ1bmN0aW9uKCl7cmV0dXJuKF9lPXUuX2Vtc2NyaXB0ZW5fcnVuX2luX21haW5fcnVudGltZV90aHJlYWRfanM9dS5hc20ueGIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sd2U9dS5fX2Vtc2NyaXB0ZW5fcHJveHlfZXhlY3V0ZV90YXNrX3F1ZXVlPWZ1bmN0aW9uKCl7cmV0dXJuKHdlPXUuX19lbXNjcmlwdGVuX3Byb3h5X2V4ZWN1dGVfdGFza19xdWV1ZT11LmFzbS55YikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxPZT11Ll9fZW1zY3JpcHRlbl90aHJlYWRfZnJlZV9kYXRhPWZ1bmN0aW9uKCl7cmV0dXJuKE9lPXUuX19lbXNjcmlwdGVuX3RocmVhZF9mcmVlX2RhdGE9dS5hc20uemIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sQWU9dS5fX2Vtc2NyaXB0ZW5fdGhyZWFkX2V4aXQ9ZnVuY3Rpb24oKXtyZXR1cm4oQWU9dS5fX2Vtc2NyaXB0ZW5fdGhyZWFkX2V4aXQ9dS5hc20uQWIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sU2U9dS5fc2V0VGhyZXc9ZnVuY3Rpb24oKXtyZXR1cm4oU2U9dS5fc2V0VGhyZXc9dS5hc20uQmIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sVGU9dS5fZW1zY3JpcHRlbl9zdGFja19zZXRfbGltaXRzPWZ1bmN0aW9uKCl7cmV0dXJuKFRlPXUuX2Vtc2NyaXB0ZW5fc3RhY2tfc2V0X2xpbWl0cz11LmFzbS5DYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxFZT11LnN0YWNrU2F2ZT1mdW5jdGlvbigpe3JldHVybihFZT11LnN0YWNrU2F2ZT11LmFzbS5EYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxNZT11LnN0YWNrUmVzdG9yZT1mdW5jdGlvbigpe3JldHVybihNZT11LnN0YWNrUmVzdG9yZT11LmFzbS5FYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxDZT11LnN0YWNrQWxsb2M9ZnVuY3Rpb24oKXtyZXR1cm4oQ2U9dS5zdGFja0FsbG9jPXUuYXNtLkZiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHhlPXUuX19fY3hhX2Nhbl9jYXRjaD1mdW5jdGlvbigpe3JldHVybih4ZT11Ll9fX2N4YV9jYW5fY2F0Y2g9dS5hc20uR2IpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sUmU9dS5fX19jeGFfaXNfcG9pbnRlcl90eXBlPWZ1bmN0aW9uKCl7cmV0dXJuKFJlPXUuX19fY3hhX2lzX3BvaW50ZXJfdHlwZT11LmFzbS5IYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxrZT11LmR5bkNhbGxfaj1mdW5jdGlvbigpe3JldHVybihrZT11LmR5bkNhbGxfaj11LmFzbS5JYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxqZT11LmR5bkNhbGxfaWlpaWlqPWZ1bmN0aW9uKCl7cmV0dXJuKGplPXUuZHluQ2FsbF9paWlpaWo9dS5hc20uSmIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sRGU9dS5keW5DYWxsX2ppaT1mdW5jdGlvbigpe3JldHVybihEZT11LmR5bkNhbGxfamlpPXUuYXNtLktiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LFBlPXUuZHluQ2FsbF92aWlpaWlqPWZ1bmN0aW9uKCl7cmV0dXJuKFBlPXUuZHluQ2FsbF92aWlpaWlqPXUuYXNtLkxiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LFVlPXUuZHluQ2FsbF92amppPWZ1bmN0aW9uKCl7cmV0dXJuKFVlPXUuZHluQ2FsbF92amppPXUuYXNtLk1iKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LEZlPXUuZHluQ2FsbF92aWlpampqaWk9ZnVuY3Rpb24oKXtyZXR1cm4oRmU9dS5keW5DYWxsX3ZpaWlqamppaT11LmFzbS5OYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxJZT11LmR5bkNhbGxfaWlqPWZ1bmN0aW9uKCl7cmV0dXJuKEllPXUuZHluQ2FsbF9paWo9dS5hc20uT2IpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sV2U9dS5keW5DYWxsX2ppPWZ1bmN0aW9uKCl7cmV0dXJuKFdlPXUuZHluQ2FsbF9qaT11LmFzbS5QYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxIZT11LmR5bkNhbGxfaWlpaWlpaj1mdW5jdGlvbigpe3JldHVybihIZT11LmR5bkNhbGxfaWlpaWlpaj11LmFzbS5RYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSx6ZT11LmR5bkNhbGxfaWlpaj1mdW5jdGlvbigpe3JldHVybih6ZT11LmR5bkNhbGxfaWlpaj11LmFzbS5SYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfTtmdW5jdGlvbiBMZSgpe2Z1bmN0aW9uIHQoKXtpZighdmUmJih2ZT0hMCx1LmNhbGxlZFJ1bj0hMCwhSCkmJihPfHxkdChYKSxzKHUpLHUub25SdW50aW1lSW5pdGlhbGl6ZWQmJnUub25SdW50aW1lSW5pdGlhbGl6ZWQoKSwhTykpe2lmKHUucG9zdFJ1bilmb3IoXCJmdW5jdGlvblwiPT10eXBlb2YgdS5wb3N0UnVuJiYodS5wb3N0UnVuPVt1LnBvc3RSdW5dKTt1LnBvc3RSdW4ubGVuZ3RoOyl7dmFyIHQ9dS5wb3N0UnVuLnNoaWZ0KCk7Wi51bnNoaWZ0KHQpfWR0KFopfX1pZighKDA8ZXQpKWlmKE8pcyh1KSxPfHxkdChYKSxwb3N0TWVzc2FnZSh7Y21kOlwibG9hZGVkXCJ9KTtlbHNle2lmKHUucHJlUnVuKWZvcihcImZ1bmN0aW9uXCI9PXR5cGVvZiB1LnByZVJ1biYmKHUucHJlUnVuPVt1LnByZVJ1bl0pO3UucHJlUnVuLmxlbmd0aDspSygpO2R0KCQpLDA8ZXR8fCh1LnNldFN0YXR1cz8odS5zZXRTdGF0dXMoXCJSdW5uaW5nLi4uXCIpLHNldFRpbWVvdXQoKGZ1bmN0aW9uKCl7c2V0VGltZW91dCgoZnVuY3Rpb24oKXt1LnNldFN0YXR1cyhcIlwiKX0pLDEpLHQoKX0pLDEpKTp0KCkpfX1pZih1LlVURjhUb1N0cmluZz1ZLHUuc3RyaW5nVG9VVEY4PWZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gQih0LHIoKSxlLG4pfSx1Lmxlbmd0aEJ5dGVzVVRGOD1HLHUua2VlcFJ1bnRpbWVBbGl2ZT1RLHUud2FzbU1lbW9yeT1rLHUuc3RhY2tTYXZlPUVlLHUuc3RhY2tSZXN0b3JlPU1lLHUuc3RhY2tBbGxvYz1DZSx1LkV4aXRTdGF0dXM9c3QsdS5QVGhyZWFkPWh0LHJ0PWZ1bmN0aW9uIHQoKXt2ZXx8TGUoKSx2ZXx8KHJ0PXQpfSx1LnByZUluaXQpZm9yKFwiZnVuY3Rpb25cIj09dHlwZW9mIHUucHJlSW5pdCYmKHUucHJlSW5pdD1bdS5wcmVJbml0XSk7MDx1LnByZUluaXQubGVuZ3RoOyl1LnByZUluaXQucG9wKCkoKTtyZXR1cm4gTGUoKSx0LnJlYWR5fSk7dC5leHBvcnRzPXJ9LDkzMjoodCxlLG4pPT57dmFyIF9zY3JpcHREaXIscj0oX3NjcmlwdERpcj0oX3NjcmlwdERpcj1cInVuZGVmaW5lZFwiIT10eXBlb2YgZG9jdW1lbnQmJmRvY3VtZW50LmN1cnJlbnRTY3JpcHQ/ZG9jdW1lbnQuY3VycmVudFNjcmlwdC5zcmM6dm9pZCAwKXx8X19maWxlbmFtZSxmdW5jdGlvbih0KXt2YXIgZSxyLGE7dD10fHx7fSxlfHwoZT12b2lkIDAhPT10P3Q6e30pLGUucmVhZHk9bmV3IFByb21pc2UoKGZ1bmN0aW9uKHQsZSl7cj10LGE9ZX0pKTt2YXIgaSxvLHUscyxjLGwsZj1PYmplY3QuYXNzaWduKHt9LGUpLHA9XCIuL3RoaXMucHJvZ3JhbVwiLGg9KHQsZSk9Pnt0aHJvdyBlfSxkPVwib2JqZWN0XCI9PXR5cGVvZiB3aW5kb3cseT1cImZ1bmN0aW9uXCI9PXR5cGVvZiBpbXBvcnRTY3JpcHRzLGI9XCJvYmplY3RcIj09dHlwZW9mIHByb2Nlc3MmJlwib2JqZWN0XCI9PXR5cGVvZiBwcm9jZXNzLnZlcnNpb25zJiZcInN0cmluZ1wiPT10eXBlb2YgcHJvY2Vzcy52ZXJzaW9ucy5ub2RlLG09XCJcIjtiPyhtPXk/bigxNykuZGlybmFtZShtKStcIi9cIjpfX2Rpcm5hbWUrXCIvXCIsbD0oKT0+e2N8fChzPW4oMTQ3KSxjPW4oMTcpKX0saT1mdW5jdGlvbih0LGUpe3JldHVybiBsKCksdD1jLm5vcm1hbGl6ZSh0KSxzLnJlYWRGaWxlU3luYyh0LGU/dm9pZCAwOlwidXRmOFwiKX0sdT10PT4oKHQ9aSh0LCEwKSkuYnVmZmVyfHwodD1uZXcgVWludDhBcnJheSh0KSksdCksbz0odCxlLG4pPT57bCgpLHQ9Yy5ub3JtYWxpemUodCkscy5yZWFkRmlsZSh0LChmdW5jdGlvbih0LHIpe3Q/bih0KTplKHIuYnVmZmVyKX0pKX0sMTxwcm9jZXNzLmFyZ3YubGVuZ3RoJiYocD1wcm9jZXNzLmFyZ3ZbMV0ucmVwbGFjZSgvXFxcXFxcXFwvZyxcIi9cIikpLHByb2Nlc3MuYXJndi5zbGljZSgyKSxwcm9jZXNzLm9uKFwidW5jYXVnaHRFeGNlcHRpb25cIiwoZnVuY3Rpb24odCl7aWYoISh0IGluc3RhbmNlb2YgSikpdGhyb3cgdH0pKSxwcm9jZXNzLm9uKFwidW5oYW5kbGVkUmVqZWN0aW9uXCIsKGZ1bmN0aW9uKHQpe3Rocm93IHR9KSksaD0odCxlKT0+e2lmKHd8fDA8eil0aHJvdyBwcm9jZXNzLmV4aXRDb2RlPXQsZTtlIGluc3RhbmNlb2YgSnx8XyhcImV4aXRpbmcgZHVlIHRvIGV4Y2VwdGlvbjogXCIrZSkscHJvY2Vzcy5leGl0KHQpfSxlLmluc3BlY3Q9ZnVuY3Rpb24oKXtyZXR1cm5cIltFbXNjcmlwdGVuIE1vZHVsZSBvYmplY3RdXCJ9KTooZHx8eSkmJih5P209c2VsZi5sb2NhdGlvbi5ocmVmOlwidW5kZWZpbmVkXCIhPXR5cGVvZiBkb2N1bWVudCYmZG9jdW1lbnQuY3VycmVudFNjcmlwdCYmKG09ZG9jdW1lbnQuY3VycmVudFNjcmlwdC5zcmMpLF9zY3JpcHREaXImJihtPV9zY3JpcHREaXIpLG09MCE9PW0uaW5kZXhPZihcImJsb2I6XCIpP20uc3Vic3RyKDAsbS5yZXBsYWNlKC9bPyNdLiovLFwiXCIpLmxhc3RJbmRleE9mKFwiL1wiKSsxKTpcIlwiLGk9dD0+e3ZhciBlPW5ldyBYTUxIdHRwUmVxdWVzdDtyZXR1cm4gZS5vcGVuKFwiR0VUXCIsdCwhMSksZS5zZW5kKG51bGwpLGUucmVzcG9uc2VUZXh0fSx5JiYodT10PT57dmFyIGU9bmV3IFhNTEh0dHBSZXF1ZXN0O3JldHVybiBlLm9wZW4oXCJHRVRcIix0LCExKSxlLnJlc3BvbnNlVHlwZT1cImFycmF5YnVmZmVyXCIsZS5zZW5kKG51bGwpLG5ldyBVaW50OEFycmF5KGUucmVzcG9uc2UpfSksbz0odCxlLG4pPT57dmFyIHI9bmV3IFhNTEh0dHBSZXF1ZXN0O3Iub3BlbihcIkdFVFwiLHQsITApLHIucmVzcG9uc2VUeXBlPVwiYXJyYXlidWZmZXJcIixyLm9ubG9hZD0oKT0+ezIwMD09ci5zdGF0dXN8fDA9PXIuc3RhdHVzJiZyLnJlc3BvbnNlP2Uoci5yZXNwb25zZSk6bigpfSxyLm9uZXJyb3I9bixyLnNlbmQobnVsbCl9KTt2YXIgZyx2PWUucHJpbnR8fGNvbnNvbGUubG9nLmJpbmQoY29uc29sZSksXz1lLnByaW50RXJyfHxjb25zb2xlLndhcm4uYmluZChjb25zb2xlKTtPYmplY3QuYXNzaWduKGUsZiksZj1udWxsLGUudGhpc1Byb2dyYW0mJihwPWUudGhpc1Byb2dyYW0pLGUucXVpdCYmKGg9ZS5xdWl0KSxlLndhc21CaW5hcnkmJihnPWUud2FzbUJpbmFyeSk7dmFyIHc9ZS5ub0V4aXRSdW50aW1lfHwhMTtcIm9iamVjdFwiIT10eXBlb2YgV2ViQXNzZW1ibHkmJlYoXCJubyBuYXRpdmUgd2FzbSBzdXBwb3J0IGRldGVjdGVkXCIpO3ZhciBPLEEsUyxULEUsTSxDPSExLHg9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIFRleHREZWNvZGVyP25ldyBUZXh0RGVjb2RlcihcInV0ZjhcIik6dm9pZCAwO2Z1bmN0aW9uIFIodCxlLG4pe3ZhciByPShlPj4+PTApK247Zm9yKG49ZTt0W25dJiYhKG4+PXIpOykrK247aWYoMTY8bi1lJiZ0LmJ1ZmZlciYmeClyZXR1cm4geC5kZWNvZGUodC5zdWJhcnJheShlLG4pKTtmb3Iocj1cIlwiO2U8bjspe3ZhciBhPXRbZSsrXTtpZigxMjgmYSl7dmFyIGk9NjMmdFtlKytdO2lmKDE5Mj09KDIyNCZhKSlyKz1TdHJpbmcuZnJvbUNoYXJDb2RlKCgzMSZhKTw8NnxpKTtlbHNle3ZhciBvPTYzJnRbZSsrXTs2NTUzNj4oYT0yMjQ9PSgyNDAmYSk/KDE1JmEpPDwxMnxpPDw2fG86KDcmYSk8PDE4fGk8PDEyfG88PDZ8NjMmdFtlKytdKT9yKz1TdHJpbmcuZnJvbUNoYXJDb2RlKGEpOihhLT02NTUzNixyKz1TdHJpbmcuZnJvbUNoYXJDb2RlKDU1Mjk2fGE+PjEwLDU2MzIwfDEwMjMmYSkpfX1lbHNlIHIrPVN0cmluZy5mcm9tQ2hhckNvZGUoYSl9cmV0dXJuIHJ9ZnVuY3Rpb24gayh0LGUpe3JldHVybih0Pj4+PTApP1IoVCx0LGUpOlwiXCJ9ZnVuY3Rpb24gaih0LGUsbixyKXtpZighKDA8cikpcmV0dXJuIDA7dmFyIGE9bj4+Pj0wO3I9bityLTE7Zm9yKHZhciBpPTA7aTx0Lmxlbmd0aDsrK2kpe3ZhciBvPXQuY2hhckNvZGVBdChpKTtpZig1NTI5Njw9byYmNTczNDM+PW8mJihvPTY1NTM2KygoMTAyMyZvKTw8MTApfDEwMjMmdC5jaGFyQ29kZUF0KCsraSkpLDEyNz49byl7aWYobj49cilicmVhaztlW24rKz4+PjBdPW99ZWxzZXtpZigyMDQ3Pj1vKXtpZihuKzE+PXIpYnJlYWs7ZVtuKys+Pj4wXT0xOTJ8bz4+Nn1lbHNle2lmKDY1NTM1Pj1vKXtpZihuKzI+PXIpYnJlYWs7ZVtuKys+Pj4wXT0yMjR8bz4+MTJ9ZWxzZXtpZihuKzM+PXIpYnJlYWs7ZVtuKys+Pj4wXT0yNDB8bz4+MTgsZVtuKys+Pj4wXT0xMjh8bz4+MTImNjN9ZVtuKys+Pj4wXT0xMjh8bz4+NiY2M31lW24rKz4+PjBdPTEyOHw2MyZvfX1yZXR1cm4gZVtuPj4+MF09MCxuLWF9ZnVuY3Rpb24gRCh0KXtmb3IodmFyIGU9MCxuPTA7bjx0Lmxlbmd0aDsrK24pe3ZhciByPXQuY2hhckNvZGVBdChuKTsxMjc+PXI/ZSsrOjIwNDc+PXI/ZSs9Mjo1NTI5Njw9ciYmNTczNDM+PXI/KGUrPTQsKytuKTplKz0zfXJldHVybiBlfWZ1bmN0aW9uIFAoKXt2YXIgdD1PLmJ1ZmZlcjtBPXQsZS5IRUFQOD1TPW5ldyBJbnQ4QXJyYXkodCksZS5IRUFQMTY9bmV3IEludDE2QXJyYXkodCksZS5IRUFQMzI9RT1uZXcgSW50MzJBcnJheSh0KSxlLkhFQVBVOD1UPW5ldyBVaW50OEFycmF5KHQpLGUuSEVBUFUxNj1uZXcgVWludDE2QXJyYXkodCksZS5IRUFQVTMyPU09bmV3IFVpbnQzMkFycmF5KHQpLGUuSEVBUEYzMj1uZXcgRmxvYXQzMkFycmF5KHQpLGUuSEVBUEY2ND1uZXcgRmxvYXQ2NEFycmF5KHQpfXZhciBVLEY9W10sST1bXSxXPVtdLEg9W10sej0wO2Z1bmN0aW9uIEwoKXt2YXIgdD1lLnByZVJ1bi5zaGlmdCgpO0YudW5zaGlmdCh0KX12YXIgWSxCPTAsRz1udWxsLE49bnVsbDtmdW5jdGlvbiBWKHQpe3Rocm93IGUub25BYm9ydCYmZS5vbkFib3J0KHQpLF8odD1cIkFib3J0ZWQoXCIrdCtcIilcIiksQz0hMCx0PW5ldyBXZWJBc3NlbWJseS5SdW50aW1lRXJyb3IodCtcIi4gQnVpbGQgd2l0aCAtc0FTU0VSVElPTlMgZm9yIG1vcmUgaW5mby5cIiksYSh0KSx0fWZ1bmN0aW9uIHEoKXtyZXR1cm4gWS5zdGFydHNXaXRoKFwiZGF0YTphcHBsaWNhdGlvbi9vY3RldC1zdHJlYW07YmFzZTY0LFwiKX1pZihZPVwib3J0LXdhc20ud2FzbVwiLCFxKCkpe3ZhciAkPVk7WT1lLmxvY2F0ZUZpbGU/ZS5sb2NhdGVGaWxlKCQsbSk6bSskfWZ1bmN0aW9uIFgoKXt2YXIgdD1ZO3RyeXtpZih0PT1ZJiZnKXJldHVybiBuZXcgVWludDhBcnJheShnKTtpZih1KXJldHVybiB1KHQpO3Rocm93XCJib3RoIGFzeW5jIGFuZCBzeW5jIGZldGNoaW5nIG9mIHRoZSB3YXNtIGZhaWxlZFwifWNhdGNoKHQpe1YodCl9fWZ1bmN0aW9uIEoodCl7dGhpcy5uYW1lPVwiRXhpdFN0YXR1c1wiLHRoaXMubWVzc2FnZT1cIlByb2dyYW0gdGVybWluYXRlZCB3aXRoIGV4aXQoXCIrdCtcIilcIix0aGlzLnN0YXR1cz10fWZ1bmN0aW9uIFoodCl7Zm9yKDswPHQubGVuZ3RoOyl0LnNoaWZ0KCkoZSl9dmFyIFE9W10sSz0wLHR0PTA7ZnVuY3Rpb24gZXQodCl7dGhpcy5EYj10LHRoaXMuemI9dC0yNCx0aGlzLlViPWZ1bmN0aW9uKHQpe01bdGhpcy56Yis0Pj4yPj4+MF09dH0sdGhpcy5FYj1mdW5jdGlvbigpe3JldHVybiBNW3RoaXMuemIrND4+Mj4+PjBdfSx0aGlzLlNiPWZ1bmN0aW9uKHQpe01bdGhpcy56Yis4Pj4yPj4+MF09dH0sdGhpcy5XYj1mdW5jdGlvbigpe3JldHVybiBNW3RoaXMuemIrOD4+Mj4+PjBdfSx0aGlzLlRiPWZ1bmN0aW9uKCl7RVt0aGlzLnpiPj4yPj4+MF09MH0sdGhpcy5JYj1mdW5jdGlvbih0KXtTW3RoaXMuemIrMTI+PjA+Pj4wXT10PzE6MH0sdGhpcy5QYj1mdW5jdGlvbigpe3JldHVybiAwIT1TW3RoaXMuemIrMTI+PjA+Pj4wXX0sdGhpcy5KYj1mdW5jdGlvbih0KXtTW3RoaXMuemIrMTM+PjA+Pj4wXT10PzE6MH0sdGhpcy5MYj1mdW5jdGlvbigpe3JldHVybiAwIT1TW3RoaXMuemIrMTM+PjA+Pj4wXX0sdGhpcy5SYj1mdW5jdGlvbih0LGUpe3RoaXMuRmIoMCksdGhpcy5VYih0KSx0aGlzLlNiKGUpLHRoaXMuVGIoKSx0aGlzLkliKCExKSx0aGlzLkpiKCExKX0sdGhpcy5OYj1mdW5jdGlvbigpe0VbdGhpcy56Yj4+Mj4+PjBdKz0xfSx0aGlzLlhiPWZ1bmN0aW9uKCl7dmFyIHQ9RVt0aGlzLnpiPj4yPj4+MF07cmV0dXJuIEVbdGhpcy56Yj4+Mj4+PjBdPXQtMSwxPT09dH0sdGhpcy5GYj1mdW5jdGlvbih0KXtNW3RoaXMuemIrMTY+PjI+Pj4wXT10fSx0aGlzLk9iPWZ1bmN0aW9uKCl7cmV0dXJuIE1bdGhpcy56YisxNj4+Mj4+PjBdfSx0aGlzLlFiPWZ1bmN0aW9uKCl7aWYoTXQodGhpcy5FYigpKSlyZXR1cm4gTVt0aGlzLkRiPj4yPj4+MF07dmFyIHQ9dGhpcy5PYigpO3JldHVybiAwIT09dD90OnRoaXMuRGJ9fWZ1bmN0aW9uIG50KHQpe3JldHVybiB2dChuZXcgZXQodCkuemIpfXZhciBydD1bXTtmdW5jdGlvbiBhdCh0KXt2YXIgZT1ydFt0XTtyZXR1cm4gZXx8KHQ+PXJ0Lmxlbmd0aCYmKHJ0Lmxlbmd0aD10KzEpLHJ0W3RdPWU9VS5nZXQodCkpLGV9ZnVuY3Rpb24gaXQodCl7dmFyIGU9RCh0KSsxLG49Z3QoZSk7cmV0dXJuIG4mJmoodCxTLG4sZSksbn12YXIgb3Q9e307ZnVuY3Rpb24gdXQoKXtpZighc3Qpe3ZhciB0LGU9e1VTRVI6XCJ3ZWJfdXNlclwiLExPR05BTUU6XCJ3ZWJfdXNlclwiLFBBVEg6XCIvXCIsUFdEOlwiL1wiLEhPTUU6XCIvaG9tZS93ZWJfdXNlclwiLExBTkc6KFwib2JqZWN0XCI9PXR5cGVvZiBuYXZpZ2F0b3ImJm5hdmlnYXRvci5sYW5ndWFnZXMmJm5hdmlnYXRvci5sYW5ndWFnZXNbMF18fFwiQ1wiKS5yZXBsYWNlKFwiLVwiLFwiX1wiKStcIi5VVEYtOFwiLF86cHx8XCIuL3RoaXMucHJvZ3JhbVwifTtmb3IodCBpbiBvdCl2b2lkIDA9PT1vdFt0XT9kZWxldGUgZVt0XTplW3RdPW90W3RdO3ZhciBuPVtdO2Zvcih0IGluIGUpbi5wdXNoKHQrXCI9XCIrZVt0XSk7c3Q9bn1yZXR1cm4gc3R9dmFyIHN0LGN0PVtudWxsLFtdLFtdXTtmdW5jdGlvbiBsdCh0LGUpe3ZhciBuPWN0W3RdOzA9PT1lfHwxMD09PWU/KCgxPT09dD92Ol8pKFIobiwwKSksbi5sZW5ndGg9MCk6bi5wdXNoKGUpfXZhciBmdD0wO2Z1bmN0aW9uIHB0KHQpe3JldHVybiAwPT10JTQmJigwIT10JTEwMHx8MD09dCU0MDApfXZhciBodD1bMzEsMjksMzEsMzAsMzEsMzAsMzEsMzEsMzAsMzEsMzAsMzFdLGR0PVszMSwyOCwzMSwzMCwzMSwzMCwzMSwzMSwzMCwzMSwzMCwzMV07ZnVuY3Rpb24geXQodCxlLG4scil7ZnVuY3Rpb24gYSh0LGUsbil7Zm9yKHQ9XCJudW1iZXJcIj09dHlwZW9mIHQ/dC50b1N0cmluZygpOnR8fFwiXCI7dC5sZW5ndGg8ZTspdD1uWzBdK3Q7cmV0dXJuIHR9ZnVuY3Rpb24gaSh0LGUpe3JldHVybiBhKHQsZSxcIjBcIil9ZnVuY3Rpb24gbyh0LGUpe2Z1bmN0aW9uIG4odCl7cmV0dXJuIDA+dD8tMTowPHQ/MTowfXZhciByO3JldHVybiAwPT09KHI9bih0LmdldEZ1bGxZZWFyKCktZS5nZXRGdWxsWWVhcigpKSkmJjA9PT0ocj1uKHQuZ2V0TW9udGgoKS1lLmdldE1vbnRoKCkpKSYmKHI9bih0LmdldERhdGUoKS1lLmdldERhdGUoKSkpLHJ9ZnVuY3Rpb24gdSh0KXtzd2l0Y2godC5nZXREYXkoKSl7Y2FzZSAwOnJldHVybiBuZXcgRGF0ZSh0LmdldEZ1bGxZZWFyKCktMSwxMSwyOSk7Y2FzZSAxOnJldHVybiB0O2Nhc2UgMjpyZXR1cm4gbmV3IERhdGUodC5nZXRGdWxsWWVhcigpLDAsMyk7Y2FzZSAzOnJldHVybiBuZXcgRGF0ZSh0LmdldEZ1bGxZZWFyKCksMCwyKTtjYXNlIDQ6cmV0dXJuIG5ldyBEYXRlKHQuZ2V0RnVsbFllYXIoKSwwLDEpO2Nhc2UgNTpyZXR1cm4gbmV3IERhdGUodC5nZXRGdWxsWWVhcigpLTEsMTEsMzEpO2Nhc2UgNjpyZXR1cm4gbmV3IERhdGUodC5nZXRGdWxsWWVhcigpLTEsMTEsMzApfX1mdW5jdGlvbiBzKHQpe3ZhciBlPXQuQmI7Zm9yKHQ9bmV3IERhdGUobmV3IERhdGUodC5DYisxOTAwLDAsMSkuZ2V0VGltZSgpKTswPGU7KXt2YXIgbj10LmdldE1vbnRoKCkscj0ocHQodC5nZXRGdWxsWWVhcigpKT9odDpkdClbbl07aWYoIShlPnItdC5nZXREYXRlKCkpKXt0LnNldERhdGUodC5nZXREYXRlKCkrZSk7YnJlYWt9ZS09ci10LmdldERhdGUoKSsxLHQuc2V0RGF0ZSgxKSwxMT5uP3Quc2V0TW9udGgobisxKToodC5zZXRNb250aCgwKSx0LnNldEZ1bGxZZWFyKHQuZ2V0RnVsbFllYXIoKSsxKSl9cmV0dXJuIG49bmV3IERhdGUodC5nZXRGdWxsWWVhcigpKzEsMCw0KSxlPXUobmV3IERhdGUodC5nZXRGdWxsWWVhcigpLDAsNCkpLG49dShuKSwwPj1vKGUsdCk/MD49byhuLHQpP3QuZ2V0RnVsbFllYXIoKSsxOnQuZ2V0RnVsbFllYXIoKTp0LmdldEZ1bGxZZWFyKCktMX12YXIgYz1FW3IrNDA+PjI+Pj4wXTtmb3IodmFyIGwgaW4gcj17JGI6RVtyPj4yPj4+MF0sWmI6RVtyKzQ+PjI+Pj4wXSxHYjpFW3IrOD4+Mj4+PjBdLEtiOkVbcisxMj4+Mj4+PjBdLEhiOkVbcisxNj4+Mj4+PjBdLENiOkVbcisyMD4+Mj4+PjBdLEFiOkVbcisyND4+Mj4+PjBdLEJiOkVbcisyOD4+Mj4+PjBdLGJjOkVbciszMj4+Mj4+PjBdLFliOkVbciszNj4+Mj4+PjBdLGFjOmM/ayhjKTpcIlwifSxuPWsobiksYz17XCIlY1wiOlwiJWEgJWIgJWQgJUg6JU06JVMgJVlcIixcIiVEXCI6XCIlbS8lZC8leVwiLFwiJUZcIjpcIiVZLSVtLSVkXCIsXCIlaFwiOlwiJWJcIixcIiVyXCI6XCIlSTolTTolUyAlcFwiLFwiJVJcIjpcIiVIOiVNXCIsXCIlVFwiOlwiJUg6JU06JVNcIixcIiV4XCI6XCIlbS8lZC8leVwiLFwiJVhcIjpcIiVIOiVNOiVTXCIsXCIlRWNcIjpcIiVjXCIsXCIlRUNcIjpcIiVDXCIsXCIlRXhcIjpcIiVtLyVkLyV5XCIsXCIlRVhcIjpcIiVIOiVNOiVTXCIsXCIlRXlcIjpcIiV5XCIsXCIlRVlcIjpcIiVZXCIsXCIlT2RcIjpcIiVkXCIsXCIlT2VcIjpcIiVlXCIsXCIlT0hcIjpcIiVIXCIsXCIlT0lcIjpcIiVJXCIsXCIlT21cIjpcIiVtXCIsXCIlT01cIjpcIiVNXCIsXCIlT1NcIjpcIiVTXCIsXCIlT3VcIjpcIiV1XCIsXCIlT1VcIjpcIiVVXCIsXCIlT1ZcIjpcIiVWXCIsXCIlT3dcIjpcIiV3XCIsXCIlT1dcIjpcIiVXXCIsXCIlT3lcIjpcIiV5XCJ9KW49bi5yZXBsYWNlKG5ldyBSZWdFeHAobCxcImdcIiksY1tsXSk7dmFyIGY9XCJTdW5kYXkgTW9uZGF5IFR1ZXNkYXkgV2VkbmVzZGF5IFRodXJzZGF5IEZyaWRheSBTYXR1cmRheVwiLnNwbGl0KFwiIFwiKSxwPVwiSmFudWFyeSBGZWJydWFyeSBNYXJjaCBBcHJpbCBNYXkgSnVuZSBKdWx5IEF1Z3VzdCBTZXB0ZW1iZXIgT2N0b2JlciBOb3ZlbWJlciBEZWNlbWJlclwiLnNwbGl0KFwiIFwiKTtmb3IobCBpbiBjPXtcIiVhXCI6ZnVuY3Rpb24odCl7cmV0dXJuIGZbdC5BYl0uc3Vic3RyaW5nKDAsMyl9LFwiJUFcIjpmdW5jdGlvbih0KXtyZXR1cm4gZlt0LkFiXX0sXCIlYlwiOmZ1bmN0aW9uKHQpe3JldHVybiBwW3QuSGJdLnN1YnN0cmluZygwLDMpfSxcIiVCXCI6ZnVuY3Rpb24odCl7cmV0dXJuIHBbdC5IYl19LFwiJUNcIjpmdW5jdGlvbih0KXtyZXR1cm4gaSgodC5DYisxOTAwKS8xMDB8MCwyKX0sXCIlZFwiOmZ1bmN0aW9uKHQpe3JldHVybiBpKHQuS2IsMil9LFwiJWVcIjpmdW5jdGlvbih0KXtyZXR1cm4gYSh0LktiLDIsXCIgXCIpfSxcIiVnXCI6ZnVuY3Rpb24odCl7cmV0dXJuIHModCkudG9TdHJpbmcoKS5zdWJzdHJpbmcoMil9LFwiJUdcIjpmdW5jdGlvbih0KXtyZXR1cm4gcyh0KX0sXCIlSFwiOmZ1bmN0aW9uKHQpe3JldHVybiBpKHQuR2IsMil9LFwiJUlcIjpmdW5jdGlvbih0KXtyZXR1cm4gMD09KHQ9dC5HYik/dD0xMjoxMjx0JiYodC09MTIpLGkodCwyKX0sXCIlalwiOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT0wLG49MDtuPD10LkhiLTE7ZSs9KHB0KHQuQ2IrMTkwMCk/aHQ6ZHQpW24rK10pO3JldHVybiBpKHQuS2IrZSwzKX0sXCIlbVwiOmZ1bmN0aW9uKHQpe3JldHVybiBpKHQuSGIrMSwyKX0sXCIlTVwiOmZ1bmN0aW9uKHQpe3JldHVybiBpKHQuWmIsMil9LFwiJW5cIjpmdW5jdGlvbigpe3JldHVyblwiXFxcXG5cIn0sXCIlcFwiOmZ1bmN0aW9uKHQpe3JldHVybiAwPD10LkdiJiYxMj50LkdiP1wiQU1cIjpcIlBNXCJ9LFwiJVNcIjpmdW5jdGlvbih0KXtyZXR1cm4gaSh0LiRiLDIpfSxcIiV0XCI6ZnVuY3Rpb24oKXtyZXR1cm5cIlxcXFx0XCJ9LFwiJXVcIjpmdW5jdGlvbih0KXtyZXR1cm4gdC5BYnx8N30sXCIlVVwiOmZ1bmN0aW9uKHQpe3JldHVybiBpKE1hdGguZmxvb3IoKHQuQmIrNy10LkFiKS83KSwyKX0sXCIlVlwiOmZ1bmN0aW9uKHQpe3ZhciBlPU1hdGguZmxvb3IoKHQuQmIrNy0odC5BYis2KSU3KS83KTtpZigyPj0odC5BYiszNzEtdC5CYi0yKSU3JiZlKyssZSk1Mz09ZSYmKDQ9PShuPSh0LkFiKzM3MS10LkJiKSU3KXx8Mz09biYmcHQodC5DYil8fChlPTEpKTtlbHNle2U9NTI7dmFyIG49KHQuQWIrNy10LkJiLTEpJTc7KDQ9PW58fDU9PW4mJnB0KHQuQ2IlNDAwLTEpKSYmZSsrfXJldHVybiBpKGUsMil9LFwiJXdcIjpmdW5jdGlvbih0KXtyZXR1cm4gdC5BYn0sXCIlV1wiOmZ1bmN0aW9uKHQpe3JldHVybiBpKE1hdGguZmxvb3IoKHQuQmIrNy0odC5BYis2KSU3KS83KSwyKX0sXCIleVwiOmZ1bmN0aW9uKHQpe3JldHVybih0LkNiKzE5MDApLnRvU3RyaW5nKCkuc3Vic3RyaW5nKDIpfSxcIiVZXCI6ZnVuY3Rpb24odCl7cmV0dXJuIHQuQ2IrMTkwMH0sXCIlelwiOmZ1bmN0aW9uKHQpe3ZhciBlPTA8PSh0PXQuWWIpO3JldHVybiB0PU1hdGguYWJzKHQpLzYwLChlP1wiK1wiOlwiLVwiKStTdHJpbmcoXCIwMDAwXCIrKHQvNjAqMTAwK3QlNjApKS5zbGljZSgtNCl9LFwiJVpcIjpmdW5jdGlvbih0KXtyZXR1cm4gdC5hY30sXCIlJVwiOmZ1bmN0aW9uKCl7cmV0dXJuXCIlXCJ9fSxuPW4ucmVwbGFjZSgvJSUvZyxcIlxcXFwwXFxcXDBcIiksYyluLmluY2x1ZGVzKGwpJiYobj1uLnJlcGxhY2UobmV3IFJlZ0V4cChsLFwiZ1wiKSxjW2xdKHIpKSk7cmV0dXJuIGw9ZnVuY3Rpb24odCl7dmFyIGU9QXJyYXkoRCh0KSsxKTtyZXR1cm4gaih0LGUsMCxlLmxlbmd0aCksZX0obj1uLnJlcGxhY2UoL1xcXFwwXFxcXDAvZyxcIiVcIikpLGwubGVuZ3RoPmU/MDooUy5zZXQobCx0Pj4+MCksbC5sZW5ndGgtMSl9dmFyIGJ0PXthOmZ1bmN0aW9uKHQpe3JldHVybiBndCh0KzI0KSsyNH0sbTpmdW5jdGlvbih0KXtyZXR1cm4odD1uZXcgZXQodCkpLlBiKCl8fCh0LkliKCEwKSxLLS0pLHQuSmIoITEpLFEucHVzaCh0KSx0Lk5iKCksdC5RYigpfSxpYTpmdW5jdGlvbih0KXt0aHJvdyBfKFwiVW5leHBlY3RlZCBleGNlcHRpb24gdGhyb3duLCB0aGlzIGlzIG5vdCBwcm9wZXJseSBzdXBwb3J0ZWQgLSBhYm9ydGluZ1wiKSxDPSEwLHR9LHc6ZnVuY3Rpb24oKXtPdCgwKTt2YXIgdD1RLnBvcCgpO2lmKHQuWGIoKSYmIXQuTGIoKSl7dmFyIGU9dC5XYigpO2UmJmF0KGUpKHQuRGIpLG50KHQuRGIpfXR0PTB9LGQ6ZnVuY3Rpb24oKXt2YXIgdD10dDtpZighdClyZXR1cm4gZnQ9MDt2YXIgZT1uZXcgZXQodCk7ZS5GYih0KTt2YXIgbj1lLkViKCk7aWYoIW4pcmV0dXJuIGZ0PTAsdDtmb3IodmFyIHI9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSxhPTA7YTxyLmxlbmd0aDthKyspe3ZhciBpPXJbYV07aWYoMD09PWl8fGk9PT1uKWJyZWFrO2lmKEV0KGksbixlLnpiKzE2KSlyZXR1cm4gZnQ9aSx0fXJldHVybiBmdD1uLHR9LGs6ZnVuY3Rpb24oKXt2YXIgdD10dDtpZighdClyZXR1cm4gZnQ9MDt2YXIgZT1uZXcgZXQodCk7ZS5GYih0KTt2YXIgbj1lLkViKCk7aWYoIW4pcmV0dXJuIGZ0PTAsdDtmb3IodmFyIHI9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSxhPTA7YTxyLmxlbmd0aDthKyspe3ZhciBpPXJbYV07aWYoMD09PWl8fGk9PT1uKWJyZWFrO2lmKEV0KGksbixlLnpiKzE2KSlyZXR1cm4gZnQ9aSx0fXJldHVybiBmdD1uLHR9LGc6ZnVuY3Rpb24oKXt2YXIgdD10dDtpZighdClyZXR1cm4gZnQ9MDt2YXIgZT1uZXcgZXQodCk7ZS5GYih0KTt2YXIgbj1lLkViKCk7aWYoIW4pcmV0dXJuIGZ0PTAsdDtmb3IodmFyIHI9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSxhPTA7YTxyLmxlbmd0aDthKyspe3ZhciBpPXJbYV07aWYoMD09PWl8fGk9PT1uKWJyZWFrO2lmKEV0KGksbixlLnpiKzE2KSlyZXR1cm4gZnQ9aSx0fXJldHVybiBmdD1uLHR9LHM6bnQsTDpmdW5jdGlvbigpe3ZhciB0PVEucG9wKCk7dHx8VihcIm5vIGV4Y2VwdGlvbiB0byB0aHJvd1wiKTt2YXIgZT10LkRiO3Rocm93IHQuTGIoKXx8KFEucHVzaCh0KSx0LkpiKCEwKSx0LkliKCExKSxLKyspLHR0PWUsZX0sYjpmdW5jdGlvbih0LGUsbil7dGhyb3cgbmV3IGV0KHQpLlJiKGUsbiksdHQ9dCxLKyssdH0sbGE6ZnVuY3Rpb24oKXtyZXR1cm4gS30saTpmdW5jdGlvbih0KXt0aHJvdyB0dHx8KHR0PXQpLHR9LEg6ZnVuY3Rpb24oKXtyZXR1cm4gMH0sQmE6ZnVuY3Rpb24oKXt9LHBhOmZ1bmN0aW9uKCl7fSxyYTpmdW5jdGlvbigpe30sa2E6ZnVuY3Rpb24oKXtyZXR1cm4gMH0semE6ZnVuY3Rpb24oKXt9LHVhOmZ1bmN0aW9uKCl7fSx5YTpmdW5jdGlvbigpe30sUjpmdW5jdGlvbigpe30scWE6ZnVuY3Rpb24oKXt9LG5hOmZ1bmN0aW9uKCl7fSxBYTpmdW5jdGlvbigpe30sb2E6ZnVuY3Rpb24oKXt9LEhhOmZ1bmN0aW9uKCl7fSxKYTpmdW5jdGlvbigpe1YoXCJUbyB1c2UgZGxvcGVuLCB5b3UgbmVlZCBlbmFibGUgZHluYW1pYyBsaW5raW5nLCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2Vtc2NyaXB0ZW4tY29yZS9lbXNjcmlwdGVuL3dpa2kvTGlua2luZ1wiKX0sSWE6ZnVuY3Rpb24oKXtWKFwiVG8gdXNlIGRsb3BlbiwgeW91IG5lZWQgZW5hYmxlIGR5bmFtaWMgbGlua2luZywgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9lbXNjcmlwdGVuLWNvcmUvZW1zY3JpcHRlbi93aWtpL0xpbmtpbmdcIil9LFM6ZnVuY3Rpb24oKXtyZXR1cm4gRGF0ZS5ub3coKX0sQ2E6ZnVuY3Rpb24oKXtyZXR1cm4hMH0sRGE6ZnVuY3Rpb24odCxlKXt0PW5ldyBEYXRlKDFlMyooTVt0Pj4+Ml0rNDI5NDk2NzI5NipFW3QrND4+PjJdKSksRVtlPj4yPj4+MF09dC5nZXRVVENTZWNvbmRzKCksRVtlKzQ+PjI+Pj4wXT10LmdldFVUQ01pbnV0ZXMoKSxFW2UrOD4+Mj4+PjBdPXQuZ2V0VVRDSG91cnMoKSxFW2UrMTI+PjI+Pj4wXT10LmdldFVUQ0RhdGUoKSxFW2UrMTY+PjI+Pj4wXT10LmdldFVUQ01vbnRoKCksRVtlKzIwPj4yPj4+MF09dC5nZXRVVENGdWxsWWVhcigpLTE5MDAsRVtlKzI0Pj4yPj4+MF09dC5nZXRVVENEYXkoKSxFW2UrMjg+PjI+Pj4wXT0odC5nZXRUaW1lKCktRGF0ZS5VVEModC5nZXRVVENGdWxsWWVhcigpLDAsMSwwLDAsMCwwKSkvODY0ZTV8MH0sRWE6ZnVuY3Rpb24odCxlKXt0PW5ldyBEYXRlKDFlMyooTVt0Pj4+Ml0rNDI5NDk2NzI5NipFW3QrND4+PjJdKSksRVtlPj4yPj4+MF09dC5nZXRTZWNvbmRzKCksRVtlKzQ+PjI+Pj4wXT10LmdldE1pbnV0ZXMoKSxFW2UrOD4+Mj4+PjBdPXQuZ2V0SG91cnMoKSxFW2UrMTI+PjI+Pj4wXT10LmdldERhdGUoKSxFW2UrMTY+PjI+Pj4wXT10LmdldE1vbnRoKCksRVtlKzIwPj4yPj4+MF09dC5nZXRGdWxsWWVhcigpLTE5MDAsRVtlKzI0Pj4yPj4+MF09dC5nZXREYXkoKTt2YXIgbj1uZXcgRGF0ZSh0LmdldEZ1bGxZZWFyKCksMCwxKTtFW2UrMjg+PjI+Pj4wXT0odC5nZXRUaW1lKCktbi5nZXRUaW1lKCkpLzg2NGU1fDAsRVtlKzM2Pj4yPj4+MF09LTYwKnQuZ2V0VGltZXpvbmVPZmZzZXQoKTt2YXIgcj1uZXcgRGF0ZSh0LmdldEZ1bGxZZWFyKCksNiwxKS5nZXRUaW1lem9uZU9mZnNldCgpO249bi5nZXRUaW1lem9uZU9mZnNldCgpLEVbZSszMj4+Mj4+PjBdPTB8KHIhPW4mJnQuZ2V0VGltZXpvbmVPZmZzZXQoKT09TWF0aC5taW4obixyKSl9LEZhOmZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBEYXRlKEVbdCsyMD4+Mj4+PjBdKzE5MDAsRVt0KzE2Pj4yPj4+MF0sRVt0KzEyPj4yPj4+MF0sRVt0Kzg+PjI+Pj4wXSxFW3QrND4+Mj4+PjBdLEVbdD4+Mj4+PjBdLDApLG49RVt0KzMyPj4yPj4+MF0scj1lLmdldFRpbWV6b25lT2Zmc2V0KCksYT1uZXcgRGF0ZShlLmdldEZ1bGxZZWFyKCksMCwxKSxpPW5ldyBEYXRlKGUuZ2V0RnVsbFllYXIoKSw2LDEpLmdldFRpbWV6b25lT2Zmc2V0KCksbz1hLmdldFRpbWV6b25lT2Zmc2V0KCksdT1NYXRoLm1pbihvLGkpO3JldHVybiAwPm4/RVt0KzMyPj4yPj4+MF09TnVtYmVyKGkhPW8mJnU9PXIpOjA8biE9KHU9PXIpJiYoaT1NYXRoLm1heChvLGkpLGUuc2V0VGltZShlLmdldFRpbWUoKSs2ZTQqKCgwPG4/dTppKS1yKSkpLEVbdCsyND4+Mj4+PjBdPWUuZ2V0RGF5KCksRVt0KzI4Pj4yPj4+MF09KGUuZ2V0VGltZSgpLWEuZ2V0VGltZSgpKS84NjRlNXwwLEVbdD4+Mj4+PjBdPWUuZ2V0U2Vjb25kcygpLEVbdCs0Pj4yPj4+MF09ZS5nZXRNaW51dGVzKCksRVt0Kzg+PjI+Pj4wXT1lLmdldEhvdXJzKCksRVt0KzEyPj4yPj4+MF09ZS5nZXREYXRlKCksRVt0KzE2Pj4yPj4+MF09ZS5nZXRNb250aCgpLGUuZ2V0VGltZSgpLzFlM3wwfSxzYTpmdW5jdGlvbigpe3JldHVybi01Mn0sdGE6ZnVuY3Rpb24oKXt9LEdhOmZ1bmN0aW9uIHQoZSxuLHIpe3QuVmJ8fCh0LlZiPSEwLGZ1bmN0aW9uKHQsZSxuKXtmdW5jdGlvbiByKHQpe3JldHVybih0PXQudG9UaW1lU3RyaW5nKCkubWF0Y2goL1xcXFwoKFtBLVphLXogXSspXFxcXCkkLykpP3RbMV06XCJHTVRcIn12YXIgYT0obmV3IERhdGUpLmdldEZ1bGxZZWFyKCksaT1uZXcgRGF0ZShhLDAsMSksbz1uZXcgRGF0ZShhLDYsMSk7YT1pLmdldFRpbWV6b25lT2Zmc2V0KCk7dmFyIHU9by5nZXRUaW1lem9uZU9mZnNldCgpO0VbdD4+Mj4+PjBdPTYwKk1hdGgubWF4KGEsdSksRVtlPj4yPj4+MF09TnVtYmVyKGEhPXUpLHQ9cihpKSxlPXIobyksdD1pdCh0KSxlPWl0KGUpLHU8YT8oTVtuPj4yPj4+MF09dCxNW24rND4+Mj4+PjBdPWUpOihNW24+PjI+Pj4wXT1lLE1bbis0Pj4yPj4+MF09dCl9KGUsbixyKSl9LEI6ZnVuY3Rpb24oKXtWKFwiXCIpfSxtYTpmdW5jdGlvbigpe3JldHVybiA0Mjk0OTAxNzYwfSxJOmI/KCk9Pnt2YXIgdD1wcm9jZXNzLmhydGltZSgpO3JldHVybiAxZTMqdFswXSt0WzFdLzFlNn06KCk9PnBlcmZvcm1hbmNlLm5vdygpLHhhOmZ1bmN0aW9uKHQsZSxuKXtULmNvcHlXaXRoaW4odD4+PjAsZT4+PjAsZStuPj4+MCl9LEc6ZnVuY3Rpb24odCl7dmFyIGU9VC5sZW5ndGg7aWYoNDI5NDkwMTc2MDwodD4+Pj0wKSlyZXR1cm4hMTtmb3IodmFyIG49MTs0Pj1uO24qPTIpe3ZhciByPWUqKDErLjIvbik7cj1NYXRoLm1pbihyLHQrMTAwNjYzMjk2KTt2YXIgYT1NYXRoO3I9TWF0aC5tYXgodCxyKSxhPWEubWluLmNhbGwoYSw0Mjk0OTAxNzYwLHIrKDY1NTM2LXIlNjU1MzYpJTY1NTM2KTt0Ont0cnl7Ty5ncm93KGEtQS5ieXRlTGVuZ3RoKzY1NTM1Pj4+MTYpLFAoKTt2YXIgaT0xO2JyZWFrIHR9Y2F0Y2godCl7fWk9dm9pZCAwfWlmKGkpcmV0dXJuITB9cmV0dXJuITF9LHZhOmZ1bmN0aW9uKHQsZSl7dmFyIG49MDtyZXR1cm4gdXQoKS5mb3JFYWNoKChmdW5jdGlvbihyLGEpe3ZhciBpPWUrbjtmb3IoYT1NW3QrNCphPj4yPj4+MF09aSxpPTA7aTxyLmxlbmd0aDsrK2kpU1thKys+PjA+Pj4wXT1yLmNoYXJDb2RlQXQoaSk7U1thPj4wPj4+MF09MCxuKz1yLmxlbmd0aCsxfSkpLDB9LHdhOmZ1bmN0aW9uKHQsZSl7dmFyIG49dXQoKTtNW3Q+PjI+Pj4wXT1uLmxlbmd0aDt2YXIgcj0wO3JldHVybiBuLmZvckVhY2goKGZ1bmN0aW9uKHQpe3IrPXQubGVuZ3RoKzF9KSksTVtlPj4yPj4+MF09ciwwfSxiYTpmdW5jdGlvbih0KXt3fHwwPHp8fCh3dCgpLFooVyksX3QoMCksY3RbMV0ubGVuZ3RoJiZsdCgxLDEwKSxjdFsyXS5sZW5ndGgmJmx0KDIsMTApKSx3fHwwPHp8fChlLm9uRXhpdCYmZS5vbkV4aXQodCksQz0hMCksaCh0LG5ldyBKKHQpKX0sRTpmdW5jdGlvbigpe3JldHVybiA1Mn0sUTpmdW5jdGlvbigpe3JldHVybiA1Mn0sY2E6ZnVuY3Rpb24oKXtyZXR1cm4gNzB9LFA6ZnVuY3Rpb24odCxlLG4scil7Zm9yKHZhciBhPTAsaT0wO2k8bjtpKyspe3ZhciBvPU1bZT4+Mj4+PjBdLHU9TVtlKzQ+PjI+Pj4wXTtlKz04O2Zvcih2YXIgcz0wO3M8dTtzKyspbHQodCxUW28rcz4+PjBdKTthKz11fXJldHVybiBNW3I+PjI+Pj4wXT1hLDB9LGM6ZnVuY3Rpb24oKXtyZXR1cm4gZnR9LGphOmZ1bmN0aW9uIHQoZSxyKXt0Lk1ifHwodC5NYj1mdW5jdGlvbigpe2lmKFwib2JqZWN0XCI9PXR5cGVvZiBjcnlwdG8mJlwiZnVuY3Rpb25cIj09dHlwZW9mIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMpe3ZhciB0PW5ldyBVaW50OEFycmF5KDEpO3JldHVybigpPT4oY3J5cHRvLmdldFJhbmRvbVZhbHVlcyh0KSx0WzBdKX1pZihiKXRyeXt2YXIgZT1uKDExMyk7cmV0dXJuKCk9PmUucmFuZG9tQnl0ZXMoMSlbMF19Y2F0Y2godCl7fXJldHVybigpPT5WKFwicmFuZG9tRGV2aWNlXCIpfSgpKTtmb3IodmFyIGE9MDthPHI7YSsrKVNbZSthPj4wPj4+MF09dC5NYigpO3JldHVybiAwfSxlYTpmdW5jdGlvbih0LGUsbil7dmFyIHI9QXQoKTt0cnl7cmV0dXJuIGF0KHQpKGUsbil9Y2F0Y2godCl7aWYoU3QociksdCE9PXQrMCl0aHJvdyB0O090KDEsMCl9fSxmYTpmdW5jdGlvbih0LGUsbil7dmFyIHI9QXQoKTt0cnl7cmV0dXJuIGF0KHQpKGUsbil9Y2F0Y2godCl7aWYoU3QociksdCE9PXQrMCl0aHJvdyB0O090KDEsMCl9fSxKOmZ1bmN0aW9uKHQpe3ZhciBlPUF0KCk7dHJ5e3JldHVybiBhdCh0KSgpfWNhdGNoKHQpe2lmKFN0KGUpLHQhPT10KzApdGhyb3cgdDtPdCgxLDApfX0sZTpmdW5jdGlvbih0LGUpe3ZhciBuPUF0KCk7dHJ5e3JldHVybiBhdCh0KShlKX1jYXRjaCh0KXtpZihTdChuKSx0IT09dCswKXRocm93IHQ7T3QoMSwwKX19LE46ZnVuY3Rpb24odCxlLG4pe3ZhciByPUF0KCk7dHJ5e3JldHVybiBhdCh0KShlLG4pfWNhdGNoKHQpe2lmKFN0KHIpLHQhPT10KzApdGhyb3cgdDtPdCgxLDApfX0sTzpmdW5jdGlvbih0LGUsbil7dmFyIHI9QXQoKTt0cnl7cmV0dXJuIGF0KHQpKGUsbil9Y2F0Y2godCl7aWYoU3QociksdCE9PXQrMCl0aHJvdyB0O090KDEsMCl9fSxqOmZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1BdCgpO3RyeXtyZXR1cm4gYXQodCkoZSxuKX1jYXRjaCh0KXtpZihTdChyKSx0IT09dCswKXRocm93IHQ7T3QoMSwwKX19LG86ZnVuY3Rpb24odCxlLG4scil7dmFyIGE9QXQoKTt0cnl7cmV0dXJuIGF0KHQpKGUsbixyKX1jYXRjaCh0KXtpZihTdChhKSx0IT09dCswKXRocm93IHQ7T3QoMSwwKX19LHA6ZnVuY3Rpb24odCxlLG4scixhKXt2YXIgaT1BdCgpO3RyeXtyZXR1cm4gYXQodCkoZSxuLHIsYSl9Y2F0Y2godCl7aWYoU3QoaSksdCE9PXQrMCl0aHJvdyB0O090KDEsMCl9fSxNOmZ1bmN0aW9uKHQsZSxuLHIsYSxpKXt2YXIgbz1BdCgpO3RyeXtyZXR1cm4gYXQodCkoZSxuLHIsYSxpKX1jYXRjaCh0KXtpZihTdChvKSx0IT09dCswKXRocm93IHQ7T3QoMSwwKX19LHI6ZnVuY3Rpb24odCxlLG4scixhLGkpe3ZhciBvPUF0KCk7dHJ5e3JldHVybiBhdCh0KShlLG4scixhLGkpfWNhdGNoKHQpe2lmKFN0KG8pLHQhPT10KzApdGhyb3cgdDtPdCgxLDApfX0sdjpmdW5jdGlvbih0LGUsbixyLGEsaSxvKXt2YXIgdT1BdCgpO3RyeXtyZXR1cm4gYXQodCkoZSxuLHIsYSxpLG8pfWNhdGNoKHQpe2lmKFN0KHUpLHQhPT10KzApdGhyb3cgdDtPdCgxLDApfX0sSzpmdW5jdGlvbih0LGUsbixyLGEsaSxvLHUpe3ZhciBzPUF0KCk7dHJ5e3JldHVybiBhdCh0KShlLG4scixhLGksbyx1KX1jYXRjaCh0KXtpZihTdChzKSx0IT09dCswKXRocm93IHQ7T3QoMSwwKX19LEQ6ZnVuY3Rpb24odCxlLG4scixhLGksbyx1LHMsYyxsLGYpe3ZhciBwPUF0KCk7dHJ5e3JldHVybiBhdCh0KShlLG4scixhLGksbyx1LHMsYyxsLGYpfWNhdGNoKHQpe2lmKFN0KHApLHQhPT10KzApdGhyb3cgdDtPdCgxLDApfX0sWDpmdW5jdGlvbih0LGUsbixyLGEsaSxvLHUpe3ZhciBzPUF0KCk7dHJ5e3JldHVybiBGdCh0LGUsbixyLGEsaSxvLHUpfWNhdGNoKHQpe2lmKFN0KHMpLHQhPT10KzApdGhyb3cgdDtPdCgxLDApfX0sVjpmdW5jdGlvbih0LGUsbixyLGEsaSxvKXt2YXIgdT1BdCgpO3RyeXtyZXR1cm4geHQodCxlLG4scixhLGksbyl9Y2F0Y2godCl7aWYoU3QodSksdCE9PXQrMCl0aHJvdyB0O090KDEsMCl9fSxVOmZ1bmN0aW9uKHQsZSxuLHIsYSl7dmFyIGk9QXQoKTt0cnl7cmV0dXJuIEl0KHQsZSxuLHIsYSl9Y2F0Y2godCl7aWYoU3QoaSksdCE9PXQrMCl0aHJvdyB0O090KDEsMCl9fSxaOmZ1bmN0aW9uKHQsZSxuLHIpe3ZhciBhPUF0KCk7dHJ5e3JldHVybiBQdCh0LGUsbixyKX1jYXRjaCh0KXtpZihTdChhKSx0IT09dCswKXRocm93IHQ7T3QoMSwwKX19LFc6ZnVuY3Rpb24odCl7dmFyIGU9QXQoKTt0cnl7cmV0dXJuIEN0KHQpfWNhdGNoKHQpe2lmKFN0KGUpLHQhPT10KzApdGhyb3cgdDtPdCgxLDApfX0sWTpmdW5jdGlvbih0LGUpe3ZhciBuPUF0KCk7dHJ5e3JldHVybiBVdCh0LGUpfWNhdGNoKHQpe2lmKFN0KG4pLHQhPT10KzApdGhyb3cgdDtPdCgxLDApfX0sVDpmdW5jdGlvbih0LGUsbil7dmFyIHI9QXQoKTt0cnl7cmV0dXJuIFJ0KHQsZSxuKX1jYXRjaCh0KXtpZihTdChyKSx0IT09dCswKXRocm93IHQ7T3QoMSwwKX19LGY6ZnVuY3Rpb24odCl7dmFyIGU9QXQoKTt0cnl7YXQodCkoKX1jYXRjaCh0KXtpZihTdChlKSx0IT09dCswKXRocm93IHQ7T3QoMSwwKX19LHE6ZnVuY3Rpb24odCxlKXt2YXIgbj1BdCgpO3RyeXthdCh0KShlKX1jYXRjaCh0KXtpZihTdChuKSx0IT09dCswKXRocm93IHQ7T3QoMSwwKX19LGg6ZnVuY3Rpb24odCxlLG4pe3ZhciByPUF0KCk7dHJ5e2F0KHQpKGUsbil9Y2F0Y2godCl7aWYoU3QociksdCE9PXQrMCl0aHJvdyB0O090KDEsMCl9fSxkYTpmdW5jdGlvbih0LGUsbixyKXt2YXIgYT1BdCgpO3RyeXthdCh0KShlLG4scil9Y2F0Y2godCl7aWYoU3QoYSksdCE9PXQrMCl0aHJvdyB0O090KDEsMCl9fSxsOmZ1bmN0aW9uKHQsZSxuLHIpe3ZhciBhPUF0KCk7dHJ5e2F0KHQpKGUsbixyKX1jYXRjaCh0KXtpZihTdChhKSx0IT09dCswKXRocm93IHQ7T3QoMSwwKX19LHQ6ZnVuY3Rpb24odCxlLG4scixhKXt2YXIgaT1BdCgpO3RyeXthdCh0KShlLG4scixhKX1jYXRjaCh0KXtpZihTdChpKSx0IT09dCswKXRocm93IHQ7T3QoMSwwKX19LHU6ZnVuY3Rpb24odCxlLG4scixhLGkpe3ZhciBvPUF0KCk7dHJ5e2F0KHQpKGUsbixyLGEsaSl9Y2F0Y2godCl7aWYoU3QobyksdCE9PXQrMCl0aHJvdyB0O090KDEsMCl9fSx4OmZ1bmN0aW9uKHQsZSxuLHIsYSxpLG8pe3ZhciB1PUF0KCk7dHJ5e2F0KHQpKGUsbixyLGEsaSxvKX1jYXRjaCh0KXtpZihTdCh1KSx0IT09dCswKXRocm93IHQ7T3QoMSwwKX19LHo6ZnVuY3Rpb24odCxlLG4scixhLGksbyx1KXt2YXIgcz1BdCgpO3RyeXthdCh0KShlLG4scixhLGksbyx1KX1jYXRjaCh0KXtpZihTdChzKSx0IT09dCswKXRocm93IHQ7T3QoMSwwKX19LGdhOmZ1bmN0aW9uKHQsZSxuLHIsYSxpLG8sdSxzKXt2YXIgYz1BdCgpO3RyeXthdCh0KShlLG4scixhLGksbyx1LHMpfWNhdGNoKHQpe2lmKFN0KGMpLHQhPT10KzApdGhyb3cgdDtPdCgxLDApfX0sQTpmdW5jdGlvbih0LGUsbixyLGEsaSxvLHUscyxjLGwpe3ZhciBmPUF0KCk7dHJ5e2F0KHQpKGUsbixyLGEsaSxvLHUscyxjLGwpfWNhdGNoKHQpe2lmKFN0KGYpLHQhPT10KzApdGhyb3cgdDtPdCgxLDApfX0sQzpmdW5jdGlvbih0LGUsbixyLGEsaSxvLHUscyxjLGwsZixwLGgsZCx5KXt2YXIgYj1BdCgpO3RyeXthdCh0KShlLG4scixhLGksbyx1LHMsYyxsLGYscCxoLGQseSl9Y2F0Y2godCl7aWYoU3QoYiksdCE9PXQrMCl0aHJvdyB0O090KDEsMCl9fSxhYTpmdW5jdGlvbih0LGUsbixyLGEsaSxvLHUpe3ZhciBzPUF0KCk7dHJ5e2t0KHQsZSxuLHIsYSxpLG8sdSl9Y2F0Y2godCl7aWYoU3QocyksdCE9PXQrMCl0aHJvdyB0O090KDEsMCl9fSxfOmZ1bmN0aW9uKHQsZSxuLHIsYSxpLG8sdSxzLGMsbCxmKXt2YXIgcD1BdCgpO3RyeXtEdCh0LGUsbixyLGEsaSxvLHUscyxjLGwsZil9Y2F0Y2godCl7aWYoU3QocCksdCE9PXQrMCl0aHJvdyB0O090KDEsMCl9fSwkOmZ1bmN0aW9uKHQsZSxuLHIsYSxpKXt2YXIgbz1BdCgpO3RyeXtqdCh0LGUsbixyLGEsaSl9Y2F0Y2godCl7aWYoU3QobyksdCE9PXQrMCl0aHJvdyB0O090KDEsMCl9fSxuOmZ1bmN0aW9uKHQpe3JldHVybiB0fSxGOmZ1bmN0aW9uKHQpe2Z0PXR9LGhhOnl0LHk6ZnVuY3Rpb24odCxlLG4scil7cmV0dXJuIHl0KHQsZSxuLHIpfX07IWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0KXtlLmFzbT10LmV4cG9ydHMsTz1lLmFzbS5LYSxQKCksVT1lLmFzbS5pYixJLnVuc2hpZnQoZS5hc20uTGEpLEItLSxlLm1vbml0b3JSdW5EZXBlbmRlbmNpZXMmJmUubW9uaXRvclJ1bkRlcGVuZGVuY2llcyhCKSwwPT1CJiYobnVsbCE9PUcmJihjbGVhckludGVydmFsKEcpLEc9bnVsbCksTiYmKHQ9TixOPW51bGwsdCgpKSl9ZnVuY3Rpb24gbihlKXt0KGUuaW5zdGFuY2UpfWZ1bmN0aW9uIHIodCl7cmV0dXJuIGZ1bmN0aW9uKCl7aWYoIWcmJihkfHx5KSl7aWYoXCJmdW5jdGlvblwiPT10eXBlb2YgZmV0Y2gmJiFZLnN0YXJ0c1dpdGgoXCJmaWxlOi8vXCIpKXJldHVybiBmZXRjaChZLHtjcmVkZW50aWFsczpcInNhbWUtb3JpZ2luXCJ9KS50aGVuKChmdW5jdGlvbih0KXtpZighdC5vayl0aHJvd1wiZmFpbGVkIHRvIGxvYWQgd2FzbSBiaW5hcnkgZmlsZSBhdCBcXCdcIitZK1wiXFwnXCI7cmV0dXJuIHQuYXJyYXlCdWZmZXIoKX0pKS5jYXRjaCgoZnVuY3Rpb24oKXtyZXR1cm4gWCgpfSkpO2lmKG8pcmV0dXJuIG5ldyBQcm9taXNlKChmdW5jdGlvbih0LGUpe28oWSwoZnVuY3Rpb24oZSl7dChuZXcgVWludDhBcnJheShlKSl9KSxlKX0pKX1yZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoZnVuY3Rpb24oKXtyZXR1cm4gWCgpfSkpfSgpLnRoZW4oKGZ1bmN0aW9uKHQpe3JldHVybiBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZSh0LGkpfSkpLnRoZW4oKGZ1bmN0aW9uKHQpe3JldHVybiB0fSkpLnRoZW4odCwoZnVuY3Rpb24odCl7XyhcImZhaWxlZCB0byBhc3luY2hyb25vdXNseSBwcmVwYXJlIHdhc206IFwiK3QpLFYodCl9KSl9dmFyIGk9e2E6YnR9O2lmKEIrKyxlLm1vbml0b3JSdW5EZXBlbmRlbmNpZXMmJmUubW9uaXRvclJ1bkRlcGVuZGVuY2llcyhCKSxlLmluc3RhbnRpYXRlV2FzbSl0cnl7cmV0dXJuIGUuaW5zdGFudGlhdGVXYXNtKGksdCl9Y2F0Y2godCl7cmV0dXJuIF8oXCJNb2R1bGUuaW5zdGFudGlhdGVXYXNtIGNhbGxiYWNrIGZhaWxlZCB3aXRoIGVycm9yOiBcIit0KSwhMX0oZ3x8XCJmdW5jdGlvblwiIT10eXBlb2YgV2ViQXNzZW1ibHkuaW5zdGFudGlhdGVTdHJlYW1pbmd8fHEoKXx8WS5zdGFydHNXaXRoKFwiZmlsZTovL1wiKXx8Ynx8XCJmdW5jdGlvblwiIT10eXBlb2YgZmV0Y2g/cihuKTpmZXRjaChZLHtjcmVkZW50aWFsczpcInNhbWUtb3JpZ2luXCJ9KS50aGVuKChmdW5jdGlvbih0KXtyZXR1cm4gV2ViQXNzZW1ibHkuaW5zdGFudGlhdGVTdHJlYW1pbmcodCxpKS50aGVuKG4sKGZ1bmN0aW9uKHQpe3JldHVybiBfKFwid2FzbSBzdHJlYW1pbmcgY29tcGlsZSBmYWlsZWQ6IFwiK3QpLF8oXCJmYWxsaW5nIGJhY2sgdG8gQXJyYXlCdWZmZXIgaW5zdGFudGlhdGlvblwiKSxyKG4pfSkpfSkpKS5jYXRjaChhKX0oKSxlLl9fX3dhc21fY2FsbF9jdG9ycz1mdW5jdGlvbigpe3JldHVybihlLl9fX3dhc21fY2FsbF9jdG9ycz1lLmFzbS5MYSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxlLl9PcnRJbml0PWZ1bmN0aW9uKCl7cmV0dXJuKGUuX09ydEluaXQ9ZS5hc20uTWEpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sZS5fT3J0Q3JlYXRlU2Vzc2lvbk9wdGlvbnM9ZnVuY3Rpb24oKXtyZXR1cm4oZS5fT3J0Q3JlYXRlU2Vzc2lvbk9wdGlvbnM9ZS5hc20uTmEpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sZS5fT3J0QXBwZW5kRXhlY3V0aW9uUHJvdmlkZXI9ZnVuY3Rpb24oKXtyZXR1cm4oZS5fT3J0QXBwZW5kRXhlY3V0aW9uUHJvdmlkZXI9ZS5hc20uT2EpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sZS5fT3J0QWRkU2Vzc2lvbkNvbmZpZ0VudHJ5PWZ1bmN0aW9uKCl7cmV0dXJuKGUuX09ydEFkZFNlc3Npb25Db25maWdFbnRyeT1lLmFzbS5QYSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxlLl9PcnRSZWxlYXNlU2Vzc2lvbk9wdGlvbnM9ZnVuY3Rpb24oKXtyZXR1cm4oZS5fT3J0UmVsZWFzZVNlc3Npb25PcHRpb25zPWUuYXNtLlFhKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGUuX09ydENyZWF0ZVNlc3Npb249ZnVuY3Rpb24oKXtyZXR1cm4oZS5fT3J0Q3JlYXRlU2Vzc2lvbj1lLmFzbS5SYSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxlLl9PcnRSZWxlYXNlU2Vzc2lvbj1mdW5jdGlvbigpe3JldHVybihlLl9PcnRSZWxlYXNlU2Vzc2lvbj1lLmFzbS5TYSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxlLl9PcnRHZXRJbnB1dENvdW50PWZ1bmN0aW9uKCl7cmV0dXJuKGUuX09ydEdldElucHV0Q291bnQ9ZS5hc20uVGEpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sZS5fT3J0R2V0T3V0cHV0Q291bnQ9ZnVuY3Rpb24oKXtyZXR1cm4oZS5fT3J0R2V0T3V0cHV0Q291bnQ9ZS5hc20uVWEpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sZS5fT3J0R2V0SW5wdXROYW1lPWZ1bmN0aW9uKCl7cmV0dXJuKGUuX09ydEdldElucHV0TmFtZT1lLmFzbS5WYSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxlLl9PcnRHZXRPdXRwdXROYW1lPWZ1bmN0aW9uKCl7cmV0dXJuKGUuX09ydEdldE91dHB1dE5hbWU9ZS5hc20uV2EpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sZS5fT3J0RnJlZT1mdW5jdGlvbigpe3JldHVybihlLl9PcnRGcmVlPWUuYXNtLlhhKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGUuX09ydENyZWF0ZVRlbnNvcj1mdW5jdGlvbigpe3JldHVybihlLl9PcnRDcmVhdGVUZW5zb3I9ZS5hc20uWWEpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sZS5fT3J0R2V0VGVuc29yRGF0YT1mdW5jdGlvbigpe3JldHVybihlLl9PcnRHZXRUZW5zb3JEYXRhPWUuYXNtLlphKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGUuX09ydFJlbGVhc2VUZW5zb3I9ZnVuY3Rpb24oKXtyZXR1cm4oZS5fT3J0UmVsZWFzZVRlbnNvcj1lLmFzbS5fYSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxlLl9PcnRDcmVhdGVSdW5PcHRpb25zPWZ1bmN0aW9uKCl7cmV0dXJuKGUuX09ydENyZWF0ZVJ1bk9wdGlvbnM9ZS5hc20uJGEpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sZS5fT3J0QWRkUnVuQ29uZmlnRW50cnk9ZnVuY3Rpb24oKXtyZXR1cm4oZS5fT3J0QWRkUnVuQ29uZmlnRW50cnk9ZS5hc20uYWIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sZS5fT3J0UmVsZWFzZVJ1bk9wdGlvbnM9ZnVuY3Rpb24oKXtyZXR1cm4oZS5fT3J0UmVsZWFzZVJ1bk9wdGlvbnM9ZS5hc20uYmIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sZS5fT3J0UnVuPWZ1bmN0aW9uKCl7cmV0dXJuKGUuX09ydFJ1bj1lLmFzbS5jYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxlLl9PcnRFbmRQcm9maWxpbmc9ZnVuY3Rpb24oKXtyZXR1cm4oZS5fT3J0RW5kUHJvZmlsaW5nPWUuYXNtLmRiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O3ZhciBtdCxndD1lLl9tYWxsb2M9ZnVuY3Rpb24oKXtyZXR1cm4oZ3Q9ZS5fbWFsbG9jPWUuYXNtLmViKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHZ0PWUuX2ZyZWU9ZnVuY3Rpb24oKXtyZXR1cm4odnQ9ZS5fZnJlZT1lLmFzbS5mYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxfdD1lLl9mZmx1c2g9ZnVuY3Rpb24oKXtyZXR1cm4oX3Q9ZS5fZmZsdXNoPWUuYXNtLmdiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHd0PWUuX19fZnVuY3Nfb25fZXhpdD1mdW5jdGlvbigpe3JldHVybih3dD1lLl9fX2Z1bmNzX29uX2V4aXQ9ZS5hc20uaGIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sT3Q9ZS5fc2V0VGhyZXc9ZnVuY3Rpb24oKXtyZXR1cm4oT3Q9ZS5fc2V0VGhyZXc9ZS5hc20uamIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sQXQ9ZS5zdGFja1NhdmU9ZnVuY3Rpb24oKXtyZXR1cm4oQXQ9ZS5zdGFja1NhdmU9ZS5hc20ua2IpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sU3Q9ZS5zdGFja1Jlc3RvcmU9ZnVuY3Rpb24oKXtyZXR1cm4oU3Q9ZS5zdGFja1Jlc3RvcmU9ZS5hc20ubGIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sVHQ9ZS5zdGFja0FsbG9jPWZ1bmN0aW9uKCl7cmV0dXJuKFR0PWUuc3RhY2tBbGxvYz1lLmFzbS5tYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxFdD1lLl9fX2N4YV9jYW5fY2F0Y2g9ZnVuY3Rpb24oKXtyZXR1cm4oRXQ9ZS5fX19jeGFfY2FuX2NhdGNoPWUuYXNtLm5iKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LE10PWUuX19fY3hhX2lzX3BvaW50ZXJfdHlwZT1mdW5jdGlvbigpe3JldHVybihNdD1lLl9fX2N4YV9pc19wb2ludGVyX3R5cGU9ZS5hc20ub2IpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sQ3Q9ZS5keW5DYWxsX2o9ZnVuY3Rpb24oKXtyZXR1cm4oQ3Q9ZS5keW5DYWxsX2o9ZS5hc20ucGIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0seHQ9ZS5keW5DYWxsX2lpaWlpaj1mdW5jdGlvbigpe3JldHVybih4dD1lLmR5bkNhbGxfaWlpaWlqPWUuYXNtLnFiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LFJ0PWUuZHluQ2FsbF9qaWk9ZnVuY3Rpb24oKXtyZXR1cm4oUnQ9ZS5keW5DYWxsX2ppaT1lLmFzbS5yYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxrdD1lLmR5bkNhbGxfdmlpaWlpaj1mdW5jdGlvbigpe3JldHVybihrdD1lLmR5bkNhbGxfdmlpaWlpaj1lLmFzbS5zYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxqdD1lLmR5bkNhbGxfdmpqaT1mdW5jdGlvbigpe3JldHVybihqdD1lLmR5bkNhbGxfdmpqaT1lLmFzbS50YikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxEdD1lLmR5bkNhbGxfdmlpaWpqamlpPWZ1bmN0aW9uKCl7cmV0dXJuKER0PWUuZHluQ2FsbF92aWlpampqaWk9ZS5hc20udWIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sUHQ9ZS5keW5DYWxsX2lpaj1mdW5jdGlvbigpe3JldHVybihQdD1lLmR5bkNhbGxfaWlqPWUuYXNtLnZiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LFV0PWUuZHluQ2FsbF9qaT1mdW5jdGlvbigpe3JldHVybihVdD1lLmR5bkNhbGxfamk9ZS5hc20ud2IpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sRnQ9ZS5keW5DYWxsX2lpaWlpaWo9ZnVuY3Rpb24oKXtyZXR1cm4oRnQ9ZS5keW5DYWxsX2lpaWlpaWo9ZS5hc20ueGIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sSXQ9ZS5keW5DYWxsX2lpaWo9ZnVuY3Rpb24oKXtyZXR1cm4oSXQ9ZS5keW5DYWxsX2lpaWo9ZS5hc20ueWIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX07ZnVuY3Rpb24gV3QoKXtmdW5jdGlvbiB0KCl7aWYoIW10JiYobXQ9ITAsZS5jYWxsZWRSdW49ITAsIUMpKXtpZihaKEkpLHIoZSksZS5vblJ1bnRpbWVJbml0aWFsaXplZCYmZS5vblJ1bnRpbWVJbml0aWFsaXplZCgpLGUucG9zdFJ1bilmb3IoXCJmdW5jdGlvblwiPT10eXBlb2YgZS5wb3N0UnVuJiYoZS5wb3N0UnVuPVtlLnBvc3RSdW5dKTtlLnBvc3RSdW4ubGVuZ3RoOyl7dmFyIHQ9ZS5wb3N0UnVuLnNoaWZ0KCk7SC51bnNoaWZ0KHQpfVooSCl9fWlmKCEoMDxCKSl7aWYoZS5wcmVSdW4pZm9yKFwiZnVuY3Rpb25cIj09dHlwZW9mIGUucHJlUnVuJiYoZS5wcmVSdW49W2UucHJlUnVuXSk7ZS5wcmVSdW4ubGVuZ3RoOylMKCk7WihGKSwwPEJ8fChlLnNldFN0YXR1cz8oZS5zZXRTdGF0dXMoXCJSdW5uaW5nLi4uXCIpLHNldFRpbWVvdXQoKGZ1bmN0aW9uKCl7c2V0VGltZW91dCgoZnVuY3Rpb24oKXtlLnNldFN0YXR1cyhcIlwiKX0pLDEpLHQoKX0pLDEpKTp0KCkpfX1pZihlLlVURjhUb1N0cmluZz1rLGUuc3RyaW5nVG9VVEY4PWZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gaih0LFQsZSxuKX0sZS5sZW5ndGhCeXRlc1VURjg9RCxlLnN0YWNrU2F2ZT1BdCxlLnN0YWNrUmVzdG9yZT1TdCxlLnN0YWNrQWxsb2M9VHQsTj1mdW5jdGlvbiB0KCl7bXR8fFd0KCksbXR8fChOPXQpfSxlLnByZUluaXQpZm9yKFwiZnVuY3Rpb25cIj09dHlwZW9mIGUucHJlSW5pdCYmKGUucHJlSW5pdD1bZS5wcmVJbml0XSk7MDxlLnByZUluaXQubGVuZ3RoOyllLnByZUluaXQucG9wKCkoKTtyZXR1cm4gV3QoKSx0LnJlYWR5fSk7dC5leHBvcnRzPXJ9LDk2NzoodCxlKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUuaXRlcmF0ZUV4dHJhT3B0aW9ucz12b2lkIDAsZS5pdGVyYXRlRXh0cmFPcHRpb25zPSh0LG4scixhKT0+e2lmKFwib2JqZWN0XCI9PXR5cGVvZiB0JiZudWxsIT09dCl7aWYoci5oYXModCkpdGhyb3cgbmV3IEVycm9yKFwiQ2lyY3VsYXIgcmVmZXJlbmNlIGluIG9wdGlvbnNcIik7ci5hZGQodCl9T2JqZWN0LmVudHJpZXModCkuZm9yRWFjaCgoKFt0LGldKT0+e2NvbnN0IG89bj9uK3Q6dDtpZihcIm9iamVjdFwiPT10eXBlb2YgaSkoMCxlLml0ZXJhdGVFeHRyYU9wdGlvbnMpKGksbytcIi5cIixyLGEpO2Vsc2UgaWYoXCJzdHJpbmdcIj09dHlwZW9mIGl8fFwibnVtYmVyXCI9PXR5cGVvZiBpKWEobyxpLnRvU3RyaW5nKCkpO2Vsc2V7aWYoXCJib29sZWFuXCIhPXR5cGVvZiBpKXRocm93IG5ldyBFcnJvcihcIkNhblxcJ3QgaGFuZGxlIGV4dHJhIGNvbmZpZyB0eXBlOiBcIit0eXBlb2YgaSk7YShvLGk/XCIxXCI6XCIwXCIpfX0pKX19LDU4NjoodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5zZXRSdW5PcHRpb25zPXZvaWQgMDtjb25zdCByPW4oOTY3KSxhPW4oOTgzKSxpPW4oMzYxKTtlLnNldFJ1bk9wdGlvbnM9dD0+e2NvbnN0IGU9KDAsaS5nZXRJbnN0YW5jZSkoKTtsZXQgbj0wO2NvbnN0IG89W10sdT10fHx7fTt0cnl7aWYodm9pZCAwPT09KG51bGw9PXQ/dm9pZCAwOnQubG9nU2V2ZXJpdHlMZXZlbCkpdS5sb2dTZXZlcml0eUxldmVsPTI7ZWxzZSBpZihcIm51bWJlclwiIT10eXBlb2YgdC5sb2dTZXZlcml0eUxldmVsfHwhTnVtYmVyLmlzSW50ZWdlcih0LmxvZ1NldmVyaXR5TGV2ZWwpfHx0LmxvZ1NldmVyaXR5TGV2ZWw8MHx8dC5sb2dTZXZlcml0eUxldmVsPjQpdGhyb3cgbmV3IEVycm9yKGBsb2cgc2VydmVyaXR5IGxldmVsIGlzIG5vdCB2YWxpZDogJHt0LmxvZ1NldmVyaXR5TGV2ZWx9YCk7aWYodm9pZCAwPT09KG51bGw9PXQ/dm9pZCAwOnQubG9nVmVyYm9zaXR5TGV2ZWwpKXUubG9nVmVyYm9zaXR5TGV2ZWw9MDtlbHNlIGlmKFwibnVtYmVyXCIhPXR5cGVvZiB0LmxvZ1ZlcmJvc2l0eUxldmVsfHwhTnVtYmVyLmlzSW50ZWdlcih0LmxvZ1ZlcmJvc2l0eUxldmVsKSl0aHJvdyBuZXcgRXJyb3IoYGxvZyB2ZXJib3NpdHkgbGV2ZWwgaXMgbm90IHZhbGlkOiAke3QubG9nVmVyYm9zaXR5TGV2ZWx9YCk7dm9pZCAwPT09KG51bGw9PXQ/dm9pZCAwOnQudGVybWluYXRlKSYmKHUudGVybWluYXRlPSExKTtsZXQgaT0wO2lmKHZvaWQgMCE9PShudWxsPT10P3ZvaWQgMDp0LnRhZykmJihpPSgwLGEuYWxsb2NXYXNtU3RyaW5nKSh0LnRhZyxvKSksbj1lLl9PcnRDcmVhdGVSdW5PcHRpb25zKHUubG9nU2V2ZXJpdHlMZXZlbCx1LmxvZ1ZlcmJvc2l0eUxldmVsLCEhdS50ZXJtaW5hdGUsaSksMD09PW4pdGhyb3cgbmV3IEVycm9yKFwiQ2FuXFwndCBjcmVhdGUgcnVuIG9wdGlvbnNcIik7cmV0dXJuIHZvaWQgMCE9PShudWxsPT10P3ZvaWQgMDp0LmV4dHJhKSYmKDAsci5pdGVyYXRlRXh0cmFPcHRpb25zKSh0LmV4dHJhLFwiXCIsbmV3IFdlYWtTZXQsKCh0LHIpPT57Y29uc3QgaT0oMCxhLmFsbG9jV2FzbVN0cmluZykodCxvKSx1PSgwLGEuYWxsb2NXYXNtU3RyaW5nKShyLG8pO2lmKDAhPT1lLl9PcnRBZGRSdW5Db25maWdFbnRyeShuLGksdSkpdGhyb3cgbmV3IEVycm9yKGBDYW5cXCd0IHNldCBhIHJ1biBjb25maWcgZW50cnk6ICR7dH0gLSAke3J9YCl9KSksW24sb119Y2F0Y2godCl7dGhyb3cgMCE9PW4mJmUuX09ydFJlbGVhc2VSdW5PcHRpb25zKG4pLG8uZm9yRWFjaChlLl9mcmVlKSx0fX19LDkxOToodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5zZXRTZXNzaW9uT3B0aW9ucz12b2lkIDA7Y29uc3Qgcj1uKDk2NyksYT1uKDk4MyksaT1uKDM2MSk7ZS5zZXRTZXNzaW9uT3B0aW9ucz10PT57Y29uc3QgZT0oMCxpLmdldEluc3RhbmNlKSgpO2xldCBuPTA7Y29uc3Qgbz1bXSx1PXR8fHt9Oyh0PT57dC5leHRyYXx8KHQuZXh0cmE9e30pLHQuZXh0cmEuc2Vzc2lvbnx8KHQuZXh0cmEuc2Vzc2lvbj17fSk7Y29uc3QgZT10LmV4dHJhLnNlc3Npb247ZS51c2Vfb3J0X21vZGVsX2J5dGVzX2RpcmVjdGx5fHwoZS51c2Vfb3J0X21vZGVsX2J5dGVzX2RpcmVjdGx5PVwiMVwiKX0pKHUpO3RyeXt2b2lkIDA9PT0obnVsbD09dD92b2lkIDA6dC5ncmFwaE9wdGltaXphdGlvbkxldmVsKSYmKHUuZ3JhcGhPcHRpbWl6YXRpb25MZXZlbD1cImFsbFwiKTtjb25zdCBzPSh0PT57c3dpdGNoKHQpe2Nhc2VcImRpc2FibGVkXCI6cmV0dXJuIDA7Y2FzZVwiYmFzaWNcIjpyZXR1cm4gMTtjYXNlXCJleHRlbmRlZFwiOnJldHVybiAyO2Nhc2VcImFsbFwiOnJldHVybiA5OTtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgZ3JhcGggb3B0aW1pemF0aW9uIGxldmVsOiAke3R9YCl9fSkodS5ncmFwaE9wdGltaXphdGlvbkxldmVsKTt2b2lkIDA9PT0obnVsbD09dD92b2lkIDA6dC5lbmFibGVDcHVNZW1BcmVuYSkmJih1LmVuYWJsZUNwdU1lbUFyZW5hPSEwKSx2b2lkIDA9PT0obnVsbD09dD92b2lkIDA6dC5lbmFibGVNZW1QYXR0ZXJuKSYmKHUuZW5hYmxlTWVtUGF0dGVybj0hMCksdm9pZCAwPT09KG51bGw9PXQ/dm9pZCAwOnQuZXhlY3V0aW9uTW9kZSkmJih1LmV4ZWN1dGlvbk1vZGU9XCJzZXF1ZW50aWFsXCIpO2NvbnN0IGM9KHQ9Pntzd2l0Y2godCl7Y2FzZVwic2VxdWVudGlhbFwiOnJldHVybiAwO2Nhc2VcInBhcmFsbGVsXCI6cmV0dXJuIDE7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIGV4ZWN1dGlvbiBtb2RlOiAke3R9YCl9fSkodS5leGVjdXRpb25Nb2RlKTtsZXQgbD0wO2lmKHZvaWQgMCE9PShudWxsPT10P3ZvaWQgMDp0LmxvZ0lkKSYmKGw9KDAsYS5hbGxvY1dhc21TdHJpbmcpKHQubG9nSWQsbykpLHZvaWQgMD09PShudWxsPT10P3ZvaWQgMDp0LmxvZ1NldmVyaXR5TGV2ZWwpKXUubG9nU2V2ZXJpdHlMZXZlbD0yO2Vsc2UgaWYoXCJudW1iZXJcIiE9dHlwZW9mIHQubG9nU2V2ZXJpdHlMZXZlbHx8IU51bWJlci5pc0ludGVnZXIodC5sb2dTZXZlcml0eUxldmVsKXx8dC5sb2dTZXZlcml0eUxldmVsPDB8fHQubG9nU2V2ZXJpdHlMZXZlbD40KXRocm93IG5ldyBFcnJvcihgbG9nIHNlcnZlcml0eSBsZXZlbCBpcyBub3QgdmFsaWQ6ICR7dC5sb2dTZXZlcml0eUxldmVsfWApO2lmKHZvaWQgMD09PShudWxsPT10P3ZvaWQgMDp0LmxvZ1ZlcmJvc2l0eUxldmVsKSl1LmxvZ1ZlcmJvc2l0eUxldmVsPTA7ZWxzZSBpZihcIm51bWJlclwiIT10eXBlb2YgdC5sb2dWZXJib3NpdHlMZXZlbHx8IU51bWJlci5pc0ludGVnZXIodC5sb2dWZXJib3NpdHlMZXZlbCkpdGhyb3cgbmV3IEVycm9yKGBsb2cgdmVyYm9zaXR5IGxldmVsIGlzIG5vdCB2YWxpZDogJHt0LmxvZ1ZlcmJvc2l0eUxldmVsfWApO2lmKHZvaWQgMD09PShudWxsPT10P3ZvaWQgMDp0LmVuYWJsZVByb2ZpbGluZykmJih1LmVuYWJsZVByb2ZpbGluZz0hMSksbj1lLl9PcnRDcmVhdGVTZXNzaW9uT3B0aW9ucyhzLCEhdS5lbmFibGVDcHVNZW1BcmVuYSwhIXUuZW5hYmxlTWVtUGF0dGVybixjLCEhdS5lbmFibGVQcm9maWxpbmcsMCxsLHUubG9nU2V2ZXJpdHlMZXZlbCx1LmxvZ1ZlcmJvc2l0eUxldmVsKSwwPT09bil0aHJvdyBuZXcgRXJyb3IoXCJDYW5cXCd0IGNyZWF0ZSBzZXNzaW9uIG9wdGlvbnNcIik7cmV0dXJuKG51bGw9PXQ/dm9pZCAwOnQuZXhlY3V0aW9uUHJvdmlkZXJzKSYmKCh0LGUsbik9Pntmb3IoY29uc3QgciBvZiBlKXtsZXQgZT1cInN0cmluZ1wiPT10eXBlb2Ygcj9yOnIubmFtZTtzd2l0Y2goZSl7Y2FzZVwieG5ucGFja1wiOmU9XCJYTk5QQUNLXCI7YnJlYWs7Y2FzZVwid2FzbVwiOmNhc2VcImNwdVwiOmNvbnRpbnVlO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBub3Qgc3VwcG9ydGVkIEVQOiAke2V9YCl9Y29uc3Qgbz0oMCxhLmFsbG9jV2FzbVN0cmluZykoZSxuKTtpZigwIT09KDAsaS5nZXRJbnN0YW5jZSkoKS5fT3J0QXBwZW5kRXhlY3V0aW9uUHJvdmlkZXIodCxvKSl0aHJvdyBuZXcgRXJyb3IoYENhblxcJ3QgYXBwZW5kIGV4ZWN1dGlvbiBwcm92aWRlcjogJHtlfWApfX0pKG4sdC5leGVjdXRpb25Qcm92aWRlcnMsbyksdm9pZCAwIT09KG51bGw9PXQ/dm9pZCAwOnQuZXh0cmEpJiYoMCxyLml0ZXJhdGVFeHRyYU9wdGlvbnMpKHQuZXh0cmEsXCJcIixuZXcgV2Vha1NldCwoKHQscik9Pntjb25zdCBpPSgwLGEuYWxsb2NXYXNtU3RyaW5nKSh0LG8pLHU9KDAsYS5hbGxvY1dhc21TdHJpbmcpKHIsbyk7aWYoMCE9PWUuX09ydEFkZFNlc3Npb25Db25maWdFbnRyeShuLGksdSkpdGhyb3cgbmV3IEVycm9yKGBDYW5cXCd0IHNldCBhIHNlc3Npb24gY29uZmlnIGVudHJ5OiAke3R9IC0gJHtyfWApfSkpLFtuLG9dfWNhdGNoKHQpe3Rocm93IDAhPT1uJiZlLl9PcnRSZWxlYXNlU2Vzc2lvbk9wdGlvbnMobiksby5mb3JFYWNoKGUuX2ZyZWUpLHR9fX0sOTgzOih0LGUsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLmFsbG9jV2FzbVN0cmluZz12b2lkIDA7Y29uc3Qgcj1uKDM2MSk7ZS5hbGxvY1dhc21TdHJpbmc9KHQsZSk9Pntjb25zdCBuPSgwLHIuZ2V0SW5zdGFuY2UpKCksYT1uLmxlbmd0aEJ5dGVzVVRGOCh0KSsxLGk9bi5fbWFsbG9jKGEpO3JldHVybiBuLnN0cmluZ1RvVVRGOCh0LGksYSksZS5wdXNoKGkpLGl9fSwzNDk6KHQsZSxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUuZXh0cmFjdFRyYW5zZmVyYWJsZUJ1ZmZlcnM9ZS5lbmRQcm9maWxpbmc9ZS5ydW49ZS5yZWxlYXNlU2Vzc2lvbj1lLmNyZWF0ZVNlc3Npb249ZS5jcmVhdGVTZXNzaW9uRmluYWxpemU9ZS5jcmVhdGVTZXNzaW9uQWxsb2NhdGU9ZS5pbml0T3J0PXZvaWQgMDtjb25zdCByPW4oNTg2KSxhPW4oOTE5KSxpPW4oOTgzKSxvPW4oMzYxKTtlLmluaXRPcnQ9KHQsZSk9Pntjb25zdCBuPSgwLG8uZ2V0SW5zdGFuY2UpKCkuX09ydEluaXQodCxlKTtpZigwIT09bil0aHJvdyBuZXcgRXJyb3IoYENhblxcJ3QgaW5pdGlhbGl6ZSBvbm54cnVudGltZS4gZXJyb3IgY29kZSA9ICR7bn1gKX07Y29uc3QgdT1uZXcgTWFwO2UuY3JlYXRlU2Vzc2lvbkFsbG9jYXRlPXQ9Pntjb25zdCBlPSgwLG8uZ2V0SW5zdGFuY2UpKCksbj1lLl9tYWxsb2ModC5ieXRlTGVuZ3RoKTtyZXR1cm4gZS5IRUFQVTguc2V0KHQsbiksW24sdC5ieXRlTGVuZ3RoXX0sZS5jcmVhdGVTZXNzaW9uRmluYWxpemU9KHQsZSk9Pntjb25zdCBuPSgwLG8uZ2V0SW5zdGFuY2UpKCk7bGV0IHI9MCxpPTAscz1bXTt0cnl7aWYoW2ksc109KDAsYS5zZXRTZXNzaW9uT3B0aW9ucykoZSkscj1uLl9PcnRDcmVhdGVTZXNzaW9uKHRbMF0sdFsxXSxpKSwwPT09cil0aHJvdyBuZXcgRXJyb3IoXCJDYW5cXCd0IGNyZWF0ZSBhIHNlc3Npb25cIil9ZmluYWxseXtuLl9mcmVlKHRbMF0pLG4uX09ydFJlbGVhc2VTZXNzaW9uT3B0aW9ucyhpKSxzLmZvckVhY2gobi5fZnJlZSl9Y29uc3QgYz1uLl9PcnRHZXRJbnB1dENvdW50KHIpLGw9bi5fT3J0R2V0T3V0cHV0Q291bnQociksZj1bXSxwPVtdLGg9W10sZD1bXTtmb3IobGV0IHQ9MDt0PGM7dCsrKXtjb25zdCBlPW4uX09ydEdldElucHV0TmFtZShyLHQpO2lmKDA9PT1lKXRocm93IG5ldyBFcnJvcihcIkNhblxcJ3QgZ2V0IGFuIGlucHV0IG5hbWVcIik7cC5wdXNoKGUpLGYucHVzaChuLlVURjhUb1N0cmluZyhlKSl9Zm9yKGxldCB0PTA7dDxsO3QrKyl7Y29uc3QgZT1uLl9PcnRHZXRPdXRwdXROYW1lKHIsdCk7aWYoMD09PWUpdGhyb3cgbmV3IEVycm9yKFwiQ2FuXFwndCBnZXQgYW4gb3V0cHV0IG5hbWVcIik7ZC5wdXNoKGUpLGgucHVzaChuLlVURjhUb1N0cmluZyhlKSl9cmV0dXJuIHUuc2V0KHIsW3IscCxkXSksW3IsZixoXX0sZS5jcmVhdGVTZXNzaW9uPSh0LG4pPT57Y29uc3Qgcj0oMCxlLmNyZWF0ZVNlc3Npb25BbGxvY2F0ZSkodCk7cmV0dXJuKDAsZS5jcmVhdGVTZXNzaW9uRmluYWxpemUpKHIsbil9LGUucmVsZWFzZVNlc3Npb249dD0+e2NvbnN0IGU9KDAsby5nZXRJbnN0YW5jZSkoKSxuPXUuZ2V0KHQpO2lmKCFuKXRocm93IG5ldyBFcnJvcihcImludmFsaWQgc2Vzc2lvbiBpZFwiKTtjb25zdCByPW5bMF0sYT1uWzFdLGk9blsyXTthLmZvckVhY2goZS5fT3J0RnJlZSksaS5mb3JFYWNoKGUuX09ydEZyZWUpLGUuX09ydFJlbGVhc2VTZXNzaW9uKHIpLHUuZGVsZXRlKHQpfTtjb25zdCBzPXQ9Pntzd2l0Y2godCl7Y2FzZVwiaW50OFwiOnJldHVybiAzO2Nhc2VcInVpbnQ4XCI6cmV0dXJuIDI7Y2FzZVwiYm9vbFwiOnJldHVybiA5O2Nhc2VcImludDE2XCI6cmV0dXJuIDU7Y2FzZVwidWludDE2XCI6cmV0dXJuIDQ7Y2FzZVwiaW50MzJcIjpyZXR1cm4gNjtjYXNlXCJ1aW50MzJcIjpyZXR1cm4gMTI7Y2FzZVwiZmxvYXQzMlwiOnJldHVybiAxO2Nhc2VcImZsb2F0NjRcIjpyZXR1cm4gMTE7Y2FzZVwic3RyaW5nXCI6cmV0dXJuIDg7Y2FzZVwiaW50NjRcIjpyZXR1cm4gNztjYXNlXCJ1aW50NjRcIjpyZXR1cm4gMTM7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIGRhdGEgdHlwZTogJHt0fWApfX0sYz10PT57c3dpdGNoKHQpe2Nhc2UgMzpyZXR1cm5cImludDhcIjtjYXNlIDI6cmV0dXJuXCJ1aW50OFwiO2Nhc2UgOTpyZXR1cm5cImJvb2xcIjtjYXNlIDU6cmV0dXJuXCJpbnQxNlwiO2Nhc2UgNDpyZXR1cm5cInVpbnQxNlwiO2Nhc2UgNjpyZXR1cm5cImludDMyXCI7Y2FzZSAxMjpyZXR1cm5cInVpbnQzMlwiO2Nhc2UgMTpyZXR1cm5cImZsb2F0MzJcIjtjYXNlIDExOnJldHVyblwiZmxvYXQ2NFwiO2Nhc2UgODpyZXR1cm5cInN0cmluZ1wiO2Nhc2UgNzpyZXR1cm5cImludDY0XCI7Y2FzZSAxMzpyZXR1cm5cInVpbnQ2NFwiO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCBkYXRhIHR5cGU6ICR7dH1gKX19LGw9dD0+e3N3aXRjaCh0KXtjYXNlXCJmbG9hdDMyXCI6cmV0dXJuIEZsb2F0MzJBcnJheTtjYXNlXCJ1aW50OFwiOmNhc2VcImJvb2xcIjpyZXR1cm4gVWludDhBcnJheTtjYXNlXCJpbnQ4XCI6cmV0dXJuIEludDhBcnJheTtjYXNlXCJ1aW50MTZcIjpyZXR1cm4gVWludDE2QXJyYXk7Y2FzZVwiaW50MTZcIjpyZXR1cm4gSW50MTZBcnJheTtjYXNlXCJpbnQzMlwiOnJldHVybiBJbnQzMkFycmF5O2Nhc2VcImZsb2F0NjRcIjpyZXR1cm4gRmxvYXQ2NEFycmF5O2Nhc2VcInVpbnQzMlwiOnJldHVybiBVaW50MzJBcnJheTtjYXNlXCJpbnQ2NFwiOnJldHVybiBCaWdJbnQ2NEFycmF5O2Nhc2VcInVpbnQ2NFwiOnJldHVybiBCaWdVaW50NjRBcnJheTtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgdHlwZTogJHt0fWApfX07ZS5ydW49KHQsZSxuLGEsZik9Pntjb25zdCBwPSgwLG8uZ2V0SW5zdGFuY2UpKCksaD11LmdldCh0KTtpZighaCl0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHNlc3Npb24gaWRcIik7Y29uc3QgZD1oWzBdLHk9aFsxXSxiPWhbMl0sbT1lLmxlbmd0aCxnPWEubGVuZ3RoO2xldCB2PTAsXz1bXTtjb25zdCB3PVtdLE89W107dHJ5e1t2LF9dPSgwLHIuc2V0UnVuT3B0aW9ucykoZik7Zm9yKGxldCB0PTA7dDxtO3QrKyl7Y29uc3QgZT1uW3RdWzBdLHI9blt0XVsxXSxhPW5bdF1bMl07bGV0IG8sdTtpZihBcnJheS5pc0FycmF5KGEpKXt1PTQqYS5sZW5ndGgsbz1wLl9tYWxsb2ModSksTy5wdXNoKG8pO2xldCB0PW8vNDtmb3IobGV0IGU9MDtlPGEubGVuZ3RoO2UrKyl7aWYoXCJzdHJpbmdcIiE9dHlwZW9mIGFbZV0pdGhyb3cgbmV3IFR5cGVFcnJvcihgdGVuc29yIGRhdGEgYXQgaW5kZXggJHtlfSBpcyBub3QgYSBzdHJpbmdgKTtwLkhFQVBVMzJbdCsrXT0oMCxpLmFsbG9jV2FzbVN0cmluZykoYVtlXSxPKX19ZWxzZSB1PWEuYnl0ZUxlbmd0aCxvPXAuX21hbGxvYyh1KSxPLnB1c2gobykscC5IRUFQVTguc2V0KG5ldyBVaW50OEFycmF5KGEuYnVmZmVyLGEuYnl0ZU9mZnNldCx1KSxvKTtjb25zdCBjPXAuc3RhY2tTYXZlKCksbD1wLnN0YWNrQWxsb2MoNCpyLmxlbmd0aCk7dHJ5e2xldCB0PWwvNDtyLmZvckVhY2goKGU9PnAuSEVBUDMyW3QrK109ZSkpO2NvbnN0IG49cC5fT3J0Q3JlYXRlVGVuc29yKHMoZSksbyx1LGwsci5sZW5ndGgpO2lmKDA9PT1uKXRocm93IG5ldyBFcnJvcihcIkNhblxcJ3QgY3JlYXRlIGEgdGVuc29yXCIpO3cucHVzaChuKX1maW5hbGx5e3Auc3RhY2tSZXN0b3JlKGMpfX1jb25zdCB0PXAuc3RhY2tTYXZlKCksbz1wLnN0YWNrQWxsb2MoNCptKSx1PXAuc3RhY2tBbGxvYyg0Km0pLGg9cC5zdGFja0FsbG9jKDQqZyksQT1wLnN0YWNrQWxsb2MoNCpnKTt0cnl7bGV0IG49by80LHI9dS80LGk9aC80LHM9QS80O2ZvcihsZXQgdD0wO3Q8bTt0KyspcC5IRUFQVTMyW24rK109d1t0XSxwLkhFQVBVMzJbcisrXT15W2VbdF1dO2ZvcihsZXQgdD0wO3Q8Zzt0KyspcC5IRUFQVTMyW2krK109MCxwLkhFQVBVMzJbcysrXT1iW2FbdF1dO2xldCBmPXAuX09ydFJ1bihkLHUsbyxtLEEsZyxoLHYpO2NvbnN0IF89W107aWYoMD09PWYpZm9yKGxldCB0PTA7dDxnO3QrKyl7Y29uc3QgZT1wLkhFQVBVMzJbaC80K3RdLG49cC5zdGFja1NhdmUoKSxyPXAuc3RhY2tBbGxvYygxNik7bGV0IGEsaT0wO3RyeXtpZihmPXAuX09ydEdldFRlbnNvckRhdGEoZSxyLHIrNCxyKzgscisxMiksMCE9PWYpdGhyb3cgbmV3IEVycm9yKGBDYW5cXCd0IGFjY2VzcyBvdXRwdXQgdGVuc29yIGRhdGEuIGVycm9yIGNvZGUgPSAke2Z9YCk7bGV0IHQ9ci80O2NvbnN0IG89cC5IRUFQVTMyW3QrK107aT1wLkhFQVBVMzJbdCsrXTtjb25zdCB1PXAuSEVBUFUzMlt0KytdLHM9cC5IRUFQVTMyW3QrK10saD1bXTtmb3IobGV0IHQ9MDt0PHM7dCsrKWgucHVzaChwLkhFQVBVMzJbdS80K3RdKTtwLl9PcnRGcmVlKHUpO2NvbnN0IGQ9MD09PWgubGVuZ3RoPzE6aC5yZWR1Y2UoKCh0LGUpPT50KmUpKTtpZihhPWMobyksXCJzdHJpbmdcIj09PWEpe2NvbnN0IHQ9W107bGV0IGU9aS80O2ZvcihsZXQgbj0wO248ZDtuKyspe2NvbnN0IHI9cC5IRUFQVTMyW2UrK10sYT1uPT09ZC0xP3ZvaWQgMDpwLkhFQVBVMzJbZV0tcjt0LnB1c2gocC5VVEY4VG9TdHJpbmcocixhKSl9Xy5wdXNoKFthLGgsdF0pfWVsc2V7Y29uc3QgdD1uZXcobChhKSkoZCk7bmV3IFVpbnQ4QXJyYXkodC5idWZmZXIsdC5ieXRlT2Zmc2V0LHQuYnl0ZUxlbmd0aCkuc2V0KHAuSEVBUFU4LnN1YmFycmF5KGksaSt0LmJ5dGVMZW5ndGgpKSxfLnB1c2goW2EsaCx0XSl9fWZpbmFsbHl7cC5zdGFja1Jlc3RvcmUobiksXCJzdHJpbmdcIj09PWEmJmkmJnAuX2ZyZWUoaSkscC5fT3J0UmVsZWFzZVRlbnNvcihlKX19aWYoMD09PWYpcmV0dXJuIF87dGhyb3cgbmV3IEVycm9yKGBmYWlsZWQgdG8gY2FsbCBPcnRSdW4oKS4gZXJyb3IgY29kZSA9ICR7Zn0uYCl9ZmluYWxseXtwLnN0YWNrUmVzdG9yZSh0KX19ZmluYWxseXt3LmZvckVhY2gocC5fT3J0UmVsZWFzZVRlbnNvciksTy5mb3JFYWNoKHAuX2ZyZWUpLHAuX09ydFJlbGVhc2VSdW5PcHRpb25zKHYpLF8uZm9yRWFjaChwLl9mcmVlKX19LGUuZW5kUHJvZmlsaW5nPXQ9Pntjb25zdCBlPSgwLG8uZ2V0SW5zdGFuY2UpKCksbj11LmdldCh0KTtpZighbil0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHNlc3Npb24gaWRcIik7Y29uc3Qgcj1uWzBdLGE9ZS5fT3J0RW5kUHJvZmlsaW5nKHIpO2lmKDA9PT1hKXRocm93IG5ldyBFcnJvcihcIkNhblxcJ3QgZ2V0IGFuIHByb2ZpbGUgZmlsZSBuYW1lXCIpO2UuX09ydEZyZWUoYSl9LGUuZXh0cmFjdFRyYW5zZmVyYWJsZUJ1ZmZlcnM9dD0+e2NvbnN0IGU9W107Zm9yKGNvbnN0IG4gb2YgdCl7Y29uc3QgdD1uWzJdOyFBcnJheS5pc0FycmF5KHQpJiZ0LmJ1ZmZlciYmZS5wdXNoKHQuYnVmZmVyKX1yZXR1cm4gZX19LDM2MTpmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7dmFyIHI9dGhpcyYmdGhpcy5fX2NyZWF0ZUJpbmRpbmd8fChPYmplY3QuY3JlYXRlP2Z1bmN0aW9uKHQsZSxuLHIpe3ZvaWQgMD09PXImJihyPW4pO3ZhciBhPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSxuKTthJiYhKFwiZ2V0XCJpbiBhPyFlLl9fZXNNb2R1bGU6YS53cml0YWJsZXx8YS5jb25maWd1cmFibGUpfHwoYT17ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gZVtuXX19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCxyLGEpfTpmdW5jdGlvbih0LGUsbixyKXt2b2lkIDA9PT1yJiYocj1uKSx0W3JdPWVbbl19KSxhPXRoaXMmJnRoaXMuX19zZXRNb2R1bGVEZWZhdWx0fHwoT2JqZWN0LmNyZWF0ZT9mdW5jdGlvbih0LGUpe09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiZGVmYXVsdFwiLHtlbnVtZXJhYmxlOiEwLHZhbHVlOmV9KX06ZnVuY3Rpb24odCxlKXt0LmRlZmF1bHQ9ZX0pLGk9dGhpcyYmdGhpcy5fX2ltcG9ydFN0YXJ8fGZ1bmN0aW9uKHQpe2lmKHQmJnQuX19lc01vZHVsZSlyZXR1cm4gdDt2YXIgZT17fTtpZihudWxsIT10KWZvcih2YXIgbiBpbiB0KVwiZGVmYXVsdFwiIT09biYmT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQsbikmJnIoZSx0LG4pO3JldHVybiBhKGUsdCksZX0sbz10aGlzJiZ0aGlzLl9faW1wb3J0RGVmYXVsdHx8ZnVuY3Rpb24odCl7cmV0dXJuIHQmJnQuX19lc01vZHVsZT90OntkZWZhdWx0OnR9fTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLmRpc3Bvc2U9ZS5nZXRJbnN0YW5jZT1lLmluaXRpYWxpemVXZWJBc3NlbWJseT12b2lkIDA7Y29uc3QgdT1pKG4oMTcpKSxzPW8obig5MzIpKSxjPW4oNDc0KTtsZXQgbCxmPSExLHA9ITEsaD0hMTtjb25zdCBkPSh0LGUpPT5lP3Q/XCJvcnQtd2FzbS1zaW1kLXRocmVhZGVkLndhc21cIjpcIm9ydC13YXNtLXRocmVhZGVkLndhc21cIjp0P1wib3J0LXdhc20tc2ltZC53YXNtXCI6XCJvcnQtd2FzbS53YXNtXCI7ZS5pbml0aWFsaXplV2ViQXNzZW1ibHk9YXN5bmMgdD0+e2lmKGYpcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO2lmKHApdGhyb3cgbmV3IEVycm9yKFwibXVsdGlwbGUgY2FsbHMgdG8gXFwnaW5pdGlhbGl6ZVdlYkFzc2VtYmx5KClcXCcgZGV0ZWN0ZWQuXCIpO2lmKGgpdGhyb3cgbmV3IEVycm9yKFwicHJldmlvdXMgY2FsbCB0byBcXCdpbml0aWFsaXplV2ViQXNzZW1ibHkoKVxcJyBmYWlsZWQuXCIpO3A9ITA7Y29uc3QgZT10LmluaXRUaW1lb3V0LHI9dC5udW1UaHJlYWRzLGE9dC5zaW1kLGk9cj4xJiYoKCk9Pnt0cnl7cmV0dXJuXCJ1bmRlZmluZWRcIiE9dHlwZW9mIFNoYXJlZEFycmF5QnVmZmVyJiYoXCJ1bmRlZmluZWRcIiE9dHlwZW9mIE1lc3NhZ2VDaGFubmVsJiYobmV3IE1lc3NhZ2VDaGFubmVsKS5wb3J0MS5wb3N0TWVzc2FnZShuZXcgU2hhcmVkQXJyYXlCdWZmZXIoMSkpLFdlYkFzc2VtYmx5LnZhbGlkYXRlKG5ldyBVaW50OEFycmF5KFswLDk3LDExNSwxMDksMSwwLDAsMCwxLDQsMSw5NiwwLDAsMywyLDEsMCw1LDQsMSwzLDEsMSwxMCwxMSwxLDksMCw2NSwwLDI1NCwxNiwyLDAsMjYsMTFdKSkpfWNhdGNoKHQpe3JldHVybiExfX0pKCksbz1hJiYoKCk9Pnt0cnl7cmV0dXJuIFdlYkFzc2VtYmx5LnZhbGlkYXRlKG5ldyBVaW50OEFycmF5KFswLDk3LDExNSwxMDksMSwwLDAsMCwxLDQsMSw5NiwwLDAsMywyLDEsMCwxMCwzMCwxLDI4LDAsNjUsMCwyNTMsMTUsMjUzLDEyLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMjUzLDE4NiwxLDI2LDExXSkpfWNhdGNoKHQpe3JldHVybiExfX0pKCkseT1cInN0cmluZ1wiPT10eXBlb2YgdC53YXNtUGF0aHM/dC53YXNtUGF0aHM6dm9pZCAwLGI9ZCghMSxpKSxtPWQobyxpKSxnPVwib2JqZWN0XCI9PXR5cGVvZiB0Lndhc21QYXRocz90Lndhc21QYXRoc1ttXTp2b2lkIDA7bGV0IHY9ITE7Y29uc3QgXz1bXTtpZihlPjAmJl8ucHVzaChuZXcgUHJvbWlzZSgodD0+e3NldFRpbWVvdXQoKCgpPT57dj0hMCx0KCl9KSxlKX0pKSksXy5wdXNoKG5ldyBQcm9taXNlKCgodCxlKT0+e2NvbnN0IHI9aT9jOnMuZGVmYXVsdCxhPXtsb2NhdGVGaWxlOih0LGUpPT5pJiZ0LmVuZHNXaXRoKFwiLndvcmtlci5qc1wiKSYmXCJ1bmRlZmluZWRcIiE9dHlwZW9mIEJsb2I/VVJMLmNyZWF0ZU9iamVjdFVSTChuZXcgQmxvYihbbigxNTQpXSx7dHlwZTpcInRleHQvamF2YXNjcmlwdFwifSkpOnQ9PT1iP251bGwhPWc/ZzoobnVsbCE9eT95OmUpK206ZSt0fTtpZihpKWlmKFwidW5kZWZpbmVkXCI9PXR5cGVvZiBCbG9iKWEubWFpblNjcmlwdFVybE9yQmxvYj11LmpvaW4oX19kaXJuYW1lLFwib3J0LXdhc20tdGhyZWFkZWQuanNcIik7ZWxzZXtjb25zdCB0PWB2YXIgb3J0V2FzbVRocmVhZGVkPShmdW5jdGlvbigpe3ZhciBfc2NyaXB0RGlyO3JldHVybiAke3IudG9TdHJpbmcoKX19KSgpO2A7YS5tYWluU2NyaXB0VXJsT3JCbG9iPW5ldyBCbG9iKFt0XSx7dHlwZTpcInRleHQvamF2YXNjcmlwdFwifSl9cihhKS50aGVuKChlPT57cD0hMSxmPSEwLGw9ZSx0KCl9KSwodD0+e3A9ITEsaD0hMCxlKHQpfSkpfSkpKSxhd2FpdCBQcm9taXNlLnJhY2UoXyksdil0aHJvdyBuZXcgRXJyb3IoYFdlYkFzc2VtYmx5IGJhY2tlbmQgaW5pdGlhbGl6aW5nIGZhaWxlZCBkdWUgdG8gdGltZW91dDogJHtlfW1zYCl9LGUuZ2V0SW5zdGFuY2U9KCk9PntpZihmJiZsKXJldHVybiBsO3Rocm93IG5ldyBFcnJvcihcIldlYkFzc2VtYmx5IGlzIG5vdCBpbml0aWFsaXplZCB5ZXQuXCIpfSxlLmRpc3Bvc2U9KCk9Pnt2YXIgdDshZnx8cHx8aHx8KHA9ITAsbnVsbD09PSh0PWwuUFRocmVhZCl8fHZvaWQgMD09PXR8fHQudGVybWluYXRlQWxsVGhyZWFkcygpLGw9dm9pZCAwLHA9ITEsZj0hMSxoPSEwKX19LDE1NDp0PT57XCJ1c2Ugc3RyaWN0XCI7dC5leHBvcnRzPVxcJ1widXNlIHN0cmljdFwiO3ZhciBlPXt9LHQ9XCJvYmplY3RcIj09dHlwZW9mIHByb2Nlc3MmJlwib2JqZWN0XCI9PXR5cGVvZiBwcm9jZXNzLnZlcnNpb25zJiZcInN0cmluZ1wiPT10eXBlb2YgcHJvY2Vzcy52ZXJzaW9ucy5ub2RlO2lmKHQpe3ZhciByPXJlcXVpcmUoXCJ3b3JrZXJfdGhyZWFkc1wiKSxhPXIucGFyZW50UG9ydDthLm9uKFwibWVzc2FnZVwiLChlPT5vbm1lc3NhZ2Uoe2RhdGE6ZX0pKSk7dmFyIG89cmVxdWlyZShcImZzXCIpO09iamVjdC5hc3NpZ24oZ2xvYmFsLHtzZWxmOmdsb2JhbCxyZXF1aXJlOnJlcXVpcmUsTW9kdWxlOmUsbG9jYXRpb246e2hyZWY6X19maWxlbmFtZX0sV29ya2VyOnIuV29ya2VyLGltcG9ydFNjcmlwdHM6ZnVuY3Rpb24oZSl7KDAsZXZhbCkoby5yZWFkRmlsZVN5bmMoZSxcInV0ZjhcIikpfSxwb3N0TWVzc2FnZTpmdW5jdGlvbihlKXthLnBvc3RNZXNzYWdlKGUpfSxwZXJmb3JtYW5jZTpnbG9iYWwucGVyZm9ybWFuY2V8fHtub3c6ZnVuY3Rpb24oKXtyZXR1cm4gRGF0ZS5ub3coKX19fSl9dmFyIHM9ITEsbj1bXSxpPWZ1bmN0aW9uKCl7dmFyIGU9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKS5qb2luKFwiIFwiKTt0P28ud3JpdGVTeW5jKDIsZStcIlxcXFxcXFxcblwiKTpjb25zb2xlLmVycm9yKGUpfTtzZWxmLmFsZXJ0PWZ1bmN0aW9uKCl7dmFyIHQ9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKS5qb2luKFwiIFwiKTtwb3N0TWVzc2FnZSh7Y21kOlwiYWxlcnRcIix0ZXh0OnQsdGhyZWFkSWQ6ZS5fcHRocmVhZF9zZWxmKCl9KX0sZS5pbnN0YW50aWF0ZVdhc209KHQscik9Pnt2YXIgYT1uZXcgV2ViQXNzZW1ibHkuSW5zdGFuY2UoZS53YXNtTW9kdWxlLHQpO3JldHVybiByKGEpLGUud2FzbU1vZHVsZT1udWxsLGEuZXhwb3J0c30sc2VsZi5vbnVuaGFuZGxlZHJlamVjdGlvbj1lPT57dGhyb3cgZS5yZWFzb24/P2V9LHNlbGYub25tZXNzYWdlPXQ9Pnt0cnl7aWYoXCJsb2FkXCI9PT10LmRhdGEuY21kKXtpZihlLndhc21Nb2R1bGU9dC5kYXRhLndhc21Nb2R1bGUsZS53YXNtTWVtb3J5PXQuZGF0YS53YXNtTWVtb3J5LGUuYnVmZmVyPWUud2FzbU1lbW9yeS5idWZmZXIsZS5FTlZJUk9OTUVOVF9JU19QVEhSRUFEPSEwLFwic3RyaW5nXCI9PXR5cGVvZiB0LmRhdGEudXJsT3JCbG9iKWltcG9ydFNjcmlwdHModC5kYXRhLnVybE9yQmxvYik7ZWxzZXt2YXIgcj1VUkwuY3JlYXRlT2JqZWN0VVJMKHQuZGF0YS51cmxPckJsb2IpO2ltcG9ydFNjcmlwdHMociksVVJMLnJldm9rZU9iamVjdFVSTChyKX1vcnRXYXNtVGhyZWFkZWQoZSkudGhlbigoZnVuY3Rpb24odCl7ZT10fSkpfWVsc2UgaWYoXCJydW5cIj09PXQuZGF0YS5jbWQpe2UuX19wZXJmb3JtYW5jZV9ub3dfY2xvY2tfZHJpZnQ9cGVyZm9ybWFuY2Uubm93KCktdC5kYXRhLnRpbWUsZS5fX2Vtc2NyaXB0ZW5fdGhyZWFkX2luaXQodC5kYXRhLnB0aHJlYWRfcHRyLDAsMCwxKSxlLmVzdGFibGlzaFN0YWNrU3BhY2UoKSxlLlBUaHJlYWQucmVjZWl2ZU9iamVjdFRyYW5zZmVyKHQuZGF0YSksZS5QVGhyZWFkLnRocmVhZEluaXRUTFMoKSxzfHwobi5mb3JFYWNoKCh0PT57ZS5leGVjdXRlTm90aWZpZWRQcm94eWluZ1F1ZXVlKHQpfSkpLG49W10scz0hMCk7dHJ5e2UuaW52b2tlRW50cnlQb2ludCh0LmRhdGEuc3RhcnRfcm91dGluZSx0LmRhdGEuYXJnKX1jYXRjaCh0KXtpZihcInVud2luZFwiIT10KXtpZighKHQgaW5zdGFuY2VvZiBlLkV4aXRTdGF0dXMpKXRocm93IHQ7ZS5rZWVwUnVudGltZUFsaXZlKCl8fGUuX19lbXNjcmlwdGVuX3RocmVhZF9leGl0KHQuc3RhdHVzKX19fWVsc2VcImNhbmNlbFwiPT09dC5kYXRhLmNtZD9lLl9wdGhyZWFkX3NlbGYoKSYmZS5fX2Vtc2NyaXB0ZW5fdGhyZWFkX2V4aXQoLTEpOlwic2V0aW1tZWRpYXRlXCI9PT10LmRhdGEudGFyZ2V0fHwoXCJwcm9jZXNzUHJveHlpbmdRdWV1ZVwiPT09dC5kYXRhLmNtZD9zP2UuZXhlY3V0ZU5vdGlmaWVkUHJveHlpbmdRdWV1ZSh0LmRhdGEucXVldWUpOm4ucHVzaCh0LmRhdGEucXVldWUpOihpKFwid29ya2VyLmpzIHJlY2VpdmVkIHVua25vd24gY29tbWFuZCBcIit0LmRhdGEuY21kKSxpKHQuZGF0YSkpKX1jYXRjaCh0KXt0aHJvdyBpKFwid29ya2VyLmpzIG9ubWVzc2FnZSgpIGNhcHR1cmVkIGFuIHVuY2F1Z2h0IGV4Y2VwdGlvbjogXCIrdCksdCYmdC5zdGFjayYmaSh0LnN0YWNrKSxlLl9fZW1zY3JpcHRlbl90aHJlYWRfY3Jhc2hlZCYmZS5fX2Vtc2NyaXB0ZW5fdGhyZWFkX2NyYXNoZWQoKSx0fX07XFxcXG5cXCd9LDExMzp0PT57XCJ1c2Ugc3RyaWN0XCI7dC5leHBvcnRzPXJlcXVpcmUoXCJjcnlwdG9cIil9LDE0Nzp0PT57XCJ1c2Ugc3RyaWN0XCI7dC5leHBvcnRzPXJlcXVpcmUoXCJmc1wiKX0sMzc6dD0+e1widXNlIHN0cmljdFwiO3QuZXhwb3J0cz1yZXF1aXJlKFwib3NcIil9LDE3OnQ9PntcInVzZSBzdHJpY3RcIjt0LmV4cG9ydHM9cmVxdWlyZShcInBhdGhcIil9LDc0OnQ9PntcInVzZSBzdHJpY3RcIjt0LmV4cG9ydHM9cmVxdWlyZShcInBlcmZfaG9va3NcIil9LDI2Nzp0PT57XCJ1c2Ugc3RyaWN0XCI7dC5leHBvcnRzPXJlcXVpcmUoXCJ3b3JrZXJfdGhyZWFkc1wiKX19LGU9e307ZnVuY3Rpb24gbihyKXt2YXIgYT1lW3JdO2lmKHZvaWQgMCE9PWEpcmV0dXJuIGEuZXhwb3J0czt2YXIgaT1lW3JdPXtleHBvcnRzOnt9fTtyZXR1cm4gdFtyXS5jYWxsKGkuZXhwb3J0cyxpLGkuZXhwb3J0cyxuKSxpLmV4cG9ydHN9KCgpPT57XCJ1c2Ugc3RyaWN0XCI7Y29uc3QgdD1uKDM0OSksZT1uKDM2MSk7c2VsZi5vbm1lc3NhZ2U9bj0+e3N3aXRjaChuLmRhdGEudHlwZSl7Y2FzZVwiaW5pdC13YXNtXCI6KDAsZS5pbml0aWFsaXplV2ViQXNzZW1ibHkpKG4uZGF0YS5pbikudGhlbigoKCk9PnBvc3RNZXNzYWdlKHt0eXBlOlwiaW5pdC13YXNtXCJ9KSksKHQ9PnBvc3RNZXNzYWdlKHt0eXBlOlwiaW5pdC13YXNtXCIsZXJyOnR9KSkpO2JyZWFrO2Nhc2VcImluaXQtb3J0XCI6dHJ5e2NvbnN0e251bVRocmVhZHM6ZSxsb2dnaW5nTGV2ZWw6cn09bi5kYXRhLmluOygwLHQuaW5pdE9ydCkoZSxyKSxwb3N0TWVzc2FnZSh7dHlwZTpcImluaXQtb3J0XCJ9KX1jYXRjaCh0KXtwb3N0TWVzc2FnZSh7dHlwZTpcImluaXQtb3J0XCIsZXJyOnR9KX1icmVhaztjYXNlXCJjcmVhdGVfYWxsb2NhdGVcIjp0cnl7Y29uc3R7bW9kZWw6ZX09bi5kYXRhLmluLHI9KDAsdC5jcmVhdGVTZXNzaW9uQWxsb2NhdGUpKGUpO3Bvc3RNZXNzYWdlKHt0eXBlOlwiY3JlYXRlX2FsbG9jYXRlXCIsb3V0OnJ9KX1jYXRjaCh0KXtwb3N0TWVzc2FnZSh7dHlwZTpcImNyZWF0ZV9hbGxvY2F0ZVwiLGVycjp0fSl9YnJlYWs7Y2FzZVwiY3JlYXRlX2ZpbmFsaXplXCI6dHJ5e2NvbnN0e21vZGVsZGF0YTplLG9wdGlvbnM6cn09bi5kYXRhLmluLGE9KDAsdC5jcmVhdGVTZXNzaW9uRmluYWxpemUpKGUscik7cG9zdE1lc3NhZ2Uoe3R5cGU6XCJjcmVhdGVfZmluYWxpemVcIixvdXQ6YX0pfWNhdGNoKHQpe3Bvc3RNZXNzYWdlKHt0eXBlOlwiY3JlYXRlX2ZpbmFsaXplXCIsZXJyOnR9KX1icmVhaztjYXNlXCJjcmVhdGVcIjp0cnl7Y29uc3R7bW9kZWw6ZSxvcHRpb25zOnJ9PW4uZGF0YS5pbixhPSgwLHQuY3JlYXRlU2Vzc2lvbikoZSxyKTtwb3N0TWVzc2FnZSh7dHlwZTpcImNyZWF0ZVwiLG91dDphfSl9Y2F0Y2godCl7cG9zdE1lc3NhZ2Uoe3R5cGU6XCJjcmVhdGVcIixlcnI6dH0pfWJyZWFrO2Nhc2VcInJlbGVhc2VcIjp0cnl7Y29uc3QgZT1uLmRhdGEuaW47KDAsdC5yZWxlYXNlU2Vzc2lvbikoZSkscG9zdE1lc3NhZ2Uoe3R5cGU6XCJyZWxlYXNlXCJ9KX1jYXRjaCh0KXtwb3N0TWVzc2FnZSh7dHlwZTpcInJlbGVhc2VcIixlcnI6dH0pfWJyZWFrO2Nhc2VcInJ1blwiOnRyeXtjb25zdHtzZXNzaW9uSWQ6ZSxpbnB1dEluZGljZXM6cixpbnB1dHM6YSxvdXRwdXRJbmRpY2VzOmksb3B0aW9uczpvfT1uLmRhdGEuaW4sdT0oMCx0LnJ1bikoZSxyLGEsaSxvKTtwb3N0TWVzc2FnZSh7dHlwZTpcInJ1blwiLG91dDp1fSwoMCx0LmV4dHJhY3RUcmFuc2ZlcmFibGVCdWZmZXJzKSh1KSl9Y2F0Y2godCl7cG9zdE1lc3NhZ2Uoe3R5cGU6XCJydW5cIixlcnI6dH0pfWJyZWFrO2Nhc2VcImVuZC1wcm9maWxpbmdcIjp0cnl7Y29uc3QgZT1uLmRhdGEuaW47KDAsdC5lbmRQcm9maWxpbmcpKGUpLHBvc3RNZXNzYWdlKHt0eXBlOlwiZW5kLXByb2ZpbGluZ1wifSl9Y2F0Y2godCl7cG9zdE1lc3NhZ2Uoe3R5cGU6XCJlbmQtcHJvZmlsaW5nXCIsZXJyOnR9KX19fX0pKCl9KSgpO1xcbicsXCJXb3JrZXJcIix2b2lkIDAsdm9pZCAwKX19LDQ3Nzp0PT57XCJ1c2Ugc3RyaWN0XCI7dC5leHBvcnRzPWZ1bmN0aW9uKHQsZSxuLHIpe3ZhciBpPXNlbGZ8fHdpbmRvdzt0cnl7dHJ5e3ZhciBvO3RyeXtvPW5ldyBpLkJsb2IoW3RdKX1jYXRjaChlKXsobz1uZXcoaS5CbG9iQnVpbGRlcnx8aS5XZWJLaXRCbG9iQnVpbGRlcnx8aS5Nb3pCbG9iQnVpbGRlcnx8aS5NU0Jsb2JCdWlsZGVyKSkuYXBwZW5kKHQpLG89by5nZXRCbG9iKCl9dmFyIGE9aS5VUkx8fGkud2Via2l0VVJMLHM9YS5jcmVhdGVPYmplY3RVUkwobyksdT1uZXcgaVtlXShzLG4pO3JldHVybiBhLnJldm9rZU9iamVjdFVSTChzKSx1fWNhdGNoKHIpe3JldHVybiBuZXcgaVtlXShcImRhdGE6YXBwbGljYXRpb24vamF2YXNjcmlwdCxcIi5jb25jYXQoZW5jb2RlVVJJQ29tcG9uZW50KHQpKSxuKX19Y2F0Y2godCl7aWYoIXIpdGhyb3cgRXJyb3IoXCJJbmxpbmUgd29ya2VyIGlzIG5vdCBzdXBwb3J0ZWRcIik7cmV0dXJuIG5ldyBpW2VdKHIsbil9fX0sNDE1NDp0PT57XCJ1c2Ugc3RyaWN0XCI7dC5leHBvcnRzPSdcInVzZSBzdHJpY3RcIjt2YXIgZT17fSx0PVwib2JqZWN0XCI9PXR5cGVvZiBwcm9jZXNzJiZcIm9iamVjdFwiPT10eXBlb2YgcHJvY2Vzcy52ZXJzaW9ucyYmXCJzdHJpbmdcIj09dHlwZW9mIHByb2Nlc3MudmVyc2lvbnMubm9kZTtpZih0KXt2YXIgcj1yZXF1aXJlKFwid29ya2VyX3RocmVhZHNcIiksYT1yLnBhcmVudFBvcnQ7YS5vbihcIm1lc3NhZ2VcIiwoZT0+b25tZXNzYWdlKHtkYXRhOmV9KSkpO3ZhciBvPXJlcXVpcmUoXCJmc1wiKTtPYmplY3QuYXNzaWduKGdsb2JhbCx7c2VsZjpnbG9iYWwscmVxdWlyZTpyZXF1aXJlLE1vZHVsZTplLGxvY2F0aW9uOntocmVmOl9fZmlsZW5hbWV9LFdvcmtlcjpyLldvcmtlcixpbXBvcnRTY3JpcHRzOmZ1bmN0aW9uKGUpeygwLGV2YWwpKG8ucmVhZEZpbGVTeW5jKGUsXCJ1dGY4XCIpKX0scG9zdE1lc3NhZ2U6ZnVuY3Rpb24oZSl7YS5wb3N0TWVzc2FnZShlKX0scGVyZm9ybWFuY2U6Z2xvYmFsLnBlcmZvcm1hbmNlfHx7bm93OmZ1bmN0aW9uKCl7cmV0dXJuIERhdGUubm93KCl9fX0pfXZhciBzPSExLG49W10saT1mdW5jdGlvbigpe3ZhciBlPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykuam9pbihcIiBcIik7dD9vLndyaXRlU3luYygyLGUrXCJcXFxcblwiKTpjb25zb2xlLmVycm9yKGUpfTtzZWxmLmFsZXJ0PWZ1bmN0aW9uKCl7dmFyIHQ9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKS5qb2luKFwiIFwiKTtwb3N0TWVzc2FnZSh7Y21kOlwiYWxlcnRcIix0ZXh0OnQsdGhyZWFkSWQ6ZS5fcHRocmVhZF9zZWxmKCl9KX0sZS5pbnN0YW50aWF0ZVdhc209KHQscik9Pnt2YXIgYT1uZXcgV2ViQXNzZW1ibHkuSW5zdGFuY2UoZS53YXNtTW9kdWxlLHQpO3JldHVybiByKGEpLGUud2FzbU1vZHVsZT1udWxsLGEuZXhwb3J0c30sc2VsZi5vbnVuaGFuZGxlZHJlamVjdGlvbj1lPT57dGhyb3cgZS5yZWFzb24/P2V9LHNlbGYub25tZXNzYWdlPXQ9Pnt0cnl7aWYoXCJsb2FkXCI9PT10LmRhdGEuY21kKXtpZihlLndhc21Nb2R1bGU9dC5kYXRhLndhc21Nb2R1bGUsZS53YXNtTWVtb3J5PXQuZGF0YS53YXNtTWVtb3J5LGUuYnVmZmVyPWUud2FzbU1lbW9yeS5idWZmZXIsZS5FTlZJUk9OTUVOVF9JU19QVEhSRUFEPSEwLFwic3RyaW5nXCI9PXR5cGVvZiB0LmRhdGEudXJsT3JCbG9iKWltcG9ydFNjcmlwdHModC5kYXRhLnVybE9yQmxvYik7ZWxzZXt2YXIgcj1VUkwuY3JlYXRlT2JqZWN0VVJMKHQuZGF0YS51cmxPckJsb2IpO2ltcG9ydFNjcmlwdHMociksVVJMLnJldm9rZU9iamVjdFVSTChyKX1vcnRXYXNtVGhyZWFkZWQoZSkudGhlbigoZnVuY3Rpb24odCl7ZT10fSkpfWVsc2UgaWYoXCJydW5cIj09PXQuZGF0YS5jbWQpe2UuX19wZXJmb3JtYW5jZV9ub3dfY2xvY2tfZHJpZnQ9cGVyZm9ybWFuY2Uubm93KCktdC5kYXRhLnRpbWUsZS5fX2Vtc2NyaXB0ZW5fdGhyZWFkX2luaXQodC5kYXRhLnB0aHJlYWRfcHRyLDAsMCwxKSxlLmVzdGFibGlzaFN0YWNrU3BhY2UoKSxlLlBUaHJlYWQucmVjZWl2ZU9iamVjdFRyYW5zZmVyKHQuZGF0YSksZS5QVGhyZWFkLnRocmVhZEluaXRUTFMoKSxzfHwobi5mb3JFYWNoKCh0PT57ZS5leGVjdXRlTm90aWZpZWRQcm94eWluZ1F1ZXVlKHQpfSkpLG49W10scz0hMCk7dHJ5e2UuaW52b2tlRW50cnlQb2ludCh0LmRhdGEuc3RhcnRfcm91dGluZSx0LmRhdGEuYXJnKX1jYXRjaCh0KXtpZihcInVud2luZFwiIT10KXtpZighKHQgaW5zdGFuY2VvZiBlLkV4aXRTdGF0dXMpKXRocm93IHQ7ZS5rZWVwUnVudGltZUFsaXZlKCl8fGUuX19lbXNjcmlwdGVuX3RocmVhZF9leGl0KHQuc3RhdHVzKX19fWVsc2VcImNhbmNlbFwiPT09dC5kYXRhLmNtZD9lLl9wdGhyZWFkX3NlbGYoKSYmZS5fX2Vtc2NyaXB0ZW5fdGhyZWFkX2V4aXQoLTEpOlwic2V0aW1tZWRpYXRlXCI9PT10LmRhdGEudGFyZ2V0fHwoXCJwcm9jZXNzUHJveHlpbmdRdWV1ZVwiPT09dC5kYXRhLmNtZD9zP2UuZXhlY3V0ZU5vdGlmaWVkUHJveHlpbmdRdWV1ZSh0LmRhdGEucXVldWUpOm4ucHVzaCh0LmRhdGEucXVldWUpOihpKFwid29ya2VyLmpzIHJlY2VpdmVkIHVua25vd24gY29tbWFuZCBcIit0LmRhdGEuY21kKSxpKHQuZGF0YSkpKX1jYXRjaCh0KXt0aHJvdyBpKFwid29ya2VyLmpzIG9ubWVzc2FnZSgpIGNhcHR1cmVkIGFuIHVuY2F1Z2h0IGV4Y2VwdGlvbjogXCIrdCksdCYmdC5zdGFjayYmaSh0LnN0YWNrKSxlLl9fZW1zY3JpcHRlbl90aHJlYWRfY3Jhc2hlZCYmZS5fX2Vtc2NyaXB0ZW5fdGhyZWFkX2NyYXNoZWQoKSx0fX07XFxuJ30sNjIzMTp0PT57XCJ1c2Ugc3RyaWN0XCI7dC5leHBvcnRzPXJlcXVpcmUoXCJmc1wiKX0sOTcxOTp0PT57XCJ1c2Ugc3RyaWN0XCI7dC5leHBvcnRzPXJlcXVpcmUoXCJvc1wiKX0sMTQyMzp0PT57XCJ1c2Ugc3RyaWN0XCI7dC5leHBvcnRzPXJlcXVpcmUoXCJwYXRoXCIpfSw0OTg6dD0+e1widXNlIHN0cmljdFwiO3QuZXhwb3J0cz1yZXF1aXJlKFwicGVyZl9ob29rc1wiKX0sNjQ2NDp0PT57XCJ1c2Ugc3RyaWN0XCI7dC5leHBvcnRzPXJlcXVpcmUoXCJ1dGlsXCIpfSw0NTY0OnQ9PntcInVzZSBzdHJpY3RcIjt0LmV4cG9ydHM9cmVxdWlyZShcIndvcmtlcl90aHJlYWRzXCIpfSw2MjA3OnQ9PntcInVzZSBzdHJpY3RcIjt0LmV4cG9ydHM9cmVxdWlyZShcIm9ubnhydW50aW1lLWNvbW1vblwiKX0sNjExMzp0PT57XCJ1c2Ugc3RyaWN0XCI7dC5leHBvcnRzPXJlcXVpcmUoXCJjcnlwdG9cIil9LDU2ODY6KHQsZSxuKT0+e1widXNlIHN0cmljdFwiO24ucihlKSxuLmQoZSx7ZmxhdGJ1ZmZlcnM6KCk9PnJ9KTt2YXIgcj17fTtyLk9mZnNldCxyLlRhYmxlLHIuU0laRU9GX1NIT1JUPTIsci5TSVpFT0ZfSU5UPTQsci5GSUxFX0lERU5USUZJRVJfTEVOR1RIPTQsci5TSVpFX1BSRUZJWF9MRU5HVEg9NCxyLkVuY29kaW5nPXtVVEY4X0JZVEVTOjEsVVRGMTZfU1RSSU5HOjJ9LHIuaW50MzI9bmV3IEludDMyQXJyYXkoMiksci5mbG9hdDMyPW5ldyBGbG9hdDMyQXJyYXkoci5pbnQzMi5idWZmZXIpLHIuZmxvYXQ2ND1uZXcgRmxvYXQ2NEFycmF5KHIuaW50MzIuYnVmZmVyKSxyLmlzTGl0dGxlRW5kaWFuPTE9PT1uZXcgVWludDE2QXJyYXkobmV3IFVpbnQ4QXJyYXkoWzEsMF0pLmJ1ZmZlcilbMF0sci5Mb25nPWZ1bmN0aW9uKHQsZSl7dGhpcy5sb3c9MHx0LHRoaXMuaGlnaD0wfGV9LHIuTG9uZy5jcmVhdGU9ZnVuY3Rpb24odCxlKXtyZXR1cm4gMD09dCYmMD09ZT9yLkxvbmcuWkVSTzpuZXcgci5Mb25nKHQsZSl9LHIuTG9uZy5wcm90b3R5cGUudG9GbG9hdDY0PWZ1bmN0aW9uKCl7cmV0dXJuKHRoaXMubG93Pj4+MCkrNDI5NDk2NzI5Nip0aGlzLmhpZ2h9LHIuTG9uZy5wcm90b3R5cGUuZXF1YWxzPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmxvdz09dC5sb3cmJnRoaXMuaGlnaD09dC5oaWdofSxyLkxvbmcuWkVSTz1uZXcgci5Mb25nKDAsMCksci5CdWlsZGVyPWZ1bmN0aW9uKHQpe2lmKHQpZT10O2Vsc2UgdmFyIGU9MTAyNDt0aGlzLmJiPXIuQnl0ZUJ1ZmZlci5hbGxvY2F0ZShlKSx0aGlzLnNwYWNlPWUsdGhpcy5taW5hbGlnbj0xLHRoaXMudnRhYmxlPW51bGwsdGhpcy52dGFibGVfaW5fdXNlPTAsdGhpcy5pc05lc3RlZD0hMSx0aGlzLm9iamVjdF9zdGFydD0wLHRoaXMudnRhYmxlcz1bXSx0aGlzLnZlY3Rvcl9udW1fZWxlbXM9MCx0aGlzLmZvcmNlX2RlZmF1bHRzPSExfSxyLkJ1aWxkZXIucHJvdG90eXBlLmNsZWFyPWZ1bmN0aW9uKCl7dGhpcy5iYi5jbGVhcigpLHRoaXMuc3BhY2U9dGhpcy5iYi5jYXBhY2l0eSgpLHRoaXMubWluYWxpZ249MSx0aGlzLnZ0YWJsZT1udWxsLHRoaXMudnRhYmxlX2luX3VzZT0wLHRoaXMuaXNOZXN0ZWQ9ITEsdGhpcy5vYmplY3Rfc3RhcnQ9MCx0aGlzLnZ0YWJsZXM9W10sdGhpcy52ZWN0b3JfbnVtX2VsZW1zPTAsdGhpcy5mb3JjZV9kZWZhdWx0cz0hMX0sci5CdWlsZGVyLnByb3RvdHlwZS5mb3JjZURlZmF1bHRzPWZ1bmN0aW9uKHQpe3RoaXMuZm9yY2VfZGVmYXVsdHM9dH0sci5CdWlsZGVyLnByb3RvdHlwZS5kYXRhQnVmZmVyPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuYmJ9LHIuQnVpbGRlci5wcm90b3R5cGUuYXNVaW50OEFycmF5PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuYmIuYnl0ZXMoKS5zdWJhcnJheSh0aGlzLmJiLnBvc2l0aW9uKCksdGhpcy5iYi5wb3NpdGlvbigpK3RoaXMub2Zmc2V0KCkpfSxyLkJ1aWxkZXIucHJvdG90eXBlLnByZXA9ZnVuY3Rpb24odCxlKXt0PnRoaXMubWluYWxpZ24mJih0aGlzLm1pbmFsaWduPXQpO2Zvcih2YXIgbj0xK34odGhpcy5iYi5jYXBhY2l0eSgpLXRoaXMuc3BhY2UrZSkmdC0xO3RoaXMuc3BhY2U8bit0K2U7KXt2YXIgaT10aGlzLmJiLmNhcGFjaXR5KCk7dGhpcy5iYj1yLkJ1aWxkZXIuZ3Jvd0J5dGVCdWZmZXIodGhpcy5iYiksdGhpcy5zcGFjZSs9dGhpcy5iYi5jYXBhY2l0eSgpLWl9dGhpcy5wYWQobil9LHIuQnVpbGRlci5wcm90b3R5cGUucGFkPWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT0wO2U8dDtlKyspdGhpcy5iYi53cml0ZUludDgoLS10aGlzLnNwYWNlLDApfSxyLkJ1aWxkZXIucHJvdG90eXBlLndyaXRlSW50OD1mdW5jdGlvbih0KXt0aGlzLmJiLndyaXRlSW50OCh0aGlzLnNwYWNlLT0xLHQpfSxyLkJ1aWxkZXIucHJvdG90eXBlLndyaXRlSW50MTY9ZnVuY3Rpb24odCl7dGhpcy5iYi53cml0ZUludDE2KHRoaXMuc3BhY2UtPTIsdCl9LHIuQnVpbGRlci5wcm90b3R5cGUud3JpdGVJbnQzMj1mdW5jdGlvbih0KXt0aGlzLmJiLndyaXRlSW50MzIodGhpcy5zcGFjZS09NCx0KX0sci5CdWlsZGVyLnByb3RvdHlwZS53cml0ZUludDY0PWZ1bmN0aW9uKHQpe3RoaXMuYmIud3JpdGVJbnQ2NCh0aGlzLnNwYWNlLT04LHQpfSxyLkJ1aWxkZXIucHJvdG90eXBlLndyaXRlRmxvYXQzMj1mdW5jdGlvbih0KXt0aGlzLmJiLndyaXRlRmxvYXQzMih0aGlzLnNwYWNlLT00LHQpfSxyLkJ1aWxkZXIucHJvdG90eXBlLndyaXRlRmxvYXQ2ND1mdW5jdGlvbih0KXt0aGlzLmJiLndyaXRlRmxvYXQ2NCh0aGlzLnNwYWNlLT04LHQpfSxyLkJ1aWxkZXIucHJvdG90eXBlLmFkZEludDg9ZnVuY3Rpb24odCl7dGhpcy5wcmVwKDEsMCksdGhpcy53cml0ZUludDgodCl9LHIuQnVpbGRlci5wcm90b3R5cGUuYWRkSW50MTY9ZnVuY3Rpb24odCl7dGhpcy5wcmVwKDIsMCksdGhpcy53cml0ZUludDE2KHQpfSxyLkJ1aWxkZXIucHJvdG90eXBlLmFkZEludDMyPWZ1bmN0aW9uKHQpe3RoaXMucHJlcCg0LDApLHRoaXMud3JpdGVJbnQzMih0KX0sci5CdWlsZGVyLnByb3RvdHlwZS5hZGRJbnQ2ND1mdW5jdGlvbih0KXt0aGlzLnByZXAoOCwwKSx0aGlzLndyaXRlSW50NjQodCl9LHIuQnVpbGRlci5wcm90b3R5cGUuYWRkRmxvYXQzMj1mdW5jdGlvbih0KXt0aGlzLnByZXAoNCwwKSx0aGlzLndyaXRlRmxvYXQzMih0KX0sci5CdWlsZGVyLnByb3RvdHlwZS5hZGRGbG9hdDY0PWZ1bmN0aW9uKHQpe3RoaXMucHJlcCg4LDApLHRoaXMud3JpdGVGbG9hdDY0KHQpfSxyLkJ1aWxkZXIucHJvdG90eXBlLmFkZEZpZWxkSW50OD1mdW5jdGlvbih0LGUsbil7KHRoaXMuZm9yY2VfZGVmYXVsdHN8fGUhPW4pJiYodGhpcy5hZGRJbnQ4KGUpLHRoaXMuc2xvdCh0KSl9LHIuQnVpbGRlci5wcm90b3R5cGUuYWRkRmllbGRJbnQxNj1mdW5jdGlvbih0LGUsbil7KHRoaXMuZm9yY2VfZGVmYXVsdHN8fGUhPW4pJiYodGhpcy5hZGRJbnQxNihlKSx0aGlzLnNsb3QodCkpfSxyLkJ1aWxkZXIucHJvdG90eXBlLmFkZEZpZWxkSW50MzI9ZnVuY3Rpb24odCxlLG4peyh0aGlzLmZvcmNlX2RlZmF1bHRzfHxlIT1uKSYmKHRoaXMuYWRkSW50MzIoZSksdGhpcy5zbG90KHQpKX0sci5CdWlsZGVyLnByb3RvdHlwZS5hZGRGaWVsZEludDY0PWZ1bmN0aW9uKHQsZSxuKXshdGhpcy5mb3JjZV9kZWZhdWx0cyYmZS5lcXVhbHMobil8fCh0aGlzLmFkZEludDY0KGUpLHRoaXMuc2xvdCh0KSl9LHIuQnVpbGRlci5wcm90b3R5cGUuYWRkRmllbGRGbG9hdDMyPWZ1bmN0aW9uKHQsZSxuKXsodGhpcy5mb3JjZV9kZWZhdWx0c3x8ZSE9bikmJih0aGlzLmFkZEZsb2F0MzIoZSksdGhpcy5zbG90KHQpKX0sci5CdWlsZGVyLnByb3RvdHlwZS5hZGRGaWVsZEZsb2F0NjQ9ZnVuY3Rpb24odCxlLG4peyh0aGlzLmZvcmNlX2RlZmF1bHRzfHxlIT1uKSYmKHRoaXMuYWRkRmxvYXQ2NChlKSx0aGlzLnNsb3QodCkpfSxyLkJ1aWxkZXIucHJvdG90eXBlLmFkZEZpZWxkT2Zmc2V0PWZ1bmN0aW9uKHQsZSxuKXsodGhpcy5mb3JjZV9kZWZhdWx0c3x8ZSE9bikmJih0aGlzLmFkZE9mZnNldChlKSx0aGlzLnNsb3QodCkpfSxyLkJ1aWxkZXIucHJvdG90eXBlLmFkZEZpZWxkU3RydWN0PWZ1bmN0aW9uKHQsZSxuKXtlIT1uJiYodGhpcy5uZXN0ZWQoZSksdGhpcy5zbG90KHQpKX0sci5CdWlsZGVyLnByb3RvdHlwZS5uZXN0ZWQ9ZnVuY3Rpb24odCl7aWYodCE9dGhpcy5vZmZzZXQoKSl0aHJvdyBuZXcgRXJyb3IoXCJGbGF0QnVmZmVyczogc3RydWN0IG11c3QgYmUgc2VyaWFsaXplZCBpbmxpbmUuXCIpfSxyLkJ1aWxkZXIucHJvdG90eXBlLm5vdE5lc3RlZD1mdW5jdGlvbigpe2lmKHRoaXMuaXNOZXN0ZWQpdGhyb3cgbmV3IEVycm9yKFwiRmxhdEJ1ZmZlcnM6IG9iamVjdCBzZXJpYWxpemF0aW9uIG11c3Qgbm90IGJlIG5lc3RlZC5cIil9LHIuQnVpbGRlci5wcm90b3R5cGUuc2xvdD1mdW5jdGlvbih0KXt0aGlzLnZ0YWJsZVt0XT10aGlzLm9mZnNldCgpfSxyLkJ1aWxkZXIucHJvdG90eXBlLm9mZnNldD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmJiLmNhcGFjaXR5KCktdGhpcy5zcGFjZX0sci5CdWlsZGVyLmdyb3dCeXRlQnVmZmVyPWZ1bmN0aW9uKHQpe3ZhciBlPXQuY2FwYWNpdHkoKTtpZigzMjIxMjI1NDcyJmUpdGhyb3cgbmV3IEVycm9yKFwiRmxhdEJ1ZmZlcnM6IGNhbm5vdCBncm93IGJ1ZmZlciBiZXlvbmQgMiBnaWdhYnl0ZXMuXCIpO3ZhciBuPWU8PDEsaT1yLkJ5dGVCdWZmZXIuYWxsb2NhdGUobik7cmV0dXJuIGkuc2V0UG9zaXRpb24obi1lKSxpLmJ5dGVzKCkuc2V0KHQuYnl0ZXMoKSxuLWUpLGl9LHIuQnVpbGRlci5wcm90b3R5cGUuYWRkT2Zmc2V0PWZ1bmN0aW9uKHQpe3RoaXMucHJlcChyLlNJWkVPRl9JTlQsMCksdGhpcy53cml0ZUludDMyKHRoaXMub2Zmc2V0KCktdCtyLlNJWkVPRl9JTlQpfSxyLkJ1aWxkZXIucHJvdG90eXBlLnN0YXJ0T2JqZWN0PWZ1bmN0aW9uKHQpe3RoaXMubm90TmVzdGVkKCksbnVsbD09dGhpcy52dGFibGUmJih0aGlzLnZ0YWJsZT1bXSksdGhpcy52dGFibGVfaW5fdXNlPXQ7Zm9yKHZhciBlPTA7ZTx0O2UrKyl0aGlzLnZ0YWJsZVtlXT0wO3RoaXMuaXNOZXN0ZWQ9ITAsdGhpcy5vYmplY3Rfc3RhcnQ9dGhpcy5vZmZzZXQoKX0sci5CdWlsZGVyLnByb3RvdHlwZS5lbmRPYmplY3Q9ZnVuY3Rpb24oKXtpZihudWxsPT10aGlzLnZ0YWJsZXx8IXRoaXMuaXNOZXN0ZWQpdGhyb3cgbmV3IEVycm9yKFwiRmxhdEJ1ZmZlcnM6IGVuZE9iamVjdCBjYWxsZWQgd2l0aG91dCBzdGFydE9iamVjdFwiKTt0aGlzLmFkZEludDMyKDApO2Zvcih2YXIgdD10aGlzLm9mZnNldCgpLGU9dGhpcy52dGFibGVfaW5fdXNlLTE7ZT49MCYmMD09dGhpcy52dGFibGVbZV07ZS0tKTtmb3IodmFyIG49ZSsxO2U+PTA7ZS0tKXRoaXMuYWRkSW50MTYoMCE9dGhpcy52dGFibGVbZV0/dC10aGlzLnZ0YWJsZVtlXTowKTt0aGlzLmFkZEludDE2KHQtdGhpcy5vYmplY3Rfc3RhcnQpO3ZhciBpPShuKzIpKnIuU0laRU9GX1NIT1JUO3RoaXMuYWRkSW50MTYoaSk7dmFyIG89MCxhPXRoaXMuc3BhY2U7dDpmb3IoZT0wO2U8dGhpcy52dGFibGVzLmxlbmd0aDtlKyspe3ZhciBzPXRoaXMuYmIuY2FwYWNpdHkoKS10aGlzLnZ0YWJsZXNbZV07aWYoaT09dGhpcy5iYi5yZWFkSW50MTYocykpe2Zvcih2YXIgdT1yLlNJWkVPRl9TSE9SVDt1PGk7dSs9ci5TSVpFT0ZfU0hPUlQpaWYodGhpcy5iYi5yZWFkSW50MTYoYSt1KSE9dGhpcy5iYi5yZWFkSW50MTYocyt1KSljb250aW51ZSB0O289dGhpcy52dGFibGVzW2VdO2JyZWFrfX1yZXR1cm4gbz8odGhpcy5zcGFjZT10aGlzLmJiLmNhcGFjaXR5KCktdCx0aGlzLmJiLndyaXRlSW50MzIodGhpcy5zcGFjZSxvLXQpKToodGhpcy52dGFibGVzLnB1c2godGhpcy5vZmZzZXQoKSksdGhpcy5iYi53cml0ZUludDMyKHRoaXMuYmIuY2FwYWNpdHkoKS10LHRoaXMub2Zmc2V0KCktdCkpLHRoaXMuaXNOZXN0ZWQ9ITEsdH0sci5CdWlsZGVyLnByb3RvdHlwZS5maW5pc2g9ZnVuY3Rpb24odCxlLG4pe3ZhciBpPW4/ci5TSVpFX1BSRUZJWF9MRU5HVEg6MDtpZihlKXt2YXIgbz1lO2lmKHRoaXMucHJlcCh0aGlzLm1pbmFsaWduLHIuU0laRU9GX0lOVCtyLkZJTEVfSURFTlRJRklFUl9MRU5HVEgraSksby5sZW5ndGghPXIuRklMRV9JREVOVElGSUVSX0xFTkdUSCl0aHJvdyBuZXcgRXJyb3IoXCJGbGF0QnVmZmVyczogZmlsZSBpZGVudGlmaWVyIG11c3QgYmUgbGVuZ3RoIFwiK3IuRklMRV9JREVOVElGSUVSX0xFTkdUSCk7Zm9yKHZhciBhPXIuRklMRV9JREVOVElGSUVSX0xFTkdUSC0xO2E+PTA7YS0tKXRoaXMud3JpdGVJbnQ4KG8uY2hhckNvZGVBdChhKSl9dGhpcy5wcmVwKHRoaXMubWluYWxpZ24sci5TSVpFT0ZfSU5UK2kpLHRoaXMuYWRkT2Zmc2V0KHQpLGkmJnRoaXMuYWRkSW50MzIodGhpcy5iYi5jYXBhY2l0eSgpLXRoaXMuc3BhY2UpLHRoaXMuYmIuc2V0UG9zaXRpb24odGhpcy5zcGFjZSl9LHIuQnVpbGRlci5wcm90b3R5cGUuZmluaXNoU2l6ZVByZWZpeGVkPWZ1bmN0aW9uKHQsZSl7dGhpcy5maW5pc2godCxlLCEwKX0sci5CdWlsZGVyLnByb3RvdHlwZS5yZXF1aXJlZEZpZWxkPWZ1bmN0aW9uKHQsZSl7dmFyIG49dGhpcy5iYi5jYXBhY2l0eSgpLXQscj1uLXRoaXMuYmIucmVhZEludDMyKG4pO2lmKDA9PXRoaXMuYmIucmVhZEludDE2KHIrZSkpdGhyb3cgbmV3IEVycm9yKFwiRmxhdEJ1ZmZlcnM6IGZpZWxkIFwiK2UrXCIgbXVzdCBiZSBzZXRcIil9LHIuQnVpbGRlci5wcm90b3R5cGUuc3RhcnRWZWN0b3I9ZnVuY3Rpb24odCxlLG4pe3RoaXMubm90TmVzdGVkKCksdGhpcy52ZWN0b3JfbnVtX2VsZW1zPWUsdGhpcy5wcmVwKHIuU0laRU9GX0lOVCx0KmUpLHRoaXMucHJlcChuLHQqZSl9LHIuQnVpbGRlci5wcm90b3R5cGUuZW5kVmVjdG9yPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMud3JpdGVJbnQzMih0aGlzLnZlY3Rvcl9udW1fZWxlbXMpLHRoaXMub2Zmc2V0KCl9LHIuQnVpbGRlci5wcm90b3R5cGUuY3JlYXRlU3RyaW5nPWZ1bmN0aW9uKHQpe2lmKHQgaW5zdGFuY2VvZiBVaW50OEFycmF5KXZhciBlPXQ7ZWxzZXtlPVtdO2Zvcih2YXIgbj0wO248dC5sZW5ndGg7KXt2YXIgcixpPXQuY2hhckNvZGVBdChuKyspOyhyPWk8NTUyOTZ8fGk+PTU2MzIwP2k6KGk8PDEwKSt0LmNoYXJDb2RlQXQobisrKSstNTY2MTM4ODgpPDEyOD9lLnB1c2gocik6KHI8MjA0OD9lLnB1c2gocj4+NiYzMXwxOTIpOihyPDY1NTM2P2UucHVzaChyPj4xMiYxNXwyMjQpOmUucHVzaChyPj4xOCY3fDI0MCxyPj4xMiY2M3wxMjgpLGUucHVzaChyPj42JjYzfDEyOCkpLGUucHVzaCg2MyZyfDEyOCkpfX10aGlzLmFkZEludDgoMCksdGhpcy5zdGFydFZlY3RvcigxLGUubGVuZ3RoLDEpLHRoaXMuYmIuc2V0UG9zaXRpb24odGhpcy5zcGFjZS09ZS5sZW5ndGgpLG49MDtmb3IodmFyIG89dGhpcy5zcGFjZSxhPXRoaXMuYmIuYnl0ZXMoKTtuPGUubGVuZ3RoO24rKylhW28rK109ZVtuXTtyZXR1cm4gdGhpcy5lbmRWZWN0b3IoKX0sci5CdWlsZGVyLnByb3RvdHlwZS5jcmVhdGVMb25nPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHIuTG9uZy5jcmVhdGUodCxlKX0sci5CeXRlQnVmZmVyPWZ1bmN0aW9uKHQpe3RoaXMuYnl0ZXNfPXQsdGhpcy5wb3NpdGlvbl89MH0sci5CeXRlQnVmZmVyLmFsbG9jYXRlPWZ1bmN0aW9uKHQpe3JldHVybiBuZXcgci5CeXRlQnVmZmVyKG5ldyBVaW50OEFycmF5KHQpKX0sci5CeXRlQnVmZmVyLnByb3RvdHlwZS5jbGVhcj1mdW5jdGlvbigpe3RoaXMucG9zaXRpb25fPTB9LHIuQnl0ZUJ1ZmZlci5wcm90b3R5cGUuYnl0ZXM9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5ieXRlc199LHIuQnl0ZUJ1ZmZlci5wcm90b3R5cGUucG9zaXRpb249ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wb3NpdGlvbl99LHIuQnl0ZUJ1ZmZlci5wcm90b3R5cGUuc2V0UG9zaXRpb249ZnVuY3Rpb24odCl7dGhpcy5wb3NpdGlvbl89dH0sci5CeXRlQnVmZmVyLnByb3RvdHlwZS5jYXBhY2l0eT1mdW5jdGlvbigpe3JldHVybiB0aGlzLmJ5dGVzXy5sZW5ndGh9LHIuQnl0ZUJ1ZmZlci5wcm90b3R5cGUucmVhZEludDg9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMucmVhZFVpbnQ4KHQpPDwyND4+MjR9LHIuQnl0ZUJ1ZmZlci5wcm90b3R5cGUucmVhZFVpbnQ4PWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmJ5dGVzX1t0XX0sci5CeXRlQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTY9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMucmVhZFVpbnQxNih0KTw8MTY+PjE2fSxyLkJ5dGVCdWZmZXIucHJvdG90eXBlLnJlYWRVaW50MTY9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuYnl0ZXNfW3RdfHRoaXMuYnl0ZXNfW3QrMV08PDh9LHIuQnl0ZUJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmJ5dGVzX1t0XXx0aGlzLmJ5dGVzX1t0KzFdPDw4fHRoaXMuYnl0ZXNfW3QrMl08PDE2fHRoaXMuYnl0ZXNfW3QrM108PDI0fSxyLkJ5dGVCdWZmZXIucHJvdG90eXBlLnJlYWRVaW50MzI9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMucmVhZEludDMyKHQpPj4+MH0sci5CeXRlQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50NjQ9ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyByLkxvbmcodGhpcy5yZWFkSW50MzIodCksdGhpcy5yZWFkSW50MzIodCs0KSl9LHIuQnl0ZUJ1ZmZlci5wcm90b3R5cGUucmVhZFVpbnQ2ND1mdW5jdGlvbih0KXtyZXR1cm4gbmV3IHIuTG9uZyh0aGlzLnJlYWRVaW50MzIodCksdGhpcy5yZWFkVWludDMyKHQrNCkpfSxyLkJ5dGVCdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdDMyPWZ1bmN0aW9uKHQpe3JldHVybiByLmludDMyWzBdPXRoaXMucmVhZEludDMyKHQpLHIuZmxvYXQzMlswXX0sci5CeXRlQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXQ2ND1mdW5jdGlvbih0KXtyZXR1cm4gci5pbnQzMltyLmlzTGl0dGxlRW5kaWFuPzA6MV09dGhpcy5yZWFkSW50MzIodCksci5pbnQzMltyLmlzTGl0dGxlRW5kaWFuPzE6MF09dGhpcy5yZWFkSW50MzIodCs0KSxyLmZsb2F0NjRbMF19LHIuQnl0ZUJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4PWZ1bmN0aW9uKHQsZSl7dGhpcy5ieXRlc19bdF09ZX0sci5CeXRlQnVmZmVyLnByb3RvdHlwZS53cml0ZVVpbnQ4PWZ1bmN0aW9uKHQsZSl7dGhpcy5ieXRlc19bdF09ZX0sci5CeXRlQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2PWZ1bmN0aW9uKHQsZSl7dGhpcy5ieXRlc19bdF09ZSx0aGlzLmJ5dGVzX1t0KzFdPWU+Pjh9LHIuQnl0ZUJ1ZmZlci5wcm90b3R5cGUud3JpdGVVaW50MTY9ZnVuY3Rpb24odCxlKXt0aGlzLmJ5dGVzX1t0XT1lLHRoaXMuYnl0ZXNfW3QrMV09ZT4+OH0sci5CeXRlQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyPWZ1bmN0aW9uKHQsZSl7dGhpcy5ieXRlc19bdF09ZSx0aGlzLmJ5dGVzX1t0KzFdPWU+PjgsdGhpcy5ieXRlc19bdCsyXT1lPj4xNix0aGlzLmJ5dGVzX1t0KzNdPWU+PjI0fSxyLkJ5dGVCdWZmZXIucHJvdG90eXBlLndyaXRlVWludDMyPWZ1bmN0aW9uKHQsZSl7dGhpcy5ieXRlc19bdF09ZSx0aGlzLmJ5dGVzX1t0KzFdPWU+PjgsdGhpcy5ieXRlc19bdCsyXT1lPj4xNix0aGlzLmJ5dGVzX1t0KzNdPWU+PjI0fSxyLkJ5dGVCdWZmZXIucHJvdG90eXBlLndyaXRlSW50NjQ9ZnVuY3Rpb24odCxlKXt0aGlzLndyaXRlSW50MzIodCxlLmxvdyksdGhpcy53cml0ZUludDMyKHQrNCxlLmhpZ2gpfSxyLkJ5dGVCdWZmZXIucHJvdG90eXBlLndyaXRlVWludDY0PWZ1bmN0aW9uKHQsZSl7dGhpcy53cml0ZVVpbnQzMih0LGUubG93KSx0aGlzLndyaXRlVWludDMyKHQrNCxlLmhpZ2gpfSxyLkJ5dGVCdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXQzMj1mdW5jdGlvbih0LGUpe3IuZmxvYXQzMlswXT1lLHRoaXMud3JpdGVJbnQzMih0LHIuaW50MzJbMF0pfSxyLkJ5dGVCdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXQ2ND1mdW5jdGlvbih0LGUpe3IuZmxvYXQ2NFswXT1lLHRoaXMud3JpdGVJbnQzMih0LHIuaW50MzJbci5pc0xpdHRsZUVuZGlhbj8wOjFdKSx0aGlzLndyaXRlSW50MzIodCs0LHIuaW50MzJbci5pc0xpdHRsZUVuZGlhbj8xOjBdKX0sci5CeXRlQnVmZmVyLnByb3RvdHlwZS5nZXRCdWZmZXJJZGVudGlmaWVyPWZ1bmN0aW9uKCl7aWYodGhpcy5ieXRlc18ubGVuZ3RoPHRoaXMucG9zaXRpb25fK3IuU0laRU9GX0lOVCtyLkZJTEVfSURFTlRJRklFUl9MRU5HVEgpdGhyb3cgbmV3IEVycm9yKFwiRmxhdEJ1ZmZlcnM6IEJ5dGVCdWZmZXIgaXMgdG9vIHNob3J0IHRvIGNvbnRhaW4gYW4gaWRlbnRpZmllci5cIik7Zm9yKHZhciB0PVwiXCIsZT0wO2U8ci5GSUxFX0lERU5USUZJRVJfTEVOR1RIO2UrKyl0Kz1TdHJpbmcuZnJvbUNoYXJDb2RlKHRoaXMucmVhZEludDgodGhpcy5wb3NpdGlvbl8rci5TSVpFT0ZfSU5UK2UpKTtyZXR1cm4gdH0sci5CeXRlQnVmZmVyLnByb3RvdHlwZS5fX29mZnNldD1mdW5jdGlvbih0LGUpe3ZhciBuPXQtdGhpcy5yZWFkSW50MzIodCk7cmV0dXJuIGU8dGhpcy5yZWFkSW50MTYobik/dGhpcy5yZWFkSW50MTYobitlKTowfSxyLkJ5dGVCdWZmZXIucHJvdG90eXBlLl9fdW5pb249ZnVuY3Rpb24odCxlKXtyZXR1cm4gdC5iYl9wb3M9ZSt0aGlzLnJlYWRJbnQzMihlKSx0LmJiPXRoaXMsdH0sci5CeXRlQnVmZmVyLnByb3RvdHlwZS5fX3N0cmluZz1mdW5jdGlvbih0LGUpe3QrPXRoaXMucmVhZEludDMyKHQpO3ZhciBuPXRoaXMucmVhZEludDMyKHQpLGk9XCJcIixvPTA7aWYodCs9ci5TSVpFT0ZfSU5ULGU9PT1yLkVuY29kaW5nLlVURjhfQllURVMpcmV0dXJuIHRoaXMuYnl0ZXNfLnN1YmFycmF5KHQsdCtuKTtmb3IoO288bjspe3ZhciBhLHM9dGhpcy5yZWFkVWludDgodCtvKyspO2lmKHM8MTkyKWE9cztlbHNle3ZhciB1PXRoaXMucmVhZFVpbnQ4KHQrbysrKTtpZihzPDIyNClhPSgzMSZzKTw8Nnw2MyZ1O2Vsc2V7dmFyIGM9dGhpcy5yZWFkVWludDgodCtvKyspO2E9czwyNDA/KDE1JnMpPDwxMnwoNjMmdSk8PDZ8NjMmYzooNyZzKTw8MTh8KDYzJnUpPDwxMnwoNjMmYyk8PDZ8NjMmdGhpcy5yZWFkVWludDgodCtvKyspfX1hPDY1NTM2P2krPVN0cmluZy5mcm9tQ2hhckNvZGUoYSk6KGEtPTY1NTM2LGkrPVN0cmluZy5mcm9tQ2hhckNvZGUoNTUyOTYrKGE+PjEwKSw1NjMyMCsoMTAyMyZhKSkpfXJldHVybiBpfSxyLkJ5dGVCdWZmZXIucHJvdG90eXBlLl9faW5kaXJlY3Q9ZnVuY3Rpb24odCl7cmV0dXJuIHQrdGhpcy5yZWFkSW50MzIodCl9LHIuQnl0ZUJ1ZmZlci5wcm90b3R5cGUuX192ZWN0b3I9ZnVuY3Rpb24odCl7cmV0dXJuIHQrdGhpcy5yZWFkSW50MzIodCkrci5TSVpFT0ZfSU5UfSxyLkJ5dGVCdWZmZXIucHJvdG90eXBlLl9fdmVjdG9yX2xlbj1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5yZWFkSW50MzIodCt0aGlzLnJlYWRJbnQzMih0KSl9LHIuQnl0ZUJ1ZmZlci5wcm90b3R5cGUuX19oYXNfaWRlbnRpZmllcj1mdW5jdGlvbih0KXtpZih0Lmxlbmd0aCE9ci5GSUxFX0lERU5USUZJRVJfTEVOR1RIKXRocm93IG5ldyBFcnJvcihcIkZsYXRCdWZmZXJzOiBmaWxlIGlkZW50aWZpZXIgbXVzdCBiZSBsZW5ndGggXCIrci5GSUxFX0lERU5USUZJRVJfTEVOR1RIKTtmb3IodmFyIGU9MDtlPHIuRklMRV9JREVOVElGSUVSX0xFTkdUSDtlKyspaWYodC5jaGFyQ29kZUF0KGUpIT10aGlzLnJlYWRJbnQ4KHRoaXMucG9zaXRpb25fK3IuU0laRU9GX0lOVCtlKSlyZXR1cm4hMTtyZXR1cm4hMH0sci5CeXRlQnVmZmVyLnByb3RvdHlwZS5jcmVhdGVMb25nPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHIuTG9uZy5jcmVhdGUodCxlKX19fSxfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX189e307ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyh0KXt2YXIgZT1fX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bdF07aWYodm9pZCAwIT09ZSlyZXR1cm4gZS5leHBvcnRzO3ZhciBuPV9fd2VicGFja19tb2R1bGVfY2FjaGVfX1t0XT17ZXhwb3J0czp7fX07cmV0dXJuIF9fd2VicGFja19tb2R1bGVzX19bdF0uY2FsbChuLmV4cG9ydHMsbixuLmV4cG9ydHMsX193ZWJwYWNrX3JlcXVpcmVfXyksbi5leHBvcnRzfV9fd2VicGFja19yZXF1aXJlX18ubj10PT57dmFyIGU9dCYmdC5fX2VzTW9kdWxlPygpPT50LmRlZmF1bHQ6KCk9PnQ7cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18uZChlLHthOmV9KSxlfSxfX3dlYnBhY2tfcmVxdWlyZV9fLmQ9KHQsZSk9Pntmb3IodmFyIG4gaW4gZSlfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZSxuKSYmIV9fd2VicGFja19yZXF1aXJlX18ubyh0LG4pJiZPYmplY3QuZGVmaW5lUHJvcGVydHkodCxuLHtlbnVtZXJhYmxlOiEwLGdldDplW25dfSl9LF9fd2VicGFja19yZXF1aXJlX18ubz0odCxlKT0+T2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQsZSksX193ZWJwYWNrX3JlcXVpcmVfXy5yPXQ9PntcInVuZGVmaW5lZFwiIT10eXBlb2YgU3ltYm9sJiZTeW1ib2wudG9TdHJpbmdUYWcmJk9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFN5bWJvbC50b1N0cmluZ1RhZyx7dmFsdWU6XCJNb2R1bGVcIn0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pfTt2YXIgX193ZWJwYWNrX2V4cG9ydHNfXz1fX3dlYnBhY2tfcmVxdWlyZV9fKDYwMTgpLF9fd2VicGFja19leHBvcnRfdGFyZ2V0X189ZXhwb3J0cztmb3IodmFyIGkgaW4gX193ZWJwYWNrX2V4cG9ydHNfXylfX3dlYnBhY2tfZXhwb3J0X3RhcmdldF9fW2ldPV9fd2VicGFja19leHBvcnRzX19baV07X193ZWJwYWNrX2V4cG9ydHNfXy5fX2VzTW9kdWxlJiZPYmplY3QuZGVmaW5lUHJvcGVydHkoX193ZWJwYWNrX2V4cG9ydF90YXJnZXRfXyxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KX0pKCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1vcnQtd2ViLm5vZGUuanMubWFwIl0sIm5hbWVzIjpbIl9fd2VicGFja19tb2R1bGVzX18iLCJ0IiwiZSIsIm4iLCJfc2NyaXB0RGlyIiwiciIsImRvY3VtZW50IiwiY3VycmVudFNjcmlwdCIsInNyYyIsIl9fZmlsZW5hbWUiLCIkIiwiYnVmZmVyIiwiQyIsIkgiLCJGIiwiTiIsImkiLCJSIiwibyIsIkwiLCJhIiwiTSIsInMiLCJ1IiwiYyIsInJlYWR5IiwiUHJvbWlzZSIsImwiLCJwIiwiZiIsImQiLCJoIiwiZyIsImIiLCJPYmplY3QiLCJhc3NpZ24iLCJtIiwieSIsIl8iLCJ2IiwiaW1wb3J0U2NyaXB0cyIsInciLCJwcm9jZXNzIiwidmVyc2lvbnMiLCJub2RlIiwieCIsIkVOVklST05NRU5UX0lTX1BUSFJFQUQiLCJUIiwiUyIsImxvY2F0ZUZpbGUiLCJkaXJuYW1lIiwiX19kaXJuYW1lIiwibm9ybWFsaXplIiwicmVhZEZpbGVTeW5jIiwiVWludDhBcnJheSIsInJlYWRGaWxlIiwiYXJndiIsImxlbmd0aCIsInJlcGxhY2UiLCJzbGljZSIsIm9uIiwidXQiLCJKIiwiZXhpdENvZGUiLCJQIiwiZXhpdCIsImluc3BlY3QiLCJjb25zb2xlIiwiZXJyb3IiLCJnbG9iYWwiLCJXb3JrZXIiLCJzZWxmIiwibG9jYXRpb24iLCJocmVmIiwiaW5kZXhPZiIsInN1YnN0ciIsImxhc3RJbmRleE9mIiwiWE1MSHR0cFJlcXVlc3QiLCJvcGVuIiwic2VuZCIsInJlc3BvbnNlVGV4dCIsInJlc3BvbnNlVHlwZSIsInJlc3BvbnNlIiwib25sb2FkIiwic3RhdHVzIiwib25lcnJvciIsInBlcmZvcm1hbmNlIiwiTyIsImxvZyIsImJpbmQiLCJBIiwid2FybiIsIndyaXRlU3luYyIsIkUiLCJJIiwicHJpbnQiLCJwcmludEVyciIsInRoaXNQcm9ncmFtIiwicXVpdCIsIndhc21CaW5hcnkiLCJEIiwibm9FeGl0UnVudGltZSIsIldlYkFzc2VtYmx5IiwiaXQiLCJrIiwiaiIsIlUiLCJUZXh0RGVjb2RlciIsIlYiLCJkZWNvZGUiLCJTaGFyZWRBcnJheUJ1ZmZlciIsInN1YmFycmF5IiwiU3RyaW5nIiwiZnJvbUNoYXJDb2RlIiwiQiIsInoiLCJjaGFyQ29kZUF0IiwiRyIsIkhFQVA4IiwiSW50OEFycmF5IiwiSEVBUDE2IiwiSW50MTZBcnJheSIsIkhFQVAzMiIsIkludDMyQXJyYXkiLCJIRUFQVTgiLCJIRUFQVTE2IiwiVWludDE2QXJyYXkiLCJIRUFQVTMyIiwiVWludDMyQXJyYXkiLCJIRUFQRjMyIiwiRmxvYXQzMkFycmF5IiwiSEVBUEY2NCIsIkZsb2F0NjRBcnJheSIsInEiLCJJTklUSUFMX01FTU9SWSIsIndhc21NZW1vcnkiLCJNZW1vcnkiLCJpbml0aWFsIiwibWF4aW11bSIsInNoYXJlZCIsIkVycm9yIiwiYnl0ZUxlbmd0aCIsIlciLCJYIiwiWSIsIksiLCJaIiwiUSIsInByZVJ1biIsInNoaWZ0IiwidW5zaGlmdCIsInR0IiwiZXQiLCJudCIsInJ0IiwicG9zdE1lc3NhZ2UiLCJjbWQiLCJhcmciLCJvbkFib3J0IiwiUnVudGltZUVycm9yIiwib3QiLCJzdGFydHNXaXRoIiwiYXQiLCJzdCIsIm5hbWUiLCJtZXNzYWdlIiwiY3QiLCJkdCIsIlZiIiwibWMiLCJsdCIsIkNjIiwiYWMiLCJwdXNoIiwiVWIiLCJzdGFydF9yb3V0aW5lIiwiSWMiLCJ6YyIsInB0aHJlYWRfcHRyIiwiJGIiLCJ0aW1lIiwibm93IiwiTmMiLCJsb2FkZWQiLCJwdCIsIld0Iiwib2MiLCJvbkV4aXQiLCJmdCIsImJ0IiwibWUiLCJodCIsImJlIiwicmUiLCJpZSIsIlliIiwicWMiLCJmYyIsIkVjIiwiUGMiLCJyZWNlaXZlT2JqZWN0VHJhbnNmZXIiLCJHYyIsInRocmVhZEluaXRUTFMiLCJwYyIsInNldEV4aXRTdGF0dXMiLCJuYyIsInZhbHVlcyIsInRlcm1pbmF0ZSIsInNwbGljZSIsInhlIiwiZm9yRWFjaCIsIkZjIiwib25tZXNzYWdlIiwiZGF0YSIsIkJjIiwidGFyZ2V0VGhyZWFkIiwiZGUiLCJRYyIsInRyYW5zZmVyTGlzdCIsIlZ0IiwicXVldWUiLCJ0aHJlYWQiLCJ0aHJlYWRJZCIsInRleHQiLCJhbGVydCIsInRhcmdldCIsImZpbGVuYW1lIiwibGluZW5vIiwidXJsT3JCbG9iIiwibWFpblNjcmlwdFVybE9yQmxvYiIsIndhc21Nb2R1bGUiLCJ5YyIsInBvcCIsImd0IiwiQWUiLCJFZSIsIlBUaHJlYWQiLCJlc3RhYmxpc2hTdGFja1NwYWNlIiwiT2UiLCJtdCIsInl0IiwiZ2V0IiwiaW52b2tlRW50cnlQb2ludCIsIlRlIiwiX3QiLCJ2dCIsInd0IiwieHQiLCJUdCIsIlN0IiwiWmIiLCJTYiIsInhjIiwiYmMiLCJ3YyIsIkRjIiwicmMiLCJoYyIsInVjIiwiaWMiLCJrYyIsImNjIiwic2MiLCJBdG9taWNzIiwiYWRkIiwiSGMiLCJzdWIiLCJ0YyIsInZjIiwiRGUiLCJPdCIsImdlIiwiQXQiLCJFdCIsIk9jIiwiSXQiLCJQdCIsIkR0IiwiJHQiLCJrdCIsIkN0IiwiRnQiLCJOdCIsIlJ0IiwiTHQiLCJNdCIsImp0IiwiVXQiLCJzdG9yZSIsIndlIiwiY29tcGFyZUV4Y2hhbmdlIiwiQnQiLCJ6dCIsIkd0IiwiSHQiLCJoZSIsInF0IiwidG9UaW1lU3RyaW5nIiwibWF0Y2giLCJEYXRlIiwiZ2V0RnVsbFllYXIiLCJnZXRUaW1lem9uZU9mZnNldCIsIk1hdGgiLCJtYXgiLCJOdW1iZXIiLCJhcmd1bWVudHMiLCJJZSIsInZlIiwiZXhlY3V0ZU5vdGlmaWVkUHJveHlpbmdRdWV1ZSIsImhydGltZSIsIl9fcGVyZm9ybWFuY2Vfbm93X2Nsb2NrX2RyaWZ0IiwiWHQiLCJZdCIsIkt0IiwiWnQiLCJVU0VSIiwiTE9HTkFNRSIsIlBBVEgiLCJQV0QiLCJIT01FIiwiTEFORyIsIm5hdmlnYXRvciIsImxhbmd1YWdlcyIsIkp0IiwiUXQiLCJ0ZSIsImVlIiwibmUiLCJvZSIsImFlIiwic2UiLCJ1ZSIsImNlIiwibGUiLCJ0b1N0cmluZyIsImdldE1vbnRoIiwiZ2V0RGF0ZSIsImdldERheSIsIldiIiwiWGIiLCJnZXRUaW1lIiwic2V0RGF0ZSIsInNldE1vbnRoIiwic2V0RnVsbFllYXIiLCJMYyIsIktjIiwiZGMiLCJqYyIsImVjIiwiVGIiLCJSYyIsIkpjIiwiTWMiLCJSZWdFeHAiLCJzcGxpdCIsInN1YnN0cmluZyIsImZsb29yIiwiYWJzIiwiaW5jbHVkZXMiLCJBcnJheSIsInNldCIsInBlIiwiZmUiLCJtYSIsIlNlIiwicHJvdG90eXBlIiwiY2FsbCIsIlBlIiwicGEiLCJGYSIsInllIiwieGEiLCJNYSIsInVhIiwid2EiLCJvYSIsIkthIiwiQ2EiLCJKYSIsInZhIiwic2EiLCJMYSIsInRhIiwiVGEiLCJVYSIsInlhIiwiT2EiLCJ6YSIsInNldFRpbWVvdXQiLCJFYSIsIlBhIiwiZ2V0VVRDU2Vjb25kcyIsImdldFVUQ01pbnV0ZXMiLCJnZXRVVENIb3VycyIsImdldFVUQ0RhdGUiLCJnZXRVVENNb250aCIsImdldFVUQ0Z1bGxZZWFyIiwiZ2V0VVRDRGF5IiwiVVRDIiwiUWEiLCJnZXRTZWNvbmRzIiwiZ2V0TWludXRlcyIsImdldEhvdXJzIiwibWluIiwiUmEiLCJzZXRUaW1lIiwiQWEiLCJCYSIsIlNhIiwiQWMiLCJyYSIsIklhIiwiY29weVdpdGhpbiIsImNwdXMiLCJoYXJkd2FyZUNvbmN1cnJlbmN5IiwiRGEiLCJhcHBseSIsInFhIiwiZ3JvdyIsIk5hIiwiR2EiLCJIYSIsImdhIiwibmEiLCJsYyIsImNyeXB0byIsImdldFJhbmRvbVZhbHVlcyIsInJhbmRvbUJ5dGVzIiwiaWEiLCJqYSIsImFhIiwiamUiLCJrZSIsIlVlIiwiY2EiLCJMZSIsIiRlIiwiYmEiLCJNZSIsIkNlIiwiaGEiLCJrYSIsImZhIiwiRmUiLCJkYSIsIlJlIiwiZWEiLCJOZSIsImxhIiwiYXNtIiwiZXhwb3J0cyIsInNiIiwidWIiLCJWYSIsIm1vbml0b3JSdW5EZXBlbmRlbmNpZXMiLCJjbGVhckludGVydmFsIiwiaW5zdGFuY2UiLCJtb2R1bGUiLCJmZXRjaCIsImNyZWRlbnRpYWxzIiwidGhlbiIsIm9rIiwiYXJyYXlCdWZmZXIiLCJjYXRjaCIsInJlc29sdmUiLCJpbnN0YW50aWF0ZSIsImluc3RhbnRpYXRlV2FzbSIsImluc3RhbnRpYXRlU3RyZWFtaW5nIiwiX19fd2FzbV9jYWxsX2N0b3JzIiwiX09ydEluaXQiLCJXYSIsIl9PcnRDcmVhdGVTZXNzaW9uT3B0aW9ucyIsIlhhIiwiX09ydEFwcGVuZEV4ZWN1dGlvblByb3ZpZGVyIiwiWWEiLCJfT3J0QWRkU2Vzc2lvbkNvbmZpZ0VudHJ5IiwiWmEiLCJfT3J0UmVsZWFzZVNlc3Npb25PcHRpb25zIiwiX2EiLCJfT3J0Q3JlYXRlU2Vzc2lvbiIsIiRhIiwiX09ydFJlbGVhc2VTZXNzaW9uIiwiYWIiLCJfT3J0R2V0SW5wdXRDb3VudCIsImJiIiwiX09ydEdldE91dHB1dENvdW50IiwiY2IiLCJfT3J0R2V0SW5wdXROYW1lIiwiZGIiLCJfT3J0R2V0T3V0cHV0TmFtZSIsImViIiwiX09ydEZyZWUiLCJmYiIsIl9PcnRDcmVhdGVUZW5zb3IiLCJnYiIsIl9PcnRHZXRUZW5zb3JEYXRhIiwiaGIiLCJfT3J0UmVsZWFzZVRlbnNvciIsImliIiwiX09ydENyZWF0ZVJ1bk9wdGlvbnMiLCJqYiIsIl9PcnRBZGRSdW5Db25maWdFbnRyeSIsImtiIiwiX09ydFJlbGVhc2VSdW5PcHRpb25zIiwibGIiLCJfT3J0UnVuIiwibWIiLCJfT3J0RW5kUHJvZmlsaW5nIiwibmIiLCJfcHRocmVhZF9zZWxmIiwib2IiLCJfbWFsbG9jIiwicGIiLCJfZnJlZSIsInFiIiwiX2ZmbHVzaCIsInJiIiwiX19lbXNjcmlwdGVuX3Rsc19pbml0IiwiX19fZnVuY3Nfb25fZXhpdCIsInRiIiwiX19lbXNjcmlwdGVuX3RocmVhZF9pbml0IiwidmIiLCJfX2Vtc2NyaXB0ZW5fdGhyZWFkX2NyYXNoZWQiLCJ3YiIsIl9lIiwiX2Vtc2NyaXB0ZW5fcnVuX2luX21haW5fcnVudGltZV90aHJlYWRfanMiLCJ4YiIsIl9fZW1zY3JpcHRlbl9wcm94eV9leGVjdXRlX3Rhc2tfcXVldWUiLCJ5YiIsIl9fZW1zY3JpcHRlbl90aHJlYWRfZnJlZV9kYXRhIiwiemIiLCJfX2Vtc2NyaXB0ZW5fdGhyZWFkX2V4aXQiLCJBYiIsIl9zZXRUaHJldyIsIkJiIiwiX2Vtc2NyaXB0ZW5fc3RhY2tfc2V0X2xpbWl0cyIsIkNiIiwic3RhY2tTYXZlIiwiRGIiLCJzdGFja1Jlc3RvcmUiLCJFYiIsInN0YWNrQWxsb2MiLCJGYiIsIl9fX2N4YV9jYW5fY2F0Y2giLCJHYiIsIl9fX2N4YV9pc19wb2ludGVyX3R5cGUiLCJIYiIsImR5bkNhbGxfaiIsIkliIiwiZHluQ2FsbF9paWlpaWoiLCJKYiIsImR5bkNhbGxfamlpIiwiS2IiLCJkeW5DYWxsX3ZpaWlpaWoiLCJMYiIsImR5bkNhbGxfdmpqaSIsIk1iIiwiZHluQ2FsbF92aWlpampqaWkiLCJOYiIsImR5bkNhbGxfaWlqIiwiT2IiLCJkeW5DYWxsX2ppIiwiUGIiLCJkeW5DYWxsX2lpaWlpaWoiLCJRYiIsImR5bkNhbGxfaWlpaiIsIlJiIiwiVmUiLCJjYWxsZWRSdW4iLCJvblJ1bnRpbWVJbml0aWFsaXplZCIsInBvc3RSdW4iLCJzZXRTdGF0dXMiLCJVVEY4VG9TdHJpbmciLCJzdHJpbmdUb1VURjgiLCJsZW5ndGhCeXRlc1VURjgiLCJrZWVwUnVudGltZUFsaXZlIiwiRXhpdFN0YXR1cyIsInByZUluaXQiLCJjaGFyQXQiLCJjZWlsIiwiZW5jb2RlIiwiam9pbiIsInRlc3QiLCJfbGlzdGVuZXJzIiwiZm4iLCJjdHgiLCJvZmYiLCJlbWl0Iiwid3JpdGVGbG9hdExFIiwid3JpdGVGbG9hdEJFIiwicmVhZEZsb2F0TEUiLCJyZWFkRmxvYXRCRSIsImlzTmFOIiwicm91bmQiLCJMTjIiLCJwb3ciLCJOYU4iLCJ3cml0ZURvdWJsZUxFIiwid3JpdGVEb3VibGVCRSIsInJlYWREb3VibGVMRSIsInJlYWREb3VibGVCRSIsImlucXVpcmUiLCJtb2R1bGVOYW1lIiwibW9kIiwiZXZhbCIsImtleXMiLCJyZWFkIiwid3JpdGUiLCJfX2VzTW9kdWxlIiwiVHlwZUVycm9yIiwidmFsdWUiLCJFTVBUWSIsImlzR3VpZCIsInZhbGlkYXRvciIsImNyZWF0ZSIsImdlbiIsImNyZWF0ZUVtcHR5IiwicGFyc2UiLCJyYXciLCJyYW5kb20iLCJlcXVhbHMiLCJpc0VtcHR5IiwidG9KU09OIiwiR3VpZCIsIkluc3RhbmNlIiwiTW9kdWxlIiwibG93IiwiaGlnaCIsInVuc2lnbmVkIiwiX19pc0xvbmdfXyIsImRlZmluZVByb3BlcnR5IiwiaXNMb25nIiwibmVnIiwiZnJvbUludCIsImZyb21OdW1iZXIiLCJmcm9tQml0cyIsIlJhbmdlRXJyb3IiLCJwYXJzZUludCIsIm11bCIsImZyb21TdHJpbmciLCJmcm9tVmFsdWUiLCJaRVJPIiwiVVpFUk8iLCJPTkUiLCJVT05FIiwiTkVHX09ORSIsIk1BWF9WQUxVRSIsIk1BWF9VTlNJR05FRF9WQUxVRSIsIk1JTl9WQUxVRSIsInRvSW50IiwidG9OdW1iZXIiLCJpc1plcm8iLCJpc05lZ2F0aXZlIiwiZXEiLCJkaXYiLCJnZXRIaWdoQml0cyIsImdldEhpZ2hCaXRzVW5zaWduZWQiLCJnZXRMb3dCaXRzIiwiZ2V0TG93Qml0c1Vuc2lnbmVkIiwiZ2V0TnVtQml0c0FicyIsImVxeiIsImlzUG9zaXRpdmUiLCJpc09kZCIsImlzRXZlbiIsIm5vdEVxdWFscyIsIm5lcSIsImxlc3NUaGFuIiwiY29tcCIsImxlc3NUaGFuT3JFcXVhbCIsImx0ZSIsImdyZWF0ZXJUaGFuIiwiZ3JlYXRlclRoYW5PckVxdWFsIiwiZ3RlIiwiY29tcGFyZSIsIm5lZ2F0ZSIsIm5vdCIsInN1YnRyYWN0IiwibXVsdGlwbHkiLCJnZXRfaGlnaCIsImRpdmlkZSIsImRpdl91IiwiZGl2X3MiLCJ0b1Vuc2lnbmVkIiwic2hydSIsInNociIsInNobCIsIm1vZHVsbyIsInJlbV91IiwicmVtX3MiLCJyZW0iLCJhbmQiLCJvciIsInhvciIsInNoaWZ0TGVmdCIsInNoaWZ0UmlnaHQiLCJzaGlmdFJpZ2h0VW5zaWduZWQiLCJzaHJfdSIsInRvU2lnbmVkIiwidG9CeXRlcyIsInRvQnl0ZXNMRSIsInRvQnl0ZXNCRSIsImZyb21CeXRlcyIsImZyb21CeXRlc0xFIiwiZnJvbUJ5dGVzQkUiLCJSZWFkZXIiLCJXcml0ZXIiLCJ1dGlsIiwicm9vdHMiLCJkZWZhdWx0Iiwib25ueCIsIlZlcnNpb24iLCJBdHRyaWJ1dGVQcm90byIsImZsb2F0cyIsImludHMiLCJzdHJpbmdzIiwidGVuc29ycyIsImdyYXBocyIsInJlZkF0dHJOYW1lIiwiZG9jU3RyaW5nIiwidHlwZSIsIkxvbmciLCJuZXdCdWZmZXIiLCJlbXB0eUFycmF5IiwiaGFzT3duUHJvcGVydHkiLCJ1aW50MzIiLCJzdHJpbmciLCJmbG9hdCIsImludDY0IiwiYnl0ZXMiLCJUZW5zb3JQcm90byIsImZvcmsiLCJsZGVsaW0iLCJHcmFwaFByb3RvIiwiaW50MzIiLCJlbmNvZGVEZWxpbWl0ZWQiLCJsZW4iLCJwb3MiLCJza2lwVHlwZSIsImRlY29kZURlbGltaXRlZCIsInZlcmlmeSIsImlzU3RyaW5nIiwiaXNJbnRlZ2VyIiwiaXNBcnJheSIsImZyb21PYmplY3QiLCJMb25nQml0cyIsImJhc2U2NCIsInRvT2JqZWN0IiwiYXJyYXlzIiwiZGVmYXVsdHMiLCJsb25ncyIsImVudW1zIiwianNvbiIsImlzRmluaXRlIiwiQXR0cmlidXRlVHlwZSIsImNvbnN0cnVjdG9yIiwidG9KU09OT3B0aW9ucyIsIlZhbHVlSW5mb1Byb3RvIiwiVHlwZVByb3RvIiwiTm9kZVByb3RvIiwiaW5wdXQiLCJvdXRwdXQiLCJhdHRyaWJ1dGUiLCJvcFR5cGUiLCJkb21haW4iLCJNb2RlbFByb3RvIiwib3BzZXRJbXBvcnQiLCJtZXRhZGF0YVByb3BzIiwiaXJWZXJzaW9uIiwicHJvZHVjZXJOYW1lIiwicHJvZHVjZXJWZXJzaW9uIiwibW9kZWxWZXJzaW9uIiwiZ3JhcGgiLCJPcGVyYXRvclNldElkUHJvdG8iLCJTdHJpbmdTdHJpbmdFbnRyeVByb3RvIiwia2V5IiwiVGVuc29yQW5ub3RhdGlvbiIsInF1YW50UGFyYW1ldGVyVGVuc29yTmFtZXMiLCJ0ZW5zb3JOYW1lIiwiaW5pdGlhbGl6ZXIiLCJ2YWx1ZUluZm8iLCJxdWFudGl6YXRpb25Bbm5vdGF0aW9uIiwiZGltcyIsImZsb2F0RGF0YSIsImludDMyRGF0YSIsInN0cmluZ0RhdGEiLCJpbnQ2NERhdGEiLCJleHRlcm5hbERhdGEiLCJkb3VibGVEYXRhIiwidWludDY0RGF0YSIsImRhdGFUeXBlIiwic2VnbWVudCIsInJhd0RhdGEiLCJkYXRhTG9jYXRpb24iLCJTZWdtZW50IiwiZG91YmxlIiwidWludDY0IiwiRGF0YUxvY2F0aW9uIiwiRGF0YVR5cGUiLCJiZWdpbiIsImVuZCIsIlRlbnNvclNoYXBlUHJvdG8iLCJkaW0iLCJEaW1lbnNpb24iLCJkaW1WYWx1ZSIsImRpbVBhcmFtIiwiZGVub3RhdGlvbiIsIm9uZU9mR2V0dGVyIiwib25lT2ZTZXR0ZXIiLCJvbmVvZnMiLCJ0ZW5zb3JUeXBlIiwiVGVuc29yIiwiZWxlbVR5cGUiLCJzaGFwZSIsInZlcnNpb24iLCJfY29uZmlndXJlIiwiQnVmZmVyV3JpdGVyIiwiQnVmZmVyUmVhZGVyIiwiYnVpbGQiLCJycGMiLCJjb25maWd1cmUiLCJ1dGY4IiwiYnVmIiwiQnVmZmVyIiwiaXNCdWZmZXIiLCJsbyIsImhpIiwiX3NsaWNlIiwic2ludDMyIiwiYm9vbCIsImZpeGVkMzIiLCJzZml4ZWQzMiIsInNraXAiLCJtZXJnZSIsInNpbnQ2NCIsInp6RGVjb2RlIiwiZml4ZWQ2NCIsInNmaXhlZDY0IiwidXRmOFNsaWNlIiwiU2VydmljZSIsIkV2ZW50RW1pdHRlciIsInJwY0ltcGwiLCJyZXF1ZXN0RGVsaW1pdGVkIiwiQm9vbGVhbiIsInJlc3BvbnNlRGVsaW1pdGVkIiwicnBjQ2FsbCIsImFzUHJvbWlzZSIsImZpbmlzaCIsInplcm8iLCJ6ekVuY29kZSIsInplcm9IYXNoIiwiZnJvbSIsInRvTG9uZyIsImZyb21IYXNoIiwidG9IYXNoIiwiY2FwdHVyZVN0YWNrVHJhY2UiLCJzdGFjayIsInBvb2wiLCJpc05vZGUiLCJ3aW5kb3ciLCJmcmVlemUiLCJlbXB0eU9iamVjdCIsImlzT2JqZWN0IiwiaXNzZXQiLCJpc1NldCIsInV0ZjhXcml0ZSIsIl9CdWZmZXJfZnJvbSIsIl9CdWZmZXJfYWxsb2NVbnNhZmUiLCJkY29kZUlPIiwia2V5MlJlIiwia2V5MzJSZSIsImtleTY0UmUiLCJsb25nVG9IYXNoIiwibG9uZ0Zyb21IYXNoIiwibGNGaXJzdCIsInRvTG93ZXJDYXNlIiwibmV3RXJyb3IiLCJQcm90b2NvbEVycm9yIiwiYWxsb2NVbnNhZmUiLCJuZXh0IiwidmFsIiwiaGVhZCIsInRhaWwiLCJzdGF0ZXMiLCJhbGxvYyIsIl9wdXNoIiwicmVzZXQiLCJ3cml0ZUJ5dGVzQnVmZmVyIiwiY29weSIsImluaXQiLCJjcmVhdGVTZXNzaW9uSGFuZGxlciIsIlNlc3Npb24iLCJsb2FkTW9kZWwiLCJPbm54anNTZXNzaW9uSGFuZGxlciIsImM4IiwiclgiLCJlbnYiLCJ3YXNtIiwiaW5pdFRpbWVvdXQiLCJzaW1kIiwicHJveHkiLCJudW1UaHJlYWRzIiwiaW5pdFdhc20iLCJPbm54cnVudGltZVdlYkFzc2VtYmx5U2Vzc2lvbkhhbmRsZXIiLCJfX2NyZWF0ZUJpbmRpbmciLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJ3cml0YWJsZSIsImNvbmZpZ3VyYWJsZSIsImVudW1lcmFibGUiLCJfX2V4cG9ydFN0YXIiLCJyZWdpc3RlckJhY2tlbmQiLCJjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkiLCJjYWNoZUtleSIsIl9jYWNoZUtleSIsImdldE93blByb3BlcnR5TmFtZXMiLCJzb3J0IiwibWFwIiwiQXR0cmlidXRlIiwib25ueHJ1bnRpbWUiLCJleHBlcmltZW50YWwiLCJmYnMiLCJfYXR0cmlidXRlcyIsIk1hcCIsImdldFZhbHVlIiwiZ2V0VHlwZSIsInNpemUiLCJkZWxldGUiLCJnZXRGbG9hdCIsImdldEludCIsImdldFN0cmluZyIsImdldFRlbnNvciIsImdldEZsb2F0cyIsImdldEludHMiLCJnZXRTdHJpbmdzIiwiZ2V0VGVuc29ycyIsIkZMT0FUIiwiSU5UIiwiU1RSSU5HIiwiVEVOU09SIiwiRkxPQVRTIiwiSU5UUyIsIlNUUklOR1MiLCJURU5TT1JTIiwiR1JBUEgiLCJHUkFQSFMiLCJnZXRWYWx1ZU5vQ2hlY2siLCJMb25nVXRpbCIsImxvbmdUb051bWJlciIsImZyb21Qcm90byIsImZyb21PcnRUZW5zb3IiLCJkZWNvZGVVdGY4U3RyaW5nIiwiZ2V0VmFsdWVOb0NoZWNrRnJvbU9ubnhGb3JtYXQiLCJnZXRWYWx1ZU5vQ2hlY2tGcm9tT3J0Rm9ybWF0IiwiZmxvYXRzQXJyYXkiLCJpbnRzTGVuZ3RoIiwic3RyaW5nc0xlbmd0aCIsInRlbnNvcnNMZW5ndGgiLCJyZXNvbHZlQmFja2VuZCIsImJhY2tlbmQiLCJpbml0aWFsaXplIiwiZGlzcG9zZSIsIndlYmdsIiwiV2ViR0xCYWNrZW5kIiwiY29udGV4dElkIiwibWF0bXVsTWF4QmF0Y2hTaXplIiwidGV4dHVyZUNhY2hlTW9kZSIsInBhY2siLCJhc3luYyIsImdsQ29udGV4dCIsImNyZWF0ZVdlYkdMQ29udGV4dCIsIkxvZ2dlciIsInNldFdpdGhFbnYiLCJ2ZXJib3NlIiwid2FybmluZyIsIldlYkdMU2Vzc2lvbkhhbmRsZXIiLCJDb29yZHNHbHNsTGliIiwiR2xzbExpYiIsImdldEZ1bmN0aW9ucyIsIm9mZnNldFRvQ29vcmRzIiwiY29vcmRzVG9PZmZzZXQiLCJ0b1ZlYyIsInZhbHVlRnJvbSIsImdldENvbW1vblV0aWxGdW5jcyIsImdldElucHV0c1NhbXBsaW5nU25pcHBldHMiLCJnZXRPdXRwdXRTYW1wbGluZ1NuaXBwZXQiLCJnZXRDdXN0b21UeXBlcyIsIkdsc2xMaWJSb3V0aW5lIiwiY29udGV4dCIsIm91dHB1dFRleHR1cmVMYXlvdXQiLCJpc1BhY2tlZCIsImdldFBhY2tlZE91dHB1dFNhbXBsaW5nU25pcHBldCIsImdldFVucGFja2VkT3V0cHV0U2FtcGxpbmdTbmlwcGV0IiwidW5wYWNrZWRTaGFwZSIsIndpZHRoIiwiaGVpZ2h0IiwiZ2V0T3V0cHV0U2NhbGFyQ29vcmRzIiwiZ2V0T3V0cHV0UGFja2VkMURDb29yZHMiLCJnZXRPdXRwdXRQYWNrZWQyRENvb3JkcyIsImdldE91dHB1dFBhY2tlZDNEQ29vcmRzIiwiZ2V0T3V0cHV0UGFja2VkTkRDb29yZHMiLCJnZXRHbHNsIiwiZmxvYXRUZXh0dXJlU2V0UkdCQSIsImdldE91dHB1dFVucGFja2VkMURDb29yZHMiLCJnZXRPdXRwdXRVbnBhY2tlZDJEQ29vcmRzIiwiZ2V0T3V0cHV0VW5wYWNrZWQzRENvb3JkcyIsImdldE91dHB1dFVucGFja2VkNERDb29yZHMiLCJnZXRPdXRwdXRVbnBhY2tlZDVEQ29vcmRzIiwiZ2V0T3V0cHV0VW5wYWNrZWQ2RENvb3JkcyIsImZsb2F0VGV4dHVyZVNldFIiLCJBcnJheVV0aWwiLCJhcnJheXNFcXVhbCIsInRleHR1cmUyRCIsInByb2dyYW1JbmZvIiwiaW5wdXROYW1lcyIsImlucHV0VGV4dHVyZUxheW91dHMiLCJnZW5lcmF0ZVNoYWRlckZ1bmNOYW1lRnJvbUlucHV0U2FtcGxlck5hbWUiLCJnZXRQYWNrZWRTYW1wbGVyRnJvbUlucHV0IiwiZ2V0VW5wYWNrZWRTYW1wbGVyRnJvbUlucHV0IiwiZ2VuZXJhdGVTaGFkZXJGdW5jTmFtZUZyb21JbnB1dFNhbXBsZXJOYW1lQXRPdXRDb29yZHMiLCJnZXRQYWNrZWRTYW1wbGVyQXRPdXRwdXRDb29yZHMiLCJnZXRVbnBhY2tlZFNhbXBsZXJBdE91dHB1dENvb3JkcyIsIkJyb2FkY2FzdFV0aWwiLCJnZXRCcm9hZGNhc3REaW1zIiwiZ2V0Q29vcmRzRGF0YVR5cGUiLCJnZXRHbENoYW5uZWxzIiwiU2hhcGVVdGlsIiwiZ2V0UGFja2VkU2FtcGxlclNjYWxhciIsImdldFBhY2tlZFNhbXBsZXIxRCIsImdldFBhY2tlZFNhbXBsZXIyRCIsImdldFBhY2tlZFNhbXBsZXIzRCIsImdldFBhY2tlZFNhbXBsZXJORCIsImdldFVucGFja2VkU2FtcGxlclNjYWxhciIsImdldFVucGFja2VkU2FtcGxlcjFEIiwiZ2V0VW5wYWNrZWRTYW1wbGVyMkQiLCJnZXRVbnBhY2tlZFNhbXBsZXIzRCIsImdldFVucGFja2VkU2FtcGxlcjREIiwiZ2V0VW5wYWNrZWRTYW1wbGVyNUQiLCJnZXRVbnBhY2tlZFNhbXBsZXI2RCIsInNxdWVlemVJbnB1dFNoYXBlIiwiSlNPTiIsInN0cmluZ2lmeSIsInJvdXRpbmVCb2R5IiwiZ2V0U3F1ZWV6ZWRQYXJhbXMiLCJkZXBlbmRlbmNpZXMiLCJuZXdTaGFwZSIsImtlcHREaW1zIiwic3F1ZWV6ZVNoYXBlIiwicmV2ZXJzZSIsInN0cmlkZXMiLCJnZXRWYWx1ZUZyb21TaW5nbGUiLCJnZXRQYWNrZWRWYWx1ZUZyb20iLCJUb3BvbG9naWNhbFNvcnRHbHNsUm91dGluZXMiLCJHbHNsTGliUm91dGluZU5vZGUiLCJHbHNsQ29udGV4dCIsIkZ1bmN0aW9uVHlwZSIsIlZhbHVlQmFzZWQiLCJQb3NpdGlvbmFsIiwiYWRkRGVwZW5kZW5jeSIsInJldHVybk9yZGVyZWROb2RlcyIsIlNldCIsImNyZWF0ZU9yZGVyZWROb2RlcyIsImRmc1RyYXZlcnNlIiwiaGFzIiwiRW5jb2RpbmdHbHNsTGliIiwiZW5jb2RlRmxvYXQzMiIsImRlY29kZUZsb2F0MzIiLCJlbmNvZGVVaW50OCIsImlzTGl0dGxlRW5kaWFuIiwiZGVjb2RlVWludDgiLCJBcnJheUJ1ZmZlciIsIkZyYWdDb2xvckdsc2xMaWIiLCJzZXRGcmFnQ29sb3IiLCJnZXRDb2xvckFzRmxvYXQiLCJyZXBsYWNlSW5saW5lcyIsImV4ZWMiLCJ0cmltIiwiZmlsdGVyIiwicGFyYW1zIiwiYm9keSIsIkdsc2xQcmVwcm9jZXNzb3IiLCJsaWJzIiwiZ2xzbExpYlJvdXRpbmVEZXBlbmRlbmN5R3JhcGgiLCJnbHNsUmVnaXN0cnkiLCJwcmVwcm9jZXNzIiwic2hhZGVyU291cmNlIiwiaGFzTWFpbiIsImdldERlZmF1bHRGcmFnU2hhZGVyTWFpbiIsImdldEZyYWdTaGFkZXJQcmVhbWJsZSIsImdldFVuaWZvcm1zIiwidmFyaWFibGVzIiwiZ2V0SW1wb3J0cyIsInNlbGVjdEdsc2xMaWJSb3V0aW5lc1RvQmVJbmNsdWRlZCIsImFycmF5TGVuZ3RoIiwiZW5jb2RpbmciLCJmcmFnY29sb3IiLCJ2ZWMiLCJWZWNHbHNsTGliIiwic2hhcGVVdGlscyIsIlNoYXBlVXRpbHNHbHNsTGliIiwiY29vcmRpbmF0ZXMiLCJiY2FzdEluZGV4IiwiYmNhc3RNYXRtdWxJbmRleCIsIm9mZnNldFRvSW5kaWNlcyIsImluZGljZXNUb09mZnNldCIsImluY3JlbWVudEluZGljZXMiLCJpbmRleFRvT2Zmc2V0U2luZ2xlIiwib2Zmc2V0VG9JbmRpY2VzU2luZ2xlIiwiZ2V0VmVydGV4U2hhZGVyU291cmNlIiwidmFyeWluZ1ZlcnRleCIsInZhcnlpbmdGcmFnIiwib3V0cHV0RGVjbGFyYXRpb24iLCJiaW5hcnlWZWNGdW5jdGlvbnMiLCJjb3B5VmVjIiwic2V0VmVjSXRlbSIsImdldFZlY0l0ZW0iLCJXZWJHTEluZmVyZW5jZUhhbmRsZXIiLCJzZXNzaW9uIiwicGFja2VkVGV4dHVyZURhdGFDYWNoZSIsInVucGFja2VkVGV4dHVyZURhdGFDYWNoZSIsImNhbGN1bGF0ZVRleHR1cmVXaWR0aEFuZEhlaWdodCIsImxheW91dFN0cmF0ZWd5IiwiZXhlY3V0ZVByb2dyYW0iLCJpbnB1dFR5cGVzIiwiZ2V0T3JDcmVhdGVUZXh0dXJlRGF0YSIsImNhY2hlSGludCIsInByb2dyYW1NYW5hZ2VyIiwiZ2V0QXJ0aWZhY3QiLCJjcmVhdGVUZXh0dXJlTGF5b3V0RnJvbVRleHR1cmVUeXBlIiwidGV4dHVyZVR5cGUiLCJjcmVhdGVUZXh0dXJlRGF0YSIsInNldEFydGlmYWN0IiwicnVuUHJvZ3JhbSIsInJ1biIsInRlbnNvciIsIlRleHR1cmVUeXBlIiwicGFja2VkIiwiZ2V0VGV4dHVyZURhdGEiLCJkYXRhSWQiLCJ1bnBhY2siLCJwYWNrZWRMYXN0RGltZW5zaW9uIiwibnVtYmVyRGF0YSIsImNyZWF0ZVRleHR1cmVMYXlvdXRGcm9tU2hhcGUiLCJyZXZlcnNlV0giLCJjcmVhdGVUZXh0dXJlRGF0YUZyb21MYXlvdXRCaW5kVGVuc29yIiwidGV4dHVyZU1hbmFnZXIiLCJjcmVhdGVUZXh0dXJlRnJvbUxheW91dCIsImNyZWF0ZVRleHR1cmVEYXRhRnJvbVRleHR1cmUiLCJyZXNoYXBlVW5wYWNrZWQiLCJ1bnBhY2tlZCIsImNoYW5uZWxzIiwiY29tcHV0ZVN0cmlkZXMiLCJ0ZXh0dXJlIiwicmVzaGFwZVBhY2tlZCIsImlzUmVzaGFwZUNoZWFwIiwicHJvY2Vzc0RpbXMzRCIsImNyZWF0ZVBhY2tlZFJlc2hhcGUzRFByb2dyYW1JbmZvTG9hZGVyIiwiY2FzdCIsInJlYWRUZXh0dXJlIiwicmVhZFRleHR1cmVBc3luYyIsInNldFRleHR1cmVEYXRhIiwiaXNJbml0aWFsaXplciIsImlzVGV4dHVyZUxheW91dENhY2hlZCIsImNsZWFyQWN0aXZlVGV4dHVyZXMiLCJyZWxlYXNlVGV4dHVyZSIsImlzRmxvYXQzMkRvd25sb2FkU3VwcG9ydGVkIiwicmVhZFVpbnQ4VGV4dHVyZUFzRmxvYXQiLCJlbmNvZGVBc1VpbnQ4IiwiY3JlYXRlUGFja1Byb2dyYW1JbmZvTG9hZGVyIiwiY3JlYXRlVW5wYWNrUHJvZ3JhbUluZm9Mb2FkZXIiLCJfX3NldE1vZHVsZURlZmF1bHQiLCJfX2ltcG9ydFN0YXIiLCJXRUJHTF9PUF9SRVNPTFZFX1JVTEVTIiwiYWNvcyIsImFzaW4iLCJhdGFuIiwiYXZlcmFnZVBvb2wiLCJwYXJzZUF2ZXJhZ2VQb29sQXR0cmlidXRlcyIsImJhdGNoTm9ybWFsaXphdGlvbiIsInBhcnNlQmF0Y2hOb3JtYWxpemF0aW9uQXR0cmlidXRlcyIsInBhcnNlQ2FzdEF0dHJpYnV0ZXMiLCJjbGlwIiwicGFyc2VDbGlwQXR0cmlidXRlcyIsImNsaXBWMTEiLCJjb25jYXQiLCJwYXJzZUNvbmNhdEF0dHJpYnV0ZXMiLCJjb252IiwicGFyc2VDb252QXR0cmlidXRlcyIsImNvbnZUcmFuc3Bvc2UiLCJwYXJzZUNvbnZUcmFuc3Bvc2VBdHRyaWJ1dGVzIiwiY29zIiwiaWRlbnRpdHkiLCJkZXB0aFRvU3BhY2UiLCJwYXJzZURlcHRoVG9TcGFjZUF0dHJpYnV0ZXMiLCJlcXVhbCIsImVsdSIsInBhcnNlRWx1QXR0cmlidXRlcyIsImV4cCIsImZsYXR0ZW4iLCJwYXJzZUZsYXR0ZW5BdHRyaWJ1dGVzIiwiZ2F0aGVyIiwicGFyc2VHYXRoZXJBdHRyaWJ1dGVzIiwiZ2VtbSIsInBhcnNlR2VtbUF0dHJpYnV0ZXNWNyIsInBhcnNlR2VtbUF0dHJpYnV0ZXNWMTEiLCJnbG9iYWxBdmVyYWdlUG9vbCIsInBhcnNlR2xvYmFsQXZlcmFnZVBvb2xBdHRyaWJ1dGVzIiwiZ2xvYmFsTWF4UG9vbCIsImdyZWF0ZXIiLCJpbWFnZVNjYWxlciIsInBhcnNlSW1hZ2VTY2FsZXJBdHRyaWJ1dGVzIiwiaW5zdGFuY2VOb3JtYWxpemF0aW9uIiwicGFyc2VJbnN0YW5jZU5vcm1hbGl6YXRpb25BdHRyaWJ1dGVzIiwibGVha3lSZWx1IiwicGFyc2VMZWFreVJlbHVBdHRyaWJ1dGVzIiwibGVzcyIsIm1hdE11bCIsInBhcnNlTWF0TXVsQXR0cmlidXRlcyIsIm1heFBvb2wiLCJwYXJzZU1heFBvb2xBdHRyaWJ1dGVzIiwicGFkVjIiLCJwYXJzZVBhZEF0dHJpYnV0ZXNWMiIsInBhZFYxMSIsInBhcnNlUGFkQXR0cmlidXRlc1YxMSIsInBSZWx1IiwicmVkdWNlTG9nU3VtIiwicGFyc2VSZWR1Y2VBdHRyaWJ1dGVzIiwicmVkdWNlTWF4IiwicmVkdWNlTWVhbiIsInJlZHVjZU1pbiIsInJlZHVjZVByb2QiLCJyZWR1Y2VTdW0iLCJyZWR1Y2VMb2dTdW1TcXVhcmUiLCJyZWx1IiwicmVzaGFwZSIsInJlc2l6ZSIsInBhcnNlUmVzaXplQXR0cmlidXRlc1YxMCIsInBhcnNlUmVzaXplQXR0cmlidXRlc1YxMSIsInNpZ21vaWQiLCJzaW4iLCJzbGljZVYxMCIsInBhcnNlU2xpY2VBdHRyaWJ1dGVzIiwic29mdG1heCIsInBhcnNlU29mdG1heEF0dHJpYnV0ZXMiLCJzb2Z0bWF4VjEzIiwicGFyc2VTb2Z0bWF4QXR0cmlidXRlc1YxMyIsInBhcnNlU3BsaXRBdHRyaWJ1dGVzIiwic3FydCIsInNxdWVlemUiLCJwYXJzZVNxdWVlemVBdHRyaWJ1dGVzIiwic3F1ZWV6ZVYxMyIsInN1bSIsInRhbiIsInRhbmgiLCJ0aWxlIiwidHJhbnNwb3NlIiwicGFyc2VUcmFuc3Bvc2VBdHRyaWJ1dGVzIiwidXBzYW1wbGUiLCJwYXJzZVVwc2FtcGxlQXR0cmlidXRlc1Y3IiwicGFyc2VVcHNhbXBsZUF0dHJpYnV0ZXNWOSIsInVuc3F1ZWV6ZSIsInBhcnNlVW5zcXVlZXplQXR0cmlidXRlcyIsInVuc3F1ZWV6ZVYxMyIsImF0dHJpYnV0ZXMiLCJlcHNpbG9uIiwibW9tZW50dW0iLCJzcGF0aWFsIiwiZ2xzbFBSZWx1IiwiZ2xzbFBvdyIsImdsc2xYb3IiLCJnbHNsT3IiLCJnbHNsQW5kIiwiZ2xzbExlc3MiLCJnbHNsR3JlYXRlciIsImdsc2xFcXVhbCIsImdsc2xTdWIiLCJnbHNsTXVsIiwiZ2xzbERpdiIsImdsc2xBZGQiLCJhcmVFcXVhbCIsImNhbGNTaGFwZSIsIlByb3RvVXRpbCIsInRlbnNvckRhdGFUeXBlRnJvbVByb3RvIiwiY3JlYXRlUGFja2VkQ29uY2F0UHJvZ3JhbUluZm9Mb2FkZXIiLCJmaWxsIiwiZ2V0Q2hhbm5lbHMiLCJ1bnBhY2tGcm9tQ2hhbm5lbCIsImF4aXMiLCJjcmVhdGVVbnBhY2tlZEdyb3VwZWRDb252UHJvZ3JhbUluZm9Mb2FkZXIiLCJncm91cCIsImF1dG9QYWQiLCJkaWxhdGlvbnMiLCJrZXJuZWxTaGFwZSIsInBhZHMiLCJjYWxjdWxhdGVPdXRwdXRTaGFwZSIsImFjdGl2YXRpb25GdW5jdGlvbiIsImFwcGx5QWN0aXZhdGlvbiIsImdldEFjdGl2YXRpb25TbmlwcGV0IiwiY29udjJEUGFja2VkIiwiY29udjJEUGFja2VkUG9pbnR3aXNlIiwiY3JlYXRlUGFja2VkTWF0bXVsUHJvZ3JhbUluZm9Mb2FkZXIiLCJjcmVhdGVQYWNrZWRJbTJDb2xQcm9ncmFtSW5mb0xvYWRlciIsIm91dHB1dFNoYXBlIiwib3V0cHV0UGFkZGluZyIsInBhcnNlSW50ZXJuYWxBY3RpdmF0aW9uQXR0cmlidXRlcyIsImNyZWF0ZU1hdG11bFByb2dyYW1JbmZvTG9hZGVyIiwiY3JlYXRlSW0yQ29sUHJvZ3JhbUluZm9Mb2FkZXIiLCJjcmVhdGVEb3RQcm9kdWN0UHJvZ3JhbUluZm9Mb2FkZXIiLCJQb29sQ29udlV0aWwiLCJhZGp1c3RQYWRzQmFzZWRPbkF1dG9QYWQiLCJibG9ja3NpemUiLCJtb2RlIiwicGVybSIsImFjdGl2YXRpb25DYWNoZUtleSIsImNhbGN1bGF0ZUltMkNvbERpbXMiLCJmbGF0dGVuU2hhcGUiLCJhY3RpdmF0aW9uIiwiZ2xzbFJlbHUiLCJnbHNsU2lnbW9pZCIsImdsc2xDbGlwIiwiY2xpcE1pbiIsImNsaXBNYXgiLCJNSU5fQ0xJUCIsIk1BWF9DTElQIiwibm9ybWFsaXplQXhpcyIsIk5VTUJFUl9UWVBFUyIsInRyYW5zQSIsInRyYW5zQiIsImFscGhhIiwiYmV0YSIsImlzT3B0aW9uYWxDIiwiR2VtbVV0aWwiLCJnZXRTaGFwZU9mR2VtbVJlc3VsdCIsInNjYWxlIiwiYmlhcyIsImdldEJpYXNGb3JNYXRtdWwiLCJ1bnBhY2tlZFJldmVyc2VkIiwiZ2V0VmVjQ2hhbm5lbHMiLCJpbnRlZ2VyRGF0YSIsInBhZFNoYXBlIiwiY2VpbE1vZGUiLCJjb3VudEluY2x1ZGVQYWQiLCJzdG9yYWdlT3JkZXIiLCJhZGp1c3RQb29sQXR0cmlidXRlcyIsImNvbXB1dGVQb29sT3V0cHV0U2hhcGUiLCJyZWR1Y2UiLCJheGVzIiwia2VlcERpbXMiLCJub3JtYWxpemVBeGVzIiwiY2FsY3VsYXRlUmVzaGFwZWREaW1zIiwidmFsaWRhdGVJbnB1dHMiLCJwYXJzZVVwc2FtcGxlQXR0cmlidXRlcyIsImV2ZXJ5IiwiY29vcmRpbmF0ZVRyYW5zZm9ybU1vZGUiLCJzY2FsZXMiLCJzY2FsZXNJbnB1dElkeCIsInNpemVzSW5wdXRJZHgiLCJpc1Jlc2l6ZSIsInNjYWxlc1ZhbGlkYXRpb24iLCJzdGFydHMiLCJlbmRzIiwic29tZSIsInNpemVUb0RpbWVuc2lvbiIsInNpemVGcm9tRGltZW5zaW9uIiwib3V0cHV0cyIsIm51bU91dHB1dHMiLCJTcGxpdFV0aWwiLCJzcGxpdFNoYXBlIiwic29ydEJhc2VkT25QZXJtIiwiZG93bmxvYWRVaW50OEFzRmxvYXQiLCJnbHNsVGFuaCIsImdsc2xUYW4iLCJnbHNsU3FydCIsImdsc2xTaW4iLCJnbHNsTm90IiwiZ2xzbE5lZyIsImdsc2xMb2ciLCJnbHNsTGVha3lSZWx1IiwiZ2xzbElkZW50aXR5IiwiZ2xzbEZsb29yIiwiZ2xzbEV4cCIsImdsc2xFbHUiLCJnbHNsQ29zIiwiZ2xzbENlaWwiLCJnbHNsQXRhbiIsImdsc2xBc2luIiwiZ2xzbEFjb3MiLCJnbHNsQWJzIiwiY3JlYXRlVW5wYWNrUHJvZ3JhbUluZm8iLCJ1bnNxdWVlemVTaGFwZSIsImlucHV0cyIsIm9wc2V0IiwiZXh0cmFwb2xhdGlvblZhbHVlIiwidXNlRXh0cmFwb2xhdGlvbiIsIm5lZWRSb2lJbnB1dCIsIm5lYXJlc3RNb2RlIiwiY3ViaWNDb2VmZmljaWVudEEiLCJleGNsdWRlT3V0c2lkZSIsInVzZU5lYXJlc3QyeE9wdGltaXphdGlvbiIsInJvaUlucHV0SWR4IiwiUHJvZ3JhbU1hbmFnZXIiLCJwcm9maWxlciIsInRleHR1cmVMYXlvdXRTdHJhdGVneSIsInJlcG8iLCJhdHRyaWJ1dGVzQm91bmQiLCJldmVudCIsImdsIiwicHJvZ3JhbSIsInVzZVByb2dyYW0iLCJiaW5kT3V0cHV0IiwiYmluZEF0dHJpYnV0ZXMiLCJhdHRyaWJMb2NhdGlvbnMiLCJiaW5kVW5pZm9ybXMiLCJ1bmlmb3JtTG9jYXRpb25zIiwiZHJhdyIsInZlcnRleFNoYWRlciIsImRlbGV0ZVNoYWRlciIsImRlbGV0ZVByb2dyYW0iLCJjb21waWxlIiwiZ2V0VW5pZm9ybUxvY2F0aW9ucyIsImdldEF0dHJpYkxvY2F0aW9ucyIsImNvbXBpbGVTaGFkZXIiLCJWRVJURVhfU0hBREVSIiwiZGVidWciLCJGUkFHTUVOVF9TSEFERVIiLCJjcmVhdGVQcm9ncmFtIiwiYXR0YWNoRnJhbWVidWZmZXIiLCJwb3NpdGlvbiIsInRleHR1cmVDb29yZCIsInNldFZlcnRleEF0dHJpYnV0ZXMiLCJmaW5kIiwiYmluZFRleHR1cmUiLCJ1bmlmb3JtMWZ2IiwidW5pZm9ybTFmIiwidW5pZm9ybTFpdiIsInVuaWZvcm0xaSIsImJpbmRUZXh0dXJlVG9Vbmlmb3JtIiwiZ2V0QXR0cmliTG9jYXRpb24iLCJnZXRVbmlmb3JtTG9jYXRpb24iLCJQcmVmZXJMb2dpY2FsU3RyYXRlZ3kiLCJtYXhUZXh0dXJlU2l6ZSIsIlRleHR1cmVNYW5hZ2VyIiwicmV1c2VUZXh0dXJlcyIsInBhY2sydW5wYWNrTWFwIiwidW5wYWNrMnBhY2tNYXAiLCJjcmVhdGVJbmZlcmVuY2VIYW5kbGVyIiwib25HcmFwaEluaXRpYWxpemVkIiwiZ2V0VmFsdWVzIiwiaW5pdGlhbGl6ZXJzIiwiYWRkSW5pdGlhbGl6ZXIiLCJyZXNvbHZlT3BlcmF0b3IiLCJpbXBsIiwib3BJbXBsIiwib3BJbml0IiwiVWludDhEYXRhRW5jb2RlciIsIlJHQkFGbG9hdERhdGFFbmNvZGVyIiwiUmVkRmxvYXQzMkRhdGFFbmNvZGVyIiwiaW50ZXJuYWxGb3JtYXQiLCJSMzJGIiwiZm9ybWF0IiwiUkVEIiwiY2hhbm5lbFNpemUiLCJSR0JBMzJGIiwiUkdCQSIsImFsbG9jYXRlIiwiQUxQSEEiLCJVTlNJR05FRF9CWVRFIiwiYnl0ZU9mZnNldCIsImdldEJhdGNoRGltIiwic2l6ZVRvU3F1YXJpc2hTaGFwZSIsImdldFJvd3NDb2xzIiwic2l6ZUZyb21TaGFwZSIsImlzSW50IiwicGFyc2VBeGlzUGFyYW0iLCJBbHdheXNLZWVwT3JpZ2luYWxTaXplU3RyYXRlZ3kiLCJhc3NlcnQiLCJjb21wdXRlVGV4dHVyZVdIIiwiYnJlYWtBeGlzIiwiY29tcHV0ZVRleHR1cmUiLCJyZXZlcnNlZFdIIiwiY29uZmlnIiwicGVuZGluZ1JlYWQiLCJpblVzZVRleHR1cmVzIiwiaWRsZVRleHR1cmVzIiwidGV4dHVyZUxvb2t1cCIsInRvRW5jb2RlclR5cGUiLCJnZXRFbmNvZGVyIiwidXBkYXRlVGV4dHVyZSIsInRvVGV4dHVyZURhdGEiLCJhbGxvY2F0ZVRleHR1cmUiLCJ0b1RlbnNvckRhdGEiLCJjcmVhdGVBbmRXYWl0Rm9yRmVuY2UiLCJkZWxldGVUZXh0dXJlIiwicmVwZWF0ZWRUcnkiLCJnZXRQYWNrZWRTaGFwZSIsInRvVXBwZXJDYXNlIiwiY3JlYXRlTmV3V2ViR0xDb250ZXh0IiwiT2Zmc2NyZWVuQ2FudmFzIiwiY3JlYXRlRWxlbWVudCIsImRlcHRoIiwiYW50aWFsaWFzIiwic3RlbmNpbCIsInByZXNlcnZlRHJhd2luZ0J1ZmZlciIsInByZW11bHRpcGxpZWRBbHBoYSIsImZhaWxJZk1ham9yUGVyZm9ybWFuY2VDYXZlYXQiLCJnZXRDb250ZXh0IiwiV2ViR0xDb250ZXh0Iiwid2ViZ2wyIiwiaXNDb250ZXh0TG9zdCIsImRpc2FibGUiLCJERVBUSF9URVNUIiwiU1RFTkNJTF9URVNUIiwiQkxFTkQiLCJESVRIRVIiLCJQT0xZR09OX09GRlNFVF9GSUxMIiwiU0FNUExFX0NPVkVSQUdFIiwiZW5hYmxlIiwiU0NJU1NPUl9URVNUIiwiQ1VMTF9GQUNFIiwiY3VsbEZhY2UiLCJCQUNLIiwibGluZWFyU2VhcmNoTGFzdFRydWUiLCJmcmFtZUJ1ZmZlckJvdW5kIiwiaXRlbXNUb1BvbGwiLCJnZXRFeHRlbnNpb25zIiwidmVydGV4YnVmZmVyIiwiY3JlYXRlVmVydGV4YnVmZmVyIiwiZnJhbWVidWZmZXIiLCJjcmVhdGVGcmFtZWJ1ZmZlciIsInF1ZXJ5Vml0YWxQYXJhbWV0ZXJzIiwiY3JlYXRlVGV4dHVyZSIsIlRFWFRVUkVfMkQiLCJ0ZXhQYXJhbWV0ZXJpIiwiVEVYVFVSRV9NSU5fRklMVEVSIiwiTkVBUkVTVCIsIlRFWFRVUkVfTUFHX0ZJTFRFUiIsIlRFWFRVUkVfV1JBUF9TIiwiQ0xBTVBfVE9fRURHRSIsIlRFWFRVUkVfV1JBUF9UIiwidGV4SW1hZ2UyRCIsImNoZWNrRXJyb3IiLCJ0ZXhTdWJJbWFnZTJEIiwiYmluZEZyYW1lYnVmZmVyIiwiRlJBTUVCVUZGRVIiLCJmcmFtZWJ1ZmZlclRleHR1cmUyRCIsIkNPTE9SX0FUVEFDSE1FTlQwIiwidmlld3BvcnQiLCJzY2lzc29yIiwicmVhZFBpeGVscyIsImlzRnJhbWVidWZmZXJSZWFkeSIsImdldEFjdGl2ZVRleHR1cmUiLCJnZXRQYXJhbWV0ZXIiLCJBQ1RJVkVfVEVYVFVSRSIsIlRFWFRVUkUwIiwiZ2V0VGV4dHVyZUJpbmRpbmciLCJURVhUVVJFX0JJTkRJTkdfMkQiLCJnZXRGcmFtZWJ1ZmZlckJpbmRpbmciLCJGUkFNRUJVRkZFUl9CSU5ESU5HIiwidmVydGV4QXR0cmliUG9pbnRlciIsImVuYWJsZVZlcnRleEF0dHJpYkFycmF5IiwiYXR0YWNoU2hhZGVyIiwibGlua1Byb2dyYW0iLCJjcmVhdGVTaGFkZXIiLCJnZXRTaGFkZXJQYXJhbWV0ZXIiLCJDT01QSUxFX1NUQVRVUyIsImdldFNoYWRlckluZm9Mb2ciLCJhY3RpdmVUZXh0dXJlIiwiZHJhd0FycmF5cyIsIlRSSUFOR0xFX1NUUklQIiwiZ2V0RXJyb3IiLCJOT19FUlJPUiIsIklOVkFMSURfRU5VTSIsIklOVkFMSURfVkFMVUUiLCJJTlZBTElEX09QRVJBVElPTiIsIklOVkFMSURfRlJBTUVCVUZGRVJfT1BFUkFUSU9OIiwiT1VUX09GX01FTU9SWSIsIkNPTlRFWFRfTE9TVF9XRUJHTCIsImlzUmVuZGVyRmxvYXQzMlN1cHBvcnRlZCIsInRleHR1cmVIYWxmRmxvYXRFeHRlbnNpb24iLCJIQUxGX0ZMT0FUX09FUyIsIm1heFRleHR1cmVJbWFnZVVuaXRzIiwiZGlzcG9zZWQiLCJkZWxldGVGcmFtZWJ1ZmZlciIsImJpbmRCdWZmZXIiLCJBUlJBWV9CVUZGRVIiLCJkZWxldGVCdWZmZXIiLCJFTEVNRU5UX0FSUkFZX0JVRkZFUiIsImNyZWF0ZURlZmF1bHRHZW9tZXRyeSIsImNyZWF0ZUJ1ZmZlciIsImJ1ZmZlckRhdGEiLCJTVEFUSUNfRFJBVyIsImlzRmxvYXRUZXh0dXJlQXR0YWNoYWJsZVRvRnJhbWVCdWZmZXIiLCJjaGVja0Zsb2F0VGV4dHVyZUF0dGFjaGFibGVUb0ZyYW1lQnVmZmVyIiwiY2hlY2tSZW5kZXJGbG9hdDMyIiwiY2hlY2tGbG9hdDMyRG93bmxvYWQiLCJpc0JsZW5kU3VwcG9ydGVkIiwiY2hlY2tGbG9hdDMyQmxlbmQiLCJNQVhfVEVYVFVSRV9TSVpFIiwiTUFYX1RFWFRVUkVfSU1BR0VfVU5JVFMiLCJjb2xvckJ1ZmZlckZsb2F0RXh0ZW5zaW9uIiwiZ2V0RXh0ZW5zaW9uIiwiZGlzam9pbnRUaW1lclF1ZXJ5V2ViZ2wyRXh0ZW5zaW9uIiwidGV4dHVyZUZsb2F0RXh0ZW5zaW9uIiwiY2hlY2tGcmFtZWJ1ZmZlclN0YXR1cyIsIkZSQU1FQlVGRkVSX0NPTVBMRVRFIiwiUE9JTlRTIiwiYmVnaW5UaW1lciIsImNyZWF0ZVF1ZXJ5IiwiYmVnaW5RdWVyeSIsIlRJTUVfRUxBUFNFRF9FWFQiLCJlbmRUaW1lciIsImVuZFF1ZXJ5IiwiaXNUaW1lclJlc3VsdEF2YWlsYWJsZSIsImdldFF1ZXJ5UGFyYW1ldGVyIiwiUVVFUllfUkVTVUxUX0FWQUlMQUJMRSIsIkdQVV9ESVNKT0lOVF9FWFQiLCJnZXRUaW1lclJlc3VsdCIsIlFVRVJZX1JFU1VMVCIsImRlbGV0ZVF1ZXJ5Iiwid2FpdEZvclF1ZXJ5QW5kR2V0VGltZSIsImNyZWF0ZUZlbmNlIiwicG9sbEZlbmNlIiwiZmVuY2VTeW5jIiwiU1lOQ19HUFVfQ09NTUFORFNfQ09NUExFVEUiLCJmbHVzaCIsImNsaWVudFdhaXRTeW5jIiwiQUxSRUFEWV9TSUdOQUxFRCIsIkNPTkRJVElPTl9TQVRJU0ZJRUQiLCJxdWVyeSIsImlzRmVuY2VQYXNzZWQiLCJhZGRJdGVtVG9Qb2xsIiwicG9sbEl0ZW1zIiwiaXNEb25lRm4iLCJyZXNvbHZlRm4iLCJFeGVjdXRpb25QbGFuIiwib3AiLCJnZXROb2RlcyIsIl9vcHMiLCJfc3RhcnRlciIsIl92YWx1ZXMiLCJnZXRJbnB1dEluZGljZXMiLCJleGVjdXRlIiwidG8iLCJnZXRPdXRwdXRJbmRpY2VzIiwiZ2V0RGF0YSIsIkdyYXBoIiwiX2Zyb20iLCJfdG8iLCJ0ZW5zb3JWYWx1ZVR5cGVGcm9tUHJvdG8iLCJOb2RlIiwidGVuc29yQXR0cmlidXRlc0Zyb21PUlRGb3JtYXQiLCJleGVjdXRlTm9kZSIsImJ1aWxkR3JhcGgiLCJ0cmFuc2Zvcm1HcmFwaCIsImNoZWNrSXNBY3ljbGljIiwiX2FsbElucHV0SW5kaWNlcyIsImdldElucHV0TmFtZXMiLCJfYWxsSW5wdXROYW1lcyIsIl9hbGxPdXRwdXRJbmRpY2VzIiwiZ2V0T3V0cHV0TmFtZXMiLCJfYWxsT3V0cHV0TmFtZXMiLCJfYWxsRGF0YSIsIl9ub2RlcyIsImJ1aWxkR3JhcGhGcm9tT25ueEZvcm1hdCIsImJ1aWxkR3JhcGhGcm9tT3J0Rm9ybWF0IiwidGVuc29yRGltc0Zyb21Qcm90byIsImlucHV0c0xlbmd0aCIsIm5vZGVBcmdzTGVuZ3RoIiwibm9kZUFyZ3MiLCJ2YWx1ZVR5cGUiLCJUeXBlSW5mb1ZhbHVlIiwidGVuc29yX3R5cGUiLCJUZW5zb3JUeXBlQW5kU2hhcGUiLCJkaW1MZW5ndGgiLCJpbml0aWFsaXplcnNMZW5ndGgiLCJ0ZW5zb3JEaW1zRnJvbU9SVEZvcm1hdCIsIm91dHB1dHNMZW5ndGgiLCJub2RlcyIsIm5vZGVzTGVuZ3RoIiwiYXR0cmlidXRlc0xlbmd0aCIsInJlbW92ZUFsbElkZW50aXR5Tm9kZXMiLCJyZW1vdmVBbGxEcm9wb3V0Tm9kZXMiLCJmdXNlQ29udkFjdGl2YXRpb25Ob2RlcyIsImZpbmFsaXplR3JhcGgiLCJkZWxldGVOb2RlIiwiaXNBY3RpdmF0aW9uIiwiUHJvZmlsZXIiLCJpbmZvIiwiZmF0YWwiLCJub25lIiwiY29sb3IiLCJwcm92aWRlciIsIm1pbmltYWxTZXZlcml0eSIsImxvZ0RhdGVUaW1lIiwibG9nU291cmNlTG9jYXRpb24iLCJ0b0lTT1N0cmluZyIsImxvZ0xldmVsIiwiY2F0ZWdvcnkiLCJzdGFydFRpbWUiLCJlbmRDYWxsYmFjayIsInRpbWVyIiwiY2hlY2tUaW1lciIsImVuZFRpbWUiLCJtYXhOdW1iZXJFdmVudHMiLCJmbHVzaEJhdGNoU2l6ZSIsImZsdXNoSW50ZXJ2YWxJbk1pbGxpc2Vjb25kcyIsIl9zdGFydGVkIiwiX2ZsdXNoUG9pbnRlciIsIl9tYXhOdW1iZXJFdmVudHMiLCJfZmx1c2hCYXRjaFNpemUiLCJfZmx1c2hJbnRlcnZhbEluTWlsbGlzZWNvbmRzIiwic3RhcnQiLCJfdGltaW5nRXZlbnRzIiwiX2ZsdXNoVGltZSIsInN0b3AiLCJsb2dPbmVFdmVudCIsImVuZFN5bmMiLCJ0b0ZpeGVkIiwic3RhcnRlZCIsIk1vZGVsIiwibG9hZCIsImxvYWRGcm9tT25ueEZvcm1hdCIsImxvYWRGcm9tT3J0Rm9ybWF0IiwiX29wc2V0cyIsIl9ncmFwaCIsImZsYXRidWZmZXJzIiwiQnl0ZUJ1ZmZlciIsIkluZmVyZW5jZVNlc3Npb24iLCJnZXRSb290QXNJbmZlcmVuY2VTZXNzaW9uIiwibW9kZWwiLCJvcHNldEltcG9ydExlbmd0aCIsIm9wc2V0cyIsIkZMT0FUX1RZUEVTIiwiSU5UX1RZUEVTIiwiZW5kc1dpdGgiLCJVTkRFRklORUQiLCJTUEFSU0VfVEVOU09SIiwiU1BBUlNFX1RFTlNPUlMiLCJVTktOT1dOIiwiVkFMVUUiLCJQQVJBTSIsIkRpbWVuc2lvblZhbHVlVHlwZSIsIlVJTlQ4IiwiSU5UOCIsIlVJTlQxNiIsIklOVDE2IiwiSU5UMzIiLCJJTlQ2NCIsIkJPT0wiLCJGTE9BVDE2IiwiRE9VQkxFIiwiVUlOVDMyIiwiVUlOVDY0IiwiQ09NUExFWDY0IiwiQ09NUExFWDEyOCIsIkJGTE9BVDE2IiwiVGVuc29yRGF0YVR5cGUiLCJQcmltaXRpdmUiLCJGdXNlZCIsIk5vZGVUeXBlIiwiTk9ORSIsInNlcXVlbmNlX3R5cGUiLCJtYXBfdHlwZSIsImJiX3BvcyIsIl9faW5pdCIsImdldFJvb3RBc1NoYXBlIiwicmVhZEludDMyIiwiZ2V0U2l6ZVByZWZpeGVkUm9vdEFzU2hhcGUiLCJzZXRQb3NpdGlvbiIsIlNJWkVfUFJFRklYX0xFTkdUSCIsIl9fb2Zmc2V0IiwiX19pbmRpcmVjdCIsIl9fdmVjdG9yIiwiX192ZWN0b3JfbGVuIiwic3RhcnRTaGFwZSIsInN0YXJ0T2JqZWN0IiwiYWRkRGltIiwiYWRkRmllbGRPZmZzZXQiLCJjcmVhdGVEaW1WZWN0b3IiLCJzdGFydFZlY3RvciIsImFkZE9mZnNldCIsImVuZFZlY3RvciIsInN0YXJ0RGltVmVjdG9yIiwiZW5kU2hhcGUiLCJlbmRPYmplY3QiLCJjcmVhdGVTaGFwZSIsIlNoYXBlIiwiZ2V0Um9vdEFzRGltZW5zaW9uIiwiZ2V0U2l6ZVByZWZpeGVkUm9vdEFzRGltZW5zaW9uIiwiRGltZW5zaW9uVmFsdWUiLCJfX3N0cmluZyIsInN0YXJ0RGltZW5zaW9uIiwiYWRkVmFsdWUiLCJhZGREZW5vdGF0aW9uIiwiZW5kRGltZW5zaW9uIiwiY3JlYXRlRGltZW5zaW9uIiwiZ2V0Um9vdEFzRGltZW5zaW9uVmFsdWUiLCJnZXRTaXplUHJlZml4ZWRSb290QXNEaW1lbnNpb25WYWx1ZSIsImRpbVR5cGUiLCJyZWFkSW50OCIsInJlYWRJbnQ2NCIsImNyZWF0ZUxvbmciLCJzdGFydERpbWVuc2lvblZhbHVlIiwiYWRkRGltVHlwZSIsImFkZEZpZWxkSW50OCIsImFkZERpbVZhbHVlIiwiYWRkRmllbGRJbnQ2NCIsImFkZERpbVBhcmFtIiwiZW5kRGltZW5zaW9uVmFsdWUiLCJjcmVhdGVEaW1lbnNpb25WYWx1ZSIsImdldFJvb3RBc1RlbnNvclR5cGVBbmRTaGFwZSIsImdldFNpemVQcmVmaXhlZFJvb3RBc1RlbnNvclR5cGVBbmRTaGFwZSIsInN0YXJ0VGVuc29yVHlwZUFuZFNoYXBlIiwiYWRkRWxlbVR5cGUiLCJhZGRGaWVsZEludDMyIiwiYWRkU2hhcGUiLCJlbmRUZW5zb3JUeXBlQW5kU2hhcGUiLCJjcmVhdGVUZW5zb3JUeXBlQW5kU2hhcGUiLCJnZXRSb290QXNNYXBUeXBlIiwiZ2V0U2l6ZVByZWZpeGVkUm9vdEFzTWFwVHlwZSIsImtleVR5cGUiLCJUeXBlSW5mbyIsInN0YXJ0TWFwVHlwZSIsImFkZEtleVR5cGUiLCJhZGRWYWx1ZVR5cGUiLCJlbmRNYXBUeXBlIiwiY3JlYXRlTWFwVHlwZSIsIk1hcFR5cGUiLCJnZXRSb290QXNTZXF1ZW5jZVR5cGUiLCJnZXRTaXplUHJlZml4ZWRSb290QXNTZXF1ZW5jZVR5cGUiLCJzdGFydFNlcXVlbmNlVHlwZSIsImVuZFNlcXVlbmNlVHlwZSIsImNyZWF0ZVNlcXVlbmNlVHlwZSIsIlNlcXVlbmNlVHlwZSIsIkVkZ2VFbmQiLCJub2RlSW5kZXgiLCJyZWFkVWludDMyIiwic3JjQXJnSW5kZXgiLCJkc3RBcmdJbmRleCIsImNyZWF0ZUVkZ2VFbmQiLCJwcmVwIiwid3JpdGVJbnQzMiIsIm9mZnNldCIsImdldFJvb3RBc05vZGVFZGdlIiwiZ2V0U2l6ZVByZWZpeGVkUm9vdEFzTm9kZUVkZ2UiLCJpbnB1dEVkZ2VzIiwiaW5wdXRFZGdlc0xlbmd0aCIsIm91dHB1dEVkZ2VzIiwib3V0cHV0RWRnZXNMZW5ndGgiLCJzdGFydE5vZGVFZGdlIiwiYWRkTm9kZUluZGV4IiwiYWRkSW5wdXRFZGdlcyIsInN0YXJ0SW5wdXRFZGdlc1ZlY3RvciIsImFkZE91dHB1dEVkZ2VzIiwic3RhcnRPdXRwdXRFZGdlc1ZlY3RvciIsImVuZE5vZGVFZGdlIiwiY3JlYXRlTm9kZUVkZ2UiLCJOb2RlRWRnZSIsImdldFJvb3RBc05vZGUiLCJnZXRTaXplUHJlZml4ZWRSb290QXNOb2RlIiwic2luY2VWZXJzaW9uIiwiaW5kZXgiLCJleGVjdXRpb25Qcm92aWRlclR5cGUiLCJpbnB1dEFyZ0NvdW50cyIsImlucHV0QXJnQ291bnRzTGVuZ3RoIiwiaW5wdXRBcmdDb3VudHNBcnJheSIsImltcGxpY2l0SW5wdXRzIiwiaW1wbGljaXRJbnB1dHNMZW5ndGgiLCJzdGFydE5vZGUiLCJhZGROYW1lIiwiYWRkRG9jU3RyaW5nIiwiYWRkRG9tYWluIiwiYWRkU2luY2VWZXJzaW9uIiwiYWRkSW5kZXgiLCJhZGRPcFR5cGUiLCJhZGRUeXBlIiwiYWRkRXhlY3V0aW9uUHJvdmlkZXJUeXBlIiwiYWRkSW5wdXRzIiwiY3JlYXRlSW5wdXRzVmVjdG9yIiwic3RhcnRJbnB1dHNWZWN0b3IiLCJhZGRPdXRwdXRzIiwiY3JlYXRlT3V0cHV0c1ZlY3RvciIsInN0YXJ0T3V0cHV0c1ZlY3RvciIsImFkZEF0dHJpYnV0ZXMiLCJjcmVhdGVBdHRyaWJ1dGVzVmVjdG9yIiwic3RhcnRBdHRyaWJ1dGVzVmVjdG9yIiwiYWRkSW5wdXRBcmdDb3VudHMiLCJjcmVhdGVJbnB1dEFyZ0NvdW50c1ZlY3RvciIsImFkZEludDMyIiwic3RhcnRJbnB1dEFyZ0NvdW50c1ZlY3RvciIsImFkZEltcGxpY2l0SW5wdXRzIiwiY3JlYXRlSW1wbGljaXRJbnB1dHNWZWN0b3IiLCJzdGFydEltcGxpY2l0SW5wdXRzVmVjdG9yIiwiZW5kTm9kZSIsImNyZWF0ZU5vZGUiLCJnZXRSb290QXNWYWx1ZUluZm8iLCJnZXRTaXplUHJlZml4ZWRSb290QXNWYWx1ZUluZm8iLCJzdGFydFZhbHVlSW5mbyIsImVuZFZhbHVlSW5mbyIsImNyZWF0ZVZhbHVlSW5mbyIsIlZhbHVlSW5mbyIsImdldFJvb3RBc1R5cGVJbmZvIiwiZ2V0U2l6ZVByZWZpeGVkUm9vdEFzVHlwZUluZm8iLCJyZWFkVWludDgiLCJfX3VuaW9uIiwic3RhcnRUeXBlSW5mbyIsImVuZFR5cGVJbmZvIiwiY3JlYXRlVHlwZUluZm8iLCJnZXRSb290QXNPcGVyYXRvclNldElkIiwiZ2V0U2l6ZVByZWZpeGVkUm9vdEFzT3BlcmF0b3JTZXRJZCIsInN0YXJ0T3BlcmF0b3JTZXRJZCIsImFkZFZlcnNpb24iLCJlbmRPcGVyYXRvclNldElkIiwiY3JlYXRlT3BlcmF0b3JTZXRJZCIsIk9wZXJhdG9yU2V0SWQiLCJnZXRSb290QXNUZW5zb3IiLCJnZXRTaXplUHJlZml4ZWRSb290QXNUZW5zb3IiLCJkaW1zTGVuZ3RoIiwicmF3RGF0YUxlbmd0aCIsInJhd0RhdGFBcnJheSIsInN0cmluZ0RhdGFMZW5ndGgiLCJzdGFydFRlbnNvciIsImFkZERpbXMiLCJjcmVhdGVEaW1zVmVjdG9yIiwiYWRkSW50NjQiLCJzdGFydERpbXNWZWN0b3IiLCJhZGREYXRhVHlwZSIsImFkZFJhd0RhdGEiLCJjcmVhdGVSYXdEYXRhVmVjdG9yIiwiYWRkSW50OCIsInN0YXJ0UmF3RGF0YVZlY3RvciIsImFkZFN0cmluZ0RhdGEiLCJjcmVhdGVTdHJpbmdEYXRhVmVjdG9yIiwic3RhcnRTdHJpbmdEYXRhVmVjdG9yIiwiZW5kVGVuc29yIiwiY3JlYXRlVGVuc29yIiwiZ2V0Um9vdEFzU3BhcnNlVGVuc29yIiwiZ2V0U2l6ZVByZWZpeGVkUm9vdEFzU3BhcnNlVGVuc29yIiwiaW5kaWNlcyIsInN0YXJ0U3BhcnNlVGVuc29yIiwiYWRkVmFsdWVzIiwiYWRkSW5kaWNlcyIsImVuZFNwYXJzZVRlbnNvciIsImNyZWF0ZVNwYXJzZVRlbnNvciIsIlNwYXJzZVRlbnNvciIsImdldFJvb3RBc0F0dHJpYnV0ZSIsImdldFNpemVQcmVmaXhlZFJvb3RBc0F0dHJpYnV0ZSIsInJlYWRGbG9hdDMyIiwiZmxvYXRzTGVuZ3RoIiwiZ3JhcGhzTGVuZ3RoIiwic3RhcnRBdHRyaWJ1dGUiLCJhZGRGIiwiYWRkRmllbGRGbG9hdDMyIiwiYWRkSSIsImFkZFMiLCJhZGRUIiwiYWRkRyIsImFkZEZsb2F0cyIsImNyZWF0ZUZsb2F0c1ZlY3RvciIsImFkZEZsb2F0MzIiLCJzdGFydEZsb2F0c1ZlY3RvciIsImFkZEludHMiLCJjcmVhdGVJbnRzVmVjdG9yIiwic3RhcnRJbnRzVmVjdG9yIiwiYWRkU3RyaW5ncyIsImNyZWF0ZVN0cmluZ3NWZWN0b3IiLCJzdGFydFN0cmluZ3NWZWN0b3IiLCJhZGRUZW5zb3JzIiwiY3JlYXRlVGVuc29yc1ZlY3RvciIsInN0YXJ0VGVuc29yc1ZlY3RvciIsImFkZEdyYXBocyIsImNyZWF0ZUdyYXBoc1ZlY3RvciIsInN0YXJ0R3JhcGhzVmVjdG9yIiwiZW5kQXR0cmlidXRlIiwiY3JlYXRlQXR0cmlidXRlIiwiZ2V0Um9vdEFzR3JhcGgiLCJnZXRTaXplUHJlZml4ZWRSb290QXNHcmFwaCIsIm1heE5vZGVJbmRleCIsIm5vZGVFZGdlcyIsIm5vZGVFZGdlc0xlbmd0aCIsInNwYXJzZUluaXRpYWxpemVycyIsInNwYXJzZUluaXRpYWxpemVyc0xlbmd0aCIsInN0YXJ0R3JhcGgiLCJhZGRJbml0aWFsaXplcnMiLCJjcmVhdGVJbml0aWFsaXplcnNWZWN0b3IiLCJzdGFydEluaXRpYWxpemVyc1ZlY3RvciIsImFkZE5vZGVBcmdzIiwiY3JlYXRlTm9kZUFyZ3NWZWN0b3IiLCJzdGFydE5vZGVBcmdzVmVjdG9yIiwiYWRkTm9kZXMiLCJjcmVhdGVOb2Rlc1ZlY3RvciIsInN0YXJ0Tm9kZXNWZWN0b3IiLCJhZGRNYXhOb2RlSW5kZXgiLCJhZGROb2RlRWRnZXMiLCJjcmVhdGVOb2RlRWRnZXNWZWN0b3IiLCJzdGFydE5vZGVFZGdlc1ZlY3RvciIsImFkZFNwYXJzZUluaXRpYWxpemVycyIsImNyZWF0ZVNwYXJzZUluaXRpYWxpemVyc1ZlY3RvciIsInN0YXJ0U3BhcnNlSW5pdGlhbGl6ZXJzVmVjdG9yIiwiZW5kR3JhcGgiLCJjcmVhdGVHcmFwaCIsImdldFJvb3RBc01vZGVsIiwiZ2V0U2l6ZVByZWZpeGVkUm9vdEFzTW9kZWwiLCJncmFwaERvY1N0cmluZyIsInN0YXJ0TW9kZWwiLCJhZGRJclZlcnNpb24iLCJhZGRPcHNldEltcG9ydCIsImNyZWF0ZU9wc2V0SW1wb3J0VmVjdG9yIiwic3RhcnRPcHNldEltcG9ydFZlY3RvciIsImFkZFByb2R1Y2VyTmFtZSIsImFkZFByb2R1Y2VyVmVyc2lvbiIsImFkZE1vZGVsVmVyc2lvbiIsImFkZEdyYXBoIiwiYWRkR3JhcGhEb2NTdHJpbmciLCJlbmRNb2RlbCIsImNyZWF0ZU1vZGVsIiwiZ2V0Um9vdEFzS2VybmVsQ3JlYXRlSW5mb3MiLCJnZXRTaXplUHJlZml4ZWRSb290QXNLZXJuZWxDcmVhdGVJbmZvcyIsIm5vZGVJbmRpY2VzIiwibm9kZUluZGljZXNMZW5ndGgiLCJub2RlSW5kaWNlc0FycmF5Iiwia2VybmVsRGVmSGFzaGVzIiwicmVhZFVpbnQ2NCIsImtlcm5lbERlZkhhc2hlc0xlbmd0aCIsInN0YXJ0S2VybmVsQ3JlYXRlSW5mb3MiLCJhZGROb2RlSW5kaWNlcyIsImNyZWF0ZU5vZGVJbmRpY2VzVmVjdG9yIiwic3RhcnROb2RlSW5kaWNlc1ZlY3RvciIsImFkZEtlcm5lbERlZkhhc2hlcyIsImNyZWF0ZUtlcm5lbERlZkhhc2hlc1ZlY3RvciIsInN0YXJ0S2VybmVsRGVmSGFzaGVzVmVjdG9yIiwiZW5kS2VybmVsQ3JlYXRlSW5mb3MiLCJjcmVhdGVLZXJuZWxDcmVhdGVJbmZvcyIsIktlcm5lbENyZWF0ZUluZm9zIiwiZ2V0Um9vdEFzU3ViR3JhcGhTZXNzaW9uU3RhdGUiLCJnZXRTaXplUHJlZml4ZWRSb290QXNTdWJHcmFwaFNlc3Npb25TdGF0ZSIsImdyYXBoSWQiLCJzZXNzaW9uU3RhdGUiLCJTZXNzaW9uU3RhdGUiLCJzdGFydFN1YkdyYXBoU2Vzc2lvblN0YXRlIiwiYWRkR3JhcGhJZCIsImFkZFNlc3Npb25TdGF0ZSIsImVuZFN1YkdyYXBoU2Vzc2lvblN0YXRlIiwicmVxdWlyZWRGaWVsZCIsImNyZWF0ZVN1YkdyYXBoU2Vzc2lvblN0YXRlIiwiU3ViR3JhcGhTZXNzaW9uU3RhdGUiLCJnZXRSb290QXNTZXNzaW9uU3RhdGUiLCJnZXRTaXplUHJlZml4ZWRSb290QXNTZXNzaW9uU3RhdGUiLCJrZXJuZWxzIiwic3ViR3JhcGhTZXNzaW9uU3RhdGVzIiwic3ViR3JhcGhTZXNzaW9uU3RhdGVzTGVuZ3RoIiwic3RhcnRTZXNzaW9uU3RhdGUiLCJhZGRLZXJuZWxzIiwiYWRkU3ViR3JhcGhTZXNzaW9uU3RhdGVzIiwiY3JlYXRlU3ViR3JhcGhTZXNzaW9uU3RhdGVzVmVjdG9yIiwic3RhcnRTdWJHcmFwaFNlc3Npb25TdGF0ZXNWZWN0b3IiLCJlbmRTZXNzaW9uU3RhdGUiLCJjcmVhdGVTZXNzaW9uU3RhdGUiLCJnZXRTaXplUHJlZml4ZWRSb290QXNJbmZlcmVuY2VTZXNzaW9uIiwiYnVmZmVySGFzSWRlbnRpZmllciIsIl9faGFzX2lkZW50aWZpZXIiLCJvcnRWZXJzaW9uIiwic3RhcnRJbmZlcmVuY2VTZXNzaW9uIiwiYWRkT3J0VmVyc2lvbiIsImFkZE1vZGVsIiwiZW5kSW5mZXJlbmNlU2Vzc2lvbiIsImZpbmlzaEluZmVyZW5jZVNlc3Npb25CdWZmZXIiLCJmaW5pc2hTaXplUHJlZml4ZWRJbmZlcmVuY2VTZXNzaW9uQnVmZmVyIiwiY3JlYXRlSW5mZXJlbmNlU2Vzc2lvbiIsIm91dHB1dE5hbWVzIiwic3RhcnRQcm9maWxpbmciLCJlbmRQcm9maWxpbmciLCJfaW5pdGlhbGl6ZWQiLCJiYWNrZW5kSGludCIsImdyYXBoSW5wdXRUeXBlcyIsImdyYXBoSW5wdXREaW1zIiwiX21vZGVsIiwic2Vzc2lvbkhhbmRsZXIiLCJwcm9taXNpZnkiLCJpc1ZpZXciLCJpbml0aWFsaXplT3BzIiwiX2V4ZWN1dGlvblBsYW4iLCJub3JtYWxpemVBbmRWYWxpZGF0ZUlucHV0cyIsImNyZWF0ZU91dHB1dCIsInZhbGlkYXRlSW5wdXRUZW5zb3JEaW1zIiwidmFsaWRhdGVJbnB1dFRlbnNvclR5cGVzIiwiY29tcGFyZVRlbnNvckRpbXMiLCJfX2ltcG9ydERlZmF1bHQiLCJjYWNoZSIsImRhdGFQcm92aWRlciIsImFzeW5jRGF0YVByb3ZpZGVyIiwiX3N0cmlkZXMiLCJ2YWxpZGF0ZURpbXNBbmRDYWxjU2l6ZSIsIkRhdGFWaWV3IiwiZnJvbURhdGEiLCJnZXRVaW50OCIsImdldEludDgiLCJnZXRVaW50MTYiLCJnZXRJbnQxNiIsImdldEZsb2F0MzIiLCJnZXRJbnQzMiIsImdldFVpbnQzMiIsImdldEZsb2F0NjQiLCJSZWR1Y2VVdGlsIiwiTWF0aFV0aWwiLCJhcnJheUNvcHlIZWxwZXIiLCJNYXRNdWxVdGlsIiwiY2hlY2tJbnB1dHNTaGFwZSIsInByZXByb2Nlc3NJbnB1dFNoYXBlcyIsInBvc3Rwcm9jZXNzT3V0cHV0U2hhcGUiLCJjYWxjTWF0TXVsU2hhcGUiLCJmaWxsSW5kZXgiLCJjYWxjIiwiaXNWYWxpZEJyb2FkY2FzdCIsInRlbnNvckRhdGFUeXBlU3RyaW5nVG9FbnVtIiwiZ2V0U2l6ZUZyb21EaW1lbnNpb25SYW5nZSIsImluY3JlbWVudEluZGV4Iiwic3FyIiwiYXhweSIsInBvd3giLCJkZXRlcm1pbmVTcGxpdCIsImNhbGNSZWR1Y2UiLCJjYWxjUmVkdWNlU2hhcGUiLCJjYWxjUmVkdWNlQnlBeGlzIiwiYWRqdXN0UGFkQW5kUmV0dXJuU2hhcGUiLCJjb21wdXRlU2hhcGVIZWxwZXIiLCJjb21wdXRlQ29udk91dHB1dFNoYXBlIiwiaXRlcmF0ZUV4dHJhT3B0aW9ucyIsImVudHJpZXMiLCJyZWxlYXNlU2Vzc2lvbiIsImNyZWF0ZVNlc3Npb24iLCJjcmVhdGVTZXNzaW9uRmluYWxpemUiLCJjcmVhdGVTZXNzaW9uQWxsb2NhdGUiLCJpbml0T3J0IiwiZXJyIiwib3V0Iiwid2FzbVBhdGhzIiwiaW4iLCJpbml0aWFsaXplV2ViQXNzZW1ibHkiLCJsb2dnaW5nTGV2ZWwiLCJtb2RlbGRhdGEiLCJvcHRpb25zIiwic2Vzc2lvbklkIiwiaW5wdXRJbmRpY2VzIiwib3V0cHV0SW5kaWNlcyIsImV4dHJhY3RUcmFuc2ZlcmFibGVCdWZmZXJzIiwic2V0UnVuT3B0aW9ucyIsImdldEluc3RhbmNlIiwibG9nU2V2ZXJpdHlMZXZlbCIsImxvZ1ZlcmJvc2l0eUxldmVsIiwidGFnIiwiYWxsb2NXYXNtU3RyaW5nIiwiZXh0cmEiLCJXZWFrU2V0Iiwic2V0U2Vzc2lvbk9wdGlvbnMiLCJ1c2Vfb3J0X21vZGVsX2J5dGVzX2RpcmVjdGx5IiwiZ3JhcGhPcHRpbWl6YXRpb25MZXZlbCIsImVuYWJsZUNwdU1lbUFyZW5hIiwiZW5hYmxlTWVtUGF0dGVybiIsImV4ZWN1dGlvbk1vZGUiLCJsb2dJZCIsImVuYWJsZVByb2ZpbGluZyIsImV4ZWN1dGlvblByb3ZpZGVycyIsIkJpZ0ludDY0QXJyYXkiLCJCaWdVaW50NjRBcnJheSIsIk1lc3NhZ2VDaGFubmVsIiwicG9ydDEiLCJ2YWxpZGF0ZSIsIkJsb2IiLCJVUkwiLCJjcmVhdGVPYmplY3RVUkwiLCJyYWNlIiwidGVybWluYXRlQWxsVGhyZWFkcyIsIkJsb2JCdWlsZGVyIiwiV2ViS2l0QmxvYkJ1aWxkZXIiLCJNb3pCbG9iQnVpbGRlciIsIk1TQmxvYkJ1aWxkZXIiLCJhcHBlbmQiLCJnZXRCbG9iIiwid2Via2l0VVJMIiwicmV2b2tlT2JqZWN0VVJMIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwicmVxdWlyZSIsIk9mZnNldCIsIlRhYmxlIiwiU0laRU9GX1NIT1JUIiwiU0laRU9GX0lOVCIsIkZJTEVfSURFTlRJRklFUl9MRU5HVEgiLCJFbmNvZGluZyIsIlVURjhfQllURVMiLCJVVEYxNl9TVFJJTkciLCJmbG9hdDMyIiwiZmxvYXQ2NCIsInRvRmxvYXQ2NCIsIkJ1aWxkZXIiLCJzcGFjZSIsIm1pbmFsaWduIiwidnRhYmxlIiwidnRhYmxlX2luX3VzZSIsImlzTmVzdGVkIiwib2JqZWN0X3N0YXJ0IiwidnRhYmxlcyIsInZlY3Rvcl9udW1fZWxlbXMiLCJmb3JjZV9kZWZhdWx0cyIsImNsZWFyIiwiY2FwYWNpdHkiLCJmb3JjZURlZmF1bHRzIiwiZGF0YUJ1ZmZlciIsImFzVWludDhBcnJheSIsImdyb3dCeXRlQnVmZmVyIiwicGFkIiwid3JpdGVJbnQ4Iiwid3JpdGVJbnQxNiIsIndyaXRlSW50NjQiLCJ3cml0ZUZsb2F0MzIiLCJ3cml0ZUZsb2F0NjQiLCJhZGRJbnQxNiIsImFkZEZsb2F0NjQiLCJzbG90IiwiYWRkRmllbGRJbnQxNiIsImFkZEZpZWxkRmxvYXQ2NCIsImFkZEZpZWxkU3RydWN0IiwibmVzdGVkIiwibm90TmVzdGVkIiwicmVhZEludDE2IiwiZmluaXNoU2l6ZVByZWZpeGVkIiwiY3JlYXRlU3RyaW5nIiwiYnl0ZXNfIiwicG9zaXRpb25fIiwicmVhZFVpbnQxNiIsInJlYWRGbG9hdDY0Iiwid3JpdGVVaW50OCIsIndyaXRlVWludDE2Iiwid3JpdGVVaW50MzIiLCJ3cml0ZVVpbnQ2NCIsImdldEJ1ZmZlcklkZW50aWZpZXIiLCJfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX18iLCJfX3dlYnBhY2tfcmVxdWlyZV9fIiwiU3ltYm9sIiwidG9TdHJpbmdUYWciLCJfX3dlYnBhY2tfZXhwb3J0c19fIiwiX193ZWJwYWNrX2V4cG9ydF90YXJnZXRfXyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/onnxruntime-web/dist/ort-web.node.js\n");

/***/ })

};
;