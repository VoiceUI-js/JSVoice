"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@huggingface";
exports.ids = ["vendor-chunks/@huggingface"];
exports.modules = {

/***/ "(ssr)/../node_modules/@huggingface/jinja/dist/index.js":
/*!********************************************************!*\
  !*** ../node_modules/@huggingface/jinja/dist/index.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Environment: () => (/* binding */ Environment),\n/* harmony export */   Interpreter: () => (/* binding */ Interpreter),\n/* harmony export */   Template: () => (/* binding */ Template),\n/* harmony export */   parse: () => (/* binding */ parse),\n/* harmony export */   tokenize: () => (/* binding */ tokenize)\n/* harmony export */ });\n// src/lexer.ts\nvar TOKEN_TYPES = Object.freeze({\n    Text: \"Text\",\n    // The text between Jinja statements or expressions\n    NumericLiteral: \"NumericLiteral\",\n    // e.g., 123\n    BooleanLiteral: \"BooleanLiteral\",\n    // true or false\n    StringLiteral: \"StringLiteral\",\n    // 'string'\n    Identifier: \"Identifier\",\n    // Variables, functions, etc.\n    Equals: \"Equals\",\n    // =\n    OpenParen: \"OpenParen\",\n    // (\n    CloseParen: \"CloseParen\",\n    // )\n    OpenStatement: \"OpenStatement\",\n    // {%\n    CloseStatement: \"CloseStatement\",\n    // %}\n    OpenExpression: \"OpenExpression\",\n    // {{\n    CloseExpression: \"CloseExpression\",\n    // }}\n    OpenSquareBracket: \"OpenSquareBracket\",\n    // [\n    CloseSquareBracket: \"CloseSquareBracket\",\n    // ]\n    OpenCurlyBracket: \"OpenCurlyBracket\",\n    // {\n    CloseCurlyBracket: \"CloseCurlyBracket\",\n    // }\n    Comma: \"Comma\",\n    // ,\n    Dot: \"Dot\",\n    // .\n    Colon: \"Colon\",\n    // :\n    Pipe: \"Pipe\",\n    // |\n    CallOperator: \"CallOperator\",\n    // ()\n    AdditiveBinaryOperator: \"AdditiveBinaryOperator\",\n    // + -\n    MultiplicativeBinaryOperator: \"MultiplicativeBinaryOperator\",\n    // * / %\n    ComparisonBinaryOperator: \"ComparisonBinaryOperator\",\n    // < > <= >= == !=\n    UnaryOperator: \"UnaryOperator\",\n    // ! - +\n    // Keywords\n    Set: \"Set\",\n    If: \"If\",\n    For: \"For\",\n    In: \"In\",\n    Is: \"Is\",\n    NotIn: \"NotIn\",\n    Else: \"Else\",\n    EndIf: \"EndIf\",\n    ElseIf: \"ElseIf\",\n    EndFor: \"EndFor\",\n    And: \"And\",\n    Or: \"Or\",\n    Not: \"UnaryOperator\"\n});\nvar KEYWORDS = Object.freeze({\n    set: TOKEN_TYPES.Set,\n    for: TOKEN_TYPES.For,\n    in: TOKEN_TYPES.In,\n    is: TOKEN_TYPES.Is,\n    if: TOKEN_TYPES.If,\n    else: TOKEN_TYPES.Else,\n    endif: TOKEN_TYPES.EndIf,\n    elif: TOKEN_TYPES.ElseIf,\n    endfor: TOKEN_TYPES.EndFor,\n    and: TOKEN_TYPES.And,\n    or: TOKEN_TYPES.Or,\n    not: TOKEN_TYPES.Not,\n    \"not in\": TOKEN_TYPES.NotIn,\n    // Literals\n    true: TOKEN_TYPES.BooleanLiteral,\n    false: TOKEN_TYPES.BooleanLiteral\n});\nvar Token = class {\n    /**\n   * Constructs a new Token.\n   * @param {string} value The raw value as seen inside the source code.\n   * @param {TokenType} type The type of token.\n   */ constructor(value, type){\n        this.value = value;\n        this.type = type;\n    }\n};\nfunction isWord(char) {\n    return /\\w/.test(char);\n}\nfunction isInteger(char) {\n    return /[0-9]/.test(char);\n}\nvar ORDERED_MAPPING_TABLE = [\n    // Control sequences\n    [\n        \"{%\",\n        TOKEN_TYPES.OpenStatement\n    ],\n    [\n        \"%}\",\n        TOKEN_TYPES.CloseStatement\n    ],\n    [\n        \"{{\",\n        TOKEN_TYPES.OpenExpression\n    ],\n    [\n        \"}}\",\n        TOKEN_TYPES.CloseExpression\n    ],\n    // Single character tokens\n    [\n        \"(\",\n        TOKEN_TYPES.OpenParen\n    ],\n    [\n        \")\",\n        TOKEN_TYPES.CloseParen\n    ],\n    [\n        \"{\",\n        TOKEN_TYPES.OpenCurlyBracket\n    ],\n    [\n        \"}\",\n        TOKEN_TYPES.CloseCurlyBracket\n    ],\n    [\n        \"[\",\n        TOKEN_TYPES.OpenSquareBracket\n    ],\n    [\n        \"]\",\n        TOKEN_TYPES.CloseSquareBracket\n    ],\n    [\n        \",\",\n        TOKEN_TYPES.Comma\n    ],\n    [\n        \".\",\n        TOKEN_TYPES.Dot\n    ],\n    [\n        \":\",\n        TOKEN_TYPES.Colon\n    ],\n    [\n        \"|\",\n        TOKEN_TYPES.Pipe\n    ],\n    // Comparison operators\n    [\n        \"<=\",\n        TOKEN_TYPES.ComparisonBinaryOperator\n    ],\n    [\n        \">=\",\n        TOKEN_TYPES.ComparisonBinaryOperator\n    ],\n    [\n        \"==\",\n        TOKEN_TYPES.ComparisonBinaryOperator\n    ],\n    [\n        \"!=\",\n        TOKEN_TYPES.ComparisonBinaryOperator\n    ],\n    [\n        \"<\",\n        TOKEN_TYPES.ComparisonBinaryOperator\n    ],\n    [\n        \">\",\n        TOKEN_TYPES.ComparisonBinaryOperator\n    ],\n    // Arithmetic operators\n    [\n        \"+\",\n        TOKEN_TYPES.AdditiveBinaryOperator\n    ],\n    [\n        \"-\",\n        TOKEN_TYPES.AdditiveBinaryOperator\n    ],\n    [\n        \"*\",\n        TOKEN_TYPES.MultiplicativeBinaryOperator\n    ],\n    [\n        \"/\",\n        TOKEN_TYPES.MultiplicativeBinaryOperator\n    ],\n    [\n        \"%\",\n        TOKEN_TYPES.MultiplicativeBinaryOperator\n    ],\n    // Assignment operator\n    [\n        \"=\",\n        TOKEN_TYPES.Equals\n    ]\n];\nvar ESCAPE_CHARACTERS = /* @__PURE__ */ new Map([\n    [\n        \"n\",\n        \"\\n\"\n    ],\n    // New line\n    [\n        \"t\",\n        \"\t\"\n    ],\n    // Horizontal tab\n    [\n        \"r\",\n        \"\\r\"\n    ],\n    // Carriage return\n    [\n        \"b\",\n        \"\\b\"\n    ],\n    // Backspace\n    [\n        \"f\",\n        \"\\f\"\n    ],\n    // Form feed\n    [\n        \"v\",\n        \"\\v\"\n    ],\n    // Vertical tab\n    [\n        \"'\",\n        \"'\"\n    ],\n    // Single quote\n    [\n        '\"',\n        '\"'\n    ],\n    // Double quote\n    [\n        \"\\\\\",\n        \"\\\\\"\n    ]\n]);\nfunction preprocess(template, options = {}) {\n    if (template.endsWith(\"\\n\")) {\n        template = template.slice(0, -1);\n    }\n    template = template.replace(/{#.*?#}/gs, \"{##}\");\n    if (options.lstrip_blocks) {\n        template = template.replace(/^[ \\t]*({[#%])/gm, \"$1\");\n    }\n    if (options.trim_blocks) {\n        template = template.replace(/([#%]})\\n/g, \"$1\");\n    }\n    return template.replace(/{##}/g, \"\").replace(/-%}\\s*/g, \"%}\").replace(/\\s*{%-/g, \"{%\").replace(/-}}\\s*/g, \"}}\").replace(/\\s*{{-/g, \"{{\");\n}\nfunction tokenize(source, options = {}) {\n    const tokens = [];\n    const src = preprocess(source, options);\n    let cursorPosition = 0;\n    const consumeWhile = (predicate)=>{\n        let str = \"\";\n        while(predicate(src[cursorPosition])){\n            if (src[cursorPosition] === \"\\\\\") {\n                ++cursorPosition;\n                if (cursorPosition >= src.length) throw new SyntaxError(\"Unexpected end of input\");\n                const escaped = src[cursorPosition++];\n                const unescaped = ESCAPE_CHARACTERS.get(escaped);\n                if (unescaped === void 0) {\n                    throw new SyntaxError(`Unexpected escaped character: ${escaped}`);\n                }\n                str += unescaped;\n                continue;\n            }\n            str += src[cursorPosition++];\n            if (cursorPosition >= src.length) throw new SyntaxError(\"Unexpected end of input\");\n        }\n        return str;\n    };\n    main: while(cursorPosition < src.length){\n        const lastTokenType = tokens.at(-1)?.type;\n        if (lastTokenType === void 0 || lastTokenType === TOKEN_TYPES.CloseStatement || lastTokenType === TOKEN_TYPES.CloseExpression) {\n            let text = \"\";\n            while(cursorPosition < src.length && // Keep going until we hit the next Jinja statement or expression\n            !(src[cursorPosition] === \"{\" && (src[cursorPosition + 1] === \"%\" || src[cursorPosition + 1] === \"{\"))){\n                text += src[cursorPosition++];\n            }\n            if (text.length > 0) {\n                tokens.push(new Token(text, TOKEN_TYPES.Text));\n                continue;\n            }\n        }\n        consumeWhile((char2)=>/\\s/.test(char2));\n        const char = src[cursorPosition];\n        if (char === \"-\" || char === \"+\") {\n            const lastTokenType2 = tokens.at(-1)?.type;\n            if (lastTokenType2 === TOKEN_TYPES.Text || lastTokenType2 === void 0) {\n                throw new SyntaxError(`Unexpected character: ${char}`);\n            }\n            switch(lastTokenType2){\n                case TOKEN_TYPES.Identifier:\n                case TOKEN_TYPES.NumericLiteral:\n                case TOKEN_TYPES.BooleanLiteral:\n                case TOKEN_TYPES.StringLiteral:\n                case TOKEN_TYPES.CloseParen:\n                case TOKEN_TYPES.CloseSquareBracket:\n                    break;\n                default:\n                    {\n                        ++cursorPosition;\n                        const num = consumeWhile(isInteger);\n                        tokens.push(new Token(`${char}${num}`, num.length > 0 ? TOKEN_TYPES.NumericLiteral : TOKEN_TYPES.UnaryOperator));\n                        continue;\n                    }\n            }\n        }\n        for (const [char2, token] of ORDERED_MAPPING_TABLE){\n            const slice2 = src.slice(cursorPosition, cursorPosition + char2.length);\n            if (slice2 === char2) {\n                tokens.push(new Token(char2, token));\n                cursorPosition += char2.length;\n                continue main;\n            }\n        }\n        if (char === \"'\" || char === '\"') {\n            ++cursorPosition;\n            const str = consumeWhile((c)=>c !== char);\n            tokens.push(new Token(str, TOKEN_TYPES.StringLiteral));\n            ++cursorPosition;\n            continue;\n        }\n        if (isInteger(char)) {\n            const num = consumeWhile(isInteger);\n            tokens.push(new Token(num, TOKEN_TYPES.NumericLiteral));\n            continue;\n        }\n        if (isWord(char)) {\n            const word = consumeWhile(isWord);\n            const type = Object.hasOwn(KEYWORDS, word) ? KEYWORDS[word] : TOKEN_TYPES.Identifier;\n            if (type === TOKEN_TYPES.In && tokens.at(-1)?.type === TOKEN_TYPES.Not) {\n                tokens.pop();\n                tokens.push(new Token(\"not in\", TOKEN_TYPES.NotIn));\n            } else {\n                tokens.push(new Token(word, type));\n            }\n            continue;\n        }\n        throw new SyntaxError(`Unexpected character: ${char}`);\n    }\n    return tokens;\n}\n// src/ast.ts\nvar Statement = class {\n    constructor(){\n        this.type = \"Statement\";\n    }\n};\nvar Program = class extends Statement {\n    constructor(body){\n        super();\n        this.type = \"Program\";\n        this.body = body;\n    }\n};\nvar If = class extends Statement {\n    constructor(test, body, alternate){\n        super();\n        this.type = \"If\";\n        this.test = test;\n        this.body = body;\n        this.alternate = alternate;\n    }\n};\nvar For = class extends Statement {\n    constructor(loopvar, iterable, body){\n        super();\n        this.type = \"For\";\n        this.loopvar = loopvar;\n        this.iterable = iterable;\n        this.body = body;\n    }\n};\nvar SetStatement = class extends Statement {\n    constructor(assignee, value){\n        super();\n        this.type = \"Set\";\n        this.assignee = assignee;\n        this.value = value;\n    }\n};\nvar Expression = class extends Statement {\n    constructor(...args){\n        super(...args);\n        this.type = \"Expression\";\n    }\n};\nvar MemberExpression = class extends Expression {\n    constructor(object, property, computed){\n        super();\n        this.type = \"MemberExpression\";\n        this.object = object;\n        this.property = property;\n        this.computed = computed;\n    }\n};\nvar CallExpression = class extends Expression {\n    constructor(callee, args){\n        super();\n        this.type = \"CallExpression\";\n        this.callee = callee;\n        this.args = args;\n    }\n};\nvar Identifier = class extends Expression {\n    /**\n   * @param {string} value The name of the identifier\n   */ constructor(value){\n        super();\n        this.type = \"Identifier\";\n        this.value = value;\n    }\n};\nvar Literal = class extends Expression {\n    constructor(value){\n        super();\n        this.type = \"Literal\";\n        this.value = value;\n    }\n};\nvar NumericLiteral = class extends Literal {\n    constructor(...args){\n        super(...args);\n        this.type = \"NumericLiteral\";\n    }\n};\nvar StringLiteral = class extends Literal {\n    constructor(...args){\n        super(...args);\n        this.type = \"StringLiteral\";\n    }\n};\nvar BooleanLiteral = class extends Literal {\n    constructor(...args){\n        super(...args);\n        this.type = \"BooleanLiteral\";\n    }\n};\nvar ArrayLiteral = class extends Literal {\n    constructor(...args){\n        super(...args);\n        this.type = \"ArrayLiteral\";\n    }\n};\nvar TupleLiteral = class extends Literal {\n    constructor(...args){\n        super(...args);\n        this.type = \"TupleLiteral\";\n    }\n};\nvar ObjectLiteral = class extends Literal {\n    constructor(...args){\n        super(...args);\n        this.type = \"ObjectLiteral\";\n    }\n};\nvar BinaryExpression = class extends Expression {\n    constructor(operator, left, right){\n        super();\n        this.type = \"BinaryExpression\";\n        this.operator = operator;\n        this.left = left;\n        this.right = right;\n    }\n};\nvar FilterExpression = class extends Expression {\n    constructor(operand, filter){\n        super();\n        this.type = \"FilterExpression\";\n        this.operand = operand;\n        this.filter = filter;\n    }\n};\nvar TestExpression = class extends Expression {\n    constructor(operand, negate, test){\n        super();\n        this.type = \"TestExpression\";\n        this.operand = operand;\n        this.negate = negate;\n        this.test = test;\n    }\n};\nvar UnaryExpression = class extends Expression {\n    constructor(operator, argument){\n        super();\n        this.type = \"UnaryExpression\";\n        this.operator = operator;\n        this.argument = argument;\n    }\n};\nvar SliceExpression = class extends Expression {\n    constructor(start = void 0, stop = void 0, step = void 0){\n        super();\n        this.type = \"SliceExpression\";\n        this.start = start;\n        this.stop = stop;\n        this.step = step;\n    }\n};\nvar KeywordArgumentExpression = class extends Expression {\n    constructor(key, value){\n        super();\n        this.type = \"KeywordArgumentExpression\";\n        this.key = key;\n        this.value = value;\n    }\n};\n// src/parser.ts\nfunction parse(tokens) {\n    const program = new Program([]);\n    let current = 0;\n    function expect(type, error) {\n        const prev = tokens[current++];\n        if (!prev || prev.type !== type) {\n            throw new Error(`Parser Error: ${error}. ${prev.type} !== ${type}.`);\n        }\n        return prev;\n    }\n    function parseAny() {\n        switch(tokens[current].type){\n            case TOKEN_TYPES.Text:\n                return parseText();\n            case TOKEN_TYPES.OpenStatement:\n                return parseJinjaStatement();\n            case TOKEN_TYPES.OpenExpression:\n                return parseJinjaExpression();\n            default:\n                throw new SyntaxError(`Unexpected token type: ${tokens[current].type}`);\n        }\n    }\n    function not(...types) {\n        return current + types.length <= tokens.length && types.some((type, i)=>type !== tokens[current + i].type);\n    }\n    function is(...types) {\n        return current + types.length <= tokens.length && types.every((type, i)=>type === tokens[current + i].type);\n    }\n    function parseText() {\n        return new StringLiteral(expect(TOKEN_TYPES.Text, \"Expected text token\").value);\n    }\n    function parseJinjaStatement() {\n        expect(TOKEN_TYPES.OpenStatement, \"Expected opening statement token\");\n        let result;\n        switch(tokens[current].type){\n            case TOKEN_TYPES.Set:\n                ++current;\n                result = parseSetStatement();\n                expect(TOKEN_TYPES.CloseStatement, \"Expected closing statement token\");\n                break;\n            case TOKEN_TYPES.If:\n                ++current;\n                result = parseIfStatement();\n                expect(TOKEN_TYPES.OpenStatement, \"Expected {% token\");\n                expect(TOKEN_TYPES.EndIf, \"Expected endif token\");\n                expect(TOKEN_TYPES.CloseStatement, \"Expected %} token\");\n                break;\n            case TOKEN_TYPES.For:\n                ++current;\n                result = parseForStatement();\n                expect(TOKEN_TYPES.OpenStatement, \"Expected {% token\");\n                expect(TOKEN_TYPES.EndFor, \"Expected endfor token\");\n                expect(TOKEN_TYPES.CloseStatement, \"Expected %} token\");\n                break;\n            default:\n                throw new SyntaxError(`Unknown statement type: ${tokens[current].type}`);\n        }\n        return result;\n    }\n    function parseJinjaExpression() {\n        expect(TOKEN_TYPES.OpenExpression, \"Expected opening expression token\");\n        const result = parseExpression();\n        expect(TOKEN_TYPES.CloseExpression, \"Expected closing expression token\");\n        return result;\n    }\n    function parseSetStatement() {\n        const left = parseExpression();\n        if (is(TOKEN_TYPES.Equals)) {\n            ++current;\n            const value = parseSetStatement();\n            return new SetStatement(left, value);\n        }\n        return left;\n    }\n    function parseIfStatement() {\n        const test = parseExpression();\n        expect(TOKEN_TYPES.CloseStatement, \"Expected closing statement token\");\n        const body = [];\n        const alternate = [];\n        while(!(tokens[current]?.type === TOKEN_TYPES.OpenStatement && (tokens[current + 1]?.type === TOKEN_TYPES.ElseIf || tokens[current + 1]?.type === TOKEN_TYPES.Else || tokens[current + 1]?.type === TOKEN_TYPES.EndIf))){\n            body.push(parseAny());\n        }\n        if (tokens[current]?.type === TOKEN_TYPES.OpenStatement && tokens[current + 1]?.type !== TOKEN_TYPES.EndIf) {\n            ++current;\n            if (is(TOKEN_TYPES.ElseIf)) {\n                expect(TOKEN_TYPES.ElseIf, \"Expected elseif token\");\n                alternate.push(parseIfStatement());\n            } else {\n                expect(TOKEN_TYPES.Else, \"Expected else token\");\n                expect(TOKEN_TYPES.CloseStatement, \"Expected closing statement token\");\n                while(!(tokens[current]?.type === TOKEN_TYPES.OpenStatement && tokens[current + 1]?.type === TOKEN_TYPES.EndIf)){\n                    alternate.push(parseAny());\n                }\n            }\n        }\n        return new If(test, body, alternate);\n    }\n    function parseExpressionSequence(primary = false) {\n        const fn = primary ? parsePrimaryExpression : parseExpression;\n        const expressions = [\n            fn()\n        ];\n        const isTuple = is(TOKEN_TYPES.Comma);\n        while(isTuple){\n            ++current;\n            expressions.push(fn());\n            if (!is(TOKEN_TYPES.Comma)) {\n                break;\n            }\n        }\n        return isTuple ? new TupleLiteral(expressions) : expressions[0];\n    }\n    function parseForStatement() {\n        const loopVariable = parseExpressionSequence(true);\n        if (!(loopVariable instanceof Identifier || loopVariable instanceof TupleLiteral)) {\n            throw new SyntaxError(`Expected identifier/tuple for the loop variable, got ${loopVariable.type} instead`);\n        }\n        expect(TOKEN_TYPES.In, \"Expected `in` keyword following loop variable\");\n        const iterable = parseExpression();\n        expect(TOKEN_TYPES.CloseStatement, \"Expected closing statement token\");\n        const body = [];\n        while(not(TOKEN_TYPES.OpenStatement, TOKEN_TYPES.EndFor)){\n            body.push(parseAny());\n        }\n        return new For(loopVariable, iterable, body);\n    }\n    function parseExpression() {\n        return parseTernaryExpression();\n    }\n    function parseTernaryExpression() {\n        const a = parseLogicalOrExpression();\n        if (is(TOKEN_TYPES.If)) {\n            ++current;\n            const predicate = parseLogicalOrExpression();\n            expect(TOKEN_TYPES.Else, \"Expected else token\");\n            const b = parseLogicalOrExpression();\n            return new If(predicate, [\n                a\n            ], [\n                b\n            ]);\n        }\n        return a;\n    }\n    function parseLogicalOrExpression() {\n        let left = parseLogicalAndExpression();\n        while(is(TOKEN_TYPES.Or)){\n            const operator = tokens[current];\n            ++current;\n            const right = parseLogicalAndExpression();\n            left = new BinaryExpression(operator, left, right);\n        }\n        return left;\n    }\n    function parseLogicalAndExpression() {\n        let left = parseLogicalNegationExpression();\n        while(is(TOKEN_TYPES.And)){\n            const operator = tokens[current];\n            ++current;\n            const right = parseLogicalNegationExpression();\n            left = new BinaryExpression(operator, left, right);\n        }\n        return left;\n    }\n    function parseLogicalNegationExpression() {\n        let right;\n        while(is(TOKEN_TYPES.Not)){\n            const operator = tokens[current];\n            ++current;\n            const arg = parseLogicalNegationExpression();\n            right = new UnaryExpression(operator, arg);\n        }\n        return right ?? parseComparisonExpression();\n    }\n    function parseComparisonExpression() {\n        let left = parseAdditiveExpression();\n        while(is(TOKEN_TYPES.ComparisonBinaryOperator) || is(TOKEN_TYPES.In) || is(TOKEN_TYPES.NotIn)){\n            const operator = tokens[current];\n            ++current;\n            const right = parseAdditiveExpression();\n            left = new BinaryExpression(operator, left, right);\n        }\n        return left;\n    }\n    function parseAdditiveExpression() {\n        let left = parseMultiplicativeExpression();\n        while(is(TOKEN_TYPES.AdditiveBinaryOperator)){\n            const operator = tokens[current];\n            ++current;\n            const right = parseMultiplicativeExpression();\n            left = new BinaryExpression(operator, left, right);\n        }\n        return left;\n    }\n    function parseCallMemberExpression() {\n        const member = parseMemberExpression();\n        if (is(TOKEN_TYPES.OpenParen)) {\n            return parseCallExpression(member);\n        }\n        return member;\n    }\n    function parseCallExpression(callee) {\n        let callExpression = new CallExpression(callee, parseArgs());\n        if (is(TOKEN_TYPES.OpenParen)) {\n            callExpression = parseCallExpression(callExpression);\n        }\n        return callExpression;\n    }\n    function parseArgs() {\n        expect(TOKEN_TYPES.OpenParen, \"Expected opening parenthesis for arguments list\");\n        const args = parseArgumentsList();\n        expect(TOKEN_TYPES.CloseParen, \"Expected closing parenthesis for arguments list\");\n        return args;\n    }\n    function parseArgumentsList() {\n        const args = [];\n        while(!is(TOKEN_TYPES.CloseParen)){\n            let argument = parseExpression();\n            if (is(TOKEN_TYPES.Equals)) {\n                ++current;\n                if (!(argument instanceof Identifier)) {\n                    throw new SyntaxError(`Expected identifier for keyword argument`);\n                }\n                const value = parseExpression();\n                argument = new KeywordArgumentExpression(argument, value);\n            }\n            args.push(argument);\n            if (is(TOKEN_TYPES.Comma)) {\n                ++current;\n            }\n        }\n        return args;\n    }\n    function parseMemberExpressionArgumentsList() {\n        const slices = [];\n        let isSlice = false;\n        while(!is(TOKEN_TYPES.CloseSquareBracket)){\n            if (is(TOKEN_TYPES.Colon)) {\n                slices.push(void 0);\n                ++current;\n                isSlice = true;\n            } else {\n                slices.push(parseExpression());\n                if (is(TOKEN_TYPES.Colon)) {\n                    ++current;\n                    isSlice = true;\n                }\n            }\n        }\n        if (slices.length === 0) {\n            throw new SyntaxError(`Expected at least one argument for member/slice expression`);\n        }\n        if (isSlice) {\n            if (slices.length > 3) {\n                throw new SyntaxError(`Expected 0-3 arguments for slice expression`);\n            }\n            return new SliceExpression(...slices);\n        }\n        return slices[0];\n    }\n    function parseMemberExpression() {\n        let object = parsePrimaryExpression();\n        while(is(TOKEN_TYPES.Dot) || is(TOKEN_TYPES.OpenSquareBracket)){\n            const operator = tokens[current];\n            ++current;\n            let property;\n            const computed = operator.type !== TOKEN_TYPES.Dot;\n            if (computed) {\n                property = parseMemberExpressionArgumentsList();\n                expect(TOKEN_TYPES.CloseSquareBracket, \"Expected closing square bracket\");\n            } else {\n                property = parsePrimaryExpression();\n                if (property.type !== \"Identifier\") {\n                    throw new SyntaxError(`Expected identifier following dot operator`);\n                }\n            }\n            object = new MemberExpression(object, property, computed);\n        }\n        return object;\n    }\n    function parseMultiplicativeExpression() {\n        let left = parseTestExpression();\n        while(is(TOKEN_TYPES.MultiplicativeBinaryOperator)){\n            const operator = tokens[current];\n            ++current;\n            const right = parseTestExpression();\n            left = new BinaryExpression(operator, left, right);\n        }\n        return left;\n    }\n    function parseTestExpression() {\n        let operand = parseFilterExpression();\n        while(is(TOKEN_TYPES.Is)){\n            ++current;\n            const negate = is(TOKEN_TYPES.Not);\n            if (negate) {\n                ++current;\n            }\n            let filter = parsePrimaryExpression();\n            if (filter instanceof BooleanLiteral) {\n                filter = new Identifier(filter.value.toString());\n            }\n            if (!(filter instanceof Identifier)) {\n                throw new SyntaxError(`Expected identifier for the test`);\n            }\n            operand = new TestExpression(operand, negate, filter);\n        }\n        return operand;\n    }\n    function parseFilterExpression() {\n        let operand = parseCallMemberExpression();\n        while(is(TOKEN_TYPES.Pipe)){\n            ++current;\n            let filter = parsePrimaryExpression();\n            if (!(filter instanceof Identifier)) {\n                throw new SyntaxError(`Expected identifier for the filter`);\n            }\n            if (is(TOKEN_TYPES.OpenParen)) {\n                filter = parseCallExpression(filter);\n            }\n            operand = new FilterExpression(operand, filter);\n        }\n        return operand;\n    }\n    function parsePrimaryExpression() {\n        const token = tokens[current];\n        switch(token.type){\n            case TOKEN_TYPES.NumericLiteral:\n                ++current;\n                return new NumericLiteral(Number(token.value));\n            case TOKEN_TYPES.StringLiteral:\n                ++current;\n                return new StringLiteral(token.value);\n            case TOKEN_TYPES.BooleanLiteral:\n                ++current;\n                return new BooleanLiteral(token.value === \"true\");\n            case TOKEN_TYPES.Identifier:\n                ++current;\n                return new Identifier(token.value);\n            case TOKEN_TYPES.OpenParen:\n                {\n                    ++current;\n                    const expression = parseExpressionSequence();\n                    if (tokens[current].type !== TOKEN_TYPES.CloseParen) {\n                        throw new SyntaxError(`Expected closing parenthesis, got ${tokens[current].type} instead`);\n                    }\n                    ++current;\n                    return expression;\n                }\n            case TOKEN_TYPES.OpenSquareBracket:\n                {\n                    ++current;\n                    const values = [];\n                    while(!is(TOKEN_TYPES.CloseSquareBracket)){\n                        values.push(parseExpression());\n                        if (is(TOKEN_TYPES.Comma)) {\n                            ++current;\n                        }\n                    }\n                    ++current;\n                    return new ArrayLiteral(values);\n                }\n            case TOKEN_TYPES.OpenCurlyBracket:\n                {\n                    ++current;\n                    const values = /* @__PURE__ */ new Map();\n                    while(!is(TOKEN_TYPES.CloseCurlyBracket)){\n                        const key = parseExpression();\n                        expect(TOKEN_TYPES.Colon, \"Expected colon between key and value in object literal\");\n                        const value = parseExpression();\n                        values.set(key, value);\n                        if (is(TOKEN_TYPES.Comma)) {\n                            ++current;\n                        }\n                    }\n                    ++current;\n                    return new ObjectLiteral(values);\n                }\n            default:\n                throw new SyntaxError(`Unexpected token: ${token.type}`);\n        }\n    }\n    while(current < tokens.length){\n        program.body.push(parseAny());\n    }\n    return program;\n}\n// src/utils.ts\nfunction range(start, stop, step = 1) {\n    if (stop === void 0) {\n        stop = start;\n        start = 0;\n    }\n    const result = [];\n    for(let i = start; i < stop; i += step){\n        result.push(i);\n    }\n    return result;\n}\nfunction slice(array, start, stop, step = 1) {\n    const direction = Math.sign(step);\n    if (direction >= 0) {\n        start = (start ??= 0) < 0 ? Math.max(array.length + start, 0) : Math.min(start, array.length);\n        stop = (stop ??= array.length) < 0 ? Math.max(array.length + stop, 0) : Math.min(stop, array.length);\n    } else {\n        start = (start ??= array.length - 1) < 0 ? Math.max(array.length + start, -1) : Math.min(start, array.length - 1);\n        stop = (stop ??= -1) < -1 ? Math.max(array.length + stop, -1) : Math.min(stop, array.length - 1);\n    }\n    const result = [];\n    for(let i = start; direction * i < direction * stop; i += step){\n        result.push(array[i]);\n    }\n    return result;\n}\nfunction titleCase(value) {\n    return value.replace(/\\b\\w/g, (c)=>c.toUpperCase());\n}\n// src/runtime.ts\nvar RuntimeValue = class {\n    /**\n   * Creates a new RuntimeValue.\n   */ constructor(value = void 0){\n        this.type = \"RuntimeValue\";\n        /**\n   * A collection of built-in functions for this type.\n   */ this.builtins = /* @__PURE__ */ new Map();\n        this.value = value;\n    }\n    /**\n   * Determines truthiness or falsiness of the runtime value.\n   * This function should be overridden by subclasses if it has custom truthiness criteria.\n   * @returns {BooleanValue} BooleanValue(true) if the value is truthy, BooleanValue(false) otherwise.\n   */ __bool__() {\n        return new BooleanValue(!!this.value);\n    }\n};\nvar NumericValue = class extends RuntimeValue {\n    constructor(...args){\n        super(...args);\n        this.type = \"NumericValue\";\n    }\n};\nvar StringValue = class extends RuntimeValue {\n    constructor(...args){\n        super(...args);\n        this.type = \"StringValue\";\n        this.builtins = /* @__PURE__ */ new Map([\n            [\n                \"upper\",\n                new FunctionValue(()=>{\n                    return new StringValue(this.value.toUpperCase());\n                })\n            ],\n            [\n                \"lower\",\n                new FunctionValue(()=>{\n                    return new StringValue(this.value.toLowerCase());\n                })\n            ],\n            [\n                \"strip\",\n                new FunctionValue(()=>{\n                    return new StringValue(this.value.trim());\n                })\n            ],\n            [\n                \"title\",\n                new FunctionValue(()=>{\n                    return new StringValue(titleCase(this.value));\n                })\n            ],\n            [\n                \"length\",\n                new NumericValue(this.value.length)\n            ]\n        ]);\n    }\n};\nvar BooleanValue = class extends RuntimeValue {\n    constructor(...args){\n        super(...args);\n        this.type = \"BooleanValue\";\n    }\n};\nvar ObjectValue = class extends RuntimeValue {\n    /**\n   * NOTE: necessary to override since all JavaScript arrays are considered truthy,\n   * while only non-empty Python arrays are consider truthy.\n   *\n   * e.g.,\n   *  - JavaScript:  {} && 5 -> 5\n   *  - Python:      {} and 5 -> {}\n   */ __bool__() {\n        return new BooleanValue(this.value.size > 0);\n    }\n    constructor(...args){\n        super(...args);\n        this.type = \"ObjectValue\";\n        this.builtins = /* @__PURE__ */ new Map([\n            [\n                \"get\",\n                new FunctionValue(([key, defaultValue])=>{\n                    if (!(key instanceof StringValue)) {\n                        throw new Error(`Object key must be a string: got ${key.type}`);\n                    }\n                    return this.value.get(key.value) ?? defaultValue ?? new NullValue();\n                })\n            ],\n            [\n                \"items\",\n                new FunctionValue(()=>{\n                    return new ArrayValue(Array.from(this.value.entries()).map(([key, value])=>new ArrayValue([\n                            new StringValue(key),\n                            value\n                        ])));\n                })\n            ]\n        ]);\n    }\n};\nvar ArrayValue = class extends RuntimeValue {\n    /**\n   * NOTE: necessary to override since all JavaScript arrays are considered truthy,\n   * while only non-empty Python arrays are consider truthy.\n   *\n   * e.g.,\n   *  - JavaScript:  [] && 5 -> 5\n   *  - Python:      [] and 5 -> []\n   */ __bool__() {\n        return new BooleanValue(this.value.length > 0);\n    }\n    constructor(...args){\n        super(...args);\n        this.type = \"ArrayValue\";\n        this.builtins = /* @__PURE__ */ new Map([\n            [\n                \"length\",\n                new NumericValue(this.value.length)\n            ]\n        ]);\n    }\n};\nvar TupleValue = class extends ArrayValue {\n    constructor(...args){\n        super(...args);\n        this.type = \"TupleValue\";\n    }\n};\nvar FunctionValue = class extends RuntimeValue {\n    constructor(...args){\n        super(...args);\n        this.type = \"FunctionValue\";\n    }\n};\nvar NullValue = class extends RuntimeValue {\n    constructor(...args){\n        super(...args);\n        this.type = \"NullValue\";\n    }\n};\nvar UndefinedValue = class extends RuntimeValue {\n    constructor(...args){\n        super(...args);\n        this.type = \"UndefinedValue\";\n    }\n};\nvar Environment = class {\n    constructor(parent){\n        /**\n   * The variables declared in this environment.\n   */ this.variables = /* @__PURE__ */ new Map([\n            [\n                \"namespace\",\n                new FunctionValue((args)=>{\n                    if (args.length === 0) {\n                        return new ObjectValue(/* @__PURE__ */ new Map());\n                    }\n                    if (args.length !== 1 || !(args[0] instanceof ObjectValue)) {\n                        throw new Error(\"`namespace` expects either zero arguments or a single object argument\");\n                    }\n                    return args[0];\n                })\n            ]\n        ]);\n        /**\n   * The tests available in this environment.\n   */ this.tests = /* @__PURE__ */ new Map([\n            [\n                \"boolean\",\n                (operand)=>operand.type === \"BooleanValue\"\n            ],\n            [\n                \"callable\",\n                (operand)=>operand instanceof FunctionValue\n            ],\n            [\n                \"odd\",\n                (operand)=>{\n                    if (operand.type !== \"NumericValue\") {\n                        throw new Error(`Cannot apply test \"odd\" to type: ${operand.type}`);\n                    }\n                    return operand.value % 2 !== 0;\n                }\n            ],\n            [\n                \"even\",\n                (operand)=>{\n                    if (operand.type !== \"NumericValue\") {\n                        throw new Error(`Cannot apply test \"even\" to type: ${operand.type}`);\n                    }\n                    return operand.value % 2 === 0;\n                }\n            ],\n            [\n                \"false\",\n                (operand)=>operand.type === \"BooleanValue\" && !operand.value\n            ],\n            [\n                \"true\",\n                (operand)=>operand.type === \"BooleanValue\" && operand.value\n            ],\n            [\n                \"number\",\n                (operand)=>operand.type === \"NumericValue\"\n            ],\n            [\n                \"integer\",\n                (operand)=>operand.type === \"NumericValue\" && Number.isInteger(operand.value)\n            ],\n            [\n                \"iterable\",\n                (operand)=>operand instanceof ArrayValue || operand instanceof StringValue\n            ],\n            [\n                \"lower\",\n                (operand)=>{\n                    const str = operand.value;\n                    return operand.type === \"StringValue\" && str === str.toLowerCase();\n                }\n            ],\n            [\n                \"upper\",\n                (operand)=>{\n                    const str = operand.value;\n                    return operand.type === \"StringValue\" && str === str.toUpperCase();\n                }\n            ],\n            [\n                \"none\",\n                (operand)=>operand.type === \"NullValue\"\n            ],\n            [\n                \"defined\",\n                (operand)=>operand.type !== \"UndefinedValue\"\n            ],\n            [\n                \"undefined\",\n                (operand)=>operand.type === \"UndefinedValue\"\n            ],\n            [\n                \"equalto\",\n                (a, b)=>a.value === b.value\n            ]\n        ]);\n        this.parent = parent;\n    }\n    /**\n   * Set the value of a variable in the current environment.\n   */ set(name, value) {\n        return this.declareVariable(name, convertToRuntimeValues(value));\n    }\n    declareVariable(name, value) {\n        if (this.variables.has(name)) {\n            throw new SyntaxError(`Variable already declared: ${name}`);\n        }\n        this.variables.set(name, value);\n        return value;\n    }\n    // private assignVariable(name: string, value: AnyRuntimeValue): AnyRuntimeValue {\n    // \tconst env = this.resolve(name);\n    // \tenv.variables.set(name, value);\n    // \treturn value;\n    // }\n    /**\n   * Set variable in the current scope.\n   * See https://jinja.palletsprojects.com/en/3.0.x/templates/#assignments for more information.\n   */ setVariable(name, value) {\n        this.variables.set(name, value);\n        return value;\n    }\n    /**\n   * Resolve the environment in which the variable is declared.\n   * @param {string} name The name of the variable.\n   * @returns {Environment} The environment in which the variable is declared.\n   */ resolve(name) {\n        if (this.variables.has(name)) {\n            return this;\n        }\n        if (this.parent) {\n            return this.parent.resolve(name);\n        }\n        throw new Error(`Unknown variable: ${name}`);\n    }\n    lookupVariable(name) {\n        try {\n            return this.resolve(name).variables.get(name) ?? new UndefinedValue();\n        } catch  {\n            return new UndefinedValue();\n        }\n    }\n};\nvar Interpreter = class {\n    constructor(env){\n        this.global = env ?? new Environment();\n    }\n    /**\n   * Run the program.\n   */ run(program) {\n        return this.evaluate(program, this.global);\n    }\n    /**\n   * Evaluates expressions following the binary operation type.\n   */ evaluateBinaryExpression(node, environment) {\n        const left = this.evaluate(node.left, environment);\n        switch(node.operator.value){\n            case \"and\":\n                return left.__bool__().value ? this.evaluate(node.right, environment) : left;\n            case \"or\":\n                return left.__bool__().value ? left : this.evaluate(node.right, environment);\n        }\n        const right = this.evaluate(node.right, environment);\n        switch(node.operator.value){\n            case \"==\":\n                return new BooleanValue(left.value == right.value);\n            case \"!=\":\n                return new BooleanValue(left.value != right.value);\n        }\n        if (left instanceof UndefinedValue || right instanceof UndefinedValue) {\n            throw new Error(\"Cannot perform operation on undefined values\");\n        } else if (left instanceof NullValue || right instanceof NullValue) {\n            throw new Error(\"Cannot perform operation on null values\");\n        } else if (left instanceof NumericValue && right instanceof NumericValue) {\n            switch(node.operator.value){\n                case \"+\":\n                    return new NumericValue(left.value + right.value);\n                case \"-\":\n                    return new NumericValue(left.value - right.value);\n                case \"*\":\n                    return new NumericValue(left.value * right.value);\n                case \"/\":\n                    return new NumericValue(left.value / right.value);\n                case \"%\":\n                    return new NumericValue(left.value % right.value);\n                case \"<\":\n                    return new BooleanValue(left.value < right.value);\n                case \">\":\n                    return new BooleanValue(left.value > right.value);\n                case \">=\":\n                    return new BooleanValue(left.value >= right.value);\n                case \"<=\":\n                    return new BooleanValue(left.value <= right.value);\n            }\n        } else if (left instanceof ArrayValue && right instanceof ArrayValue) {\n            switch(node.operator.value){\n                case \"+\":\n                    return new ArrayValue(left.value.concat(right.value));\n            }\n        } else if (right instanceof ArrayValue) {\n            const member = right.value.find((x)=>x.value === left.value) !== void 0;\n            switch(node.operator.value){\n                case \"in\":\n                    return new BooleanValue(member);\n                case \"not in\":\n                    return new BooleanValue(!member);\n            }\n        }\n        if (left instanceof StringValue || right instanceof StringValue) {\n            switch(node.operator.value){\n                case \"+\":\n                    return new StringValue(left.value.toString() + right.value.toString());\n            }\n        }\n        if (left instanceof StringValue && right instanceof StringValue) {\n            switch(node.operator.value){\n                case \"in\":\n                    return new BooleanValue(right.value.includes(left.value));\n                case \"not in\":\n                    return new BooleanValue(!right.value.includes(left.value));\n            }\n        }\n        if (left instanceof StringValue && right instanceof ObjectValue) {\n            switch(node.operator.value){\n                case \"in\":\n                    return new BooleanValue(right.value.has(left.value));\n                case \"not in\":\n                    return new BooleanValue(!right.value.has(left.value));\n            }\n        }\n        throw new SyntaxError(`Unknown operator \"${node.operator.value}\" between ${left.type} and ${right.type}`);\n    }\n    /**\n   * Evaluates expressions following the filter operation type.\n   */ evaluateFilterExpression(node, environment) {\n        const operand = this.evaluate(node.operand, environment);\n        if (node.filter.type === \"Identifier\") {\n            const filter = node.filter;\n            if (operand instanceof ArrayValue) {\n                switch(filter.value){\n                    case \"list\":\n                        return operand;\n                    case \"first\":\n                        return operand.value[0];\n                    case \"last\":\n                        return operand.value[operand.value.length - 1];\n                    case \"length\":\n                        return new NumericValue(operand.value.length);\n                    case \"reverse\":\n                        return new ArrayValue(operand.value.reverse());\n                    case \"sort\":\n                        return new ArrayValue(operand.value.sort((a, b)=>{\n                            if (a.type !== b.type) {\n                                throw new Error(`Cannot compare different types: ${a.type} and ${b.type}`);\n                            }\n                            switch(a.type){\n                                case \"NumericValue\":\n                                    return a.value - b.value;\n                                case \"StringValue\":\n                                    return a.value.localeCompare(b.value);\n                                default:\n                                    throw new Error(`Cannot compare type: ${a.type}`);\n                            }\n                        }));\n                    default:\n                        throw new Error(`Unknown ArrayValue filter: ${filter.value}`);\n                }\n            } else if (operand instanceof StringValue) {\n                switch(filter.value){\n                    case \"length\":\n                        return new NumericValue(operand.value.length);\n                    case \"upper\":\n                        return new StringValue(operand.value.toUpperCase());\n                    case \"lower\":\n                        return new StringValue(operand.value.toLowerCase());\n                    case \"title\":\n                        return new StringValue(titleCase(operand.value));\n                    case \"capitalize\":\n                        return new StringValue(operand.value.charAt(0).toUpperCase() + operand.value.slice(1));\n                    case \"trim\":\n                        return new StringValue(operand.value.trim());\n                    default:\n                        throw new Error(`Unknown StringValue filter: ${filter.value}`);\n                }\n            } else if (operand instanceof NumericValue) {\n                switch(filter.value){\n                    case \"abs\":\n                        return new NumericValue(Math.abs(operand.value));\n                    default:\n                        throw new Error(`Unknown NumericValue filter: ${filter.value}`);\n                }\n            } else if (operand instanceof ObjectValue) {\n                switch(filter.value){\n                    case \"items\":\n                        return new ArrayValue(Array.from(operand.value.entries()).map(([key, value])=>new ArrayValue([\n                                new StringValue(key),\n                                value\n                            ])));\n                    case \"length\":\n                        return new NumericValue(operand.value.size);\n                    default:\n                        throw new Error(`Unknown ObjectValue filter: ${filter.value}`);\n                }\n            }\n            throw new Error(`Cannot apply filter \"${filter.value}\" to type: ${operand.type}`);\n        } else if (node.filter.type === \"CallExpression\") {\n            const filter = node.filter;\n            if (filter.callee.type !== \"Identifier\") {\n                throw new Error(`Unknown filter: ${filter.callee.type}`);\n            }\n            const filterName = filter.callee.value;\n            if (operand instanceof ArrayValue) {\n                switch(filterName){\n                    case \"selectattr\":\n                        {\n                            if (operand.value.some((x)=>!(x instanceof ObjectValue))) {\n                                throw new Error(\"`selectattr` can only be applied to array of objects\");\n                            }\n                            if (filter.args.some((x)=>x.type !== \"StringLiteral\")) {\n                                throw new Error(\"arguments of `selectattr` must be strings\");\n                            }\n                            const [attr, testName, value] = filter.args.map((x)=>this.evaluate(x, environment));\n                            let testFunction;\n                            if (testName) {\n                                const test = environment.tests.get(testName.value);\n                                if (!test) {\n                                    throw new Error(`Unknown test: ${testName.value}`);\n                                }\n                                testFunction = test;\n                            } else {\n                                testFunction = (...x)=>x[0].__bool__().value;\n                            }\n                            const filtered = operand.value.filter((item)=>{\n                                const a = item.value.get(attr.value);\n                                if (a) {\n                                    return testFunction(a, value);\n                                }\n                                return false;\n                            });\n                            return new ArrayValue(filtered);\n                        }\n                }\n                throw new Error(`Unknown ArrayValue filter: ${filterName}`);\n            } else {\n                throw new Error(`Cannot apply filter \"${filterName}\" to type: ${operand.type}`);\n            }\n        }\n        throw new Error(`Unknown filter: ${node.filter.type}`);\n    }\n    /**\n   * Evaluates expressions following the test operation type.\n   */ evaluateTestExpression(node, environment) {\n        const operand = this.evaluate(node.operand, environment);\n        const test = environment.tests.get(node.test.value);\n        if (!test) {\n            throw new Error(`Unknown test: ${node.test.value}`);\n        }\n        const result = test(operand);\n        return new BooleanValue(node.negate ? !result : result);\n    }\n    /**\n   * Evaluates expressions following the unary operation type.\n   */ evaluateUnaryExpression(node, environment) {\n        const argument = this.evaluate(node.argument, environment);\n        switch(node.operator.value){\n            case \"not\":\n                return new BooleanValue(!argument.value);\n            default:\n                throw new SyntaxError(`Unknown operator: ${node.operator.value}`);\n        }\n    }\n    evalProgram(program, environment) {\n        return this.evaluateBlock(program.body, environment);\n    }\n    evaluateBlock(statements, environment) {\n        let result = \"\";\n        for (const statement of statements){\n            const lastEvaluated = this.evaluate(statement, environment);\n            if (lastEvaluated.type !== \"NullValue\" && lastEvaluated.type !== \"UndefinedValue\") {\n                result += lastEvaluated.value;\n            }\n        }\n        return new StringValue(result);\n    }\n    evaluateIdentifier(node, environment) {\n        return environment.lookupVariable(node.value);\n    }\n    evaluateCallExpression(expr, environment) {\n        const args = [];\n        const kwargs = /* @__PURE__ */ new Map();\n        for (const argument of expr.args){\n            if (argument.type === \"KeywordArgumentExpression\") {\n                const kwarg = argument;\n                kwargs.set(kwarg.key.value, this.evaluate(kwarg.value, environment));\n            } else {\n                args.push(this.evaluate(argument, environment));\n            }\n        }\n        if (kwargs.size > 0) {\n            args.push(new ObjectValue(kwargs));\n        }\n        const fn = this.evaluate(expr.callee, environment);\n        if (fn.type !== \"FunctionValue\") {\n            throw new Error(`Cannot call something that is not a function: got ${fn.type}`);\n        }\n        return fn.value(args, environment);\n    }\n    evaluateSliceExpression(object, expr, environment) {\n        if (!(object instanceof ArrayValue || object instanceof StringValue)) {\n            throw new Error(\"Slice object must be an array or string\");\n        }\n        const start = this.evaluate(expr.start, environment);\n        const stop = this.evaluate(expr.stop, environment);\n        const step = this.evaluate(expr.step, environment);\n        if (!(start instanceof NumericValue || start instanceof UndefinedValue)) {\n            throw new Error(\"Slice start must be numeric or undefined\");\n        }\n        if (!(stop instanceof NumericValue || stop instanceof UndefinedValue)) {\n            throw new Error(\"Slice stop must be numeric or undefined\");\n        }\n        if (!(step instanceof NumericValue || step instanceof UndefinedValue)) {\n            throw new Error(\"Slice step must be numeric or undefined\");\n        }\n        if (object instanceof ArrayValue) {\n            return new ArrayValue(slice(object.value, start.value, stop.value, step.value));\n        } else {\n            return new StringValue(slice(Array.from(object.value), start.value, stop.value, step.value).join(\"\"));\n        }\n    }\n    evaluateMemberExpression(expr, environment) {\n        const object = this.evaluate(expr.object, environment);\n        let property;\n        if (expr.computed) {\n            if (expr.property.type === \"SliceExpression\") {\n                return this.evaluateSliceExpression(object, expr.property, environment);\n            } else {\n                property = this.evaluate(expr.property, environment);\n            }\n        } else {\n            property = new StringValue(expr.property.value);\n        }\n        let value;\n        if (object instanceof ObjectValue) {\n            if (!(property instanceof StringValue)) {\n                throw new Error(`Cannot access property with non-string: got ${property.type}`);\n            }\n            value = object.value.get(property.value) ?? object.builtins.get(property.value);\n        } else if (object instanceof ArrayValue || object instanceof StringValue) {\n            if (property instanceof NumericValue) {\n                value = object.value.at(property.value);\n                if (object instanceof StringValue) {\n                    value = new StringValue(object.value.at(property.value));\n                }\n            } else if (property instanceof StringValue) {\n                value = object.builtins.get(property.value);\n            } else {\n                throw new Error(`Cannot access property with non-string/non-number: got ${property.type}`);\n            }\n        } else {\n            if (!(property instanceof StringValue)) {\n                throw new Error(`Cannot access property with non-string: got ${property.type}`);\n            }\n            value = object.builtins.get(property.value);\n        }\n        return value instanceof RuntimeValue ? value : new UndefinedValue();\n    }\n    evaluateSet(node, environment) {\n        const rhs = this.evaluate(node.value, environment);\n        if (node.assignee.type === \"Identifier\") {\n            const variableName = node.assignee.value;\n            environment.setVariable(variableName, rhs);\n        } else if (node.assignee.type === \"MemberExpression\") {\n            const member = node.assignee;\n            const object = this.evaluate(member.object, environment);\n            if (!(object instanceof ObjectValue)) {\n                throw new Error(\"Cannot assign to member of non-object\");\n            }\n            if (member.property.type !== \"Identifier\") {\n                throw new Error(\"Cannot assign to member with non-identifier property\");\n            }\n            object.value.set(member.property.value, rhs);\n        } else {\n            throw new Error(`Invalid LHS inside assignment expression: ${JSON.stringify(node.assignee)}`);\n        }\n        return new NullValue();\n    }\n    evaluateIf(node, environment) {\n        const test = this.evaluate(node.test, environment);\n        return this.evaluateBlock(test.__bool__().value ? node.body : node.alternate, environment);\n    }\n    evaluateFor(node, environment) {\n        const scope = new Environment(environment);\n        const iterable = this.evaluate(node.iterable, scope);\n        if (!(iterable instanceof ArrayValue)) {\n            throw new Error(`Expected iterable type in for loop: got ${iterable.type}`);\n        }\n        let result = \"\";\n        for(let i = 0; i < iterable.value.length; ++i){\n            const loop = /* @__PURE__ */ new Map([\n                [\n                    \"index\",\n                    new NumericValue(i + 1)\n                ],\n                [\n                    \"index0\",\n                    new NumericValue(i)\n                ],\n                [\n                    \"revindex\",\n                    new NumericValue(iterable.value.length - i)\n                ],\n                [\n                    \"revindex0\",\n                    new NumericValue(iterable.value.length - i - 1)\n                ],\n                [\n                    \"first\",\n                    new BooleanValue(i === 0)\n                ],\n                [\n                    \"last\",\n                    new BooleanValue(i === iterable.value.length - 1)\n                ],\n                [\n                    \"length\",\n                    new NumericValue(iterable.value.length)\n                ],\n                [\n                    \"previtem\",\n                    i > 0 ? iterable.value[i - 1] : new UndefinedValue()\n                ],\n                [\n                    \"nextitem\",\n                    i < iterable.value.length - 1 ? iterable.value[i + 1] : new UndefinedValue()\n                ]\n            ]);\n            scope.setVariable(\"loop\", new ObjectValue(loop));\n            const current = iterable.value[i];\n            if (node.loopvar.type === \"Identifier\") {\n                scope.setVariable(node.loopvar.value, current);\n            } else if (node.loopvar.type === \"TupleLiteral\") {\n                const loopvar = node.loopvar;\n                if (current.type !== \"ArrayValue\") {\n                    throw new Error(`Cannot unpack non-iterable type: ${current.type}`);\n                }\n                const c = current;\n                if (loopvar.value.length !== c.value.length) {\n                    throw new Error(`Too ${loopvar.value.length > c.value.length ? \"few\" : \"many\"} items to unpack`);\n                }\n                for(let j = 0; j < loopvar.value.length; ++j){\n                    if (loopvar.value[j].type !== \"Identifier\") {\n                        throw new Error(`Cannot unpack non-identifier type: ${loopvar.value[j].type}`);\n                    }\n                    scope.setVariable(loopvar.value[j].value, c.value[j]);\n                }\n            }\n            const evaluated = this.evaluateBlock(node.body, scope);\n            result += evaluated.value;\n        }\n        return new StringValue(result);\n    }\n    evaluate(statement, environment) {\n        if (statement === void 0) return new UndefinedValue();\n        switch(statement.type){\n            case \"Program\":\n                return this.evalProgram(statement, environment);\n            case \"Set\":\n                return this.evaluateSet(statement, environment);\n            case \"If\":\n                return this.evaluateIf(statement, environment);\n            case \"For\":\n                return this.evaluateFor(statement, environment);\n            case \"NumericLiteral\":\n                return new NumericValue(Number(statement.value));\n            case \"StringLiteral\":\n                return new StringValue(statement.value);\n            case \"BooleanLiteral\":\n                return new BooleanValue(statement.value);\n            case \"ArrayLiteral\":\n                return new ArrayValue(statement.value.map((x)=>this.evaluate(x, environment)));\n            case \"TupleLiteral\":\n                return new TupleValue(statement.value.map((x)=>this.evaluate(x, environment)));\n            case \"ObjectLiteral\":\n                {\n                    const mapping = /* @__PURE__ */ new Map();\n                    for (const [key, value] of statement.value){\n                        const evaluatedKey = this.evaluate(key, environment);\n                        if (!(evaluatedKey instanceof StringValue)) {\n                            throw new Error(`Object keys must be strings: got ${evaluatedKey.type}`);\n                        }\n                        mapping.set(evaluatedKey.value, this.evaluate(value, environment));\n                    }\n                    return new ObjectValue(mapping);\n                }\n            case \"Identifier\":\n                return this.evaluateIdentifier(statement, environment);\n            case \"CallExpression\":\n                return this.evaluateCallExpression(statement, environment);\n            case \"MemberExpression\":\n                return this.evaluateMemberExpression(statement, environment);\n            case \"UnaryExpression\":\n                return this.evaluateUnaryExpression(statement, environment);\n            case \"BinaryExpression\":\n                return this.evaluateBinaryExpression(statement, environment);\n            case \"FilterExpression\":\n                return this.evaluateFilterExpression(statement, environment);\n            case \"TestExpression\":\n                return this.evaluateTestExpression(statement, environment);\n            default:\n                throw new SyntaxError(`Unknown node type: ${statement.type}`);\n        }\n    }\n};\nfunction convertToRuntimeValues(input) {\n    switch(typeof input){\n        case \"number\":\n            return new NumericValue(input);\n        case \"string\":\n            return new StringValue(input);\n        case \"boolean\":\n            return new BooleanValue(input);\n        case \"object\":\n            if (input === null) {\n                return new NullValue();\n            } else if (Array.isArray(input)) {\n                return new ArrayValue(input.map(convertToRuntimeValues));\n            } else {\n                return new ObjectValue(new Map(Object.entries(input).map(([key, value])=>[\n                        key,\n                        convertToRuntimeValues(value)\n                    ])));\n            }\n        case \"function\":\n            return new FunctionValue((args, _scope)=>{\n                const result = input(...args.map((x)=>x.value)) ?? null;\n                return convertToRuntimeValues(result);\n            });\n        default:\n            throw new Error(`Cannot convert to runtime value: ${input}`);\n    }\n}\n// src/index.ts\nvar Template = class {\n    /**\n   * @param {string} template The template string\n   */ constructor(template){\n        const tokens = tokenize(template, {\n            lstrip_blocks: true,\n            trim_blocks: true\n        });\n        this.parsed = parse(tokens);\n    }\n    render(items) {\n        const env = new Environment();\n        env.set(\"false\", false);\n        env.set(\"true\", true);\n        env.set(\"raise_exception\", (args)=>{\n            throw new Error(args);\n        });\n        env.set(\"range\", range);\n        for (const [key, value] of Object.entries(items)){\n            env.set(key, value);\n        }\n        const interpreter = new Interpreter(env);\n        const result = interpreter.run(this.parsed);\n        return result.value;\n    }\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0BodWdnaW5nZmFjZS9qaW5qYS9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUEsZUFBZTtBQUNmLElBQUlBLGNBQWNDLE9BQU9DLE1BQU0sQ0FBQztJQUM5QkMsTUFBTTtJQUNOLG1EQUFtRDtJQUNuREMsZ0JBQWdCO0lBQ2hCLFlBQVk7SUFDWkMsZ0JBQWdCO0lBQ2hCLGdCQUFnQjtJQUNoQkMsZUFBZTtJQUNmLFdBQVc7SUFDWEMsWUFBWTtJQUNaLDZCQUE2QjtJQUM3QkMsUUFBUTtJQUNSLElBQUk7SUFDSkMsV0FBVztJQUNYLElBQUk7SUFDSkMsWUFBWTtJQUNaLElBQUk7SUFDSkMsZUFBZTtJQUNmLEtBQUs7SUFDTEMsZ0JBQWdCO0lBQ2hCLEtBQUs7SUFDTEMsZ0JBQWdCO0lBQ2hCLEtBQUs7SUFDTEMsaUJBQWlCO0lBQ2pCLEtBQUs7SUFDTEMsbUJBQW1CO0lBQ25CLElBQUk7SUFDSkMsb0JBQW9CO0lBQ3BCLElBQUk7SUFDSkMsa0JBQWtCO0lBQ2xCLElBQUk7SUFDSkMsbUJBQW1CO0lBQ25CLElBQUk7SUFDSkMsT0FBTztJQUNQLElBQUk7SUFDSkMsS0FBSztJQUNMLElBQUk7SUFDSkMsT0FBTztJQUNQLElBQUk7SUFDSkMsTUFBTTtJQUNOLElBQUk7SUFDSkMsY0FBYztJQUNkLEtBQUs7SUFDTEMsd0JBQXdCO0lBQ3hCLE1BQU07SUFDTkMsOEJBQThCO0lBQzlCLFFBQVE7SUFDUkMsMEJBQTBCO0lBQzFCLGtCQUFrQjtJQUNsQkMsZUFBZTtJQUNmLFFBQVE7SUFDUixXQUFXO0lBQ1hDLEtBQUs7SUFDTEMsSUFBSTtJQUNKQyxLQUFLO0lBQ0xDLElBQUk7SUFDSkMsSUFBSTtJQUNKQyxPQUFPO0lBQ1BDLE1BQU07SUFDTkMsT0FBTztJQUNQQyxRQUFRO0lBQ1JDLFFBQVE7SUFDUkMsS0FBSztJQUNMQyxJQUFJO0lBQ0pDLEtBQUs7QUFDUDtBQUNBLElBQUlDLFdBQVd4QyxPQUFPQyxNQUFN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QUFNUyxTQUFTRixTQUFTUCxVQUFVO1lBQ2hDSyxlQUFlO1lBQ2ZDLGFBQWE7UUFDZjtRQUNBLElBQUksQ0FBQ3NOLE1BQU0sR0FBR3JKLE1BQU05RDtJQUN0QjtJQUNBb04sT0FBT0MsS0FBSyxFQUFFO1FBQ1osTUFBTXpELE1BQU0sSUFBSVo7UUFDaEJZLElBQUkvTCxHQUFHLENBQUMsU0FBUztRQUNqQitMLElBQUkvTCxHQUFHLENBQUMsUUFBUTtRQUNoQitMLElBQUkvTCxHQUFHLENBQUMsbUJBQW1CLENBQUMyRTtZQUMxQixNQUFNLElBQUk0QixNQUFNNUI7UUFDbEI7UUFDQW9ILElBQUkvTCxHQUFHLENBQUMsU0FBU3NKO1FBQ2pCLEtBQUssTUFBTSxDQUFDdEQsS0FBS2hGLE1BQU0sSUFBSXpELE9BQU93TixPQUFPLENBQUN5RSxPQUFRO1lBQ2hEekQsSUFBSS9MLEdBQUcsQ0FBQ2dHLEtBQUtoRjtRQUNmO1FBQ0EsTUFBTXlPLGNBQWMsSUFBSTNELFlBQVlDO1FBQ3BDLE1BQU0vRSxTQUFTeUksWUFBWXhELEdBQUcsQ0FBQyxJQUFJLENBQUNxRCxNQUFNO1FBQzFDLE9BQU90SSxPQUFPaEcsS0FBSztJQUNyQjtBQUNGO0FBT0UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9qc3ZvaWNlLWRlbW8vLi4vbm9kZV9tb2R1bGVzL0BodWdnaW5nZmFjZS9qaW5qYS9kaXN0L2luZGV4LmpzP2I4NjMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL2xleGVyLnRzXG52YXIgVE9LRU5fVFlQRVMgPSBPYmplY3QuZnJlZXplKHtcbiAgVGV4dDogXCJUZXh0XCIsXG4gIC8vIFRoZSB0ZXh0IGJldHdlZW4gSmluamEgc3RhdGVtZW50cyBvciBleHByZXNzaW9uc1xuICBOdW1lcmljTGl0ZXJhbDogXCJOdW1lcmljTGl0ZXJhbFwiLFxuICAvLyBlLmcuLCAxMjNcbiAgQm9vbGVhbkxpdGVyYWw6IFwiQm9vbGVhbkxpdGVyYWxcIixcbiAgLy8gdHJ1ZSBvciBmYWxzZVxuICBTdHJpbmdMaXRlcmFsOiBcIlN0cmluZ0xpdGVyYWxcIixcbiAgLy8gJ3N0cmluZydcbiAgSWRlbnRpZmllcjogXCJJZGVudGlmaWVyXCIsXG4gIC8vIFZhcmlhYmxlcywgZnVuY3Rpb25zLCBldGMuXG4gIEVxdWFsczogXCJFcXVhbHNcIixcbiAgLy8gPVxuICBPcGVuUGFyZW46IFwiT3BlblBhcmVuXCIsXG4gIC8vIChcbiAgQ2xvc2VQYXJlbjogXCJDbG9zZVBhcmVuXCIsXG4gIC8vIClcbiAgT3BlblN0YXRlbWVudDogXCJPcGVuU3RhdGVtZW50XCIsXG4gIC8vIHslXG4gIENsb3NlU3RhdGVtZW50OiBcIkNsb3NlU3RhdGVtZW50XCIsXG4gIC8vICV9XG4gIE9wZW5FeHByZXNzaW9uOiBcIk9wZW5FeHByZXNzaW9uXCIsXG4gIC8vIHt7XG4gIENsb3NlRXhwcmVzc2lvbjogXCJDbG9zZUV4cHJlc3Npb25cIixcbiAgLy8gfX1cbiAgT3BlblNxdWFyZUJyYWNrZXQ6IFwiT3BlblNxdWFyZUJyYWNrZXRcIixcbiAgLy8gW1xuICBDbG9zZVNxdWFyZUJyYWNrZXQ6IFwiQ2xvc2VTcXVhcmVCcmFja2V0XCIsXG4gIC8vIF1cbiAgT3BlbkN1cmx5QnJhY2tldDogXCJPcGVuQ3VybHlCcmFja2V0XCIsXG4gIC8vIHtcbiAgQ2xvc2VDdXJseUJyYWNrZXQ6IFwiQ2xvc2VDdXJseUJyYWNrZXRcIixcbiAgLy8gfVxuICBDb21tYTogXCJDb21tYVwiLFxuICAvLyAsXG4gIERvdDogXCJEb3RcIixcbiAgLy8gLlxuICBDb2xvbjogXCJDb2xvblwiLFxuICAvLyA6XG4gIFBpcGU6IFwiUGlwZVwiLFxuICAvLyB8XG4gIENhbGxPcGVyYXRvcjogXCJDYWxsT3BlcmF0b3JcIixcbiAgLy8gKClcbiAgQWRkaXRpdmVCaW5hcnlPcGVyYXRvcjogXCJBZGRpdGl2ZUJpbmFyeU9wZXJhdG9yXCIsXG4gIC8vICsgLVxuICBNdWx0aXBsaWNhdGl2ZUJpbmFyeU9wZXJhdG9yOiBcIk11bHRpcGxpY2F0aXZlQmluYXJ5T3BlcmF0b3JcIixcbiAgLy8gKiAvICVcbiAgQ29tcGFyaXNvbkJpbmFyeU9wZXJhdG9yOiBcIkNvbXBhcmlzb25CaW5hcnlPcGVyYXRvclwiLFxuICAvLyA8ID4gPD0gPj0gPT0gIT1cbiAgVW5hcnlPcGVyYXRvcjogXCJVbmFyeU9wZXJhdG9yXCIsXG4gIC8vICEgLSArXG4gIC8vIEtleXdvcmRzXG4gIFNldDogXCJTZXRcIixcbiAgSWY6IFwiSWZcIixcbiAgRm9yOiBcIkZvclwiLFxuICBJbjogXCJJblwiLFxuICBJczogXCJJc1wiLFxuICBOb3RJbjogXCJOb3RJblwiLFxuICBFbHNlOiBcIkVsc2VcIixcbiAgRW5kSWY6IFwiRW5kSWZcIixcbiAgRWxzZUlmOiBcIkVsc2VJZlwiLFxuICBFbmRGb3I6IFwiRW5kRm9yXCIsXG4gIEFuZDogXCJBbmRcIixcbiAgT3I6IFwiT3JcIixcbiAgTm90OiBcIlVuYXJ5T3BlcmF0b3JcIlxufSk7XG52YXIgS0VZV09SRFMgPSBPYmplY3QuZnJlZXplKHtcbiAgc2V0OiBUT0tFTl9UWVBFUy5TZXQsXG4gIGZvcjogVE9LRU5fVFlQRVMuRm9yLFxuICBpbjogVE9LRU5fVFlQRVMuSW4sXG4gIGlzOiBUT0tFTl9UWVBFUy5JcyxcbiAgaWY6IFRPS0VOX1RZUEVTLklmLFxuICBlbHNlOiBUT0tFTl9UWVBFUy5FbHNlLFxuICBlbmRpZjogVE9LRU5fVFlQRVMuRW5kSWYsXG4gIGVsaWY6IFRPS0VOX1RZUEVTLkVsc2VJZixcbiAgZW5kZm9yOiBUT0tFTl9UWVBFUy5FbmRGb3IsXG4gIGFuZDogVE9LRU5fVFlQRVMuQW5kLFxuICBvcjogVE9LRU5fVFlQRVMuT3IsXG4gIG5vdDogVE9LRU5fVFlQRVMuTm90LFxuICBcIm5vdCBpblwiOiBUT0tFTl9UWVBFUy5Ob3RJbixcbiAgLy8gTGl0ZXJhbHNcbiAgdHJ1ZTogVE9LRU5fVFlQRVMuQm9vbGVhbkxpdGVyYWwsXG4gIGZhbHNlOiBUT0tFTl9UWVBFUy5Cb29sZWFuTGl0ZXJhbFxufSk7XG52YXIgVG9rZW4gPSBjbGFzcyB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgbmV3IFRva2VuLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgVGhlIHJhdyB2YWx1ZSBhcyBzZWVuIGluc2lkZSB0aGUgc291cmNlIGNvZGUuXG4gICAqIEBwYXJhbSB7VG9rZW5UeXBlfSB0eXBlIFRoZSB0eXBlIG9mIHRva2VuLlxuICAgKi9cbiAgY29uc3RydWN0b3IodmFsdWUsIHR5cGUpIHtcbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgfVxufTtcbmZ1bmN0aW9uIGlzV29yZChjaGFyKSB7XG4gIHJldHVybiAvXFx3Ly50ZXN0KGNoYXIpO1xufVxuZnVuY3Rpb24gaXNJbnRlZ2VyKGNoYXIpIHtcbiAgcmV0dXJuIC9bMC05XS8udGVzdChjaGFyKTtcbn1cbnZhciBPUkRFUkVEX01BUFBJTkdfVEFCTEUgPSBbXG4gIC8vIENvbnRyb2wgc2VxdWVuY2VzXG4gIFtcInslXCIsIFRPS0VOX1RZUEVTLk9wZW5TdGF0ZW1lbnRdLFxuICBbXCIlfVwiLCBUT0tFTl9UWVBFUy5DbG9zZVN0YXRlbWVudF0sXG4gIFtcInt7XCIsIFRPS0VOX1RZUEVTLk9wZW5FeHByZXNzaW9uXSxcbiAgW1wifX1cIiwgVE9LRU5fVFlQRVMuQ2xvc2VFeHByZXNzaW9uXSxcbiAgLy8gU2luZ2xlIGNoYXJhY3RlciB0b2tlbnNcbiAgW1wiKFwiLCBUT0tFTl9UWVBFUy5PcGVuUGFyZW5dLFxuICBbXCIpXCIsIFRPS0VOX1RZUEVTLkNsb3NlUGFyZW5dLFxuICBbXCJ7XCIsIFRPS0VOX1RZUEVTLk9wZW5DdXJseUJyYWNrZXRdLFxuICBbXCJ9XCIsIFRPS0VOX1RZUEVTLkNsb3NlQ3VybHlCcmFja2V0XSxcbiAgW1wiW1wiLCBUT0tFTl9UWVBFUy5PcGVuU3F1YXJlQnJhY2tldF0sXG4gIFtcIl1cIiwgVE9LRU5fVFlQRVMuQ2xvc2VTcXVhcmVCcmFja2V0XSxcbiAgW1wiLFwiLCBUT0tFTl9UWVBFUy5Db21tYV0sXG4gIFtcIi5cIiwgVE9LRU5fVFlQRVMuRG90XSxcbiAgW1wiOlwiLCBUT0tFTl9UWVBFUy5Db2xvbl0sXG4gIFtcInxcIiwgVE9LRU5fVFlQRVMuUGlwZV0sXG4gIC8vIENvbXBhcmlzb24gb3BlcmF0b3JzXG4gIFtcIjw9XCIsIFRPS0VOX1RZUEVTLkNvbXBhcmlzb25CaW5hcnlPcGVyYXRvcl0sXG4gIFtcIj49XCIsIFRPS0VOX1RZUEVTLkNvbXBhcmlzb25CaW5hcnlPcGVyYXRvcl0sXG4gIFtcIj09XCIsIFRPS0VOX1RZUEVTLkNvbXBhcmlzb25CaW5hcnlPcGVyYXRvcl0sXG4gIFtcIiE9XCIsIFRPS0VOX1RZUEVTLkNvbXBhcmlzb25CaW5hcnlPcGVyYXRvcl0sXG4gIFtcIjxcIiwgVE9LRU5fVFlQRVMuQ29tcGFyaXNvbkJpbmFyeU9wZXJhdG9yXSxcbiAgW1wiPlwiLCBUT0tFTl9UWVBFUy5Db21wYXJpc29uQmluYXJ5T3BlcmF0b3JdLFxuICAvLyBBcml0aG1ldGljIG9wZXJhdG9yc1xuICBbXCIrXCIsIFRPS0VOX1RZUEVTLkFkZGl0aXZlQmluYXJ5T3BlcmF0b3JdLFxuICBbXCItXCIsIFRPS0VOX1RZUEVTLkFkZGl0aXZlQmluYXJ5T3BlcmF0b3JdLFxuICBbXCIqXCIsIFRPS0VOX1RZUEVTLk11bHRpcGxpY2F0aXZlQmluYXJ5T3BlcmF0b3JdLFxuICBbXCIvXCIsIFRPS0VOX1RZUEVTLk11bHRpcGxpY2F0aXZlQmluYXJ5T3BlcmF0b3JdLFxuICBbXCIlXCIsIFRPS0VOX1RZUEVTLk11bHRpcGxpY2F0aXZlQmluYXJ5T3BlcmF0b3JdLFxuICAvLyBBc3NpZ25tZW50IG9wZXJhdG9yXG4gIFtcIj1cIiwgVE9LRU5fVFlQRVMuRXF1YWxzXVxuXTtcbnZhciBFU0NBUEVfQ0hBUkFDVEVSUyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKFtcbiAgW1wiblwiLCBcIlxcblwiXSxcbiAgLy8gTmV3IGxpbmVcbiAgW1widFwiLCBcIlx0XCJdLFxuICAvLyBIb3Jpem9udGFsIHRhYlxuICBbXCJyXCIsIFwiXFxyXCJdLFxuICAvLyBDYXJyaWFnZSByZXR1cm5cbiAgW1wiYlwiLCBcIlxcYlwiXSxcbiAgLy8gQmFja3NwYWNlXG4gIFtcImZcIiwgXCJcXGZcIl0sXG4gIC8vIEZvcm0gZmVlZFxuICBbXCJ2XCIsIFwiXFx2XCJdLFxuICAvLyBWZXJ0aWNhbCB0YWJcbiAgW1wiJ1wiLCBcIidcIl0sXG4gIC8vIFNpbmdsZSBxdW90ZVxuICBbJ1wiJywgJ1wiJ10sXG4gIC8vIERvdWJsZSBxdW90ZVxuICBbXCJcXFxcXCIsIFwiXFxcXFwiXVxuICAvLyBCYWNrc2xhc2hcbl0pO1xuZnVuY3Rpb24gcHJlcHJvY2Vzcyh0ZW1wbGF0ZSwgb3B0aW9ucyA9IHt9KSB7XG4gIGlmICh0ZW1wbGF0ZS5lbmRzV2l0aChcIlxcblwiKSkge1xuICAgIHRlbXBsYXRlID0gdGVtcGxhdGUuc2xpY2UoMCwgLTEpO1xuICB9XG4gIHRlbXBsYXRlID0gdGVtcGxhdGUucmVwbGFjZSgveyMuKj8jfS9ncywgXCJ7IyN9XCIpO1xuICBpZiAob3B0aW9ucy5sc3RyaXBfYmxvY2tzKSB7XG4gICAgdGVtcGxhdGUgPSB0ZW1wbGF0ZS5yZXBsYWNlKC9eWyBcXHRdKih7WyMlXSkvZ20sIFwiJDFcIik7XG4gIH1cbiAgaWYgKG9wdGlvbnMudHJpbV9ibG9ja3MpIHtcbiAgICB0ZW1wbGF0ZSA9IHRlbXBsYXRlLnJlcGxhY2UoLyhbIyVdfSlcXG4vZywgXCIkMVwiKTtcbiAgfVxuICByZXR1cm4gdGVtcGxhdGUucmVwbGFjZSgveyMjfS9nLCBcIlwiKS5yZXBsYWNlKC8tJX1cXHMqL2csIFwiJX1cIikucmVwbGFjZSgvXFxzKnslLS9nLCBcInslXCIpLnJlcGxhY2UoLy19fVxccyovZywgXCJ9fVwiKS5yZXBsYWNlKC9cXHMqe3stL2csIFwie3tcIik7XG59XG5mdW5jdGlvbiB0b2tlbml6ZShzb3VyY2UsIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB0b2tlbnMgPSBbXTtcbiAgY29uc3Qgc3JjID0gcHJlcHJvY2Vzcyhzb3VyY2UsIG9wdGlvbnMpO1xuICBsZXQgY3Vyc29yUG9zaXRpb24gPSAwO1xuICBjb25zdCBjb25zdW1lV2hpbGUgPSAocHJlZGljYXRlKSA9PiB7XG4gICAgbGV0IHN0ciA9IFwiXCI7XG4gICAgd2hpbGUgKHByZWRpY2F0ZShzcmNbY3Vyc29yUG9zaXRpb25dKSkge1xuICAgICAgaWYgKHNyY1tjdXJzb3JQb3NpdGlvbl0gPT09IFwiXFxcXFwiKSB7XG4gICAgICAgICsrY3Vyc29yUG9zaXRpb247XG4gICAgICAgIGlmIChjdXJzb3JQb3NpdGlvbiA+PSBzcmMubGVuZ3RoKVxuICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihcIlVuZXhwZWN0ZWQgZW5kIG9mIGlucHV0XCIpO1xuICAgICAgICBjb25zdCBlc2NhcGVkID0gc3JjW2N1cnNvclBvc2l0aW9uKytdO1xuICAgICAgICBjb25zdCB1bmVzY2FwZWQgPSBFU0NBUEVfQ0hBUkFDVEVSUy5nZXQoZXNjYXBlZCk7XG4gICAgICAgIGlmICh1bmVzY2FwZWQgPT09IHZvaWQgMCkge1xuICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgVW5leHBlY3RlZCBlc2NhcGVkIGNoYXJhY3RlcjogJHtlc2NhcGVkfWApO1xuICAgICAgICB9XG4gICAgICAgIHN0ciArPSB1bmVzY2FwZWQ7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgc3RyICs9IHNyY1tjdXJzb3JQb3NpdGlvbisrXTtcbiAgICAgIGlmIChjdXJzb3JQb3NpdGlvbiA+PSBzcmMubGVuZ3RoKVxuICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXCJVbmV4cGVjdGVkIGVuZCBvZiBpbnB1dFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0cjtcbiAgfTtcbiAgbWFpbjpcbiAgICB3aGlsZSAoY3Vyc29yUG9zaXRpb24gPCBzcmMubGVuZ3RoKSB7XG4gICAgICBjb25zdCBsYXN0VG9rZW5UeXBlID0gdG9rZW5zLmF0KC0xKT8udHlwZTtcbiAgICAgIGlmIChsYXN0VG9rZW5UeXBlID09PSB2b2lkIDAgfHwgbGFzdFRva2VuVHlwZSA9PT0gVE9LRU5fVFlQRVMuQ2xvc2VTdGF0ZW1lbnQgfHwgbGFzdFRva2VuVHlwZSA9PT0gVE9LRU5fVFlQRVMuQ2xvc2VFeHByZXNzaW9uKSB7XG4gICAgICAgIGxldCB0ZXh0ID0gXCJcIjtcbiAgICAgICAgd2hpbGUgKGN1cnNvclBvc2l0aW9uIDwgc3JjLmxlbmd0aCAmJiAvLyBLZWVwIGdvaW5nIHVudGlsIHdlIGhpdCB0aGUgbmV4dCBKaW5qYSBzdGF0ZW1lbnQgb3IgZXhwcmVzc2lvblxuICAgICAgICAhKHNyY1tjdXJzb3JQb3NpdGlvbl0gPT09IFwie1wiICYmIChzcmNbY3Vyc29yUG9zaXRpb24gKyAxXSA9PT0gXCIlXCIgfHwgc3JjW2N1cnNvclBvc2l0aW9uICsgMV0gPT09IFwie1wiKSkpIHtcbiAgICAgICAgICB0ZXh0ICs9IHNyY1tjdXJzb3JQb3NpdGlvbisrXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGV4dC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgdG9rZW5zLnB1c2gobmV3IFRva2VuKHRleHQsIFRPS0VOX1RZUEVTLlRleHQpKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3VtZVdoaWxlKChjaGFyMikgPT4gL1xccy8udGVzdChjaGFyMikpO1xuICAgICAgY29uc3QgY2hhciA9IHNyY1tjdXJzb3JQb3NpdGlvbl07XG4gICAgICBpZiAoY2hhciA9PT0gXCItXCIgfHwgY2hhciA9PT0gXCIrXCIpIHtcbiAgICAgICAgY29uc3QgbGFzdFRva2VuVHlwZTIgPSB0b2tlbnMuYXQoLTEpPy50eXBlO1xuICAgICAgICBpZiAobGFzdFRva2VuVHlwZTIgPT09IFRPS0VOX1RZUEVTLlRleHQgfHwgbGFzdFRva2VuVHlwZTIgPT09IHZvaWQgMCkge1xuICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgVW5leHBlY3RlZCBjaGFyYWN0ZXI6ICR7Y2hhcn1gKTtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKGxhc3RUb2tlblR5cGUyKSB7XG4gICAgICAgICAgY2FzZSBUT0tFTl9UWVBFUy5JZGVudGlmaWVyOlxuICAgICAgICAgIGNhc2UgVE9LRU5fVFlQRVMuTnVtZXJpY0xpdGVyYWw6XG4gICAgICAgICAgY2FzZSBUT0tFTl9UWVBFUy5Cb29sZWFuTGl0ZXJhbDpcbiAgICAgICAgICBjYXNlIFRPS0VOX1RZUEVTLlN0cmluZ0xpdGVyYWw6XG4gICAgICAgICAgY2FzZSBUT0tFTl9UWVBFUy5DbG9zZVBhcmVuOlxuICAgICAgICAgIGNhc2UgVE9LRU5fVFlQRVMuQ2xvc2VTcXVhcmVCcmFja2V0OlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgKytjdXJzb3JQb3NpdGlvbjtcbiAgICAgICAgICAgIGNvbnN0IG51bSA9IGNvbnN1bWVXaGlsZShpc0ludGVnZXIpO1xuICAgICAgICAgICAgdG9rZW5zLnB1c2goXG4gICAgICAgICAgICAgIG5ldyBUb2tlbihgJHtjaGFyfSR7bnVtfWAsIG51bS5sZW5ndGggPiAwID8gVE9LRU5fVFlQRVMuTnVtZXJpY0xpdGVyYWwgOiBUT0tFTl9UWVBFUy5VbmFyeU9wZXJhdG9yKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBbY2hhcjIsIHRva2VuXSBvZiBPUkRFUkVEX01BUFBJTkdfVEFCTEUpIHtcbiAgICAgICAgY29uc3Qgc2xpY2UyID0gc3JjLnNsaWNlKGN1cnNvclBvc2l0aW9uLCBjdXJzb3JQb3NpdGlvbiArIGNoYXIyLmxlbmd0aCk7XG4gICAgICAgIGlmIChzbGljZTIgPT09IGNoYXIyKSB7XG4gICAgICAgICAgdG9rZW5zLnB1c2gobmV3IFRva2VuKGNoYXIyLCB0b2tlbikpO1xuICAgICAgICAgIGN1cnNvclBvc2l0aW9uICs9IGNoYXIyLmxlbmd0aDtcbiAgICAgICAgICBjb250aW51ZSBtYWluO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoY2hhciA9PT0gXCInXCIgfHwgY2hhciA9PT0gJ1wiJykge1xuICAgICAgICArK2N1cnNvclBvc2l0aW9uO1xuICAgICAgICBjb25zdCBzdHIgPSBjb25zdW1lV2hpbGUoKGMpID0+IGMgIT09IGNoYXIpO1xuICAgICAgICB0b2tlbnMucHVzaChuZXcgVG9rZW4oc3RyLCBUT0tFTl9UWVBFUy5TdHJpbmdMaXRlcmFsKSk7XG4gICAgICAgICsrY3Vyc29yUG9zaXRpb247XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKGlzSW50ZWdlcihjaGFyKSkge1xuICAgICAgICBjb25zdCBudW0gPSBjb25zdW1lV2hpbGUoaXNJbnRlZ2VyKTtcbiAgICAgICAgdG9rZW5zLnB1c2gobmV3IFRva2VuKG51bSwgVE9LRU5fVFlQRVMuTnVtZXJpY0xpdGVyYWwpKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoaXNXb3JkKGNoYXIpKSB7XG4gICAgICAgIGNvbnN0IHdvcmQgPSBjb25zdW1lV2hpbGUoaXNXb3JkKTtcbiAgICAgICAgY29uc3QgdHlwZSA9IE9iamVjdC5oYXNPd24oS0VZV09SRFMsIHdvcmQpID8gS0VZV09SRFNbd29yZF0gOiBUT0tFTl9UWVBFUy5JZGVudGlmaWVyO1xuICAgICAgICBpZiAodHlwZSA9PT0gVE9LRU5fVFlQRVMuSW4gJiYgdG9rZW5zLmF0KC0xKT8udHlwZSA9PT0gVE9LRU5fVFlQRVMuTm90KSB7XG4gICAgICAgICAgdG9rZW5zLnBvcCgpO1xuICAgICAgICAgIHRva2Vucy5wdXNoKG5ldyBUb2tlbihcIm5vdCBpblwiLCBUT0tFTl9UWVBFUy5Ob3RJbikpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRva2Vucy5wdXNoKG5ldyBUb2tlbih3b3JkLCB0eXBlKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYFVuZXhwZWN0ZWQgY2hhcmFjdGVyOiAke2NoYXJ9YCk7XG4gICAgfVxuICByZXR1cm4gdG9rZW5zO1xufVxuXG4vLyBzcmMvYXN0LnRzXG52YXIgU3RhdGVtZW50ID0gY2xhc3Mge1xuICB0eXBlID0gXCJTdGF0ZW1lbnRcIjtcbn07XG52YXIgUHJvZ3JhbSA9IGNsYXNzIGV4dGVuZHMgU3RhdGVtZW50IHtcbiAgY29uc3RydWN0b3IoYm9keSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgfVxuICB0eXBlID0gXCJQcm9ncmFtXCI7XG59O1xudmFyIElmID0gY2xhc3MgZXh0ZW5kcyBTdGF0ZW1lbnQge1xuICBjb25zdHJ1Y3Rvcih0ZXN0LCBib2R5LCBhbHRlcm5hdGUpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMudGVzdCA9IHRlc3Q7XG4gICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICB0aGlzLmFsdGVybmF0ZSA9IGFsdGVybmF0ZTtcbiAgfVxuICB0eXBlID0gXCJJZlwiO1xufTtcbnZhciBGb3IgPSBjbGFzcyBleHRlbmRzIFN0YXRlbWVudCB7XG4gIGNvbnN0cnVjdG9yKGxvb3B2YXIsIGl0ZXJhYmxlLCBib2R5KSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmxvb3B2YXIgPSBsb29wdmFyO1xuICAgIHRoaXMuaXRlcmFibGUgPSBpdGVyYWJsZTtcbiAgICB0aGlzLmJvZHkgPSBib2R5O1xuICB9XG4gIHR5cGUgPSBcIkZvclwiO1xufTtcbnZhciBTZXRTdGF0ZW1lbnQgPSBjbGFzcyBleHRlbmRzIFN0YXRlbWVudCB7XG4gIGNvbnN0cnVjdG9yKGFzc2lnbmVlLCB2YWx1ZSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5hc3NpZ25lZSA9IGFzc2lnbmVlO1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICB0eXBlID0gXCJTZXRcIjtcbn07XG52YXIgRXhwcmVzc2lvbiA9IGNsYXNzIGV4dGVuZHMgU3RhdGVtZW50IHtcbiAgdHlwZSA9IFwiRXhwcmVzc2lvblwiO1xufTtcbnZhciBNZW1iZXJFeHByZXNzaW9uID0gY2xhc3MgZXh0ZW5kcyBFeHByZXNzaW9uIHtcbiAgY29uc3RydWN0b3Iob2JqZWN0LCBwcm9wZXJ0eSwgY29tcHV0ZWQpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMub2JqZWN0ID0gb2JqZWN0O1xuICAgIHRoaXMucHJvcGVydHkgPSBwcm9wZXJ0eTtcbiAgICB0aGlzLmNvbXB1dGVkID0gY29tcHV0ZWQ7XG4gIH1cbiAgdHlwZSA9IFwiTWVtYmVyRXhwcmVzc2lvblwiO1xufTtcbnZhciBDYWxsRXhwcmVzc2lvbiA9IGNsYXNzIGV4dGVuZHMgRXhwcmVzc2lvbiB7XG4gIGNvbnN0cnVjdG9yKGNhbGxlZSwgYXJncykge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5jYWxsZWUgPSBjYWxsZWU7XG4gICAgdGhpcy5hcmdzID0gYXJncztcbiAgfVxuICB0eXBlID0gXCJDYWxsRXhwcmVzc2lvblwiO1xufTtcbnZhciBJZGVudGlmaWVyID0gY2xhc3MgZXh0ZW5kcyBFeHByZXNzaW9uIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSBUaGUgbmFtZSBvZiB0aGUgaWRlbnRpZmllclxuICAgKi9cbiAgY29uc3RydWN0b3IodmFsdWUpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICB0eXBlID0gXCJJZGVudGlmaWVyXCI7XG59O1xudmFyIExpdGVyYWwgPSBjbGFzcyBleHRlbmRzIEV4cHJlc3Npb24ge1xuICBjb25zdHJ1Y3Rvcih2YWx1ZSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIHR5cGUgPSBcIkxpdGVyYWxcIjtcbn07XG52YXIgTnVtZXJpY0xpdGVyYWwgPSBjbGFzcyBleHRlbmRzIExpdGVyYWwge1xuICB0eXBlID0gXCJOdW1lcmljTGl0ZXJhbFwiO1xufTtcbnZhciBTdHJpbmdMaXRlcmFsID0gY2xhc3MgZXh0ZW5kcyBMaXRlcmFsIHtcbiAgdHlwZSA9IFwiU3RyaW5nTGl0ZXJhbFwiO1xufTtcbnZhciBCb29sZWFuTGl0ZXJhbCA9IGNsYXNzIGV4dGVuZHMgTGl0ZXJhbCB7XG4gIHR5cGUgPSBcIkJvb2xlYW5MaXRlcmFsXCI7XG59O1xudmFyIEFycmF5TGl0ZXJhbCA9IGNsYXNzIGV4dGVuZHMgTGl0ZXJhbCB7XG4gIHR5cGUgPSBcIkFycmF5TGl0ZXJhbFwiO1xufTtcbnZhciBUdXBsZUxpdGVyYWwgPSBjbGFzcyBleHRlbmRzIExpdGVyYWwge1xuICB0eXBlID0gXCJUdXBsZUxpdGVyYWxcIjtcbn07XG52YXIgT2JqZWN0TGl0ZXJhbCA9IGNsYXNzIGV4dGVuZHMgTGl0ZXJhbCB7XG4gIHR5cGUgPSBcIk9iamVjdExpdGVyYWxcIjtcbn07XG52YXIgQmluYXJ5RXhwcmVzc2lvbiA9IGNsYXNzIGV4dGVuZHMgRXhwcmVzc2lvbiB7XG4gIGNvbnN0cnVjdG9yKG9wZXJhdG9yLCBsZWZ0LCByaWdodCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5vcGVyYXRvciA9IG9wZXJhdG9yO1xuICAgIHRoaXMubGVmdCA9IGxlZnQ7XG4gICAgdGhpcy5yaWdodCA9IHJpZ2h0O1xuICB9XG4gIHR5cGUgPSBcIkJpbmFyeUV4cHJlc3Npb25cIjtcbn07XG52YXIgRmlsdGVyRXhwcmVzc2lvbiA9IGNsYXNzIGV4dGVuZHMgRXhwcmVzc2lvbiB7XG4gIGNvbnN0cnVjdG9yKG9wZXJhbmQsIGZpbHRlcikge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5vcGVyYW5kID0gb3BlcmFuZDtcbiAgICB0aGlzLmZpbHRlciA9IGZpbHRlcjtcbiAgfVxuICB0eXBlID0gXCJGaWx0ZXJFeHByZXNzaW9uXCI7XG59O1xudmFyIFRlc3RFeHByZXNzaW9uID0gY2xhc3MgZXh0ZW5kcyBFeHByZXNzaW9uIHtcbiAgY29uc3RydWN0b3Iob3BlcmFuZCwgbmVnYXRlLCB0ZXN0KSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLm9wZXJhbmQgPSBvcGVyYW5kO1xuICAgIHRoaXMubmVnYXRlID0gbmVnYXRlO1xuICAgIHRoaXMudGVzdCA9IHRlc3Q7XG4gIH1cbiAgdHlwZSA9IFwiVGVzdEV4cHJlc3Npb25cIjtcbn07XG52YXIgVW5hcnlFeHByZXNzaW9uID0gY2xhc3MgZXh0ZW5kcyBFeHByZXNzaW9uIHtcbiAgY29uc3RydWN0b3Iob3BlcmF0b3IsIGFyZ3VtZW50KSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLm9wZXJhdG9yID0gb3BlcmF0b3I7XG4gICAgdGhpcy5hcmd1bWVudCA9IGFyZ3VtZW50O1xuICB9XG4gIHR5cGUgPSBcIlVuYXJ5RXhwcmVzc2lvblwiO1xufTtcbnZhciBTbGljZUV4cHJlc3Npb24gPSBjbGFzcyBleHRlbmRzIEV4cHJlc3Npb24ge1xuICBjb25zdHJ1Y3RvcihzdGFydCA9IHZvaWQgMCwgc3RvcCA9IHZvaWQgMCwgc3RlcCA9IHZvaWQgMCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5zdGFydCA9IHN0YXJ0O1xuICAgIHRoaXMuc3RvcCA9IHN0b3A7XG4gICAgdGhpcy5zdGVwID0gc3RlcDtcbiAgfVxuICB0eXBlID0gXCJTbGljZUV4cHJlc3Npb25cIjtcbn07XG52YXIgS2V5d29yZEFyZ3VtZW50RXhwcmVzc2lvbiA9IGNsYXNzIGV4dGVuZHMgRXhwcmVzc2lvbiB7XG4gIGNvbnN0cnVjdG9yKGtleSwgdmFsdWUpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMua2V5ID0ga2V5O1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICB0eXBlID0gXCJLZXl3b3JkQXJndW1lbnRFeHByZXNzaW9uXCI7XG59O1xuXG4vLyBzcmMvcGFyc2VyLnRzXG5mdW5jdGlvbiBwYXJzZSh0b2tlbnMpIHtcbiAgY29uc3QgcHJvZ3JhbSA9IG5ldyBQcm9ncmFtKFtdKTtcbiAgbGV0IGN1cnJlbnQgPSAwO1xuICBmdW5jdGlvbiBleHBlY3QodHlwZSwgZXJyb3IpIHtcbiAgICBjb25zdCBwcmV2ID0gdG9rZW5zW2N1cnJlbnQrK107XG4gICAgaWYgKCFwcmV2IHx8IHByZXYudHlwZSAhPT0gdHlwZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBQYXJzZXIgRXJyb3I6ICR7ZXJyb3J9LiAke3ByZXYudHlwZX0gIT09ICR7dHlwZX0uYCk7XG4gICAgfVxuICAgIHJldHVybiBwcmV2O1xuICB9XG4gIGZ1bmN0aW9uIHBhcnNlQW55KCkge1xuICAgIHN3aXRjaCAodG9rZW5zW2N1cnJlbnRdLnR5cGUpIHtcbiAgICAgIGNhc2UgVE9LRU5fVFlQRVMuVGV4dDpcbiAgICAgICAgcmV0dXJuIHBhcnNlVGV4dCgpO1xuICAgICAgY2FzZSBUT0tFTl9UWVBFUy5PcGVuU3RhdGVtZW50OlxuICAgICAgICByZXR1cm4gcGFyc2VKaW5qYVN0YXRlbWVudCgpO1xuICAgICAgY2FzZSBUT0tFTl9UWVBFUy5PcGVuRXhwcmVzc2lvbjpcbiAgICAgICAgcmV0dXJuIHBhcnNlSmluamFFeHByZXNzaW9uKCk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYFVuZXhwZWN0ZWQgdG9rZW4gdHlwZTogJHt0b2tlbnNbY3VycmVudF0udHlwZX1gKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gbm90KC4uLnR5cGVzKSB7XG4gICAgcmV0dXJuIGN1cnJlbnQgKyB0eXBlcy5sZW5ndGggPD0gdG9rZW5zLmxlbmd0aCAmJiB0eXBlcy5zb21lKCh0eXBlLCBpKSA9PiB0eXBlICE9PSB0b2tlbnNbY3VycmVudCArIGldLnR5cGUpO1xuICB9XG4gIGZ1bmN0aW9uIGlzKC4uLnR5cGVzKSB7XG4gICAgcmV0dXJuIGN1cnJlbnQgKyB0eXBlcy5sZW5ndGggPD0gdG9rZW5zLmxlbmd0aCAmJiB0eXBlcy5ldmVyeSgodHlwZSwgaSkgPT4gdHlwZSA9PT0gdG9rZW5zW2N1cnJlbnQgKyBpXS50eXBlKTtcbiAgfVxuICBmdW5jdGlvbiBwYXJzZVRleHQoKSB7XG4gICAgcmV0dXJuIG5ldyBTdHJpbmdMaXRlcmFsKGV4cGVjdChUT0tFTl9UWVBFUy5UZXh0LCBcIkV4cGVjdGVkIHRleHQgdG9rZW5cIikudmFsdWUpO1xuICB9XG4gIGZ1bmN0aW9uIHBhcnNlSmluamFTdGF0ZW1lbnQoKSB7XG4gICAgZXhwZWN0KFRPS0VOX1RZUEVTLk9wZW5TdGF0ZW1lbnQsIFwiRXhwZWN0ZWQgb3BlbmluZyBzdGF0ZW1lbnQgdG9rZW5cIik7XG4gICAgbGV0IHJlc3VsdDtcbiAgICBzd2l0Y2ggKHRva2Vuc1tjdXJyZW50XS50eXBlKSB7XG4gICAgICBjYXNlIFRPS0VOX1RZUEVTLlNldDpcbiAgICAgICAgKytjdXJyZW50O1xuICAgICAgICByZXN1bHQgPSBwYXJzZVNldFN0YXRlbWVudCgpO1xuICAgICAgICBleHBlY3QoVE9LRU5fVFlQRVMuQ2xvc2VTdGF0ZW1lbnQsIFwiRXhwZWN0ZWQgY2xvc2luZyBzdGF0ZW1lbnQgdG9rZW5cIik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBUT0tFTl9UWVBFUy5JZjpcbiAgICAgICAgKytjdXJyZW50O1xuICAgICAgICByZXN1bHQgPSBwYXJzZUlmU3RhdGVtZW50KCk7XG4gICAgICAgIGV4cGVjdChUT0tFTl9UWVBFUy5PcGVuU3RhdGVtZW50LCBcIkV4cGVjdGVkIHslIHRva2VuXCIpO1xuICAgICAgICBleHBlY3QoVE9LRU5fVFlQRVMuRW5kSWYsIFwiRXhwZWN0ZWQgZW5kaWYgdG9rZW5cIik7XG4gICAgICAgIGV4cGVjdChUT0tFTl9UWVBFUy5DbG9zZVN0YXRlbWVudCwgXCJFeHBlY3RlZCAlfSB0b2tlblwiKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFRPS0VOX1RZUEVTLkZvcjpcbiAgICAgICAgKytjdXJyZW50O1xuICAgICAgICByZXN1bHQgPSBwYXJzZUZvclN0YXRlbWVudCgpO1xuICAgICAgICBleHBlY3QoVE9LRU5fVFlQRVMuT3BlblN0YXRlbWVudCwgXCJFeHBlY3RlZCB7JSB0b2tlblwiKTtcbiAgICAgICAgZXhwZWN0KFRPS0VOX1RZUEVTLkVuZEZvciwgXCJFeHBlY3RlZCBlbmRmb3IgdG9rZW5cIik7XG4gICAgICAgIGV4cGVjdChUT0tFTl9UWVBFUy5DbG9zZVN0YXRlbWVudCwgXCJFeHBlY3RlZCAlfSB0b2tlblwiKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYFVua25vd24gc3RhdGVtZW50IHR5cGU6ICR7dG9rZW5zW2N1cnJlbnRdLnR5cGV9YCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgZnVuY3Rpb24gcGFyc2VKaW5qYUV4cHJlc3Npb24oKSB7XG4gICAgZXhwZWN0KFRPS0VOX1RZUEVTLk9wZW5FeHByZXNzaW9uLCBcIkV4cGVjdGVkIG9wZW5pbmcgZXhwcmVzc2lvbiB0b2tlblwiKTtcbiAgICBjb25zdCByZXN1bHQgPSBwYXJzZUV4cHJlc3Npb24oKTtcbiAgICBleHBlY3QoVE9LRU5fVFlQRVMuQ2xvc2VFeHByZXNzaW9uLCBcIkV4cGVjdGVkIGNsb3NpbmcgZXhwcmVzc2lvbiB0b2tlblwiKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGZ1bmN0aW9uIHBhcnNlU2V0U3RhdGVtZW50KCkge1xuICAgIGNvbnN0IGxlZnQgPSBwYXJzZUV4cHJlc3Npb24oKTtcbiAgICBpZiAoaXMoVE9LRU5fVFlQRVMuRXF1YWxzKSkge1xuICAgICAgKytjdXJyZW50O1xuICAgICAgY29uc3QgdmFsdWUgPSBwYXJzZVNldFN0YXRlbWVudCgpO1xuICAgICAgcmV0dXJuIG5ldyBTZXRTdGF0ZW1lbnQobGVmdCwgdmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gbGVmdDtcbiAgfVxuICBmdW5jdGlvbiBwYXJzZUlmU3RhdGVtZW50KCkge1xuICAgIGNvbnN0IHRlc3QgPSBwYXJzZUV4cHJlc3Npb24oKTtcbiAgICBleHBlY3QoVE9LRU5fVFlQRVMuQ2xvc2VTdGF0ZW1lbnQsIFwiRXhwZWN0ZWQgY2xvc2luZyBzdGF0ZW1lbnQgdG9rZW5cIik7XG4gICAgY29uc3QgYm9keSA9IFtdO1xuICAgIGNvbnN0IGFsdGVybmF0ZSA9IFtdO1xuICAgIHdoaWxlICghKHRva2Vuc1tjdXJyZW50XT8udHlwZSA9PT0gVE9LRU5fVFlQRVMuT3BlblN0YXRlbWVudCAmJiAodG9rZW5zW2N1cnJlbnQgKyAxXT8udHlwZSA9PT0gVE9LRU5fVFlQRVMuRWxzZUlmIHx8IHRva2Vuc1tjdXJyZW50ICsgMV0/LnR5cGUgPT09IFRPS0VOX1RZUEVTLkVsc2UgfHwgdG9rZW5zW2N1cnJlbnQgKyAxXT8udHlwZSA9PT0gVE9LRU5fVFlQRVMuRW5kSWYpKSkge1xuICAgICAgYm9keS5wdXNoKHBhcnNlQW55KCkpO1xuICAgIH1cbiAgICBpZiAodG9rZW5zW2N1cnJlbnRdPy50eXBlID09PSBUT0tFTl9UWVBFUy5PcGVuU3RhdGVtZW50ICYmIHRva2Vuc1tjdXJyZW50ICsgMV0/LnR5cGUgIT09IFRPS0VOX1RZUEVTLkVuZElmKSB7XG4gICAgICArK2N1cnJlbnQ7XG4gICAgICBpZiAoaXMoVE9LRU5fVFlQRVMuRWxzZUlmKSkge1xuICAgICAgICBleHBlY3QoVE9LRU5fVFlQRVMuRWxzZUlmLCBcIkV4cGVjdGVkIGVsc2VpZiB0b2tlblwiKTtcbiAgICAgICAgYWx0ZXJuYXRlLnB1c2gocGFyc2VJZlN0YXRlbWVudCgpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGV4cGVjdChUT0tFTl9UWVBFUy5FbHNlLCBcIkV4cGVjdGVkIGVsc2UgdG9rZW5cIik7XG4gICAgICAgIGV4cGVjdChUT0tFTl9UWVBFUy5DbG9zZVN0YXRlbWVudCwgXCJFeHBlY3RlZCBjbG9zaW5nIHN0YXRlbWVudCB0b2tlblwiKTtcbiAgICAgICAgd2hpbGUgKCEodG9rZW5zW2N1cnJlbnRdPy50eXBlID09PSBUT0tFTl9UWVBFUy5PcGVuU3RhdGVtZW50ICYmIHRva2Vuc1tjdXJyZW50ICsgMV0/LnR5cGUgPT09IFRPS0VOX1RZUEVTLkVuZElmKSkge1xuICAgICAgICAgIGFsdGVybmF0ZS5wdXNoKHBhcnNlQW55KCkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXcgSWYodGVzdCwgYm9keSwgYWx0ZXJuYXRlKTtcbiAgfVxuICBmdW5jdGlvbiBwYXJzZUV4cHJlc3Npb25TZXF1ZW5jZShwcmltYXJ5ID0gZmFsc2UpIHtcbiAgICBjb25zdCBmbiA9IHByaW1hcnkgPyBwYXJzZVByaW1hcnlFeHByZXNzaW9uIDogcGFyc2VFeHByZXNzaW9uO1xuICAgIGNvbnN0IGV4cHJlc3Npb25zID0gW2ZuKCldO1xuICAgIGNvbnN0IGlzVHVwbGUgPSBpcyhUT0tFTl9UWVBFUy5Db21tYSk7XG4gICAgd2hpbGUgKGlzVHVwbGUpIHtcbiAgICAgICsrY3VycmVudDtcbiAgICAgIGV4cHJlc3Npb25zLnB1c2goZm4oKSk7XG4gICAgICBpZiAoIWlzKFRPS0VOX1RZUEVTLkNvbW1hKSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGlzVHVwbGUgPyBuZXcgVHVwbGVMaXRlcmFsKGV4cHJlc3Npb25zKSA6IGV4cHJlc3Npb25zWzBdO1xuICB9XG4gIGZ1bmN0aW9uIHBhcnNlRm9yU3RhdGVtZW50KCkge1xuICAgIGNvbnN0IGxvb3BWYXJpYWJsZSA9IHBhcnNlRXhwcmVzc2lvblNlcXVlbmNlKHRydWUpO1xuICAgIGlmICghKGxvb3BWYXJpYWJsZSBpbnN0YW5jZW9mIElkZW50aWZpZXIgfHwgbG9vcFZhcmlhYmxlIGluc3RhbmNlb2YgVHVwbGVMaXRlcmFsKSkge1xuICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBFeHBlY3RlZCBpZGVudGlmaWVyL3R1cGxlIGZvciB0aGUgbG9vcCB2YXJpYWJsZSwgZ290ICR7bG9vcFZhcmlhYmxlLnR5cGV9IGluc3RlYWRgKTtcbiAgICB9XG4gICAgZXhwZWN0KFRPS0VOX1RZUEVTLkluLCBcIkV4cGVjdGVkIGBpbmAga2V5d29yZCBmb2xsb3dpbmcgbG9vcCB2YXJpYWJsZVwiKTtcbiAgICBjb25zdCBpdGVyYWJsZSA9IHBhcnNlRXhwcmVzc2lvbigpO1xuICAgIGV4cGVjdChUT0tFTl9UWVBFUy5DbG9zZVN0YXRlbWVudCwgXCJFeHBlY3RlZCBjbG9zaW5nIHN0YXRlbWVudCB0b2tlblwiKTtcbiAgICBjb25zdCBib2R5ID0gW107XG4gICAgd2hpbGUgKG5vdChUT0tFTl9UWVBFUy5PcGVuU3RhdGVtZW50LCBUT0tFTl9UWVBFUy5FbmRGb3IpKSB7XG4gICAgICBib2R5LnB1c2gocGFyc2VBbnkoKSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgRm9yKGxvb3BWYXJpYWJsZSwgaXRlcmFibGUsIGJvZHkpO1xuICB9XG4gIGZ1bmN0aW9uIHBhcnNlRXhwcmVzc2lvbigpIHtcbiAgICByZXR1cm4gcGFyc2VUZXJuYXJ5RXhwcmVzc2lvbigpO1xuICB9XG4gIGZ1bmN0aW9uIHBhcnNlVGVybmFyeUV4cHJlc3Npb24oKSB7XG4gICAgY29uc3QgYSA9IHBhcnNlTG9naWNhbE9yRXhwcmVzc2lvbigpO1xuICAgIGlmIChpcyhUT0tFTl9UWVBFUy5JZikpIHtcbiAgICAgICsrY3VycmVudDtcbiAgICAgIGNvbnN0IHByZWRpY2F0ZSA9IHBhcnNlTG9naWNhbE9yRXhwcmVzc2lvbigpO1xuICAgICAgZXhwZWN0KFRPS0VOX1RZUEVTLkVsc2UsIFwiRXhwZWN0ZWQgZWxzZSB0b2tlblwiKTtcbiAgICAgIGNvbnN0IGIgPSBwYXJzZUxvZ2ljYWxPckV4cHJlc3Npb24oKTtcbiAgICAgIHJldHVybiBuZXcgSWYocHJlZGljYXRlLCBbYV0sIFtiXSk7XG4gICAgfVxuICAgIHJldHVybiBhO1xuICB9XG4gIGZ1bmN0aW9uIHBhcnNlTG9naWNhbE9yRXhwcmVzc2lvbigpIHtcbiAgICBsZXQgbGVmdCA9IHBhcnNlTG9naWNhbEFuZEV4cHJlc3Npb24oKTtcbiAgICB3aGlsZSAoaXMoVE9LRU5fVFlQRVMuT3IpKSB7XG4gICAgICBjb25zdCBvcGVyYXRvciA9IHRva2Vuc1tjdXJyZW50XTtcbiAgICAgICsrY3VycmVudDtcbiAgICAgIGNvbnN0IHJpZ2h0ID0gcGFyc2VMb2dpY2FsQW5kRXhwcmVzc2lvbigpO1xuICAgICAgbGVmdCA9IG5ldyBCaW5hcnlFeHByZXNzaW9uKG9wZXJhdG9yLCBsZWZ0LCByaWdodCk7XG4gICAgfVxuICAgIHJldHVybiBsZWZ0O1xuICB9XG4gIGZ1bmN0aW9uIHBhcnNlTG9naWNhbEFuZEV4cHJlc3Npb24oKSB7XG4gICAgbGV0IGxlZnQgPSBwYXJzZUxvZ2ljYWxOZWdhdGlvbkV4cHJlc3Npb24oKTtcbiAgICB3aGlsZSAoaXMoVE9LRU5fVFlQRVMuQW5kKSkge1xuICAgICAgY29uc3Qgb3BlcmF0b3IgPSB0b2tlbnNbY3VycmVudF07XG4gICAgICArK2N1cnJlbnQ7XG4gICAgICBjb25zdCByaWdodCA9IHBhcnNlTG9naWNhbE5lZ2F0aW9uRXhwcmVzc2lvbigpO1xuICAgICAgbGVmdCA9IG5ldyBCaW5hcnlFeHByZXNzaW9uKG9wZXJhdG9yLCBsZWZ0LCByaWdodCk7XG4gICAgfVxuICAgIHJldHVybiBsZWZ0O1xuICB9XG4gIGZ1bmN0aW9uIHBhcnNlTG9naWNhbE5lZ2F0aW9uRXhwcmVzc2lvbigpIHtcbiAgICBsZXQgcmlnaHQ7XG4gICAgd2hpbGUgKGlzKFRPS0VOX1RZUEVTLk5vdCkpIHtcbiAgICAgIGNvbnN0IG9wZXJhdG9yID0gdG9rZW5zW2N1cnJlbnRdO1xuICAgICAgKytjdXJyZW50O1xuICAgICAgY29uc3QgYXJnID0gcGFyc2VMb2dpY2FsTmVnYXRpb25FeHByZXNzaW9uKCk7XG4gICAgICByaWdodCA9IG5ldyBVbmFyeUV4cHJlc3Npb24ob3BlcmF0b3IsIGFyZyk7XG4gICAgfVxuICAgIHJldHVybiByaWdodCA/PyBwYXJzZUNvbXBhcmlzb25FeHByZXNzaW9uKCk7XG4gIH1cbiAgZnVuY3Rpb24gcGFyc2VDb21wYXJpc29uRXhwcmVzc2lvbigpIHtcbiAgICBsZXQgbGVmdCA9IHBhcnNlQWRkaXRpdmVFeHByZXNzaW9uKCk7XG4gICAgd2hpbGUgKGlzKFRPS0VOX1RZUEVTLkNvbXBhcmlzb25CaW5hcnlPcGVyYXRvcikgfHwgaXMoVE9LRU5fVFlQRVMuSW4pIHx8IGlzKFRPS0VOX1RZUEVTLk5vdEluKSkge1xuICAgICAgY29uc3Qgb3BlcmF0b3IgPSB0b2tlbnNbY3VycmVudF07XG4gICAgICArK2N1cnJlbnQ7XG4gICAgICBjb25zdCByaWdodCA9IHBhcnNlQWRkaXRpdmVFeHByZXNzaW9uKCk7XG4gICAgICBsZWZ0ID0gbmV3IEJpbmFyeUV4cHJlc3Npb24ob3BlcmF0b3IsIGxlZnQsIHJpZ2h0KTtcbiAgICB9XG4gICAgcmV0dXJuIGxlZnQ7XG4gIH1cbiAgZnVuY3Rpb24gcGFyc2VBZGRpdGl2ZUV4cHJlc3Npb24oKSB7XG4gICAgbGV0IGxlZnQgPSBwYXJzZU11bHRpcGxpY2F0aXZlRXhwcmVzc2lvbigpO1xuICAgIHdoaWxlIChpcyhUT0tFTl9UWVBFUy5BZGRpdGl2ZUJpbmFyeU9wZXJhdG9yKSkge1xuICAgICAgY29uc3Qgb3BlcmF0b3IgPSB0b2tlbnNbY3VycmVudF07XG4gICAgICArK2N1cnJlbnQ7XG4gICAgICBjb25zdCByaWdodCA9IHBhcnNlTXVsdGlwbGljYXRpdmVFeHByZXNzaW9uKCk7XG4gICAgICBsZWZ0ID0gbmV3IEJpbmFyeUV4cHJlc3Npb24ob3BlcmF0b3IsIGxlZnQsIHJpZ2h0KTtcbiAgICB9XG4gICAgcmV0dXJuIGxlZnQ7XG4gIH1cbiAgZnVuY3Rpb24gcGFyc2VDYWxsTWVtYmVyRXhwcmVzc2lvbigpIHtcbiAgICBjb25zdCBtZW1iZXIgPSBwYXJzZU1lbWJlckV4cHJlc3Npb24oKTtcbiAgICBpZiAoaXMoVE9LRU5fVFlQRVMuT3BlblBhcmVuKSkge1xuICAgICAgcmV0dXJuIHBhcnNlQ2FsbEV4cHJlc3Npb24obWVtYmVyKTtcbiAgICB9XG4gICAgcmV0dXJuIG1lbWJlcjtcbiAgfVxuICBmdW5jdGlvbiBwYXJzZUNhbGxFeHByZXNzaW9uKGNhbGxlZSkge1xuICAgIGxldCBjYWxsRXhwcmVzc2lvbiA9IG5ldyBDYWxsRXhwcmVzc2lvbihjYWxsZWUsIHBhcnNlQXJncygpKTtcbiAgICBpZiAoaXMoVE9LRU5fVFlQRVMuT3BlblBhcmVuKSkge1xuICAgICAgY2FsbEV4cHJlc3Npb24gPSBwYXJzZUNhbGxFeHByZXNzaW9uKGNhbGxFeHByZXNzaW9uKTtcbiAgICB9XG4gICAgcmV0dXJuIGNhbGxFeHByZXNzaW9uO1xuICB9XG4gIGZ1bmN0aW9uIHBhcnNlQXJncygpIHtcbiAgICBleHBlY3QoVE9LRU5fVFlQRVMuT3BlblBhcmVuLCBcIkV4cGVjdGVkIG9wZW5pbmcgcGFyZW50aGVzaXMgZm9yIGFyZ3VtZW50cyBsaXN0XCIpO1xuICAgIGNvbnN0IGFyZ3MgPSBwYXJzZUFyZ3VtZW50c0xpc3QoKTtcbiAgICBleHBlY3QoVE9LRU5fVFlQRVMuQ2xvc2VQYXJlbiwgXCJFeHBlY3RlZCBjbG9zaW5nIHBhcmVudGhlc2lzIGZvciBhcmd1bWVudHMgbGlzdFwiKTtcbiAgICByZXR1cm4gYXJncztcbiAgfVxuICBmdW5jdGlvbiBwYXJzZUFyZ3VtZW50c0xpc3QoKSB7XG4gICAgY29uc3QgYXJncyA9IFtdO1xuICAgIHdoaWxlICghaXMoVE9LRU5fVFlQRVMuQ2xvc2VQYXJlbikpIHtcbiAgICAgIGxldCBhcmd1bWVudCA9IHBhcnNlRXhwcmVzc2lvbigpO1xuICAgICAgaWYgKGlzKFRPS0VOX1RZUEVTLkVxdWFscykpIHtcbiAgICAgICAgKytjdXJyZW50O1xuICAgICAgICBpZiAoIShhcmd1bWVudCBpbnN0YW5jZW9mIElkZW50aWZpZXIpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBFeHBlY3RlZCBpZGVudGlmaWVyIGZvciBrZXl3b3JkIGFyZ3VtZW50YCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmFsdWUgPSBwYXJzZUV4cHJlc3Npb24oKTtcbiAgICAgICAgYXJndW1lbnQgPSBuZXcgS2V5d29yZEFyZ3VtZW50RXhwcmVzc2lvbihhcmd1bWVudCwgdmFsdWUpO1xuICAgICAgfVxuICAgICAgYXJncy5wdXNoKGFyZ3VtZW50KTtcbiAgICAgIGlmIChpcyhUT0tFTl9UWVBFUy5Db21tYSkpIHtcbiAgICAgICAgKytjdXJyZW50O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXJncztcbiAgfVxuICBmdW5jdGlvbiBwYXJzZU1lbWJlckV4cHJlc3Npb25Bcmd1bWVudHNMaXN0KCkge1xuICAgIGNvbnN0IHNsaWNlcyA9IFtdO1xuICAgIGxldCBpc1NsaWNlID0gZmFsc2U7XG4gICAgd2hpbGUgKCFpcyhUT0tFTl9UWVBFUy5DbG9zZVNxdWFyZUJyYWNrZXQpKSB7XG4gICAgICBpZiAoaXMoVE9LRU5fVFlQRVMuQ29sb24pKSB7XG4gICAgICAgIHNsaWNlcy5wdXNoKHZvaWQgMCk7XG4gICAgICAgICsrY3VycmVudDtcbiAgICAgICAgaXNTbGljZSA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzbGljZXMucHVzaChwYXJzZUV4cHJlc3Npb24oKSk7XG4gICAgICAgIGlmIChpcyhUT0tFTl9UWVBFUy5Db2xvbikpIHtcbiAgICAgICAgICArK2N1cnJlbnQ7XG4gICAgICAgICAgaXNTbGljZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHNsaWNlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgRXhwZWN0ZWQgYXQgbGVhc3Qgb25lIGFyZ3VtZW50IGZvciBtZW1iZXIvc2xpY2UgZXhwcmVzc2lvbmApO1xuICAgIH1cbiAgICBpZiAoaXNTbGljZSkge1xuICAgICAgaWYgKHNsaWNlcy5sZW5ndGggPiAzKSB7XG4gICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgRXhwZWN0ZWQgMC0zIGFyZ3VtZW50cyBmb3Igc2xpY2UgZXhwcmVzc2lvbmApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBTbGljZUV4cHJlc3Npb24oLi4uc2xpY2VzKTtcbiAgICB9XG4gICAgcmV0dXJuIHNsaWNlc1swXTtcbiAgfVxuICBmdW5jdGlvbiBwYXJzZU1lbWJlckV4cHJlc3Npb24oKSB7XG4gICAgbGV0IG9iamVjdCA9IHBhcnNlUHJpbWFyeUV4cHJlc3Npb24oKTtcbiAgICB3aGlsZSAoaXMoVE9LRU5fVFlQRVMuRG90KSB8fCBpcyhUT0tFTl9UWVBFUy5PcGVuU3F1YXJlQnJhY2tldCkpIHtcbiAgICAgIGNvbnN0IG9wZXJhdG9yID0gdG9rZW5zW2N1cnJlbnRdO1xuICAgICAgKytjdXJyZW50O1xuICAgICAgbGV0IHByb3BlcnR5O1xuICAgICAgY29uc3QgY29tcHV0ZWQgPSBvcGVyYXRvci50eXBlICE9PSBUT0tFTl9UWVBFUy5Eb3Q7XG4gICAgICBpZiAoY29tcHV0ZWQpIHtcbiAgICAgICAgcHJvcGVydHkgPSBwYXJzZU1lbWJlckV4cHJlc3Npb25Bcmd1bWVudHNMaXN0KCk7XG4gICAgICAgIGV4cGVjdChUT0tFTl9UWVBFUy5DbG9zZVNxdWFyZUJyYWNrZXQsIFwiRXhwZWN0ZWQgY2xvc2luZyBzcXVhcmUgYnJhY2tldFwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb3BlcnR5ID0gcGFyc2VQcmltYXJ5RXhwcmVzc2lvbigpO1xuICAgICAgICBpZiAocHJvcGVydHkudHlwZSAhPT0gXCJJZGVudGlmaWVyXCIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYEV4cGVjdGVkIGlkZW50aWZpZXIgZm9sbG93aW5nIGRvdCBvcGVyYXRvcmApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBvYmplY3QgPSBuZXcgTWVtYmVyRXhwcmVzc2lvbihvYmplY3QsIHByb3BlcnR5LCBjb21wdXRlZCk7XG4gICAgfVxuICAgIHJldHVybiBvYmplY3Q7XG4gIH1cbiAgZnVuY3Rpb24gcGFyc2VNdWx0aXBsaWNhdGl2ZUV4cHJlc3Npb24oKSB7XG4gICAgbGV0IGxlZnQgPSBwYXJzZVRlc3RFeHByZXNzaW9uKCk7XG4gICAgd2hpbGUgKGlzKFRPS0VOX1RZUEVTLk11bHRpcGxpY2F0aXZlQmluYXJ5T3BlcmF0b3IpKSB7XG4gICAgICBjb25zdCBvcGVyYXRvciA9IHRva2Vuc1tjdXJyZW50XTtcbiAgICAgICsrY3VycmVudDtcbiAgICAgIGNvbnN0IHJpZ2h0ID0gcGFyc2VUZXN0RXhwcmVzc2lvbigpO1xuICAgICAgbGVmdCA9IG5ldyBCaW5hcnlFeHByZXNzaW9uKG9wZXJhdG9yLCBsZWZ0LCByaWdodCk7XG4gICAgfVxuICAgIHJldHVybiBsZWZ0O1xuICB9XG4gIGZ1bmN0aW9uIHBhcnNlVGVzdEV4cHJlc3Npb24oKSB7XG4gICAgbGV0IG9wZXJhbmQgPSBwYXJzZUZpbHRlckV4cHJlc3Npb24oKTtcbiAgICB3aGlsZSAoaXMoVE9LRU5fVFlQRVMuSXMpKSB7XG4gICAgICArK2N1cnJlbnQ7XG4gICAgICBjb25zdCBuZWdhdGUgPSBpcyhUT0tFTl9UWVBFUy5Ob3QpO1xuICAgICAgaWYgKG5lZ2F0ZSkge1xuICAgICAgICArK2N1cnJlbnQ7XG4gICAgICB9XG4gICAgICBsZXQgZmlsdGVyID0gcGFyc2VQcmltYXJ5RXhwcmVzc2lvbigpO1xuICAgICAgaWYgKGZpbHRlciBpbnN0YW5jZW9mIEJvb2xlYW5MaXRlcmFsKSB7XG4gICAgICAgIGZpbHRlciA9IG5ldyBJZGVudGlmaWVyKGZpbHRlci52YWx1ZS50b1N0cmluZygpKTtcbiAgICAgIH1cbiAgICAgIGlmICghKGZpbHRlciBpbnN0YW5jZW9mIElkZW50aWZpZXIpKSB7XG4gICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgRXhwZWN0ZWQgaWRlbnRpZmllciBmb3IgdGhlIHRlc3RgKTtcbiAgICAgIH1cbiAgICAgIG9wZXJhbmQgPSBuZXcgVGVzdEV4cHJlc3Npb24ob3BlcmFuZCwgbmVnYXRlLCBmaWx0ZXIpO1xuICAgIH1cbiAgICByZXR1cm4gb3BlcmFuZDtcbiAgfVxuICBmdW5jdGlvbiBwYXJzZUZpbHRlckV4cHJlc3Npb24oKSB7XG4gICAgbGV0IG9wZXJhbmQgPSBwYXJzZUNhbGxNZW1iZXJFeHByZXNzaW9uKCk7XG4gICAgd2hpbGUgKGlzKFRPS0VOX1RZUEVTLlBpcGUpKSB7XG4gICAgICArK2N1cnJlbnQ7XG4gICAgICBsZXQgZmlsdGVyID0gcGFyc2VQcmltYXJ5RXhwcmVzc2lvbigpO1xuICAgICAgaWYgKCEoZmlsdGVyIGluc3RhbmNlb2YgSWRlbnRpZmllcikpIHtcbiAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBFeHBlY3RlZCBpZGVudGlmaWVyIGZvciB0aGUgZmlsdGVyYCk7XG4gICAgICB9XG4gICAgICBpZiAoaXMoVE9LRU5fVFlQRVMuT3BlblBhcmVuKSkge1xuICAgICAgICBmaWx0ZXIgPSBwYXJzZUNhbGxFeHByZXNzaW9uKGZpbHRlcik7XG4gICAgICB9XG4gICAgICBvcGVyYW5kID0gbmV3IEZpbHRlckV4cHJlc3Npb24ob3BlcmFuZCwgZmlsdGVyKTtcbiAgICB9XG4gICAgcmV0dXJuIG9wZXJhbmQ7XG4gIH1cbiAgZnVuY3Rpb24gcGFyc2VQcmltYXJ5RXhwcmVzc2lvbigpIHtcbiAgICBjb25zdCB0b2tlbiA9IHRva2Vuc1tjdXJyZW50XTtcbiAgICBzd2l0Y2ggKHRva2VuLnR5cGUpIHtcbiAgICAgIGNhc2UgVE9LRU5fVFlQRVMuTnVtZXJpY0xpdGVyYWw6XG4gICAgICAgICsrY3VycmVudDtcbiAgICAgICAgcmV0dXJuIG5ldyBOdW1lcmljTGl0ZXJhbChOdW1iZXIodG9rZW4udmFsdWUpKTtcbiAgICAgIGNhc2UgVE9LRU5fVFlQRVMuU3RyaW5nTGl0ZXJhbDpcbiAgICAgICAgKytjdXJyZW50O1xuICAgICAgICByZXR1cm4gbmV3IFN0cmluZ0xpdGVyYWwodG9rZW4udmFsdWUpO1xuICAgICAgY2FzZSBUT0tFTl9UWVBFUy5Cb29sZWFuTGl0ZXJhbDpcbiAgICAgICAgKytjdXJyZW50O1xuICAgICAgICByZXR1cm4gbmV3IEJvb2xlYW5MaXRlcmFsKHRva2VuLnZhbHVlID09PSBcInRydWVcIik7XG4gICAgICBjYXNlIFRPS0VOX1RZUEVTLklkZW50aWZpZXI6XG4gICAgICAgICsrY3VycmVudDtcbiAgICAgICAgcmV0dXJuIG5ldyBJZGVudGlmaWVyKHRva2VuLnZhbHVlKTtcbiAgICAgIGNhc2UgVE9LRU5fVFlQRVMuT3BlblBhcmVuOiB7XG4gICAgICAgICsrY3VycmVudDtcbiAgICAgICAgY29uc3QgZXhwcmVzc2lvbiA9IHBhcnNlRXhwcmVzc2lvblNlcXVlbmNlKCk7XG4gICAgICAgIGlmICh0b2tlbnNbY3VycmVudF0udHlwZSAhPT0gVE9LRU5fVFlQRVMuQ2xvc2VQYXJlbikge1xuICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgRXhwZWN0ZWQgY2xvc2luZyBwYXJlbnRoZXNpcywgZ290ICR7dG9rZW5zW2N1cnJlbnRdLnR5cGV9IGluc3RlYWRgKTtcbiAgICAgICAgfVxuICAgICAgICArK2N1cnJlbnQ7XG4gICAgICAgIHJldHVybiBleHByZXNzaW9uO1xuICAgICAgfVxuICAgICAgY2FzZSBUT0tFTl9UWVBFUy5PcGVuU3F1YXJlQnJhY2tldDoge1xuICAgICAgICArK2N1cnJlbnQ7XG4gICAgICAgIGNvbnN0IHZhbHVlcyA9IFtdO1xuICAgICAgICB3aGlsZSAoIWlzKFRPS0VOX1RZUEVTLkNsb3NlU3F1YXJlQnJhY2tldCkpIHtcbiAgICAgICAgICB2YWx1ZXMucHVzaChwYXJzZUV4cHJlc3Npb24oKSk7XG4gICAgICAgICAgaWYgKGlzKFRPS0VOX1RZUEVTLkNvbW1hKSkge1xuICAgICAgICAgICAgKytjdXJyZW50O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICArK2N1cnJlbnQ7XG4gICAgICAgIHJldHVybiBuZXcgQXJyYXlMaXRlcmFsKHZhbHVlcyk7XG4gICAgICB9XG4gICAgICBjYXNlIFRPS0VOX1RZUEVTLk9wZW5DdXJseUJyYWNrZXQ6IHtcbiAgICAgICAgKytjdXJyZW50O1xuICAgICAgICBjb25zdCB2YWx1ZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgICB3aGlsZSAoIWlzKFRPS0VOX1RZUEVTLkNsb3NlQ3VybHlCcmFja2V0KSkge1xuICAgICAgICAgIGNvbnN0IGtleSA9IHBhcnNlRXhwcmVzc2lvbigpO1xuICAgICAgICAgIGV4cGVjdChUT0tFTl9UWVBFUy5Db2xvbiwgXCJFeHBlY3RlZCBjb2xvbiBiZXR3ZWVuIGtleSBhbmQgdmFsdWUgaW4gb2JqZWN0IGxpdGVyYWxcIik7XG4gICAgICAgICAgY29uc3QgdmFsdWUgPSBwYXJzZUV4cHJlc3Npb24oKTtcbiAgICAgICAgICB2YWx1ZXMuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICAgIGlmIChpcyhUT0tFTl9UWVBFUy5Db21tYSkpIHtcbiAgICAgICAgICAgICsrY3VycmVudDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgKytjdXJyZW50O1xuICAgICAgICByZXR1cm4gbmV3IE9iamVjdExpdGVyYWwodmFsdWVzKTtcbiAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgVW5leHBlY3RlZCB0b2tlbjogJHt0b2tlbi50eXBlfWApO1xuICAgIH1cbiAgfVxuICB3aGlsZSAoY3VycmVudCA8IHRva2Vucy5sZW5ndGgpIHtcbiAgICBwcm9ncmFtLmJvZHkucHVzaChwYXJzZUFueSgpKTtcbiAgfVxuICByZXR1cm4gcHJvZ3JhbTtcbn1cblxuLy8gc3JjL3V0aWxzLnRzXG5mdW5jdGlvbiByYW5nZShzdGFydCwgc3RvcCwgc3RlcCA9IDEpIHtcbiAgaWYgKHN0b3AgPT09IHZvaWQgMCkge1xuICAgIHN0b3AgPSBzdGFydDtcbiAgICBzdGFydCA9IDA7XG4gIH1cbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IHN0b3A7IGkgKz0gc3RlcCkge1xuICAgIHJlc3VsdC5wdXNoKGkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBzbGljZShhcnJheSwgc3RhcnQsIHN0b3AsIHN0ZXAgPSAxKSB7XG4gIGNvbnN0IGRpcmVjdGlvbiA9IE1hdGguc2lnbihzdGVwKTtcbiAgaWYgKGRpcmVjdGlvbiA+PSAwKSB7XG4gICAgc3RhcnQgPSAoc3RhcnQgPz89IDApIDwgMCA/IE1hdGgubWF4KGFycmF5Lmxlbmd0aCArIHN0YXJ0LCAwKSA6IE1hdGgubWluKHN0YXJ0LCBhcnJheS5sZW5ndGgpO1xuICAgIHN0b3AgPSAoc3RvcCA/Pz0gYXJyYXkubGVuZ3RoKSA8IDAgPyBNYXRoLm1heChhcnJheS5sZW5ndGggKyBzdG9wLCAwKSA6IE1hdGgubWluKHN0b3AsIGFycmF5Lmxlbmd0aCk7XG4gIH0gZWxzZSB7XG4gICAgc3RhcnQgPSAoc3RhcnQgPz89IGFycmF5Lmxlbmd0aCAtIDEpIDwgMCA/IE1hdGgubWF4KGFycmF5Lmxlbmd0aCArIHN0YXJ0LCAtMSkgOiBNYXRoLm1pbihzdGFydCwgYXJyYXkubGVuZ3RoIC0gMSk7XG4gICAgc3RvcCA9IChzdG9wID8/PSAtMSkgPCAtMSA/IE1hdGgubWF4KGFycmF5Lmxlbmd0aCArIHN0b3AsIC0xKSA6IE1hdGgubWluKHN0b3AsIGFycmF5Lmxlbmd0aCAtIDEpO1xuICB9XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBmb3IgKGxldCBpID0gc3RhcnQ7IGRpcmVjdGlvbiAqIGkgPCBkaXJlY3Rpb24gKiBzdG9wOyBpICs9IHN0ZXApIHtcbiAgICByZXN1bHQucHVzaChhcnJheVtpXSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHRpdGxlQ2FzZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUucmVwbGFjZSgvXFxiXFx3L2csIChjKSA9PiBjLnRvVXBwZXJDYXNlKCkpO1xufVxuXG4vLyBzcmMvcnVudGltZS50c1xudmFyIFJ1bnRpbWVWYWx1ZSA9IGNsYXNzIHtcbiAgdHlwZSA9IFwiUnVudGltZVZhbHVlXCI7XG4gIHZhbHVlO1xuICAvKipcbiAgICogQSBjb2xsZWN0aW9uIG9mIGJ1aWx0LWluIGZ1bmN0aW9ucyBmb3IgdGhpcyB0eXBlLlxuICAgKi9cbiAgYnVpbHRpbnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBSdW50aW1lVmFsdWUuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih2YWx1ZSA9IHZvaWQgMCkge1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogRGV0ZXJtaW5lcyB0cnV0aGluZXNzIG9yIGZhbHNpbmVzcyBvZiB0aGUgcnVudGltZSB2YWx1ZS5cbiAgICogVGhpcyBmdW5jdGlvbiBzaG91bGQgYmUgb3ZlcnJpZGRlbiBieSBzdWJjbGFzc2VzIGlmIGl0IGhhcyBjdXN0b20gdHJ1dGhpbmVzcyBjcml0ZXJpYS5cbiAgICogQHJldHVybnMge0Jvb2xlYW5WYWx1ZX0gQm9vbGVhblZhbHVlKHRydWUpIGlmIHRoZSB2YWx1ZSBpcyB0cnV0aHksIEJvb2xlYW5WYWx1ZShmYWxzZSkgb3RoZXJ3aXNlLlxuICAgKi9cbiAgX19ib29sX18oKSB7XG4gICAgcmV0dXJuIG5ldyBCb29sZWFuVmFsdWUoISF0aGlzLnZhbHVlKTtcbiAgfVxufTtcbnZhciBOdW1lcmljVmFsdWUgPSBjbGFzcyBleHRlbmRzIFJ1bnRpbWVWYWx1ZSB7XG4gIHR5cGUgPSBcIk51bWVyaWNWYWx1ZVwiO1xufTtcbnZhciBTdHJpbmdWYWx1ZSA9IGNsYXNzIGV4dGVuZHMgUnVudGltZVZhbHVlIHtcbiAgdHlwZSA9IFwiU3RyaW5nVmFsdWVcIjtcbiAgYnVpbHRpbnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcChbXG4gICAgW1xuICAgICAgXCJ1cHBlclwiLFxuICAgICAgbmV3IEZ1bmN0aW9uVmFsdWUoKCkgPT4ge1xuICAgICAgICByZXR1cm4gbmV3IFN0cmluZ1ZhbHVlKHRoaXMudmFsdWUudG9VcHBlckNhc2UoKSk7XG4gICAgICB9KVxuICAgIF0sXG4gICAgW1xuICAgICAgXCJsb3dlclwiLFxuICAgICAgbmV3IEZ1bmN0aW9uVmFsdWUoKCkgPT4ge1xuICAgICAgICByZXR1cm4gbmV3IFN0cmluZ1ZhbHVlKHRoaXMudmFsdWUudG9Mb3dlckNhc2UoKSk7XG4gICAgICB9KVxuICAgIF0sXG4gICAgW1xuICAgICAgXCJzdHJpcFwiLFxuICAgICAgbmV3IEZ1bmN0aW9uVmFsdWUoKCkgPT4ge1xuICAgICAgICByZXR1cm4gbmV3IFN0cmluZ1ZhbHVlKHRoaXMudmFsdWUudHJpbSgpKTtcbiAgICAgIH0pXG4gICAgXSxcbiAgICBbXG4gICAgICBcInRpdGxlXCIsXG4gICAgICBuZXcgRnVuY3Rpb25WYWx1ZSgoKSA9PiB7XG4gICAgICAgIHJldHVybiBuZXcgU3RyaW5nVmFsdWUodGl0bGVDYXNlKHRoaXMudmFsdWUpKTtcbiAgICAgIH0pXG4gICAgXSxcbiAgICBbXCJsZW5ndGhcIiwgbmV3IE51bWVyaWNWYWx1ZSh0aGlzLnZhbHVlLmxlbmd0aCldXG4gIF0pO1xufTtcbnZhciBCb29sZWFuVmFsdWUgPSBjbGFzcyBleHRlbmRzIFJ1bnRpbWVWYWx1ZSB7XG4gIHR5cGUgPSBcIkJvb2xlYW5WYWx1ZVwiO1xufTtcbnZhciBPYmplY3RWYWx1ZSA9IGNsYXNzIGV4dGVuZHMgUnVudGltZVZhbHVlIHtcbiAgdHlwZSA9IFwiT2JqZWN0VmFsdWVcIjtcbiAgLyoqXG4gICAqIE5PVEU6IG5lY2Vzc2FyeSB0byBvdmVycmlkZSBzaW5jZSBhbGwgSmF2YVNjcmlwdCBhcnJheXMgYXJlIGNvbnNpZGVyZWQgdHJ1dGh5LFxuICAgKiB3aGlsZSBvbmx5IG5vbi1lbXB0eSBQeXRob24gYXJyYXlzIGFyZSBjb25zaWRlciB0cnV0aHkuXG4gICAqXG4gICAqIGUuZy4sXG4gICAqICAtIEphdmFTY3JpcHQ6ICB7fSAmJiA1IC0+IDVcbiAgICogIC0gUHl0aG9uOiAgICAgIHt9IGFuZCA1IC0+IHt9XG4gICAqL1xuICBfX2Jvb2xfXygpIHtcbiAgICByZXR1cm4gbmV3IEJvb2xlYW5WYWx1ZSh0aGlzLnZhbHVlLnNpemUgPiAwKTtcbiAgfVxuICBidWlsdGlucyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKFtcbiAgICBbXG4gICAgICBcImdldFwiLFxuICAgICAgbmV3IEZ1bmN0aW9uVmFsdWUoKFtrZXksIGRlZmF1bHRWYWx1ZV0pID0+IHtcbiAgICAgICAgaWYgKCEoa2V5IGluc3RhbmNlb2YgU3RyaW5nVmFsdWUpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBPYmplY3Qga2V5IG11c3QgYmUgYSBzdHJpbmc6IGdvdCAke2tleS50eXBlfWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlLmdldChrZXkudmFsdWUpID8/IGRlZmF1bHRWYWx1ZSA/PyBuZXcgTnVsbFZhbHVlKCk7XG4gICAgICB9KVxuICAgIF0sXG4gICAgW1xuICAgICAgXCJpdGVtc1wiLFxuICAgICAgbmV3IEZ1bmN0aW9uVmFsdWUoKCkgPT4ge1xuICAgICAgICByZXR1cm4gbmV3IEFycmF5VmFsdWUoXG4gICAgICAgICAgQXJyYXkuZnJvbSh0aGlzLnZhbHVlLmVudHJpZXMoKSkubWFwKChba2V5LCB2YWx1ZV0pID0+IG5ldyBBcnJheVZhbHVlKFtuZXcgU3RyaW5nVmFsdWUoa2V5KSwgdmFsdWVdKSlcbiAgICAgICAgKTtcbiAgICAgIH0pXG4gICAgXVxuICBdKTtcbn07XG52YXIgQXJyYXlWYWx1ZSA9IGNsYXNzIGV4dGVuZHMgUnVudGltZVZhbHVlIHtcbiAgdHlwZSA9IFwiQXJyYXlWYWx1ZVwiO1xuICBidWlsdGlucyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKFtbXCJsZW5ndGhcIiwgbmV3IE51bWVyaWNWYWx1ZSh0aGlzLnZhbHVlLmxlbmd0aCldXSk7XG4gIC8qKlxuICAgKiBOT1RFOiBuZWNlc3NhcnkgdG8gb3ZlcnJpZGUgc2luY2UgYWxsIEphdmFTY3JpcHQgYXJyYXlzIGFyZSBjb25zaWRlcmVkIHRydXRoeSxcbiAgICogd2hpbGUgb25seSBub24tZW1wdHkgUHl0aG9uIGFycmF5cyBhcmUgY29uc2lkZXIgdHJ1dGh5LlxuICAgKlxuICAgKiBlLmcuLFxuICAgKiAgLSBKYXZhU2NyaXB0OiAgW10gJiYgNSAtPiA1XG4gICAqICAtIFB5dGhvbjogICAgICBbXSBhbmQgNSAtPiBbXVxuICAgKi9cbiAgX19ib29sX18oKSB7XG4gICAgcmV0dXJuIG5ldyBCb29sZWFuVmFsdWUodGhpcy52YWx1ZS5sZW5ndGggPiAwKTtcbiAgfVxufTtcbnZhciBUdXBsZVZhbHVlID0gY2xhc3MgZXh0ZW5kcyBBcnJheVZhbHVlIHtcbiAgdHlwZSA9IFwiVHVwbGVWYWx1ZVwiO1xufTtcbnZhciBGdW5jdGlvblZhbHVlID0gY2xhc3MgZXh0ZW5kcyBSdW50aW1lVmFsdWUge1xuICB0eXBlID0gXCJGdW5jdGlvblZhbHVlXCI7XG59O1xudmFyIE51bGxWYWx1ZSA9IGNsYXNzIGV4dGVuZHMgUnVudGltZVZhbHVlIHtcbiAgdHlwZSA9IFwiTnVsbFZhbHVlXCI7XG59O1xudmFyIFVuZGVmaW5lZFZhbHVlID0gY2xhc3MgZXh0ZW5kcyBSdW50aW1lVmFsdWUge1xuICB0eXBlID0gXCJVbmRlZmluZWRWYWx1ZVwiO1xufTtcbnZhciBFbnZpcm9ubWVudCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IocGFyZW50KSB7XG4gICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSB2YXJpYWJsZXMgZGVjbGFyZWQgaW4gdGhpcyBlbnZpcm9ubWVudC5cbiAgICovXG4gIHZhcmlhYmxlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKFtcbiAgICBbXG4gICAgICBcIm5hbWVzcGFjZVwiLFxuICAgICAgbmV3IEZ1bmN0aW9uVmFsdWUoKGFyZ3MpID0+IHtcbiAgICAgICAgaWYgKGFyZ3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBPYmplY3RWYWx1ZSgvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXJncy5sZW5ndGggIT09IDEgfHwgIShhcmdzWzBdIGluc3RhbmNlb2YgT2JqZWN0VmFsdWUpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYG5hbWVzcGFjZWAgZXhwZWN0cyBlaXRoZXIgemVybyBhcmd1bWVudHMgb3IgYSBzaW5nbGUgb2JqZWN0IGFyZ3VtZW50XCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcmdzWzBdO1xuICAgICAgfSlcbiAgICBdXG4gIF0pO1xuICAvKipcbiAgICogVGhlIHRlc3RzIGF2YWlsYWJsZSBpbiB0aGlzIGVudmlyb25tZW50LlxuICAgKi9cbiAgdGVzdHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcChbXG4gICAgW1wiYm9vbGVhblwiLCAob3BlcmFuZCkgPT4gb3BlcmFuZC50eXBlID09PSBcIkJvb2xlYW5WYWx1ZVwiXSxcbiAgICBbXCJjYWxsYWJsZVwiLCAob3BlcmFuZCkgPT4gb3BlcmFuZCBpbnN0YW5jZW9mIEZ1bmN0aW9uVmFsdWVdLFxuICAgIFtcbiAgICAgIFwib2RkXCIsXG4gICAgICAob3BlcmFuZCkgPT4ge1xuICAgICAgICBpZiAob3BlcmFuZC50eXBlICE9PSBcIk51bWVyaWNWYWx1ZVwiKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgYXBwbHkgdGVzdCBcIm9kZFwiIHRvIHR5cGU6ICR7b3BlcmFuZC50eXBlfWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvcGVyYW5kLnZhbHVlICUgMiAhPT0gMDtcbiAgICAgIH1cbiAgICBdLFxuICAgIFtcbiAgICAgIFwiZXZlblwiLFxuICAgICAgKG9wZXJhbmQpID0+IHtcbiAgICAgICAgaWYgKG9wZXJhbmQudHlwZSAhPT0gXCJOdW1lcmljVmFsdWVcIikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IGFwcGx5IHRlc3QgXCJldmVuXCIgdG8gdHlwZTogJHtvcGVyYW5kLnR5cGV9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9wZXJhbmQudmFsdWUgJSAyID09PSAwO1xuICAgICAgfVxuICAgIF0sXG4gICAgW1wiZmFsc2VcIiwgKG9wZXJhbmQpID0+IG9wZXJhbmQudHlwZSA9PT0gXCJCb29sZWFuVmFsdWVcIiAmJiAhb3BlcmFuZC52YWx1ZV0sXG4gICAgW1widHJ1ZVwiLCAob3BlcmFuZCkgPT4gb3BlcmFuZC50eXBlID09PSBcIkJvb2xlYW5WYWx1ZVwiICYmIG9wZXJhbmQudmFsdWVdLFxuICAgIFtcIm51bWJlclwiLCAob3BlcmFuZCkgPT4gb3BlcmFuZC50eXBlID09PSBcIk51bWVyaWNWYWx1ZVwiXSxcbiAgICBbXCJpbnRlZ2VyXCIsIChvcGVyYW5kKSA9PiBvcGVyYW5kLnR5cGUgPT09IFwiTnVtZXJpY1ZhbHVlXCIgJiYgTnVtYmVyLmlzSW50ZWdlcihvcGVyYW5kLnZhbHVlKV0sXG4gICAgW1wiaXRlcmFibGVcIiwgKG9wZXJhbmQpID0+IG9wZXJhbmQgaW5zdGFuY2VvZiBBcnJheVZhbHVlIHx8IG9wZXJhbmQgaW5zdGFuY2VvZiBTdHJpbmdWYWx1ZV0sXG4gICAgW1xuICAgICAgXCJsb3dlclwiLFxuICAgICAgKG9wZXJhbmQpID0+IHtcbiAgICAgICAgY29uc3Qgc3RyID0gb3BlcmFuZC52YWx1ZTtcbiAgICAgICAgcmV0dXJuIG9wZXJhbmQudHlwZSA9PT0gXCJTdHJpbmdWYWx1ZVwiICYmIHN0ciA9PT0gc3RyLnRvTG93ZXJDYXNlKCk7XG4gICAgICB9XG4gICAgXSxcbiAgICBbXG4gICAgICBcInVwcGVyXCIsXG4gICAgICAob3BlcmFuZCkgPT4ge1xuICAgICAgICBjb25zdCBzdHIgPSBvcGVyYW5kLnZhbHVlO1xuICAgICAgICByZXR1cm4gb3BlcmFuZC50eXBlID09PSBcIlN0cmluZ1ZhbHVlXCIgJiYgc3RyID09PSBzdHIudG9VcHBlckNhc2UoKTtcbiAgICAgIH1cbiAgICBdLFxuICAgIFtcIm5vbmVcIiwgKG9wZXJhbmQpID0+IG9wZXJhbmQudHlwZSA9PT0gXCJOdWxsVmFsdWVcIl0sXG4gICAgW1wiZGVmaW5lZFwiLCAob3BlcmFuZCkgPT4gb3BlcmFuZC50eXBlICE9PSBcIlVuZGVmaW5lZFZhbHVlXCJdLFxuICAgIFtcInVuZGVmaW5lZFwiLCAob3BlcmFuZCkgPT4gb3BlcmFuZC50eXBlID09PSBcIlVuZGVmaW5lZFZhbHVlXCJdLFxuICAgIFtcImVxdWFsdG9cIiwgKGEsIGIpID0+IGEudmFsdWUgPT09IGIudmFsdWVdXG4gIF0pO1xuICAvKipcbiAgICogU2V0IHRoZSB2YWx1ZSBvZiBhIHZhcmlhYmxlIGluIHRoZSBjdXJyZW50IGVudmlyb25tZW50LlxuICAgKi9cbiAgc2V0KG5hbWUsIHZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMuZGVjbGFyZVZhcmlhYmxlKG5hbWUsIGNvbnZlcnRUb1J1bnRpbWVWYWx1ZXModmFsdWUpKTtcbiAgfVxuICBkZWNsYXJlVmFyaWFibGUobmFtZSwgdmFsdWUpIHtcbiAgICBpZiAodGhpcy52YXJpYWJsZXMuaGFzKG5hbWUpKSB7XG4gICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYFZhcmlhYmxlIGFscmVhZHkgZGVjbGFyZWQ6ICR7bmFtZX1gKTtcbiAgICB9XG4gICAgdGhpcy52YXJpYWJsZXMuc2V0KG5hbWUsIHZhbHVlKTtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgLy8gcHJpdmF0ZSBhc3NpZ25WYXJpYWJsZShuYW1lOiBzdHJpbmcsIHZhbHVlOiBBbnlSdW50aW1lVmFsdWUpOiBBbnlSdW50aW1lVmFsdWUge1xuICAvLyBcdGNvbnN0IGVudiA9IHRoaXMucmVzb2x2ZShuYW1lKTtcbiAgLy8gXHRlbnYudmFyaWFibGVzLnNldChuYW1lLCB2YWx1ZSk7XG4gIC8vIFx0cmV0dXJuIHZhbHVlO1xuICAvLyB9XG4gIC8qKlxuICAgKiBTZXQgdmFyaWFibGUgaW4gdGhlIGN1cnJlbnQgc2NvcGUuXG4gICAqIFNlZSBodHRwczovL2ppbmphLnBhbGxldHNwcm9qZWN0cy5jb20vZW4vMy4wLngvdGVtcGxhdGVzLyNhc3NpZ25tZW50cyBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAgICovXG4gIHNldFZhcmlhYmxlKG5hbWUsIHZhbHVlKSB7XG4gICAgdGhpcy52YXJpYWJsZXMuc2V0KG5hbWUsIHZhbHVlKTtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFJlc29sdmUgdGhlIGVudmlyb25tZW50IGluIHdoaWNoIHRoZSB2YXJpYWJsZSBpcyBkZWNsYXJlZC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIHZhcmlhYmxlLlxuICAgKiBAcmV0dXJucyB7RW52aXJvbm1lbnR9IFRoZSBlbnZpcm9ubWVudCBpbiB3aGljaCB0aGUgdmFyaWFibGUgaXMgZGVjbGFyZWQuXG4gICAqL1xuICByZXNvbHZlKG5hbWUpIHtcbiAgICBpZiAodGhpcy52YXJpYWJsZXMuaGFzKG5hbWUpKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgaWYgKHRoaXMucGFyZW50KSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJlbnQucmVzb2x2ZShuYW1lKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIHZhcmlhYmxlOiAke25hbWV9YCk7XG4gIH1cbiAgbG9va3VwVmFyaWFibGUobmFtZSkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gdGhpcy5yZXNvbHZlKG5hbWUpLnZhcmlhYmxlcy5nZXQobmFtZSkgPz8gbmV3IFVuZGVmaW5lZFZhbHVlKCk7XG4gICAgfSBjYXRjaCB7XG4gICAgICByZXR1cm4gbmV3IFVuZGVmaW5lZFZhbHVlKCk7XG4gICAgfVxuICB9XG59O1xudmFyIEludGVycHJldGVyID0gY2xhc3Mge1xuICBnbG9iYWw7XG4gIGNvbnN0cnVjdG9yKGVudikge1xuICAgIHRoaXMuZ2xvYmFsID0gZW52ID8/IG5ldyBFbnZpcm9ubWVudCgpO1xuICB9XG4gIC8qKlxuICAgKiBSdW4gdGhlIHByb2dyYW0uXG4gICAqL1xuICBydW4ocHJvZ3JhbSkge1xuICAgIHJldHVybiB0aGlzLmV2YWx1YXRlKHByb2dyYW0sIHRoaXMuZ2xvYmFsKTtcbiAgfVxuICAvKipcbiAgICogRXZhbHVhdGVzIGV4cHJlc3Npb25zIGZvbGxvd2luZyB0aGUgYmluYXJ5IG9wZXJhdGlvbiB0eXBlLlxuICAgKi9cbiAgZXZhbHVhdGVCaW5hcnlFeHByZXNzaW9uKG5vZGUsIGVudmlyb25tZW50KSB7XG4gICAgY29uc3QgbGVmdCA9IHRoaXMuZXZhbHVhdGUobm9kZS5sZWZ0LCBlbnZpcm9ubWVudCk7XG4gICAgc3dpdGNoIChub2RlLm9wZXJhdG9yLnZhbHVlKSB7XG4gICAgICBjYXNlIFwiYW5kXCI6XG4gICAgICAgIHJldHVybiBsZWZ0Ll9fYm9vbF9fKCkudmFsdWUgPyB0aGlzLmV2YWx1YXRlKG5vZGUucmlnaHQsIGVudmlyb25tZW50KSA6IGxlZnQ7XG4gICAgICBjYXNlIFwib3JcIjpcbiAgICAgICAgcmV0dXJuIGxlZnQuX19ib29sX18oKS52YWx1ZSA/IGxlZnQgOiB0aGlzLmV2YWx1YXRlKG5vZGUucmlnaHQsIGVudmlyb25tZW50KTtcbiAgICB9XG4gICAgY29uc3QgcmlnaHQgPSB0aGlzLmV2YWx1YXRlKG5vZGUucmlnaHQsIGVudmlyb25tZW50KTtcbiAgICBzd2l0Y2ggKG5vZGUub3BlcmF0b3IudmFsdWUpIHtcbiAgICAgIGNhc2UgXCI9PVwiOlxuICAgICAgICByZXR1cm4gbmV3IEJvb2xlYW5WYWx1ZShsZWZ0LnZhbHVlID09IHJpZ2h0LnZhbHVlKTtcbiAgICAgIGNhc2UgXCIhPVwiOlxuICAgICAgICByZXR1cm4gbmV3IEJvb2xlYW5WYWx1ZShsZWZ0LnZhbHVlICE9IHJpZ2h0LnZhbHVlKTtcbiAgICB9XG4gICAgaWYgKGxlZnQgaW5zdGFuY2VvZiBVbmRlZmluZWRWYWx1ZSB8fCByaWdodCBpbnN0YW5jZW9mIFVuZGVmaW5lZFZhbHVlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgcGVyZm9ybSBvcGVyYXRpb24gb24gdW5kZWZpbmVkIHZhbHVlc1wiKTtcbiAgICB9IGVsc2UgaWYgKGxlZnQgaW5zdGFuY2VvZiBOdWxsVmFsdWUgfHwgcmlnaHQgaW5zdGFuY2VvZiBOdWxsVmFsdWUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBwZXJmb3JtIG9wZXJhdGlvbiBvbiBudWxsIHZhbHVlc1wiKTtcbiAgICB9IGVsc2UgaWYgKGxlZnQgaW5zdGFuY2VvZiBOdW1lcmljVmFsdWUgJiYgcmlnaHQgaW5zdGFuY2VvZiBOdW1lcmljVmFsdWUpIHtcbiAgICAgIHN3aXRjaCAobm9kZS5vcGVyYXRvci52YWx1ZSkge1xuICAgICAgICBjYXNlIFwiK1wiOlxuICAgICAgICAgIHJldHVybiBuZXcgTnVtZXJpY1ZhbHVlKGxlZnQudmFsdWUgKyByaWdodC52YWx1ZSk7XG4gICAgICAgIGNhc2UgXCItXCI6XG4gICAgICAgICAgcmV0dXJuIG5ldyBOdW1lcmljVmFsdWUobGVmdC52YWx1ZSAtIHJpZ2h0LnZhbHVlKTtcbiAgICAgICAgY2FzZSBcIipcIjpcbiAgICAgICAgICByZXR1cm4gbmV3IE51bWVyaWNWYWx1ZShsZWZ0LnZhbHVlICogcmlnaHQudmFsdWUpO1xuICAgICAgICBjYXNlIFwiL1wiOlxuICAgICAgICAgIHJldHVybiBuZXcgTnVtZXJpY1ZhbHVlKGxlZnQudmFsdWUgLyByaWdodC52YWx1ZSk7XG4gICAgICAgIGNhc2UgXCIlXCI6XG4gICAgICAgICAgcmV0dXJuIG5ldyBOdW1lcmljVmFsdWUobGVmdC52YWx1ZSAlIHJpZ2h0LnZhbHVlKTtcbiAgICAgICAgY2FzZSBcIjxcIjpcbiAgICAgICAgICByZXR1cm4gbmV3IEJvb2xlYW5WYWx1ZShsZWZ0LnZhbHVlIDwgcmlnaHQudmFsdWUpO1xuICAgICAgICBjYXNlIFwiPlwiOlxuICAgICAgICAgIHJldHVybiBuZXcgQm9vbGVhblZhbHVlKGxlZnQudmFsdWUgPiByaWdodC52YWx1ZSk7XG4gICAgICAgIGNhc2UgXCI+PVwiOlxuICAgICAgICAgIHJldHVybiBuZXcgQm9vbGVhblZhbHVlKGxlZnQudmFsdWUgPj0gcmlnaHQudmFsdWUpO1xuICAgICAgICBjYXNlIFwiPD1cIjpcbiAgICAgICAgICByZXR1cm4gbmV3IEJvb2xlYW5WYWx1ZShsZWZ0LnZhbHVlIDw9IHJpZ2h0LnZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGxlZnQgaW5zdGFuY2VvZiBBcnJheVZhbHVlICYmIHJpZ2h0IGluc3RhbmNlb2YgQXJyYXlWYWx1ZSkge1xuICAgICAgc3dpdGNoIChub2RlLm9wZXJhdG9yLnZhbHVlKSB7XG4gICAgICAgIGNhc2UgXCIrXCI6XG4gICAgICAgICAgcmV0dXJuIG5ldyBBcnJheVZhbHVlKGxlZnQudmFsdWUuY29uY2F0KHJpZ2h0LnZhbHVlKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChyaWdodCBpbnN0YW5jZW9mIEFycmF5VmFsdWUpIHtcbiAgICAgIGNvbnN0IG1lbWJlciA9IHJpZ2h0LnZhbHVlLmZpbmQoKHgpID0+IHgudmFsdWUgPT09IGxlZnQudmFsdWUpICE9PSB2b2lkIDA7XG4gICAgICBzd2l0Y2ggKG5vZGUub3BlcmF0b3IudmFsdWUpIHtcbiAgICAgICAgY2FzZSBcImluXCI6XG4gICAgICAgICAgcmV0dXJuIG5ldyBCb29sZWFuVmFsdWUobWVtYmVyKTtcbiAgICAgICAgY2FzZSBcIm5vdCBpblwiOlxuICAgICAgICAgIHJldHVybiBuZXcgQm9vbGVhblZhbHVlKCFtZW1iZXIpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobGVmdCBpbnN0YW5jZW9mIFN0cmluZ1ZhbHVlIHx8IHJpZ2h0IGluc3RhbmNlb2YgU3RyaW5nVmFsdWUpIHtcbiAgICAgIHN3aXRjaCAobm9kZS5vcGVyYXRvci52YWx1ZSkge1xuICAgICAgICBjYXNlIFwiK1wiOlxuICAgICAgICAgIHJldHVybiBuZXcgU3RyaW5nVmFsdWUobGVmdC52YWx1ZS50b1N0cmluZygpICsgcmlnaHQudmFsdWUudG9TdHJpbmcoKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChsZWZ0IGluc3RhbmNlb2YgU3RyaW5nVmFsdWUgJiYgcmlnaHQgaW5zdGFuY2VvZiBTdHJpbmdWYWx1ZSkge1xuICAgICAgc3dpdGNoIChub2RlLm9wZXJhdG9yLnZhbHVlKSB7XG4gICAgICAgIGNhc2UgXCJpblwiOlxuICAgICAgICAgIHJldHVybiBuZXcgQm9vbGVhblZhbHVlKHJpZ2h0LnZhbHVlLmluY2x1ZGVzKGxlZnQudmFsdWUpKTtcbiAgICAgICAgY2FzZSBcIm5vdCBpblwiOlxuICAgICAgICAgIHJldHVybiBuZXcgQm9vbGVhblZhbHVlKCFyaWdodC52YWx1ZS5pbmNsdWRlcyhsZWZ0LnZhbHVlKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChsZWZ0IGluc3RhbmNlb2YgU3RyaW5nVmFsdWUgJiYgcmlnaHQgaW5zdGFuY2VvZiBPYmplY3RWYWx1ZSkge1xuICAgICAgc3dpdGNoIChub2RlLm9wZXJhdG9yLnZhbHVlKSB7XG4gICAgICAgIGNhc2UgXCJpblwiOlxuICAgICAgICAgIHJldHVybiBuZXcgQm9vbGVhblZhbHVlKHJpZ2h0LnZhbHVlLmhhcyhsZWZ0LnZhbHVlKSk7XG4gICAgICAgIGNhc2UgXCJub3QgaW5cIjpcbiAgICAgICAgICByZXR1cm4gbmV3IEJvb2xlYW5WYWx1ZSghcmlnaHQudmFsdWUuaGFzKGxlZnQudmFsdWUpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBVbmtub3duIG9wZXJhdG9yIFwiJHtub2RlLm9wZXJhdG9yLnZhbHVlfVwiIGJldHdlZW4gJHtsZWZ0LnR5cGV9IGFuZCAke3JpZ2h0LnR5cGV9YCk7XG4gIH1cbiAgLyoqXG4gICAqIEV2YWx1YXRlcyBleHByZXNzaW9ucyBmb2xsb3dpbmcgdGhlIGZpbHRlciBvcGVyYXRpb24gdHlwZS5cbiAgICovXG4gIGV2YWx1YXRlRmlsdGVyRXhwcmVzc2lvbihub2RlLCBlbnZpcm9ubWVudCkge1xuICAgIGNvbnN0IG9wZXJhbmQgPSB0aGlzLmV2YWx1YXRlKG5vZGUub3BlcmFuZCwgZW52aXJvbm1lbnQpO1xuICAgIGlmIChub2RlLmZpbHRlci50eXBlID09PSBcIklkZW50aWZpZXJcIikge1xuICAgICAgY29uc3QgZmlsdGVyID0gbm9kZS5maWx0ZXI7XG4gICAgICBpZiAob3BlcmFuZCBpbnN0YW5jZW9mIEFycmF5VmFsdWUpIHtcbiAgICAgICAgc3dpdGNoIChmaWx0ZXIudmFsdWUpIHtcbiAgICAgICAgICBjYXNlIFwibGlzdFwiOlxuICAgICAgICAgICAgcmV0dXJuIG9wZXJhbmQ7XG4gICAgICAgICAgY2FzZSBcImZpcnN0XCI6XG4gICAgICAgICAgICByZXR1cm4gb3BlcmFuZC52YWx1ZVswXTtcbiAgICAgICAgICBjYXNlIFwibGFzdFwiOlxuICAgICAgICAgICAgcmV0dXJuIG9wZXJhbmQudmFsdWVbb3BlcmFuZC52YWx1ZS5sZW5ndGggLSAxXTtcbiAgICAgICAgICBjYXNlIFwibGVuZ3RoXCI6XG4gICAgICAgICAgICByZXR1cm4gbmV3IE51bWVyaWNWYWx1ZShvcGVyYW5kLnZhbHVlLmxlbmd0aCk7XG4gICAgICAgICAgY2FzZSBcInJldmVyc2VcIjpcbiAgICAgICAgICAgIHJldHVybiBuZXcgQXJyYXlWYWx1ZShvcGVyYW5kLnZhbHVlLnJldmVyc2UoKSk7XG4gICAgICAgICAgY2FzZSBcInNvcnRcIjpcbiAgICAgICAgICAgIHJldHVybiBuZXcgQXJyYXlWYWx1ZShcbiAgICAgICAgICAgICAgb3BlcmFuZC52YWx1ZS5zb3J0KChhLCBiKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGEudHlwZSAhPT0gYi50eXBlKSB7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBjb21wYXJlIGRpZmZlcmVudCB0eXBlczogJHthLnR5cGV9IGFuZCAke2IudHlwZX1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3dpdGNoIChhLnR5cGUpIHtcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJOdW1lcmljVmFsdWVcIjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGEudmFsdWUgLSBiLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgY2FzZSBcIlN0cmluZ1ZhbHVlXCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhLnZhbHVlLmxvY2FsZUNvbXBhcmUoYi52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBjb21wYXJlIHR5cGU6ICR7YS50eXBlfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBBcnJheVZhbHVlIGZpbHRlcjogJHtmaWx0ZXIudmFsdWV9YCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAob3BlcmFuZCBpbnN0YW5jZW9mIFN0cmluZ1ZhbHVlKSB7XG4gICAgICAgIHN3aXRjaCAoZmlsdGVyLnZhbHVlKSB7XG4gICAgICAgICAgY2FzZSBcImxlbmd0aFwiOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBOdW1lcmljVmFsdWUob3BlcmFuZC52YWx1ZS5sZW5ndGgpO1xuICAgICAgICAgIGNhc2UgXCJ1cHBlclwiOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBTdHJpbmdWYWx1ZShvcGVyYW5kLnZhbHVlLnRvVXBwZXJDYXNlKCkpO1xuICAgICAgICAgIGNhc2UgXCJsb3dlclwiOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBTdHJpbmdWYWx1ZShvcGVyYW5kLnZhbHVlLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICAgIGNhc2UgXCJ0aXRsZVwiOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBTdHJpbmdWYWx1ZSh0aXRsZUNhc2Uob3BlcmFuZC52YWx1ZSkpO1xuICAgICAgICAgIGNhc2UgXCJjYXBpdGFsaXplXCI6XG4gICAgICAgICAgICByZXR1cm4gbmV3IFN0cmluZ1ZhbHVlKG9wZXJhbmQudmFsdWUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBvcGVyYW5kLnZhbHVlLnNsaWNlKDEpKTtcbiAgICAgICAgICBjYXNlIFwidHJpbVwiOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBTdHJpbmdWYWx1ZShvcGVyYW5kLnZhbHVlLnRyaW0oKSk7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBTdHJpbmdWYWx1ZSBmaWx0ZXI6ICR7ZmlsdGVyLnZhbHVlfWApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKG9wZXJhbmQgaW5zdGFuY2VvZiBOdW1lcmljVmFsdWUpIHtcbiAgICAgICAgc3dpdGNoIChmaWx0ZXIudmFsdWUpIHtcbiAgICAgICAgICBjYXNlIFwiYWJzXCI6XG4gICAgICAgICAgICByZXR1cm4gbmV3IE51bWVyaWNWYWx1ZShNYXRoLmFicyhvcGVyYW5kLnZhbHVlKSk7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBOdW1lcmljVmFsdWUgZmlsdGVyOiAke2ZpbHRlci52YWx1ZX1gKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChvcGVyYW5kIGluc3RhbmNlb2YgT2JqZWN0VmFsdWUpIHtcbiAgICAgICAgc3dpdGNoIChmaWx0ZXIudmFsdWUpIHtcbiAgICAgICAgICBjYXNlIFwiaXRlbXNcIjpcbiAgICAgICAgICAgIHJldHVybiBuZXcgQXJyYXlWYWx1ZShcbiAgICAgICAgICAgICAgQXJyYXkuZnJvbShvcGVyYW5kLnZhbHVlLmVudHJpZXMoKSkubWFwKChba2V5LCB2YWx1ZV0pID0+IG5ldyBBcnJheVZhbHVlKFtuZXcgU3RyaW5nVmFsdWUoa2V5KSwgdmFsdWVdKSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgY2FzZSBcImxlbmd0aFwiOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBOdW1lcmljVmFsdWUob3BlcmFuZC52YWx1ZS5zaXplKTtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIE9iamVjdFZhbHVlIGZpbHRlcjogJHtmaWx0ZXIudmFsdWV9YCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IGFwcGx5IGZpbHRlciBcIiR7ZmlsdGVyLnZhbHVlfVwiIHRvIHR5cGU6ICR7b3BlcmFuZC50eXBlfWApO1xuICAgIH0gZWxzZSBpZiAobm9kZS5maWx0ZXIudHlwZSA9PT0gXCJDYWxsRXhwcmVzc2lvblwiKSB7XG4gICAgICBjb25zdCBmaWx0ZXIgPSBub2RlLmZpbHRlcjtcbiAgICAgIGlmIChmaWx0ZXIuY2FsbGVlLnR5cGUgIT09IFwiSWRlbnRpZmllclwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBmaWx0ZXI6ICR7ZmlsdGVyLmNhbGxlZS50eXBlfWApO1xuICAgICAgfVxuICAgICAgY29uc3QgZmlsdGVyTmFtZSA9IGZpbHRlci5jYWxsZWUudmFsdWU7XG4gICAgICBpZiAob3BlcmFuZCBpbnN0YW5jZW9mIEFycmF5VmFsdWUpIHtcbiAgICAgICAgc3dpdGNoIChmaWx0ZXJOYW1lKSB7XG4gICAgICAgICAgY2FzZSBcInNlbGVjdGF0dHJcIjoge1xuICAgICAgICAgICAgaWYgKG9wZXJhbmQudmFsdWUuc29tZSgoeCkgPT4gISh4IGluc3RhbmNlb2YgT2JqZWN0VmFsdWUpKSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJgc2VsZWN0YXR0cmAgY2FuIG9ubHkgYmUgYXBwbGllZCB0byBhcnJheSBvZiBvYmplY3RzXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZpbHRlci5hcmdzLnNvbWUoKHgpID0+IHgudHlwZSAhPT0gXCJTdHJpbmdMaXRlcmFsXCIpKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImFyZ3VtZW50cyBvZiBgc2VsZWN0YXR0cmAgbXVzdCBiZSBzdHJpbmdzXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgW2F0dHIsIHRlc3ROYW1lLCB2YWx1ZV0gPSBmaWx0ZXIuYXJncy5tYXAoKHgpID0+IHRoaXMuZXZhbHVhdGUoeCwgZW52aXJvbm1lbnQpKTtcbiAgICAgICAgICAgIGxldCB0ZXN0RnVuY3Rpb247XG4gICAgICAgICAgICBpZiAodGVzdE5hbWUpIHtcbiAgICAgICAgICAgICAgY29uc3QgdGVzdCA9IGVudmlyb25tZW50LnRlc3RzLmdldCh0ZXN0TmFtZS52YWx1ZSk7XG4gICAgICAgICAgICAgIGlmICghdGVzdCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biB0ZXN0OiAke3Rlc3ROYW1lLnZhbHVlfWApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRlc3RGdW5jdGlvbiA9IHRlc3Q7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0ZXN0RnVuY3Rpb24gPSAoLi4ueCkgPT4geFswXS5fX2Jvb2xfXygpLnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZmlsdGVyZWQgPSBvcGVyYW5kLnZhbHVlLmZpbHRlcigoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICBjb25zdCBhID0gaXRlbS52YWx1ZS5nZXQoYXR0ci52YWx1ZSk7XG4gICAgICAgICAgICAgIGlmIChhKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRlc3RGdW5jdGlvbihhLCB2YWx1ZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEFycmF5VmFsdWUoZmlsdGVyZWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gQXJyYXlWYWx1ZSBmaWx0ZXI6ICR7ZmlsdGVyTmFtZX1gKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IGFwcGx5IGZpbHRlciBcIiR7ZmlsdGVyTmFtZX1cIiB0byB0eXBlOiAke29wZXJhbmQudHlwZX1gKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGZpbHRlcjogJHtub2RlLmZpbHRlci50eXBlfWApO1xuICB9XG4gIC8qKlxuICAgKiBFdmFsdWF0ZXMgZXhwcmVzc2lvbnMgZm9sbG93aW5nIHRoZSB0ZXN0IG9wZXJhdGlvbiB0eXBlLlxuICAgKi9cbiAgZXZhbHVhdGVUZXN0RXhwcmVzc2lvbihub2RlLCBlbnZpcm9ubWVudCkge1xuICAgIGNvbnN0IG9wZXJhbmQgPSB0aGlzLmV2YWx1YXRlKG5vZGUub3BlcmFuZCwgZW52aXJvbm1lbnQpO1xuICAgIGNvbnN0IHRlc3QgPSBlbnZpcm9ubWVudC50ZXN0cy5nZXQobm9kZS50ZXN0LnZhbHVlKTtcbiAgICBpZiAoIXRlc3QpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biB0ZXN0OiAke25vZGUudGVzdC52YWx1ZX1gKTtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gdGVzdChvcGVyYW5kKTtcbiAgICByZXR1cm4gbmV3IEJvb2xlYW5WYWx1ZShub2RlLm5lZ2F0ZSA/ICFyZXN1bHQgOiByZXN1bHQpO1xuICB9XG4gIC8qKlxuICAgKiBFdmFsdWF0ZXMgZXhwcmVzc2lvbnMgZm9sbG93aW5nIHRoZSB1bmFyeSBvcGVyYXRpb24gdHlwZS5cbiAgICovXG4gIGV2YWx1YXRlVW5hcnlFeHByZXNzaW9uKG5vZGUsIGVudmlyb25tZW50KSB7XG4gICAgY29uc3QgYXJndW1lbnQgPSB0aGlzLmV2YWx1YXRlKG5vZGUuYXJndW1lbnQsIGVudmlyb25tZW50KTtcbiAgICBzd2l0Y2ggKG5vZGUub3BlcmF0b3IudmFsdWUpIHtcbiAgICAgIGNhc2UgXCJub3RcIjpcbiAgICAgICAgcmV0dXJuIG5ldyBCb29sZWFuVmFsdWUoIWFyZ3VtZW50LnZhbHVlKTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgVW5rbm93biBvcGVyYXRvcjogJHtub2RlLm9wZXJhdG9yLnZhbHVlfWApO1xuICAgIH1cbiAgfVxuICBldmFsUHJvZ3JhbShwcm9ncmFtLCBlbnZpcm9ubWVudCkge1xuICAgIHJldHVybiB0aGlzLmV2YWx1YXRlQmxvY2socHJvZ3JhbS5ib2R5LCBlbnZpcm9ubWVudCk7XG4gIH1cbiAgZXZhbHVhdGVCbG9jayhzdGF0ZW1lbnRzLCBlbnZpcm9ubWVudCkge1xuICAgIGxldCByZXN1bHQgPSBcIlwiO1xuICAgIGZvciAoY29uc3Qgc3RhdGVtZW50IG9mIHN0YXRlbWVudHMpIHtcbiAgICAgIGNvbnN0IGxhc3RFdmFsdWF0ZWQgPSB0aGlzLmV2YWx1YXRlKHN0YXRlbWVudCwgZW52aXJvbm1lbnQpO1xuICAgICAgaWYgKGxhc3RFdmFsdWF0ZWQudHlwZSAhPT0gXCJOdWxsVmFsdWVcIiAmJiBsYXN0RXZhbHVhdGVkLnR5cGUgIT09IFwiVW5kZWZpbmVkVmFsdWVcIikge1xuICAgICAgICByZXN1bHQgKz0gbGFzdEV2YWx1YXRlZC52YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ldyBTdHJpbmdWYWx1ZShyZXN1bHQpO1xuICB9XG4gIGV2YWx1YXRlSWRlbnRpZmllcihub2RlLCBlbnZpcm9ubWVudCkge1xuICAgIHJldHVybiBlbnZpcm9ubWVudC5sb29rdXBWYXJpYWJsZShub2RlLnZhbHVlKTtcbiAgfVxuICBldmFsdWF0ZUNhbGxFeHByZXNzaW9uKGV4cHIsIGVudmlyb25tZW50KSB7XG4gICAgY29uc3QgYXJncyA9IFtdO1xuICAgIGNvbnN0IGt3YXJncyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgZm9yIChjb25zdCBhcmd1bWVudCBvZiBleHByLmFyZ3MpIHtcbiAgICAgIGlmIChhcmd1bWVudC50eXBlID09PSBcIktleXdvcmRBcmd1bWVudEV4cHJlc3Npb25cIikge1xuICAgICAgICBjb25zdCBrd2FyZyA9IGFyZ3VtZW50O1xuICAgICAgICBrd2FyZ3Muc2V0KGt3YXJnLmtleS52YWx1ZSwgdGhpcy5ldmFsdWF0ZShrd2FyZy52YWx1ZSwgZW52aXJvbm1lbnQpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFyZ3MucHVzaCh0aGlzLmV2YWx1YXRlKGFyZ3VtZW50LCBlbnZpcm9ubWVudCkpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoa3dhcmdzLnNpemUgPiAwKSB7XG4gICAgICBhcmdzLnB1c2gobmV3IE9iamVjdFZhbHVlKGt3YXJncykpO1xuICAgIH1cbiAgICBjb25zdCBmbiA9IHRoaXMuZXZhbHVhdGUoZXhwci5jYWxsZWUsIGVudmlyb25tZW50KTtcbiAgICBpZiAoZm4udHlwZSAhPT0gXCJGdW5jdGlvblZhbHVlXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IGNhbGwgc29tZXRoaW5nIHRoYXQgaXMgbm90IGEgZnVuY3Rpb246IGdvdCAke2ZuLnR5cGV9YCk7XG4gICAgfVxuICAgIHJldHVybiBmbi52YWx1ZShhcmdzLCBlbnZpcm9ubWVudCk7XG4gIH1cbiAgZXZhbHVhdGVTbGljZUV4cHJlc3Npb24ob2JqZWN0LCBleHByLCBlbnZpcm9ubWVudCkge1xuICAgIGlmICghKG9iamVjdCBpbnN0YW5jZW9mIEFycmF5VmFsdWUgfHwgb2JqZWN0IGluc3RhbmNlb2YgU3RyaW5nVmFsdWUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTbGljZSBvYmplY3QgbXVzdCBiZSBhbiBhcnJheSBvciBzdHJpbmdcIik7XG4gICAgfVxuICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5ldmFsdWF0ZShleHByLnN0YXJ0LCBlbnZpcm9ubWVudCk7XG4gICAgY29uc3Qgc3RvcCA9IHRoaXMuZXZhbHVhdGUoZXhwci5zdG9wLCBlbnZpcm9ubWVudCk7XG4gICAgY29uc3Qgc3RlcCA9IHRoaXMuZXZhbHVhdGUoZXhwci5zdGVwLCBlbnZpcm9ubWVudCk7XG4gICAgaWYgKCEoc3RhcnQgaW5zdGFuY2VvZiBOdW1lcmljVmFsdWUgfHwgc3RhcnQgaW5zdGFuY2VvZiBVbmRlZmluZWRWYWx1ZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlNsaWNlIHN0YXJ0IG11c3QgYmUgbnVtZXJpYyBvciB1bmRlZmluZWRcIik7XG4gICAgfVxuICAgIGlmICghKHN0b3AgaW5zdGFuY2VvZiBOdW1lcmljVmFsdWUgfHwgc3RvcCBpbnN0YW5jZW9mIFVuZGVmaW5lZFZhbHVlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2xpY2Ugc3RvcCBtdXN0IGJlIG51bWVyaWMgb3IgdW5kZWZpbmVkXCIpO1xuICAgIH1cbiAgICBpZiAoIShzdGVwIGluc3RhbmNlb2YgTnVtZXJpY1ZhbHVlIHx8IHN0ZXAgaW5zdGFuY2VvZiBVbmRlZmluZWRWYWx1ZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlNsaWNlIHN0ZXAgbXVzdCBiZSBudW1lcmljIG9yIHVuZGVmaW5lZFwiKTtcbiAgICB9XG4gICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIEFycmF5VmFsdWUpIHtcbiAgICAgIHJldHVybiBuZXcgQXJyYXlWYWx1ZShzbGljZShvYmplY3QudmFsdWUsIHN0YXJ0LnZhbHVlLCBzdG9wLnZhbHVlLCBzdGVwLnZhbHVlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBuZXcgU3RyaW5nVmFsdWUoc2xpY2UoQXJyYXkuZnJvbShvYmplY3QudmFsdWUpLCBzdGFydC52YWx1ZSwgc3RvcC52YWx1ZSwgc3RlcC52YWx1ZSkuam9pbihcIlwiKSk7XG4gICAgfVxuICB9XG4gIGV2YWx1YXRlTWVtYmVyRXhwcmVzc2lvbihleHByLCBlbnZpcm9ubWVudCkge1xuICAgIGNvbnN0IG9iamVjdCA9IHRoaXMuZXZhbHVhdGUoZXhwci5vYmplY3QsIGVudmlyb25tZW50KTtcbiAgICBsZXQgcHJvcGVydHk7XG4gICAgaWYgKGV4cHIuY29tcHV0ZWQpIHtcbiAgICAgIGlmIChleHByLnByb3BlcnR5LnR5cGUgPT09IFwiU2xpY2VFeHByZXNzaW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXZhbHVhdGVTbGljZUV4cHJlc3Npb24ob2JqZWN0LCBleHByLnByb3BlcnR5LCBlbnZpcm9ubWVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9wZXJ0eSA9IHRoaXMuZXZhbHVhdGUoZXhwci5wcm9wZXJ0eSwgZW52aXJvbm1lbnQpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwcm9wZXJ0eSA9IG5ldyBTdHJpbmdWYWx1ZShleHByLnByb3BlcnR5LnZhbHVlKTtcbiAgICB9XG4gICAgbGV0IHZhbHVlO1xuICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiBPYmplY3RWYWx1ZSkge1xuICAgICAgaWYgKCEocHJvcGVydHkgaW5zdGFuY2VvZiBTdHJpbmdWYWx1ZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgYWNjZXNzIHByb3BlcnR5IHdpdGggbm9uLXN0cmluZzogZ290ICR7cHJvcGVydHkudHlwZX1gKTtcbiAgICAgIH1cbiAgICAgIHZhbHVlID0gb2JqZWN0LnZhbHVlLmdldChwcm9wZXJ0eS52YWx1ZSkgPz8gb2JqZWN0LmJ1aWx0aW5zLmdldChwcm9wZXJ0eS52YWx1ZSk7XG4gICAgfSBlbHNlIGlmIChvYmplY3QgaW5zdGFuY2VvZiBBcnJheVZhbHVlIHx8IG9iamVjdCBpbnN0YW5jZW9mIFN0cmluZ1ZhbHVlKSB7XG4gICAgICBpZiAocHJvcGVydHkgaW5zdGFuY2VvZiBOdW1lcmljVmFsdWUpIHtcbiAgICAgICAgdmFsdWUgPSBvYmplY3QudmFsdWUuYXQocHJvcGVydHkudmFsdWUpO1xuICAgICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgU3RyaW5nVmFsdWUpIHtcbiAgICAgICAgICB2YWx1ZSA9IG5ldyBTdHJpbmdWYWx1ZShvYmplY3QudmFsdWUuYXQocHJvcGVydHkudmFsdWUpKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChwcm9wZXJ0eSBpbnN0YW5jZW9mIFN0cmluZ1ZhbHVlKSB7XG4gICAgICAgIHZhbHVlID0gb2JqZWN0LmJ1aWx0aW5zLmdldChwcm9wZXJ0eS52YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBhY2Nlc3MgcHJvcGVydHkgd2l0aCBub24tc3RyaW5nL25vbi1udW1iZXI6IGdvdCAke3Byb3BlcnR5LnR5cGV9YCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghKHByb3BlcnR5IGluc3RhbmNlb2YgU3RyaW5nVmFsdWUpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IGFjY2VzcyBwcm9wZXJ0eSB3aXRoIG5vbi1zdHJpbmc6IGdvdCAke3Byb3BlcnR5LnR5cGV9YCk7XG4gICAgICB9XG4gICAgICB2YWx1ZSA9IG9iamVjdC5idWlsdGlucy5nZXQocHJvcGVydHkudmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBSdW50aW1lVmFsdWUgPyB2YWx1ZSA6IG5ldyBVbmRlZmluZWRWYWx1ZSgpO1xuICB9XG4gIGV2YWx1YXRlU2V0KG5vZGUsIGVudmlyb25tZW50KSB7XG4gICAgY29uc3QgcmhzID0gdGhpcy5ldmFsdWF0ZShub2RlLnZhbHVlLCBlbnZpcm9ubWVudCk7XG4gICAgaWYgKG5vZGUuYXNzaWduZWUudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIpIHtcbiAgICAgIGNvbnN0IHZhcmlhYmxlTmFtZSA9IG5vZGUuYXNzaWduZWUudmFsdWU7XG4gICAgICBlbnZpcm9ubWVudC5zZXRWYXJpYWJsZSh2YXJpYWJsZU5hbWUsIHJocyk7XG4gICAgfSBlbHNlIGlmIChub2RlLmFzc2lnbmVlLnR5cGUgPT09IFwiTWVtYmVyRXhwcmVzc2lvblwiKSB7XG4gICAgICBjb25zdCBtZW1iZXIgPSBub2RlLmFzc2lnbmVlO1xuICAgICAgY29uc3Qgb2JqZWN0ID0gdGhpcy5ldmFsdWF0ZShtZW1iZXIub2JqZWN0LCBlbnZpcm9ubWVudCk7XG4gICAgICBpZiAoIShvYmplY3QgaW5zdGFuY2VvZiBPYmplY3RWYWx1ZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGFzc2lnbiB0byBtZW1iZXIgb2Ygbm9uLW9iamVjdFwiKTtcbiAgICAgIH1cbiAgICAgIGlmIChtZW1iZXIucHJvcGVydHkudHlwZSAhPT0gXCJJZGVudGlmaWVyXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGFzc2lnbiB0byBtZW1iZXIgd2l0aCBub24taWRlbnRpZmllciBwcm9wZXJ0eVwiKTtcbiAgICAgIH1cbiAgICAgIG9iamVjdC52YWx1ZS5zZXQobWVtYmVyLnByb3BlcnR5LnZhbHVlLCByaHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgTEhTIGluc2lkZSBhc3NpZ25tZW50IGV4cHJlc3Npb246ICR7SlNPTi5zdHJpbmdpZnkobm9kZS5hc3NpZ25lZSl9YCk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgTnVsbFZhbHVlKCk7XG4gIH1cbiAgZXZhbHVhdGVJZihub2RlLCBlbnZpcm9ubWVudCkge1xuICAgIGNvbnN0IHRlc3QgPSB0aGlzLmV2YWx1YXRlKG5vZGUudGVzdCwgZW52aXJvbm1lbnQpO1xuICAgIHJldHVybiB0aGlzLmV2YWx1YXRlQmxvY2sodGVzdC5fX2Jvb2xfXygpLnZhbHVlID8gbm9kZS5ib2R5IDogbm9kZS5hbHRlcm5hdGUsIGVudmlyb25tZW50KTtcbiAgfVxuICBldmFsdWF0ZUZvcihub2RlLCBlbnZpcm9ubWVudCkge1xuICAgIGNvbnN0IHNjb3BlID0gbmV3IEVudmlyb25tZW50KGVudmlyb25tZW50KTtcbiAgICBjb25zdCBpdGVyYWJsZSA9IHRoaXMuZXZhbHVhdGUobm9kZS5pdGVyYWJsZSwgc2NvcGUpO1xuICAgIGlmICghKGl0ZXJhYmxlIGluc3RhbmNlb2YgQXJyYXlWYWx1ZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgaXRlcmFibGUgdHlwZSBpbiBmb3IgbG9vcDogZ290ICR7aXRlcmFibGUudHlwZX1gKTtcbiAgICB9XG4gICAgbGV0IHJlc3VsdCA9IFwiXCI7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpdGVyYWJsZS52YWx1ZS5sZW5ndGg7ICsraSkge1xuICAgICAgY29uc3QgbG9vcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKFtcbiAgICAgICAgW1wiaW5kZXhcIiwgbmV3IE51bWVyaWNWYWx1ZShpICsgMSldLFxuICAgICAgICBbXCJpbmRleDBcIiwgbmV3IE51bWVyaWNWYWx1ZShpKV0sXG4gICAgICAgIFtcInJldmluZGV4XCIsIG5ldyBOdW1lcmljVmFsdWUoaXRlcmFibGUudmFsdWUubGVuZ3RoIC0gaSldLFxuICAgICAgICBbXCJyZXZpbmRleDBcIiwgbmV3IE51bWVyaWNWYWx1ZShpdGVyYWJsZS52YWx1ZS5sZW5ndGggLSBpIC0gMSldLFxuICAgICAgICBbXCJmaXJzdFwiLCBuZXcgQm9vbGVhblZhbHVlKGkgPT09IDApXSxcbiAgICAgICAgW1wibGFzdFwiLCBuZXcgQm9vbGVhblZhbHVlKGkgPT09IGl0ZXJhYmxlLnZhbHVlLmxlbmd0aCAtIDEpXSxcbiAgICAgICAgW1wibGVuZ3RoXCIsIG5ldyBOdW1lcmljVmFsdWUoaXRlcmFibGUudmFsdWUubGVuZ3RoKV0sXG4gICAgICAgIFtcInByZXZpdGVtXCIsIGkgPiAwID8gaXRlcmFibGUudmFsdWVbaSAtIDFdIDogbmV3IFVuZGVmaW5lZFZhbHVlKCldLFxuICAgICAgICBbXCJuZXh0aXRlbVwiLCBpIDwgaXRlcmFibGUudmFsdWUubGVuZ3RoIC0gMSA/IGl0ZXJhYmxlLnZhbHVlW2kgKyAxXSA6IG5ldyBVbmRlZmluZWRWYWx1ZSgpXVxuICAgICAgXSk7XG4gICAgICBzY29wZS5zZXRWYXJpYWJsZShcImxvb3BcIiwgbmV3IE9iamVjdFZhbHVlKGxvb3ApKTtcbiAgICAgIGNvbnN0IGN1cnJlbnQgPSBpdGVyYWJsZS52YWx1ZVtpXTtcbiAgICAgIGlmIChub2RlLmxvb3B2YXIudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIpIHtcbiAgICAgICAgc2NvcGUuc2V0VmFyaWFibGUobm9kZS5sb29wdmFyLnZhbHVlLCBjdXJyZW50KTtcbiAgICAgIH0gZWxzZSBpZiAobm9kZS5sb29wdmFyLnR5cGUgPT09IFwiVHVwbGVMaXRlcmFsXCIpIHtcbiAgICAgICAgY29uc3QgbG9vcHZhciA9IG5vZGUubG9vcHZhcjtcbiAgICAgICAgaWYgKGN1cnJlbnQudHlwZSAhPT0gXCJBcnJheVZhbHVlXCIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCB1bnBhY2sgbm9uLWl0ZXJhYmxlIHR5cGU6ICR7Y3VycmVudC50eXBlfWApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGMgPSBjdXJyZW50O1xuICAgICAgICBpZiAobG9vcHZhci52YWx1ZS5sZW5ndGggIT09IGMudmFsdWUubGVuZ3RoKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUb28gJHtsb29wdmFyLnZhbHVlLmxlbmd0aCA+IGMudmFsdWUubGVuZ3RoID8gXCJmZXdcIiA6IFwibWFueVwifSBpdGVtcyB0byB1bnBhY2tgKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGxvb3B2YXIudmFsdWUubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICBpZiAobG9vcHZhci52YWx1ZVtqXS50eXBlICE9PSBcIklkZW50aWZpZXJcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgdW5wYWNrIG5vbi1pZGVudGlmaWVyIHR5cGU6ICR7bG9vcHZhci52YWx1ZVtqXS50eXBlfWApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzY29wZS5zZXRWYXJpYWJsZShsb29wdmFyLnZhbHVlW2pdLnZhbHVlLCBjLnZhbHVlW2pdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgZXZhbHVhdGVkID0gdGhpcy5ldmFsdWF0ZUJsb2NrKG5vZGUuYm9keSwgc2NvcGUpO1xuICAgICAgcmVzdWx0ICs9IGV2YWx1YXRlZC52YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBTdHJpbmdWYWx1ZShyZXN1bHQpO1xuICB9XG4gIGV2YWx1YXRlKHN0YXRlbWVudCwgZW52aXJvbm1lbnQpIHtcbiAgICBpZiAoc3RhdGVtZW50ID09PSB2b2lkIDApXG4gICAgICByZXR1cm4gbmV3IFVuZGVmaW5lZFZhbHVlKCk7XG4gICAgc3dpdGNoIChzdGF0ZW1lbnQudHlwZSkge1xuICAgICAgY2FzZSBcIlByb2dyYW1cIjpcbiAgICAgICAgcmV0dXJuIHRoaXMuZXZhbFByb2dyYW0oc3RhdGVtZW50LCBlbnZpcm9ubWVudCk7XG4gICAgICBjYXNlIFwiU2V0XCI6XG4gICAgICAgIHJldHVybiB0aGlzLmV2YWx1YXRlU2V0KHN0YXRlbWVudCwgZW52aXJvbm1lbnQpO1xuICAgICAgY2FzZSBcIklmXCI6XG4gICAgICAgIHJldHVybiB0aGlzLmV2YWx1YXRlSWYoc3RhdGVtZW50LCBlbnZpcm9ubWVudCk7XG4gICAgICBjYXNlIFwiRm9yXCI6XG4gICAgICAgIHJldHVybiB0aGlzLmV2YWx1YXRlRm9yKHN0YXRlbWVudCwgZW52aXJvbm1lbnQpO1xuICAgICAgY2FzZSBcIk51bWVyaWNMaXRlcmFsXCI6XG4gICAgICAgIHJldHVybiBuZXcgTnVtZXJpY1ZhbHVlKE51bWJlcihzdGF0ZW1lbnQudmFsdWUpKTtcbiAgICAgIGNhc2UgXCJTdHJpbmdMaXRlcmFsXCI6XG4gICAgICAgIHJldHVybiBuZXcgU3RyaW5nVmFsdWUoc3RhdGVtZW50LnZhbHVlKTtcbiAgICAgIGNhc2UgXCJCb29sZWFuTGl0ZXJhbFwiOlxuICAgICAgICByZXR1cm4gbmV3IEJvb2xlYW5WYWx1ZShzdGF0ZW1lbnQudmFsdWUpO1xuICAgICAgY2FzZSBcIkFycmF5TGl0ZXJhbFwiOlxuICAgICAgICByZXR1cm4gbmV3IEFycmF5VmFsdWUoc3RhdGVtZW50LnZhbHVlLm1hcCgoeCkgPT4gdGhpcy5ldmFsdWF0ZSh4LCBlbnZpcm9ubWVudCkpKTtcbiAgICAgIGNhc2UgXCJUdXBsZUxpdGVyYWxcIjpcbiAgICAgICAgcmV0dXJuIG5ldyBUdXBsZVZhbHVlKHN0YXRlbWVudC52YWx1ZS5tYXAoKHgpID0+IHRoaXMuZXZhbHVhdGUoeCwgZW52aXJvbm1lbnQpKSk7XG4gICAgICBjYXNlIFwiT2JqZWN0TGl0ZXJhbFwiOiB7XG4gICAgICAgIGNvbnN0IG1hcHBpbmcgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBzdGF0ZW1lbnQudmFsdWUpIHtcbiAgICAgICAgICBjb25zdCBldmFsdWF0ZWRLZXkgPSB0aGlzLmV2YWx1YXRlKGtleSwgZW52aXJvbm1lbnQpO1xuICAgICAgICAgIGlmICghKGV2YWx1YXRlZEtleSBpbnN0YW5jZW9mIFN0cmluZ1ZhbHVlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBPYmplY3Qga2V5cyBtdXN0IGJlIHN0cmluZ3M6IGdvdCAke2V2YWx1YXRlZEtleS50eXBlfWApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBtYXBwaW5nLnNldChldmFsdWF0ZWRLZXkudmFsdWUsIHRoaXMuZXZhbHVhdGUodmFsdWUsIGVudmlyb25tZW50KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBPYmplY3RWYWx1ZShtYXBwaW5nKTtcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJJZGVudGlmaWVyXCI6XG4gICAgICAgIHJldHVybiB0aGlzLmV2YWx1YXRlSWRlbnRpZmllcihzdGF0ZW1lbnQsIGVudmlyb25tZW50KTtcbiAgICAgIGNhc2UgXCJDYWxsRXhwcmVzc2lvblwiOlxuICAgICAgICByZXR1cm4gdGhpcy5ldmFsdWF0ZUNhbGxFeHByZXNzaW9uKHN0YXRlbWVudCwgZW52aXJvbm1lbnQpO1xuICAgICAgY2FzZSBcIk1lbWJlckV4cHJlc3Npb25cIjpcbiAgICAgICAgcmV0dXJuIHRoaXMuZXZhbHVhdGVNZW1iZXJFeHByZXNzaW9uKHN0YXRlbWVudCwgZW52aXJvbm1lbnQpO1xuICAgICAgY2FzZSBcIlVuYXJ5RXhwcmVzc2lvblwiOlxuICAgICAgICByZXR1cm4gdGhpcy5ldmFsdWF0ZVVuYXJ5RXhwcmVzc2lvbihzdGF0ZW1lbnQsIGVudmlyb25tZW50KTtcbiAgICAgIGNhc2UgXCJCaW5hcnlFeHByZXNzaW9uXCI6XG4gICAgICAgIHJldHVybiB0aGlzLmV2YWx1YXRlQmluYXJ5RXhwcmVzc2lvbihzdGF0ZW1lbnQsIGVudmlyb25tZW50KTtcbiAgICAgIGNhc2UgXCJGaWx0ZXJFeHByZXNzaW9uXCI6XG4gICAgICAgIHJldHVybiB0aGlzLmV2YWx1YXRlRmlsdGVyRXhwcmVzc2lvbihzdGF0ZW1lbnQsIGVudmlyb25tZW50KTtcbiAgICAgIGNhc2UgXCJUZXN0RXhwcmVzc2lvblwiOlxuICAgICAgICByZXR1cm4gdGhpcy5ldmFsdWF0ZVRlc3RFeHByZXNzaW9uKHN0YXRlbWVudCwgZW52aXJvbm1lbnQpO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBVbmtub3duIG5vZGUgdHlwZTogJHtzdGF0ZW1lbnQudHlwZX1gKTtcbiAgICB9XG4gIH1cbn07XG5mdW5jdGlvbiBjb252ZXJ0VG9SdW50aW1lVmFsdWVzKGlucHV0KSB7XG4gIHN3aXRjaCAodHlwZW9mIGlucHV0KSB7XG4gICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgcmV0dXJuIG5ldyBOdW1lcmljVmFsdWUoaW5wdXQpO1xuICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgIHJldHVybiBuZXcgU3RyaW5nVmFsdWUoaW5wdXQpO1xuICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICByZXR1cm4gbmV3IEJvb2xlYW5WYWx1ZShpbnB1dCk7XG4gICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAgaWYgKGlucHV0ID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBuZXcgTnVsbFZhbHVlKCk7XG4gICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoaW5wdXQpKSB7XG4gICAgICAgIHJldHVybiBuZXcgQXJyYXlWYWx1ZShpbnB1dC5tYXAoY29udmVydFRvUnVudGltZVZhbHVlcykpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG5ldyBPYmplY3RWYWx1ZShcbiAgICAgICAgICBuZXcgTWFwKE9iamVjdC5lbnRyaWVzKGlucHV0KS5tYXAoKFtrZXksIHZhbHVlXSkgPT4gW2tleSwgY29udmVydFRvUnVudGltZVZhbHVlcyh2YWx1ZSldKSlcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICBjYXNlIFwiZnVuY3Rpb25cIjpcbiAgICAgIHJldHVybiBuZXcgRnVuY3Rpb25WYWx1ZSgoYXJncywgX3Njb3BlKSA9PiB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGlucHV0KC4uLmFyZ3MubWFwKCh4KSA9PiB4LnZhbHVlKSkgPz8gbnVsbDtcbiAgICAgICAgcmV0dXJuIGNvbnZlcnRUb1J1bnRpbWVWYWx1ZXMocmVzdWx0KTtcbiAgICAgIH0pO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBjb252ZXJ0IHRvIHJ1bnRpbWUgdmFsdWU6ICR7aW5wdXR9YCk7XG4gIH1cbn1cblxuLy8gc3JjL2luZGV4LnRzXG52YXIgVGVtcGxhdGUgPSBjbGFzcyB7XG4gIHBhcnNlZDtcbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0ZW1wbGF0ZSBUaGUgdGVtcGxhdGUgc3RyaW5nXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih0ZW1wbGF0ZSkge1xuICAgIGNvbnN0IHRva2VucyA9IHRva2VuaXplKHRlbXBsYXRlLCB7XG4gICAgICBsc3RyaXBfYmxvY2tzOiB0cnVlLFxuICAgICAgdHJpbV9ibG9ja3M6IHRydWVcbiAgICB9KTtcbiAgICB0aGlzLnBhcnNlZCA9IHBhcnNlKHRva2Vucyk7XG4gIH1cbiAgcmVuZGVyKGl0ZW1zKSB7XG4gICAgY29uc3QgZW52ID0gbmV3IEVudmlyb25tZW50KCk7XG4gICAgZW52LnNldChcImZhbHNlXCIsIGZhbHNlKTtcbiAgICBlbnYuc2V0KFwidHJ1ZVwiLCB0cnVlKTtcbiAgICBlbnYuc2V0KFwicmFpc2VfZXhjZXB0aW9uXCIsIChhcmdzKSA9PiB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYXJncyk7XG4gICAgfSk7XG4gICAgZW52LnNldChcInJhbmdlXCIsIHJhbmdlKTtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhpdGVtcykpIHtcbiAgICAgIGVudi5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgfVxuICAgIGNvbnN0IGludGVycHJldGVyID0gbmV3IEludGVycHJldGVyKGVudik7XG4gICAgY29uc3QgcmVzdWx0ID0gaW50ZXJwcmV0ZXIucnVuKHRoaXMucGFyc2VkKTtcbiAgICByZXR1cm4gcmVzdWx0LnZhbHVlO1xuICB9XG59O1xuZXhwb3J0IHtcbiAgRW52aXJvbm1lbnQsXG4gIEludGVycHJldGVyLFxuICBUZW1wbGF0ZSxcbiAgcGFyc2UsXG4gIHRva2VuaXplXG59O1xuIl0sIm5hbWVzIjpbIlRPS0VOX1RZUEVTIiwiT2JqZWN0IiwiZnJlZXplIiwiVGV4dCIsIk51bWVyaWNMaXRlcmFsIiwiQm9vbGVhbkxpdGVyYWwiLCJTdHJpbmdMaXRlcmFsIiwiSWRlbnRpZmllciIsIkVxdWFscyIsIk9wZW5QYXJlbiIsIkNsb3NlUGFyZW4iLCJPcGVuU3RhdGVtZW50IiwiQ2xvc2VTdGF0ZW1lbnQiLCJPcGVuRXhwcmVzc2lvbiIsIkNsb3NlRXhwcmVzc2lvbiIsIk9wZW5TcXVhcmVCcmFja2V0IiwiQ2xvc2VTcXVhcmVCcmFja2V0IiwiT3BlbkN1cmx5QnJhY2tldCIsIkNsb3NlQ3VybHlCcmFja2V0IiwiQ29tbWEiLCJEb3QiLCJDb2xvbiIsIlBpcGUiLCJDYWxsT3BlcmF0b3IiLCJBZGRpdGl2ZUJpbmFyeU9wZXJhdG9yIiwiTXVsdGlwbGljYXRpdmVCaW5hcnlPcGVyYXRvciIsIkNvbXBhcmlzb25CaW5hcnlPcGVyYXRvciIsIlVuYXJ5T3BlcmF0b3IiLCJTZXQiLCJJZiIsIkZvciIsIkluIiwiSXMiLCJOb3RJbiIsIkVsc2UiLCJFbmRJZiIsIkVsc2VJZiIsIkVuZEZvciIsIkFuZCIsIk9yIiwiTm90IiwiS0VZV09SRFMiLCJzZXQiLCJmb3IiLCJpbiIsImlzIiwiaWYiLCJlbHNlIiwiZW5kaWYiLCJlbGlmIiwiZW5kZm9yIiwiYW5kIiwib3IiLCJub3QiLCJ0cnVlIiwiZmFsc2UiLCJUb2tlbiIsImNvbnN0cnVjdG9yIiwidmFsdWUiLCJ0eXBlIiwiaXNXb3JkIiwiY2hhciIsInRlc3QiLCJpc0ludGVnZXIiLCJPUkRFUkVEX01BUFBJTkdfVEFCTEUiLCJFU0NBUEVfQ0hBUkFDVEVSUyIsIk1hcCIsInByZXByb2Nlc3MiLCJ0ZW1wbGF0ZSIsIm9wdGlvbnMiLCJlbmRzV2l0aCIsInNsaWNlIiwicmVwbGFjZSIsImxzdHJpcF9ibG9ja3MiLCJ0cmltX2Jsb2NrcyIsInRva2VuaXplIiwic291cmNlIiwidG9rZW5zIiwic3JjIiwiY3Vyc29yUG9zaXRpb24iLCJjb25zdW1lV2hpbGUiLCJwcmVkaWNhdGUiLCJzdHIiLCJsZW5ndGgiLCJTeW50YXhFcnJvciIsImVzY2FwZWQiLCJ1bmVzY2FwZWQiLCJnZXQiLCJtYWluIiwibGFzdFRva2VuVHlwZSIsImF0IiwidGV4dCIsInB1c2giLCJjaGFyMiIsImxhc3RUb2tlblR5cGUyIiwibnVtIiwidG9rZW4iLCJzbGljZTIiLCJjIiwid29yZCIsImhhc093biIsInBvcCIsIlN0YXRlbWVudCIsIlByb2dyYW0iLCJib2R5IiwiYWx0ZXJuYXRlIiwibG9vcHZhciIsIml0ZXJhYmxlIiwiU2V0U3RhdGVtZW50IiwiYXNzaWduZWUiLCJFeHByZXNzaW9uIiwiTWVtYmVyRXhwcmVzc2lvbiIsIm9iamVjdCIsInByb3BlcnR5IiwiY29tcHV0ZWQiLCJDYWxsRXhwcmVzc2lvbiIsImNhbGxlZSIsImFyZ3MiLCJMaXRlcmFsIiwiQXJyYXlMaXRlcmFsIiwiVHVwbGVMaXRlcmFsIiwiT2JqZWN0TGl0ZXJhbCIsIkJpbmFyeUV4cHJlc3Npb24iLCJvcGVyYXRvciIsImxlZnQiLCJyaWdodCIsIkZpbHRlckV4cHJlc3Npb24iLCJvcGVyYW5kIiwiZmlsdGVyIiwiVGVzdEV4cHJlc3Npb24iLCJuZWdhdGUiLCJVbmFyeUV4cHJlc3Npb24iLCJhcmd1bWVudCIsIlNsaWNlRXhwcmVzc2lvbiIsInN0YXJ0Iiwic3RvcCIsInN0ZXAiLCJLZXl3b3JkQXJndW1lbnRFeHByZXNzaW9uIiwia2V5IiwicGFyc2UiLCJwcm9ncmFtIiwiY3VycmVudCIsImV4cGVjdCIsImVycm9yIiwicHJldiIsIkVycm9yIiwicGFyc2VBbnkiLCJwYXJzZVRleHQiLCJwYXJzZUppbmphU3RhdGVtZW50IiwicGFyc2VKaW5qYUV4cHJlc3Npb24iLCJ0eXBlcyIsInNvbWUiLCJpIiwiZXZlcnkiLCJyZXN1bHQiLCJwYXJzZVNldFN0YXRlbWVudCIsInBhcnNlSWZTdGF0ZW1lbnQiLCJwYXJzZUZvclN0YXRlbWVudCIsInBhcnNlRXhwcmVzc2lvbiIsInBhcnNlRXhwcmVzc2lvblNlcXVlbmNlIiwicHJpbWFyeSIsImZuIiwicGFyc2VQcmltYXJ5RXhwcmVzc2lvbiIsImV4cHJlc3Npb25zIiwiaXNUdXBsZSIsImxvb3BWYXJpYWJsZSIsInBhcnNlVGVybmFyeUV4cHJlc3Npb24iLCJhIiwicGFyc2VMb2dpY2FsT3JFeHByZXNzaW9uIiwiYiIsInBhcnNlTG9naWNhbEFuZEV4cHJlc3Npb24iLCJwYXJzZUxvZ2ljYWxOZWdhdGlvbkV4cHJlc3Npb24iLCJhcmciLCJwYXJzZUNvbXBhcmlzb25FeHByZXNzaW9uIiwicGFyc2VBZGRpdGl2ZUV4cHJlc3Npb24iLCJwYXJzZU11bHRpcGxpY2F0aXZlRXhwcmVzc2lvbiIsInBhcnNlQ2FsbE1lbWJlckV4cHJlc3Npb24iLCJtZW1iZXIiLCJwYXJzZU1lbWJlckV4cHJlc3Npb24iLCJwYXJzZUNhbGxFeHByZXNzaW9uIiwiY2FsbEV4cHJlc3Npb24iLCJwYXJzZUFyZ3MiLCJwYXJzZUFyZ3VtZW50c0xpc3QiLCJwYXJzZU1lbWJlckV4cHJlc3Npb25Bcmd1bWVudHNMaXN0Iiwic2xpY2VzIiwiaXNTbGljZSIsInBhcnNlVGVzdEV4cHJlc3Npb24iLCJwYXJzZUZpbHRlckV4cHJlc3Npb24iLCJ0b1N0cmluZyIsIk51bWJlciIsImV4cHJlc3Npb24iLCJ2YWx1ZXMiLCJyYW5nZSIsImFycmF5IiwiZGlyZWN0aW9uIiwiTWF0aCIsInNpZ24iLCJtYXgiLCJtaW4iLCJ0aXRsZUNhc2UiLCJ0b1VwcGVyQ2FzZSIsIlJ1bnRpbWVWYWx1ZSIsImJ1aWx0aW5zIiwiX19ib29sX18iLCJCb29sZWFuVmFsdWUiLCJOdW1lcmljVmFsdWUiLCJTdHJpbmdWYWx1ZSIsIkZ1bmN0aW9uVmFsdWUiLCJ0b0xvd2VyQ2FzZSIsInRyaW0iLCJPYmplY3RWYWx1ZSIsInNpemUiLCJkZWZhdWx0VmFsdWUiLCJOdWxsVmFsdWUiLCJBcnJheVZhbHVlIiwiQXJyYXkiLCJmcm9tIiwiZW50cmllcyIsIm1hcCIsIlR1cGxlVmFsdWUiLCJVbmRlZmluZWRWYWx1ZSIsIkVudmlyb25tZW50IiwicGFyZW50IiwidmFyaWFibGVzIiwidGVzdHMiLCJuYW1lIiwiZGVjbGFyZVZhcmlhYmxlIiwiY29udmVydFRvUnVudGltZVZhbHVlcyIsImhhcyIsInNldFZhcmlhYmxlIiwicmVzb2x2ZSIsImxvb2t1cFZhcmlhYmxlIiwiSW50ZXJwcmV0ZXIiLCJlbnYiLCJnbG9iYWwiLCJydW4iLCJldmFsdWF0ZSIsImV2YWx1YXRlQmluYXJ5RXhwcmVzc2lvbiIsIm5vZGUiLCJlbnZpcm9ubWVudCIsImNvbmNhdCIsImZpbmQiLCJ4IiwiaW5jbHVkZXMiLCJldmFsdWF0ZUZpbHRlckV4cHJlc3Npb24iLCJyZXZlcnNlIiwic29ydCIsImxvY2FsZUNvbXBhcmUiLCJjaGFyQXQiLCJhYnMiLCJmaWx0ZXJOYW1lIiwiYXR0ciIsInRlc3ROYW1lIiwidGVzdEZ1bmN0aW9uIiwiZmlsdGVyZWQiLCJpdGVtIiwiZXZhbHVhdGVUZXN0RXhwcmVzc2lvbiIsImV2YWx1YXRlVW5hcnlFeHByZXNzaW9uIiwiZXZhbFByb2dyYW0iLCJldmFsdWF0ZUJsb2NrIiwic3RhdGVtZW50cyIsInN0YXRlbWVudCIsImxhc3RFdmFsdWF0ZWQiLCJldmFsdWF0ZUlkZW50aWZpZXIiLCJldmFsdWF0ZUNhbGxFeHByZXNzaW9uIiwiZXhwciIsImt3YXJncyIsImt3YXJnIiwiZXZhbHVhdGVTbGljZUV4cHJlc3Npb24iLCJqb2luIiwiZXZhbHVhdGVNZW1iZXJFeHByZXNzaW9uIiwiZXZhbHVhdGVTZXQiLCJyaHMiLCJ2YXJpYWJsZU5hbWUiLCJKU09OIiwic3RyaW5naWZ5IiwiZXZhbHVhdGVJZiIsImV2YWx1YXRlRm9yIiwic2NvcGUiLCJsb29wIiwiaiIsImV2YWx1YXRlZCIsIm1hcHBpbmciLCJldmFsdWF0ZWRLZXkiLCJpbnB1dCIsImlzQXJyYXkiLCJfc2NvcGUiLCJUZW1wbGF0ZSIsInBhcnNlZCIsInJlbmRlciIsIml0ZW1zIiwiaW50ZXJwcmV0ZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@huggingface/jinja/dist/index.js\n");

/***/ })

};
;