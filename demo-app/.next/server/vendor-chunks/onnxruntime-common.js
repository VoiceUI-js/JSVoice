"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/onnxruntime-common";
exports.ids = ["vendor-chunks/onnxruntime-common"];
exports.modules = {

/***/ "(ssr)/../node_modules/onnxruntime-common/dist/lib/backend-impl.js":
/*!*******************************************************************!*\
  !*** ../node_modules/onnxruntime-common/dist/lib/backend-impl.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   registerBackend: () => (/* binding */ registerBackend),\n/* harmony export */   resolveBackend: () => (/* binding */ resolveBackend)\n/* harmony export */ });\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\nconst backends = {};\nconst backendsSortedByPriority = [];\n/**\n * Register a backend.\n *\n * @param name - the name as a key to lookup as an execution provider.\n * @param backend - the backend object.\n * @param priority - an integer indicating the priority of the backend. Higher number means higher priority. if priority\n * < 0, it will be considered as a 'beta' version and will not be used as a fallback backend by default.\n *\n * @internal\n */ const registerBackend = (name, backend, priority)=>{\n    if (backend && typeof backend.init === \"function\" && typeof backend.createSessionHandler === \"function\") {\n        const currentBackend = backends[name];\n        if (currentBackend === undefined) {\n            backends[name] = {\n                backend,\n                priority\n            };\n        } else if (currentBackend.priority > priority) {\n            // same name is already registered with a higher priority. skip registeration.\n            return;\n        } else if (currentBackend.priority === priority) {\n            if (currentBackend.backend !== backend) {\n                throw new Error(`cannot register backend \"${name}\" using priority ${priority}`);\n            }\n        }\n        if (priority >= 0) {\n            const i = backendsSortedByPriority.indexOf(name);\n            if (i !== -1) {\n                backendsSortedByPriority.splice(i, 1);\n            }\n            for(let i = 0; i < backendsSortedByPriority.length; i++){\n                if (backends[backendsSortedByPriority[i]].priority <= priority) {\n                    backendsSortedByPriority.splice(i, 0, name);\n                    return;\n                }\n            }\n            backendsSortedByPriority.push(name);\n        }\n        return;\n    }\n    throw new TypeError(\"not a valid backend\");\n};\n/**\n * Resolve backend by specified hints.\n *\n * @param backendHints - a list of execution provider names to lookup. If omitted use registered backends as list.\n * @returns a promise that resolves to the backend.\n *\n * @internal\n */ const resolveBackend = async (backendHints)=>{\n    const backendNames = backendHints.length === 0 ? backendsSortedByPriority : backendHints;\n    const errors = [];\n    for (const backendName of backendNames){\n        const backendInfo = backends[backendName];\n        if (backendInfo) {\n            if (backendInfo.initialized) {\n                return backendInfo.backend;\n            } else if (backendInfo.aborted) {\n                continue; // current backend is unavailable; try next\n            }\n            const isInitializing = !!backendInfo.initPromise;\n            try {\n                if (!isInitializing) {\n                    backendInfo.initPromise = backendInfo.backend.init();\n                }\n                await backendInfo.initPromise;\n                backendInfo.initialized = true;\n                return backendInfo.backend;\n            } catch (e) {\n                if (!isInitializing) {\n                    errors.push({\n                        name: backendName,\n                        err: e\n                    });\n                }\n                backendInfo.aborted = true;\n            } finally{\n                delete backendInfo.initPromise;\n            }\n        }\n    }\n    throw new Error(`no available backend found. ERR: ${errors.map((e)=>`[${e.name}] ${e.err}`).join(\", \")}`);\n}; //# sourceMappingURL=backend-impl.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL29ubnhydW50aW1lLWNvbW1vbi9kaXN0L2xpYi9iYWNrZW5kLWltcGwuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSw0REFBNEQ7QUFDNUQsa0NBQWtDO0FBQ2xDLE1BQU1BLFdBQVcsQ0FBQztBQUNsQixNQUFNQywyQkFBMkIsRUFBRTtBQUNuQzs7Ozs7Ozs7O0NBU0MsR0FDTSxNQUFNQyxrQkFBa0IsQ0FBQ0MsTUFBTUMsU0FBU0M7SUFDM0MsSUFBSUQsV0FBVyxPQUFPQSxRQUFRRSxJQUFJLEtBQUssY0FBYyxPQUFPRixRQUFRRyxvQkFBb0IsS0FBSyxZQUFZO1FBQ3JHLE1BQU1DLGlCQUFpQlIsUUFBUSxDQUFDRyxLQUFLO1FBQ3JDLElBQUlLLG1CQUFtQkMsV0FBVztZQUM5QlQsUUFBUSxDQUFDRyxLQUFLLEdBQUc7Z0JBQUVDO2dCQUFTQztZQUFTO1FBQ3pDLE9BQ0ssSUFBSUcsZUFBZUgsUUFBUSxHQUFHQSxVQUFVO1lBQ3pDLDhFQUE4RTtZQUM5RTtRQUNKLE9BQ0ssSUFBSUcsZUFBZUgsUUFBUSxLQUFLQSxVQUFVO1lBQzNDLElBQUlHLGVBQWVKLE9BQU8sS0FBS0EsU0FBUztnQkFDcEMsTUFBTSxJQUFJTSxNQUFNLENBQUMseUJBQXlCLEVBQUVQLEtBQUssaUJBQWlCLEVBQUVFLFNBQVMsQ0FBQztZQUNsRjtRQUNKO1FBQ0EsSUFBSUEsWUFBWSxHQUFHO1lBQ2YsTUFBTU0sSUFBSVYseUJBQXlCVyxPQUFPLENBQUNUO1lBQzNDLElBQUlRLE1BQU0sQ0FBQyxHQUFHO2dCQUNWVix5QkFBeUJZLE1BQU0sQ0FBQ0YsR0FBRztZQUN2QztZQUNBLElBQUssSUFBSUEsSUFBSSxHQUFHQSxJQUFJVix5QkFBeUJhLE1BQU0sRUFBRUgsSUFBSztnQkFDdEQsSUFBSVgsUUFBUSxDQUFDQyx3QkFBd0IsQ0FBQ1UsRUFBRSxDQUFDLENBQUNOLFFBQVEsSUFBSUEsVUFBVTtvQkFDNURKLHlCQUF5QlksTUFBTSxDQUFDRixHQUFHLEdBQUdSO29CQUN0QztnQkFDSjtZQUNKO1lBQ0FGLHlCQUF5QmMsSUFBSSxDQUFDWjtRQUNsQztRQUNBO0lBQ0o7SUFDQSxNQUFNLElBQUlhLFVBQVU7QUFDeEIsRUFBRTtBQUNGOzs7Ozs7O0NBT0MsR0FDTSxNQUFNQyxpQkFBaUIsT0FBT0M7SUFDakMsTUFBTUMsZUFBZUQsYUFBYUosTUFBTSxLQUFLLElBQUliLDJCQUEyQmlCO0lBQzVFLE1BQU1FLFNBQVMsRUFBRTtJQUNqQixLQUFLLE1BQU1DLGVBQWVGLGFBQWM7UUFDcEMsTUFBTUcsY0FBY3RCLFFBQVEsQ0FBQ3FCLFlBQVk7UUFDekMsSUFBSUMsYUFBYTtZQUNiLElBQUlBLFlBQVlDLFdBQVcsRUFBRTtnQkFDekIsT0FBT0QsWUFBWWxCLE9BQU87WUFDOUIsT0FDSyxJQUFJa0IsWUFBWUUsT0FBTyxFQUFFO2dCQUMxQixVQUFVLDJDQUEyQztZQUN6RDtZQUNBLE1BQU1DLGlCQUFpQixDQUFDLENBQUNILFlBQVlJLFdBQVc7WUFDaEQsSUFBSTtnQkFDQSxJQUFJLENBQUNELGdCQUFnQjtvQkFDakJILFlBQVlJLFdBQVcsR0FBR0osWUFBWWxCLE9BQU8sQ0FBQ0UsSUFBSTtnQkFDdEQ7Z0JBQ0EsTUFBTWdCLFlBQVlJLFdBQVc7Z0JBQzdCSixZQUFZQyxXQUFXLEdBQUc7Z0JBQzFCLE9BQU9ELFlBQVlsQixPQUFPO1lBQzlCLEVBQ0EsT0FBT3VCLEdBQUc7Z0JBQ04sSUFBSSxDQUFDRixnQkFBZ0I7b0JBQ2pCTCxPQUFPTCxJQUFJLENBQUM7d0JBQUVaLE1BQU1rQjt3QkFBYU8sS0FBS0Q7b0JBQUU7Z0JBQzVDO2dCQUNBTCxZQUFZRSxPQUFPLEdBQUc7WUFDMUIsU0FDUTtnQkFDSixPQUFPRixZQUFZSSxXQUFXO1lBQ2xDO1FBQ0o7SUFDSjtJQUNBLE1BQU0sSUFBSWhCLE1BQU0sQ0FBQyxpQ0FBaUMsRUFBRVUsT0FBT1MsR0FBRyxDQUFDRixDQUFBQSxJQUFLLENBQUMsQ0FBQyxFQUFFQSxFQUFFeEIsSUFBSSxDQUFDLEVBQUUsRUFBRXdCLEVBQUVDLEdBQUcsQ0FBQyxDQUFDLEVBQUVFLElBQUksQ0FBQyxNQUFNLENBQUM7QUFDNUcsRUFBRSxDQUNGLHdDQUF3QyIsInNvdXJjZXMiOlsid2VicGFjazovL2pzdm9pY2UtZGVtby8uLi9ub2RlX21vZHVsZXMvb25ueHJ1bnRpbWUtY29tbW9uL2Rpc3QvbGliL2JhY2tlbmQtaW1wbC5qcz8zZGIzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuY29uc3QgYmFja2VuZHMgPSB7fTtcbmNvbnN0IGJhY2tlbmRzU29ydGVkQnlQcmlvcml0eSA9IFtdO1xuLyoqXG4gKiBSZWdpc3RlciBhIGJhY2tlbmQuXG4gKlxuICogQHBhcmFtIG5hbWUgLSB0aGUgbmFtZSBhcyBhIGtleSB0byBsb29rdXAgYXMgYW4gZXhlY3V0aW9uIHByb3ZpZGVyLlxuICogQHBhcmFtIGJhY2tlbmQgLSB0aGUgYmFja2VuZCBvYmplY3QuXG4gKiBAcGFyYW0gcHJpb3JpdHkgLSBhbiBpbnRlZ2VyIGluZGljYXRpbmcgdGhlIHByaW9yaXR5IG9mIHRoZSBiYWNrZW5kLiBIaWdoZXIgbnVtYmVyIG1lYW5zIGhpZ2hlciBwcmlvcml0eS4gaWYgcHJpb3JpdHlcbiAqIDwgMCwgaXQgd2lsbCBiZSBjb25zaWRlcmVkIGFzIGEgJ2JldGEnIHZlcnNpb24gYW5kIHdpbGwgbm90IGJlIHVzZWQgYXMgYSBmYWxsYmFjayBiYWNrZW5kIGJ5IGRlZmF1bHQuXG4gKlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBjb25zdCByZWdpc3RlckJhY2tlbmQgPSAobmFtZSwgYmFja2VuZCwgcHJpb3JpdHkpID0+IHtcbiAgICBpZiAoYmFja2VuZCAmJiB0eXBlb2YgYmFja2VuZC5pbml0ID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBiYWNrZW5kLmNyZWF0ZVNlc3Npb25IYW5kbGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRCYWNrZW5kID0gYmFja2VuZHNbbmFtZV07XG4gICAgICAgIGlmIChjdXJyZW50QmFja2VuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBiYWNrZW5kc1tuYW1lXSA9IHsgYmFja2VuZCwgcHJpb3JpdHkgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjdXJyZW50QmFja2VuZC5wcmlvcml0eSA+IHByaW9yaXR5KSB7XG4gICAgICAgICAgICAvLyBzYW1lIG5hbWUgaXMgYWxyZWFkeSByZWdpc3RlcmVkIHdpdGggYSBoaWdoZXIgcHJpb3JpdHkuIHNraXAgcmVnaXN0ZXJhdGlvbi5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjdXJyZW50QmFja2VuZC5wcmlvcml0eSA9PT0gcHJpb3JpdHkpIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50QmFja2VuZC5iYWNrZW5kICE9PSBiYWNrZW5kKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjYW5ub3QgcmVnaXN0ZXIgYmFja2VuZCBcIiR7bmFtZX1cIiB1c2luZyBwcmlvcml0eSAke3ByaW9yaXR5fWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChwcmlvcml0eSA+PSAwKSB7XG4gICAgICAgICAgICBjb25zdCBpID0gYmFja2VuZHNTb3J0ZWRCeVByaW9yaXR5LmluZGV4T2YobmFtZSk7XG4gICAgICAgICAgICBpZiAoaSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBiYWNrZW5kc1NvcnRlZEJ5UHJpb3JpdHkuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBiYWNrZW5kc1NvcnRlZEJ5UHJpb3JpdHkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoYmFja2VuZHNbYmFja2VuZHNTb3J0ZWRCeVByaW9yaXR5W2ldXS5wcmlvcml0eSA8PSBwcmlvcml0eSkge1xuICAgICAgICAgICAgICAgICAgICBiYWNrZW5kc1NvcnRlZEJ5UHJpb3JpdHkuc3BsaWNlKGksIDAsIG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYmFja2VuZHNTb3J0ZWRCeVByaW9yaXR5LnB1c2gobmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdub3QgYSB2YWxpZCBiYWNrZW5kJyk7XG59O1xuLyoqXG4gKiBSZXNvbHZlIGJhY2tlbmQgYnkgc3BlY2lmaWVkIGhpbnRzLlxuICpcbiAqIEBwYXJhbSBiYWNrZW5kSGludHMgLSBhIGxpc3Qgb2YgZXhlY3V0aW9uIHByb3ZpZGVyIG5hbWVzIHRvIGxvb2t1cC4gSWYgb21pdHRlZCB1c2UgcmVnaXN0ZXJlZCBiYWNrZW5kcyBhcyBsaXN0LlxuICogQHJldHVybnMgYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIGJhY2tlbmQuXG4gKlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBjb25zdCByZXNvbHZlQmFja2VuZCA9IGFzeW5jIChiYWNrZW5kSGludHMpID0+IHtcbiAgICBjb25zdCBiYWNrZW5kTmFtZXMgPSBiYWNrZW5kSGludHMubGVuZ3RoID09PSAwID8gYmFja2VuZHNTb3J0ZWRCeVByaW9yaXR5IDogYmFja2VuZEhpbnRzO1xuICAgIGNvbnN0IGVycm9ycyA9IFtdO1xuICAgIGZvciAoY29uc3QgYmFja2VuZE5hbWUgb2YgYmFja2VuZE5hbWVzKSB7XG4gICAgICAgIGNvbnN0IGJhY2tlbmRJbmZvID0gYmFja2VuZHNbYmFja2VuZE5hbWVdO1xuICAgICAgICBpZiAoYmFja2VuZEluZm8pIHtcbiAgICAgICAgICAgIGlmIChiYWNrZW5kSW5mby5pbml0aWFsaXplZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBiYWNrZW5kSW5mby5iYWNrZW5kO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYmFja2VuZEluZm8uYWJvcnRlZCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlOyAvLyBjdXJyZW50IGJhY2tlbmQgaXMgdW5hdmFpbGFibGU7IHRyeSBuZXh0XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBpc0luaXRpYWxpemluZyA9ICEhYmFja2VuZEluZm8uaW5pdFByb21pc2U7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmICghaXNJbml0aWFsaXppbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgYmFja2VuZEluZm8uaW5pdFByb21pc2UgPSBiYWNrZW5kSW5mby5iYWNrZW5kLmluaXQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYXdhaXQgYmFja2VuZEluZm8uaW5pdFByb21pc2U7XG4gICAgICAgICAgICAgICAgYmFja2VuZEluZm8uaW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJldHVybiBiYWNrZW5kSW5mby5iYWNrZW5kO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzSW5pdGlhbGl6aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKHsgbmFtZTogYmFja2VuZE5hbWUsIGVycjogZSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYmFja2VuZEluZm8uYWJvcnRlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICBkZWxldGUgYmFja2VuZEluZm8uaW5pdFByb21pc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBubyBhdmFpbGFibGUgYmFja2VuZCBmb3VuZC4gRVJSOiAke2Vycm9ycy5tYXAoZSA9PiBgWyR7ZS5uYW1lfV0gJHtlLmVycn1gKS5qb2luKCcsICcpfWApO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJhY2tlbmQtaW1wbC5qcy5tYXAiXSwibmFtZXMiOlsiYmFja2VuZHMiLCJiYWNrZW5kc1NvcnRlZEJ5UHJpb3JpdHkiLCJyZWdpc3RlckJhY2tlbmQiLCJuYW1lIiwiYmFja2VuZCIsInByaW9yaXR5IiwiaW5pdCIsImNyZWF0ZVNlc3Npb25IYW5kbGVyIiwiY3VycmVudEJhY2tlbmQiLCJ1bmRlZmluZWQiLCJFcnJvciIsImkiLCJpbmRleE9mIiwic3BsaWNlIiwibGVuZ3RoIiwicHVzaCIsIlR5cGVFcnJvciIsInJlc29sdmVCYWNrZW5kIiwiYmFja2VuZEhpbnRzIiwiYmFja2VuZE5hbWVzIiwiZXJyb3JzIiwiYmFja2VuZE5hbWUiLCJiYWNrZW5kSW5mbyIsImluaXRpYWxpemVkIiwiYWJvcnRlZCIsImlzSW5pdGlhbGl6aW5nIiwiaW5pdFByb21pc2UiLCJlIiwiZXJyIiwibWFwIiwiam9pbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/onnxruntime-common/dist/lib/backend-impl.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/onnxruntime-common/dist/lib/backend.js":
/*!**************************************************************!*\
  !*** ../node_modules/onnxruntime-common/dist/lib/backend.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   registerBackend: () => (/* reexport safe */ _backend_impl__WEBPACK_IMPORTED_MODULE_0__.registerBackend)\n/* harmony export */ });\n/* harmony import */ var _backend_impl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./backend-impl */ \"(ssr)/../node_modules/onnxruntime-common/dist/lib/backend-impl.js\");\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n //# sourceMappingURL=backend.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL29ubnhydW50aW1lLWNvbW1vbi9kaXN0L2xpYi9iYWNrZW5kLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsNERBQTREO0FBQzVELGtDQUFrQztBQUNlLENBQ2pELG1DQUFtQyIsInNvdXJjZXMiOlsid2VicGFjazovL2pzdm9pY2UtZGVtby8uLi9ub2RlX21vZHVsZXMvb25ueHJ1bnRpbWUtY29tbW9uL2Rpc3QvbGliL2JhY2tlbmQuanM/NTEzZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbmV4cG9ydCB7IHJlZ2lzdGVyQmFja2VuZCB9IGZyb20gJy4vYmFja2VuZC1pbXBsJztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJhY2tlbmQuanMubWFwIl0sIm5hbWVzIjpbInJlZ2lzdGVyQmFja2VuZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/onnxruntime-common/dist/lib/backend.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/onnxruntime-common/dist/lib/env-impl.js":
/*!***************************************************************!*\
  !*** ../node_modules/onnxruntime-common/dist/lib/env-impl.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EnvImpl: () => (/* binding */ EnvImpl)\n/* harmony export */ });\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\nclass EnvImpl {\n    constructor(){\n        this.wasm = {};\n        this.webgl = {};\n        this.logLevelInternal = \"warning\";\n    }\n    // TODO standadize the getter and setter convention in env for other fields.\n    set logLevel(value) {\n        if (value === undefined) {\n            return;\n        }\n        if (typeof value !== \"string\" || [\n            \"verbose\",\n            \"info\",\n            \"warning\",\n            \"error\",\n            \"fatal\"\n        ].indexOf(value) === -1) {\n            throw new Error(`Unsupported logging level: ${value}`);\n        }\n        this.logLevelInternal = value;\n    }\n    get logLevel() {\n        return this.logLevelInternal;\n    }\n} //# sourceMappingURL=env-impl.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL29ubnhydW50aW1lLWNvbW1vbi9kaXN0L2xpYi9lbnYtaW1wbC5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsNERBQTREO0FBQzVELGtDQUFrQztBQUMzQixNQUFNQTtJQUNUQyxhQUFjO1FBQ1YsSUFBSSxDQUFDQyxJQUFJLEdBQUcsQ0FBQztRQUNiLElBQUksQ0FBQ0MsS0FBSyxHQUFHLENBQUM7UUFDZCxJQUFJLENBQUNDLGdCQUFnQixHQUFHO0lBQzVCO0lBQ0EsNEVBQTRFO0lBQzVFLElBQUlDLFNBQVNDLEtBQUssRUFBRTtRQUNoQixJQUFJQSxVQUFVQyxXQUFXO1lBQ3JCO1FBQ0o7UUFDQSxJQUFJLE9BQU9ELFVBQVUsWUFBWTtZQUFDO1lBQVc7WUFBUTtZQUFXO1lBQVM7U0FBUSxDQUFDRSxPQUFPLENBQUNGLFdBQVcsQ0FBQyxHQUFHO1lBQ3JHLE1BQU0sSUFBSUcsTUFBTSxDQUFDLDJCQUEyQixFQUFFSCxNQUFNLENBQUM7UUFDekQ7UUFDQSxJQUFJLENBQUNGLGdCQUFnQixHQUFHRTtJQUM1QjtJQUNBLElBQUlELFdBQVc7UUFDWCxPQUFPLElBQUksQ0FBQ0QsZ0JBQWdCO0lBQ2hDO0FBQ0osRUFDQSxvQ0FBb0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9qc3ZvaWNlLWRlbW8vLi4vbm9kZV9tb2R1bGVzL29ubnhydW50aW1lLWNvbW1vbi9kaXN0L2xpYi9lbnYtaW1wbC5qcz83YzZiIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuZXhwb3J0IGNsYXNzIEVudkltcGwge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLndhc20gPSB7fTtcbiAgICAgICAgdGhpcy53ZWJnbCA9IHt9O1xuICAgICAgICB0aGlzLmxvZ0xldmVsSW50ZXJuYWwgPSAnd2FybmluZyc7XG4gICAgfVxuICAgIC8vIFRPRE8gc3RhbmRhZGl6ZSB0aGUgZ2V0dGVyIGFuZCBzZXR0ZXIgY29udmVudGlvbiBpbiBlbnYgZm9yIG90aGVyIGZpZWxkcy5cbiAgICBzZXQgbG9nTGV2ZWwodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJyB8fCBbJ3ZlcmJvc2UnLCAnaW5mbycsICd3YXJuaW5nJywgJ2Vycm9yJywgJ2ZhdGFsJ10uaW5kZXhPZih2YWx1ZSkgPT09IC0xKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGxvZ2dpbmcgbGV2ZWw6ICR7dmFsdWV9YCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sb2dMZXZlbEludGVybmFsID0gdmFsdWU7XG4gICAgfVxuICAgIGdldCBsb2dMZXZlbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9nTGV2ZWxJbnRlcm5hbDtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lbnYtaW1wbC5qcy5tYXAiXSwibmFtZXMiOlsiRW52SW1wbCIsImNvbnN0cnVjdG9yIiwid2FzbSIsIndlYmdsIiwibG9nTGV2ZWxJbnRlcm5hbCIsImxvZ0xldmVsIiwidmFsdWUiLCJ1bmRlZmluZWQiLCJpbmRleE9mIiwiRXJyb3IiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/onnxruntime-common/dist/lib/env-impl.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/onnxruntime-common/dist/lib/env.js":
/*!**********************************************************!*\
  !*** ../node_modules/onnxruntime-common/dist/lib/env.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   env: () => (/* binding */ env)\n/* harmony export */ });\n/* harmony import */ var _env_impl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./env-impl */ \"(ssr)/../node_modules/onnxruntime-common/dist/lib/env-impl.js\");\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\n/**\n * Represent a set of flags as a global singleton.\n */ const env = new _env_impl__WEBPACK_IMPORTED_MODULE_0__.EnvImpl(); //# sourceMappingURL=env.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL29ubnhydW50aW1lLWNvbW1vbi9kaXN0L2xpYi9lbnYuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSw0REFBNEQ7QUFDNUQsa0NBQWtDO0FBQ0c7QUFDckM7O0NBRUMsR0FDTSxNQUFNQyxNQUFNLElBQUlELDhDQUFPQSxHQUFHLENBQ2pDLCtCQUErQiIsInNvdXJjZXMiOlsid2VicGFjazovL2pzdm9pY2UtZGVtby8uLi9ub2RlX21vZHVsZXMvb25ueHJ1bnRpbWUtY29tbW9uL2Rpc3QvbGliL2Vudi5qcz84NGVhIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuaW1wb3J0IHsgRW52SW1wbCB9IGZyb20gJy4vZW52LWltcGwnO1xuLyoqXG4gKiBSZXByZXNlbnQgYSBzZXQgb2YgZmxhZ3MgYXMgYSBnbG9iYWwgc2luZ2xldG9uLlxuICovXG5leHBvcnQgY29uc3QgZW52ID0gbmV3IEVudkltcGwoKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVudi5qcy5tYXAiXSwibmFtZXMiOlsiRW52SW1wbCIsImVudiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/onnxruntime-common/dist/lib/env.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/onnxruntime-common/dist/lib/index.js":
/*!************************************************************!*\
  !*** ../node_modules/onnxruntime-common/dist/lib/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InferenceSession: () => (/* reexport safe */ _inference_session__WEBPACK_IMPORTED_MODULE_2__.InferenceSession),\n/* harmony export */   Tensor: () => (/* reexport safe */ _tensor__WEBPACK_IMPORTED_MODULE_3__.Tensor),\n/* harmony export */   env: () => (/* reexport safe */ _env__WEBPACK_IMPORTED_MODULE_1__.env),\n/* harmony export */   registerBackend: () => (/* reexport safe */ _backend__WEBPACK_IMPORTED_MODULE_0__.registerBackend)\n/* harmony export */ });\n/* harmony import */ var _backend__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./backend */ \"(ssr)/../node_modules/onnxruntime-common/dist/lib/backend.js\");\n/* harmony import */ var _env__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./env */ \"(ssr)/../node_modules/onnxruntime-common/dist/lib/env.js\");\n/* harmony import */ var _inference_session__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./inference-session */ \"(ssr)/../node_modules/onnxruntime-common/dist/lib/inference-session.js\");\n/* harmony import */ var _tensor__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./tensor */ \"(ssr)/../node_modules/onnxruntime-common/dist/lib/tensor.js\");\n/* harmony import */ var _onnx_value__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./onnx-value */ \"(ssr)/../node_modules/onnxruntime-common/dist/lib/onnx-value.js\");\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n/**\n * # ONNX Runtime JavaScript API\n *\n * ONNX Runtime JavaScript API is a unified API for all JavaScript usages, including the following NPM packages:\n *\n * - [onnxruntime-node](https://www.npmjs.com/package/onnxruntime-node)\n * - [onnxruntime-web](https://www.npmjs.com/package/onnxruntime-web)\n * - [onnxruntime-react-native](https://www.npmjs.com/package/onnxruntime-react-native)\n *\n * See also:\n * - [Get Started](https://onnxruntime.ai/docs/get-started/with-javascript.html)\n * - [Inference examples](https://github.com/microsoft/onnxruntime-inference-examples/tree/main/js)\n *\n * @packageDocumentation\n */ \n\n\n\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL29ubnhydW50aW1lLWNvbW1vbi9kaXN0L2xpYi9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBQSw0REFBNEQ7QUFDNUQsa0NBQWtDO0FBQ2xDOzs7Ozs7Ozs7Ozs7OztDQWNDLEdBQ3lCO0FBQ0o7QUFDYztBQUNYO0FBQ0ksQ0FDN0IsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vanN2b2ljZS1kZW1vLy4uL25vZGVfbW9kdWxlcy9vbm54cnVudGltZS1jb21tb24vZGlzdC9saWIvaW5kZXguanM/Yzg1NCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbi8qKlxuICogIyBPTk5YIFJ1bnRpbWUgSmF2YVNjcmlwdCBBUElcbiAqXG4gKiBPTk5YIFJ1bnRpbWUgSmF2YVNjcmlwdCBBUEkgaXMgYSB1bmlmaWVkIEFQSSBmb3IgYWxsIEphdmFTY3JpcHQgdXNhZ2VzLCBpbmNsdWRpbmcgdGhlIGZvbGxvd2luZyBOUE0gcGFja2FnZXM6XG4gKlxuICogLSBbb25ueHJ1bnRpbWUtbm9kZV0oaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2Uvb25ueHJ1bnRpbWUtbm9kZSlcbiAqIC0gW29ubnhydW50aW1lLXdlYl0oaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2Uvb25ueHJ1bnRpbWUtd2ViKVxuICogLSBbb25ueHJ1bnRpbWUtcmVhY3QtbmF0aXZlXShodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS9vbm54cnVudGltZS1yZWFjdC1uYXRpdmUpXG4gKlxuICogU2VlIGFsc286XG4gKiAtIFtHZXQgU3RhcnRlZF0oaHR0cHM6Ly9vbm54cnVudGltZS5haS9kb2NzL2dldC1zdGFydGVkL3dpdGgtamF2YXNjcmlwdC5odG1sKVxuICogLSBbSW5mZXJlbmNlIGV4YW1wbGVzXShodHRwczovL2dpdGh1Yi5jb20vbWljcm9zb2Z0L29ubnhydW50aW1lLWluZmVyZW5jZS1leGFtcGxlcy90cmVlL21haW4vanMpXG4gKlxuICogQHBhY2thZ2VEb2N1bWVudGF0aW9uXG4gKi9cbmV4cG9ydCAqIGZyb20gJy4vYmFja2VuZCc7XG5leHBvcnQgKiBmcm9tICcuL2Vudic7XG5leHBvcnQgKiBmcm9tICcuL2luZmVyZW5jZS1zZXNzaW9uJztcbmV4cG9ydCAqIGZyb20gJy4vdGVuc29yJztcbmV4cG9ydCAqIGZyb20gJy4vb25ueC12YWx1ZSc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/onnxruntime-common/dist/lib/index.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/onnxruntime-common/dist/lib/inference-session-impl.js":
/*!*****************************************************************************!*\
  !*** ../node_modules/onnxruntime-common/dist/lib/inference-session-impl.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InferenceSession: () => (/* binding */ InferenceSession)\n/* harmony export */ });\n/* harmony import */ var _backend_impl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./backend-impl */ \"(ssr)/../node_modules/onnxruntime-common/dist/lib/backend-impl.js\");\n/* harmony import */ var _tensor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./tensor */ \"(ssr)/../node_modules/onnxruntime-common/dist/lib/tensor.js\");\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\n\nclass InferenceSession {\n    constructor(handler){\n        this.handler = handler;\n    }\n    async run(feeds, arg1, arg2) {\n        const fetches = {};\n        let options = {};\n        // check inputs\n        if (typeof feeds !== \"object\" || feeds === null || feeds instanceof _tensor__WEBPACK_IMPORTED_MODULE_1__.Tensor || Array.isArray(feeds)) {\n            throw new TypeError(\"'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.\");\n        }\n        let isFetchesEmpty = true;\n        // determine which override is being used\n        if (typeof arg1 === \"object\") {\n            if (arg1 === null) {\n                throw new TypeError(\"Unexpected argument[1]: cannot be null.\");\n            }\n            if (arg1 instanceof _tensor__WEBPACK_IMPORTED_MODULE_1__.Tensor) {\n                throw new TypeError(\"'fetches' cannot be a Tensor\");\n            }\n            if (Array.isArray(arg1)) {\n                if (arg1.length === 0) {\n                    throw new TypeError(\"'fetches' cannot be an empty array.\");\n                }\n                isFetchesEmpty = false;\n                // output names\n                for (const name of arg1){\n                    if (typeof name !== \"string\") {\n                        throw new TypeError(\"'fetches' must be a string array or an object.\");\n                    }\n                    if (this.outputNames.indexOf(name) === -1) {\n                        throw new RangeError(`'fetches' contains invalid output name: ${name}.`);\n                    }\n                    fetches[name] = null;\n                }\n                if (typeof arg2 === \"object\" && arg2 !== null) {\n                    options = arg2;\n                } else if (typeof arg2 !== \"undefined\") {\n                    throw new TypeError(\"'options' must be an object.\");\n                }\n            } else {\n                // decide whether arg1 is fetches or options\n                // if any output name is present and its value is valid OnnxValue, we consider it fetches\n                let isFetches = false;\n                const arg1Keys = Object.getOwnPropertyNames(arg1);\n                for (const name of this.outputNames){\n                    if (arg1Keys.indexOf(name) !== -1) {\n                        const v = arg1[name];\n                        if (v === null || v instanceof _tensor__WEBPACK_IMPORTED_MODULE_1__.Tensor) {\n                            isFetches = true;\n                            isFetchesEmpty = false;\n                            fetches[name] = v;\n                        }\n                    }\n                }\n                if (isFetches) {\n                    if (typeof arg2 === \"object\" && arg2 !== null) {\n                        options = arg2;\n                    } else if (typeof arg2 !== \"undefined\") {\n                        throw new TypeError(\"'options' must be an object.\");\n                    }\n                } else {\n                    options = arg1;\n                }\n            }\n        } else if (typeof arg1 !== \"undefined\") {\n            throw new TypeError(\"Unexpected argument[1]: must be 'fetches' or 'options'.\");\n        }\n        // check if all inputs are in feed\n        for (const name of this.inputNames){\n            if (typeof feeds[name] === \"undefined\") {\n                throw new Error(`input '${name}' is missing in 'feeds'.`);\n            }\n        }\n        // if no fetches is specified, we use the full output names list\n        if (isFetchesEmpty) {\n            for (const name of this.outputNames){\n                fetches[name] = null;\n            }\n        }\n        // feeds, fetches and options are prepared\n        const results = await this.handler.run(feeds, fetches, options);\n        const returnValue = {};\n        for(const key in results){\n            if (Object.hasOwnProperty.call(results, key)) {\n                returnValue[key] = new _tensor__WEBPACK_IMPORTED_MODULE_1__.Tensor(results[key].type, results[key].data, results[key].dims);\n            }\n        }\n        return returnValue;\n    }\n    static async create(arg0, arg1, arg2, arg3) {\n        // either load from a file or buffer\n        let filePathOrUint8Array;\n        let options = {};\n        if (typeof arg0 === \"string\") {\n            filePathOrUint8Array = arg0;\n            if (typeof arg1 === \"object\" && arg1 !== null) {\n                options = arg1;\n            } else if (typeof arg1 !== \"undefined\") {\n                throw new TypeError(\"'options' must be an object.\");\n            }\n        } else if (arg0 instanceof Uint8Array) {\n            filePathOrUint8Array = arg0;\n            if (typeof arg1 === \"object\" && arg1 !== null) {\n                options = arg1;\n            } else if (typeof arg1 !== \"undefined\") {\n                throw new TypeError(\"'options' must be an object.\");\n            }\n        } else if (arg0 instanceof ArrayBuffer || typeof SharedArrayBuffer !== \"undefined\" && arg0 instanceof SharedArrayBuffer) {\n            const buffer = arg0;\n            let byteOffset = 0;\n            let byteLength = arg0.byteLength;\n            if (typeof arg1 === \"object\" && arg1 !== null) {\n                options = arg1;\n            } else if (typeof arg1 === \"number\") {\n                byteOffset = arg1;\n                if (!Number.isSafeInteger(byteOffset)) {\n                    throw new RangeError(\"'byteOffset' must be an integer.\");\n                }\n                if (byteOffset < 0 || byteOffset >= buffer.byteLength) {\n                    throw new RangeError(`'byteOffset' is out of range [0, ${buffer.byteLength}).`);\n                }\n                byteLength = arg0.byteLength - byteOffset;\n                if (typeof arg2 === \"number\") {\n                    byteLength = arg2;\n                    if (!Number.isSafeInteger(byteLength)) {\n                        throw new RangeError(\"'byteLength' must be an integer.\");\n                    }\n                    if (byteLength <= 0 || byteOffset + byteLength > buffer.byteLength) {\n                        throw new RangeError(`'byteLength' is out of range (0, ${buffer.byteLength - byteOffset}].`);\n                    }\n                    if (typeof arg3 === \"object\" && arg3 !== null) {\n                        options = arg3;\n                    } else if (typeof arg3 !== \"undefined\") {\n                        throw new TypeError(\"'options' must be an object.\");\n                    }\n                } else if (typeof arg2 !== \"undefined\") {\n                    throw new TypeError(\"'byteLength' must be a number.\");\n                }\n            } else if (typeof arg1 !== \"undefined\") {\n                throw new TypeError(\"'options' must be an object.\");\n            }\n            filePathOrUint8Array = new Uint8Array(buffer, byteOffset, byteLength);\n        } else {\n            throw new TypeError(\"Unexpected argument[0]: must be 'path' or 'buffer'.\");\n        }\n        // get backend hints\n        const eps = options.executionProviders || [];\n        const backendHints = eps.map((i)=>typeof i === \"string\" ? i : i.name);\n        const backend = await (0,_backend_impl__WEBPACK_IMPORTED_MODULE_0__.resolveBackend)(backendHints);\n        const handler = await backend.createSessionHandler(filePathOrUint8Array, options);\n        return new InferenceSession(handler);\n    }\n    startProfiling() {\n        this.handler.startProfiling();\n    }\n    endProfiling() {\n        this.handler.endProfiling();\n    }\n    get inputNames() {\n        return this.handler.inputNames;\n    }\n    get outputNames() {\n        return this.handler.outputNames;\n    }\n} //# sourceMappingURL=inference-session-impl.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL29ubnhydW50aW1lLWNvbW1vbi9kaXN0L2xpYi9pbmZlcmVuY2Utc2Vzc2lvbi1pbXBsLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLDREQUE0RDtBQUM1RCxrQ0FBa0M7QUFDYztBQUNkO0FBQzNCLE1BQU1FO0lBQ1RDLFlBQVlDLE9BQU8sQ0FBRTtRQUNqQixJQUFJLENBQUNBLE9BQU8sR0FBR0E7SUFDbkI7SUFDQSxNQUFNQyxJQUFJQyxLQUFLLEVBQUVDLElBQUksRUFBRUMsSUFBSSxFQUFFO1FBQ3pCLE1BQU1DLFVBQVUsQ0FBQztRQUNqQixJQUFJQyxVQUFVLENBQUM7UUFDZixlQUFlO1FBQ2YsSUFBSSxPQUFPSixVQUFVLFlBQVlBLFVBQVUsUUFBUUEsaUJBQWlCTCwyQ0FBTUEsSUFBSVUsTUFBTUMsT0FBTyxDQUFDTixRQUFRO1lBQ2hHLE1BQU0sSUFBSU8sVUFBVTtRQUN4QjtRQUNBLElBQUlDLGlCQUFpQjtRQUNyQix5Q0FBeUM7UUFDekMsSUFBSSxPQUFPUCxTQUFTLFVBQVU7WUFDMUIsSUFBSUEsU0FBUyxNQUFNO2dCQUNmLE1BQU0sSUFBSU0sVUFBVTtZQUN4QjtZQUNBLElBQUlOLGdCQUFnQk4sMkNBQU1BLEVBQUU7Z0JBQ3hCLE1BQU0sSUFBSVksVUFBVTtZQUN4QjtZQUNBLElBQUlGLE1BQU1DLE9BQU8sQ0FBQ0wsT0FBTztnQkFDckIsSUFBSUEsS0FBS1EsTUFBTSxLQUFLLEdBQUc7b0JBQ25CLE1BQU0sSUFBSUYsVUFBVTtnQkFDeEI7Z0JBQ0FDLGlCQUFpQjtnQkFDakIsZUFBZTtnQkFDZixLQUFLLE1BQU1FLFFBQVFULEtBQU07b0JBQ3JCLElBQUksT0FBT1MsU0FBUyxVQUFVO3dCQUMxQixNQUFNLElBQUlILFVBQVU7b0JBQ3hCO29CQUNBLElBQUksSUFBSSxDQUFDSSxXQUFXLENBQUNDLE9BQU8sQ0FBQ0YsVUFBVSxDQUFDLEdBQUc7d0JBQ3ZDLE1BQU0sSUFBSUcsV0FBVyxDQUFDLHdDQUF3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QVMsYUFBYTtnQkFDbEMsTUFBTSxJQUFJTSxVQUFVO1lBQ3hCO1lBQ0F5Qix1QkFBdUIsSUFBSUMsV0FBV0csUUFBUUMsWUFBWUM7UUFDOUQsT0FDSztZQUNELE1BQU0sSUFBSS9CLFVBQVU7UUFDeEI7UUFDQSxvQkFBb0I7UUFDcEIsTUFBTWtDLE1BQU1yQyxRQUFRc0Msa0JBQWtCLElBQUksRUFBRTtRQUM1QyxNQUFNQyxlQUFlRixJQUFJRyxHQUFHLENBQUNDLENBQUFBLElBQUssT0FBT0EsTUFBTSxXQUFXQSxJQUFJQSxFQUFFbkMsSUFBSTtRQUNwRSxNQUFNb0MsVUFBVSxNQUFNcEQsNkRBQWNBLENBQUNpRDtRQUNyQyxNQUFNN0MsVUFBVSxNQUFNZ0QsUUFBUUMsb0JBQW9CLENBQUNmLHNCQUFzQjVCO1FBQ3pFLE9BQU8sSUFBSVIsaUJBQWlCRTtJQUNoQztJQUNBa0QsaUJBQWlCO1FBQ2IsSUFBSSxDQUFDbEQsT0FBTyxDQUFDa0QsY0FBYztJQUMvQjtJQUNBQyxlQUFlO1FBQ1gsSUFBSSxDQUFDbkQsT0FBTyxDQUFDbUQsWUFBWTtJQUM3QjtJQUNBLElBQUk5QixhQUFhO1FBQ2IsT0FBTyxJQUFJLENBQUNyQixPQUFPLENBQUNxQixVQUFVO0lBQ2xDO0lBQ0EsSUFBSVIsY0FBYztRQUNkLE9BQU8sSUFBSSxDQUFDYixPQUFPLENBQUNhLFdBQVc7SUFDbkM7QUFDSixFQUNBLGtEQUFrRCIsInNvdXJjZXMiOlsid2VicGFjazovL2pzdm9pY2UtZGVtby8uLi9ub2RlX21vZHVsZXMvb25ueHJ1bnRpbWUtY29tbW9uL2Rpc3QvbGliL2luZmVyZW5jZS1zZXNzaW9uLWltcGwuanM/MDQ0ZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbmltcG9ydCB7IHJlc29sdmVCYWNrZW5kIH0gZnJvbSAnLi9iYWNrZW5kLWltcGwnO1xuaW1wb3J0IHsgVGVuc29yIH0gZnJvbSAnLi90ZW5zb3InO1xuZXhwb3J0IGNsYXNzIEluZmVyZW5jZVNlc3Npb24ge1xuICAgIGNvbnN0cnVjdG9yKGhhbmRsZXIpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVyID0gaGFuZGxlcjtcbiAgICB9XG4gICAgYXN5bmMgcnVuKGZlZWRzLCBhcmcxLCBhcmcyKSB7XG4gICAgICAgIGNvbnN0IGZldGNoZXMgPSB7fTtcbiAgICAgICAgbGV0IG9wdGlvbnMgPSB7fTtcbiAgICAgICAgLy8gY2hlY2sgaW5wdXRzXG4gICAgICAgIGlmICh0eXBlb2YgZmVlZHMgIT09ICdvYmplY3QnIHx8IGZlZWRzID09PSBudWxsIHx8IGZlZWRzIGluc3RhbmNlb2YgVGVuc29yIHx8IEFycmF5LmlzQXJyYXkoZmVlZHMpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcXCdmZWVkc1xcJyBtdXN0IGJlIGFuIG9iamVjdCB0aGF0IHVzZSBpbnB1dCBuYW1lcyBhcyBrZXlzIGFuZCBPbm54VmFsdWUgYXMgY29ycmVzcG9uZGluZyB2YWx1ZXMuJyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGlzRmV0Y2hlc0VtcHR5ID0gdHJ1ZTtcbiAgICAgICAgLy8gZGV0ZXJtaW5lIHdoaWNoIG92ZXJyaWRlIGlzIGJlaW5nIHVzZWRcbiAgICAgICAgaWYgKHR5cGVvZiBhcmcxID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgaWYgKGFyZzEgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmV4cGVjdGVkIGFyZ3VtZW50WzFdOiBjYW5ub3QgYmUgbnVsbC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhcmcxIGluc3RhbmNlb2YgVGVuc29yKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXFwnZmV0Y2hlc1xcJyBjYW5ub3QgYmUgYSBUZW5zb3InKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGFyZzEpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFyZzEubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1xcJ2ZldGNoZXNcXCcgY2Fubm90IGJlIGFuIGVtcHR5IGFycmF5LicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpc0ZldGNoZXNFbXB0eSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIC8vIG91dHB1dCBuYW1lc1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgbmFtZSBvZiBhcmcxKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1xcJ2ZldGNoZXNcXCcgbXVzdCBiZSBhIHN0cmluZyBhcnJheSBvciBhbiBvYmplY3QuJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMub3V0cHV0TmFtZXMuaW5kZXhPZihuYW1lKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGAnZmV0Y2hlcycgY29udGFpbnMgaW52YWxpZCBvdXRwdXQgbmFtZTogJHtuYW1lfS5gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmZXRjaGVzW25hbWVdID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBhcmcyID09PSAnb2JqZWN0JyAmJiBhcmcyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMgPSBhcmcyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgYXJnMiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXFwnb3B0aW9uc1xcJyBtdXN0IGJlIGFuIG9iamVjdC4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBkZWNpZGUgd2hldGhlciBhcmcxIGlzIGZldGNoZXMgb3Igb3B0aW9uc1xuICAgICAgICAgICAgICAgIC8vIGlmIGFueSBvdXRwdXQgbmFtZSBpcyBwcmVzZW50IGFuZCBpdHMgdmFsdWUgaXMgdmFsaWQgT25ueFZhbHVlLCB3ZSBjb25zaWRlciBpdCBmZXRjaGVzXG4gICAgICAgICAgICAgICAgbGV0IGlzRmV0Y2hlcyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGNvbnN0IGFyZzFLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoYXJnMSk7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBuYW1lIG9mIHRoaXMub3V0cHV0TmFtZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFyZzFLZXlzLmluZGV4T2YobmFtZSkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB2ID0gYXJnMVtuYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2ID09PSBudWxsIHx8IHYgaW5zdGFuY2VvZiBUZW5zb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0ZldGNoZXMgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzRmV0Y2hlc0VtcHR5ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmV0Y2hlc1tuYW1lXSA9IHY7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGlzRmV0Y2hlcykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGFyZzIgPT09ICdvYmplY3QnICYmIGFyZzIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMgPSBhcmcyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBhcmcyICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXFwnb3B0aW9uc1xcJyBtdXN0IGJlIGFuIG9iamVjdC4nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucyA9IGFyZzE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBhcmcxICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5leHBlY3RlZCBhcmd1bWVudFsxXTogbXVzdCBiZSBcXCdmZXRjaGVzXFwnIG9yIFxcJ29wdGlvbnNcXCcuJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY2hlY2sgaWYgYWxsIGlucHV0cyBhcmUgaW4gZmVlZFxuICAgICAgICBmb3IgKGNvbnN0IG5hbWUgb2YgdGhpcy5pbnB1dE5hbWVzKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGZlZWRzW25hbWVdID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgaW5wdXQgJyR7bmFtZX0nIGlzIG1pc3NpbmcgaW4gJ2ZlZWRzJy5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBpZiBubyBmZXRjaGVzIGlzIHNwZWNpZmllZCwgd2UgdXNlIHRoZSBmdWxsIG91dHB1dCBuYW1lcyBsaXN0XG4gICAgICAgIGlmIChpc0ZldGNoZXNFbXB0eSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBuYW1lIG9mIHRoaXMub3V0cHV0TmFtZXMpIHtcbiAgICAgICAgICAgICAgICBmZXRjaGVzW25hbWVdID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBmZWVkcywgZmV0Y2hlcyBhbmQgb3B0aW9ucyBhcmUgcHJlcGFyZWRcbiAgICAgICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IHRoaXMuaGFuZGxlci5ydW4oZmVlZHMsIGZldGNoZXMsIG9wdGlvbnMpO1xuICAgICAgICBjb25zdCByZXR1cm5WYWx1ZSA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiByZXN1bHRzKSB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwocmVzdWx0cywga2V5KSkge1xuICAgICAgICAgICAgICAgIHJldHVyblZhbHVlW2tleV0gPSBuZXcgVGVuc29yKHJlc3VsdHNba2V5XS50eXBlLCByZXN1bHRzW2tleV0uZGF0YSwgcmVzdWx0c1trZXldLmRpbXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXR1cm5WYWx1ZTtcbiAgICB9XG4gICAgc3RhdGljIGFzeW5jIGNyZWF0ZShhcmcwLCBhcmcxLCBhcmcyLCBhcmczKSB7XG4gICAgICAgIC8vIGVpdGhlciBsb2FkIGZyb20gYSBmaWxlIG9yIGJ1ZmZlclxuICAgICAgICBsZXQgZmlsZVBhdGhPclVpbnQ4QXJyYXk7XG4gICAgICAgIGxldCBvcHRpb25zID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgYXJnMCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGZpbGVQYXRoT3JVaW50OEFycmF5ID0gYXJnMDtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgYXJnMSA9PT0gJ29iamVjdCcgJiYgYXJnMSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSBhcmcxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGFyZzEgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXFwnb3B0aW9uc1xcJyBtdXN0IGJlIGFuIG9iamVjdC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhcmcwIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgICAgICAgZmlsZVBhdGhPclVpbnQ4QXJyYXkgPSBhcmcwO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBhcmcxID09PSAnb2JqZWN0JyAmJiBhcmcxICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IGFyZzE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgYXJnMSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcXCdvcHRpb25zXFwnIG11c3QgYmUgYW4gb2JqZWN0LicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGFyZzAgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciB8fFxuICAgICAgICAgICAgKHR5cGVvZiBTaGFyZWRBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgYXJnMCBpbnN0YW5jZW9mIFNoYXJlZEFycmF5QnVmZmVyKSkge1xuICAgICAgICAgICAgY29uc3QgYnVmZmVyID0gYXJnMDtcbiAgICAgICAgICAgIGxldCBieXRlT2Zmc2V0ID0gMDtcbiAgICAgICAgICAgIGxldCBieXRlTGVuZ3RoID0gYXJnMC5ieXRlTGVuZ3RoO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBhcmcxID09PSAnb2JqZWN0JyAmJiBhcmcxICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IGFyZzE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgYXJnMSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICBieXRlT2Zmc2V0ID0gYXJnMTtcbiAgICAgICAgICAgICAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKGJ5dGVPZmZzZXQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcXCdieXRlT2Zmc2V0XFwnIG11c3QgYmUgYW4gaW50ZWdlci4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGJ5dGVPZmZzZXQgPCAwIHx8IGJ5dGVPZmZzZXQgPj0gYnVmZmVyLmJ5dGVMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYCdieXRlT2Zmc2V0JyBpcyBvdXQgb2YgcmFuZ2UgWzAsICR7YnVmZmVyLmJ5dGVMZW5ndGh9KS5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnl0ZUxlbmd0aCA9IGFyZzAuYnl0ZUxlbmd0aCAtIGJ5dGVPZmZzZXQ7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBhcmcyID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgICAgICBieXRlTGVuZ3RoID0gYXJnMjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihieXRlTGVuZ3RoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1xcJ2J5dGVMZW5ndGhcXCcgbXVzdCBiZSBhbiBpbnRlZ2VyLicpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChieXRlTGVuZ3RoIDw9IDAgfHwgYnl0ZU9mZnNldCArIGJ5dGVMZW5ndGggPiBidWZmZXIuYnl0ZUxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYCdieXRlTGVuZ3RoJyBpcyBvdXQgb2YgcmFuZ2UgKDAsICR7YnVmZmVyLmJ5dGVMZW5ndGggLSBieXRlT2Zmc2V0fV0uYCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBhcmczID09PSAnb2JqZWN0JyAmJiBhcmczICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zID0gYXJnMztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgYXJnMyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1xcJ29wdGlvbnNcXCcgbXVzdCBiZSBhbiBvYmplY3QuJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGFyZzIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1xcJ2J5dGVMZW5ndGhcXCcgbXVzdCBiZSBhIG51bWJlci4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgYXJnMSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcXCdvcHRpb25zXFwnIG11c3QgYmUgYW4gb2JqZWN0LicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmlsZVBhdGhPclVpbnQ4QXJyYXkgPSBuZXcgVWludDhBcnJheShidWZmZXIsIGJ5dGVPZmZzZXQsIGJ5dGVMZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5leHBlY3RlZCBhcmd1bWVudFswXTogbXVzdCBiZSBcXCdwYXRoXFwnIG9yIFxcJ2J1ZmZlclxcJy4nKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBnZXQgYmFja2VuZCBoaW50c1xuICAgICAgICBjb25zdCBlcHMgPSBvcHRpb25zLmV4ZWN1dGlvblByb3ZpZGVycyB8fCBbXTtcbiAgICAgICAgY29uc3QgYmFja2VuZEhpbnRzID0gZXBzLm1hcChpID0+IHR5cGVvZiBpID09PSAnc3RyaW5nJyA/IGkgOiBpLm5hbWUpO1xuICAgICAgICBjb25zdCBiYWNrZW5kID0gYXdhaXQgcmVzb2x2ZUJhY2tlbmQoYmFja2VuZEhpbnRzKTtcbiAgICAgICAgY29uc3QgaGFuZGxlciA9IGF3YWl0IGJhY2tlbmQuY3JlYXRlU2Vzc2lvbkhhbmRsZXIoZmlsZVBhdGhPclVpbnQ4QXJyYXksIG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gbmV3IEluZmVyZW5jZVNlc3Npb24oaGFuZGxlcik7XG4gICAgfVxuICAgIHN0YXJ0UHJvZmlsaW5nKCkge1xuICAgICAgICB0aGlzLmhhbmRsZXIuc3RhcnRQcm9maWxpbmcoKTtcbiAgICB9XG4gICAgZW5kUHJvZmlsaW5nKCkge1xuICAgICAgICB0aGlzLmhhbmRsZXIuZW5kUHJvZmlsaW5nKCk7XG4gICAgfVxuICAgIGdldCBpbnB1dE5hbWVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVyLmlucHV0TmFtZXM7XG4gICAgfVxuICAgIGdldCBvdXRwdXROYW1lcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlci5vdXRwdXROYW1lcztcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmZlcmVuY2Utc2Vzc2lvbi1pbXBsLmpzLm1hcCJdLCJuYW1lcyI6WyJyZXNvbHZlQmFja2VuZCIsIlRlbnNvciIsIkluZmVyZW5jZVNlc3Npb24iLCJjb25zdHJ1Y3RvciIsImhhbmRsZXIiLCJydW4iLCJmZWVkcyIsImFyZzEiLCJhcmcyIiwiZmV0Y2hlcyIsIm9wdGlvbnMiLCJBcnJheSIsImlzQXJyYXkiLCJUeXBlRXJyb3IiLCJpc0ZldGNoZXNFbXB0eSIsImxlbmd0aCIsIm5hbWUiLCJvdXRwdXROYW1lcyIsImluZGV4T2YiLCJSYW5nZUVycm9yIiwiaXNGZXRjaGVzIiwiYXJnMUtleXMiLCJPYmplY3QiLCJnZXRPd25Qcm9wZXJ0eU5hbWVzIiwidiIsImlucHV0TmFtZXMiLCJFcnJvciIsInJlc3VsdHMiLCJyZXR1cm5WYWx1ZSIsImtleSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsInR5cGUiLCJkYXRhIiwiZGltcyIsImNyZWF0ZSIsImFyZzAiLCJhcmczIiwiZmlsZVBhdGhPclVpbnQ4QXJyYXkiLCJVaW50OEFycmF5IiwiQXJyYXlCdWZmZXIiLCJTaGFyZWRBcnJheUJ1ZmZlciIsImJ1ZmZlciIsImJ5dGVPZmZzZXQiLCJieXRlTGVuZ3RoIiwiTnVtYmVyIiwiaXNTYWZlSW50ZWdlciIsImVwcyIsImV4ZWN1dGlvblByb3ZpZGVycyIsImJhY2tlbmRIaW50cyIsIm1hcCIsImkiLCJiYWNrZW5kIiwiY3JlYXRlU2Vzc2lvbkhhbmRsZXIiLCJzdGFydFByb2ZpbGluZyIsImVuZFByb2ZpbGluZyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/onnxruntime-common/dist/lib/inference-session-impl.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/onnxruntime-common/dist/lib/inference-session.js":
/*!************************************************************************!*\
  !*** ../node_modules/onnxruntime-common/dist/lib/inference-session.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InferenceSession: () => (/* binding */ InferenceSession)\n/* harmony export */ });\n/* harmony import */ var _inference_session_impl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./inference-session-impl */ \"(ssr)/../node_modules/onnxruntime-common/dist/lib/inference-session-impl.js\");\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\n// eslint-disable-next-line @typescript-eslint/naming-convention\nconst InferenceSession = _inference_session_impl__WEBPACK_IMPORTED_MODULE_0__.InferenceSession; //# sourceMappingURL=inference-session.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL29ubnhydW50aW1lLWNvbW1vbi9kaXN0L2xpYi9pbmZlcmVuY2Utc2Vzc2lvbi5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBLDREQUE0RDtBQUM1RCxrQ0FBa0M7QUFDa0Q7QUFDcEYsZ0VBQWdFO0FBQ3pELE1BQU1BLG1CQUFtQkMscUVBQW9CQSxDQUFDLENBQ3JELDZDQUE2QyIsInNvdXJjZXMiOlsid2VicGFjazovL2pzdm9pY2UtZGVtby8uLi9ub2RlX21vZHVsZXMvb25ueHJ1bnRpbWUtY29tbW9uL2Rpc3QvbGliL2luZmVyZW5jZS1zZXNzaW9uLmpzP2M5NmIiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5pbXBvcnQgeyBJbmZlcmVuY2VTZXNzaW9uIGFzIEluZmVyZW5jZVNlc3Npb25JbXBsIH0gZnJvbSAnLi9pbmZlcmVuY2Utc2Vzc2lvbi1pbXBsJztcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cbmV4cG9ydCBjb25zdCBJbmZlcmVuY2VTZXNzaW9uID0gSW5mZXJlbmNlU2Vzc2lvbkltcGw7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmZlcmVuY2Utc2Vzc2lvbi5qcy5tYXAiXSwibmFtZXMiOlsiSW5mZXJlbmNlU2Vzc2lvbiIsIkluZmVyZW5jZVNlc3Npb25JbXBsIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/onnxruntime-common/dist/lib/inference-session.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/onnxruntime-common/dist/lib/onnx-value.js":
/*!*****************************************************************!*\
  !*** ../node_modules/onnxruntime-common/dist/lib/onnx-value.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n //# sourceMappingURL=onnx-value.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL29ubnhydW50aW1lLWNvbW1vbi9kaXN0L2xpYi9vbm54LXZhbHVlLmpzIiwibWFwcGluZ3MiOiI7QUFBQSw0REFBNEQ7QUFDNUQsa0NBQWtDO0FBQ3hCLENBQ1Ysc0NBQXNDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vanN2b2ljZS1kZW1vLy4uL25vZGVfbW9kdWxlcy9vbm54cnVudGltZS1jb21tb24vZGlzdC9saWIvb25ueC12YWx1ZS5qcz85MzNhIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuZXhwb3J0IHt9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9b25ueC12YWx1ZS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/onnxruntime-common/dist/lib/onnx-value.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/onnxruntime-common/dist/lib/tensor-impl.js":
/*!******************************************************************!*\
  !*** ../node_modules/onnxruntime-common/dist/lib/tensor-impl.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Tensor: () => (/* binding */ Tensor)\n/* harmony export */ });\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\nconst isBigInt64ArrayAvailable = typeof BigInt64Array !== \"undefined\" && typeof BigInt64Array.from === \"function\";\nconst isBigUint64ArrayAvailable = typeof BigUint64Array !== \"undefined\" && typeof BigUint64Array.from === \"function\";\n// a runtime map that maps type string to TypedArray constructor. Should match Tensor.DataTypeMap.\nconst NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP = new Map([\n    [\n        \"float32\",\n        Float32Array\n    ],\n    [\n        \"uint8\",\n        Uint8Array\n    ],\n    [\n        \"int8\",\n        Int8Array\n    ],\n    [\n        \"uint16\",\n        Uint16Array\n    ],\n    [\n        \"int16\",\n        Int16Array\n    ],\n    [\n        \"int32\",\n        Int32Array\n    ],\n    [\n        \"bool\",\n        Uint8Array\n    ],\n    [\n        \"float64\",\n        Float64Array\n    ],\n    [\n        \"uint32\",\n        Uint32Array\n    ]\n]);\n// a runtime map that maps type string to TypedArray constructor. Should match Tensor.DataTypeMap.\nconst NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP = new Map([\n    [\n        Float32Array,\n        \"float32\"\n    ],\n    [\n        Uint8Array,\n        \"uint8\"\n    ],\n    [\n        Int8Array,\n        \"int8\"\n    ],\n    [\n        Uint16Array,\n        \"uint16\"\n    ],\n    [\n        Int16Array,\n        \"int16\"\n    ],\n    [\n        Int32Array,\n        \"int32\"\n    ],\n    [\n        Float64Array,\n        \"float64\"\n    ],\n    [\n        Uint32Array,\n        \"uint32\"\n    ]\n]);\nif (isBigInt64ArrayAvailable) {\n    NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.set(\"int64\", BigInt64Array);\n    NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.set(BigInt64Array, \"int64\");\n}\nif (isBigUint64ArrayAvailable) {\n    NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.set(\"uint64\", BigUint64Array);\n    NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.set(BigUint64Array, \"uint64\");\n}\n/**\n * calculate size from dims.\n *\n * @param dims the dims array. May be an illegal input.\n */ const calculateSize = (dims)=>{\n    let size = 1;\n    for(let i = 0; i < dims.length; i++){\n        const dim = dims[i];\n        if (typeof dim !== \"number\" || !Number.isSafeInteger(dim)) {\n            throw new TypeError(`dims[${i}] must be an integer, got: ${dim}`);\n        }\n        if (dim < 0) {\n            throw new RangeError(`dims[${i}] must be a non-negative integer, got: ${dim}`);\n        }\n        size *= dim;\n    }\n    return size;\n};\nclass Tensor {\n    constructor(arg0, arg1, arg2){\n        let type;\n        let data;\n        let dims;\n        // check whether arg0 is type or data\n        if (typeof arg0 === \"string\") {\n            //\n            // Override: constructor(type, data, ...)\n            //\n            type = arg0;\n            dims = arg2;\n            if (arg0 === \"string\") {\n                // string tensor\n                if (!Array.isArray(arg1)) {\n                    throw new TypeError(\"A string tensor's data must be a string array.\");\n                }\n                // we don't check whether every element in the array is string; this is too slow. we assume it's correct and\n                // error will be populated at inference\n                data = arg1;\n            } else {\n                // numeric tensor\n                const typedArrayConstructor = NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.get(arg0);\n                if (typedArrayConstructor === undefined) {\n                    throw new TypeError(`Unsupported tensor type: ${arg0}.`);\n                }\n                if (Array.isArray(arg1)) {\n                    // use 'as any' here because TypeScript's check on type of 'SupportedTypedArrayConstructors.from()' produces\n                    // incorrect results.\n                    // 'typedArrayConstructor' should be one of the typed array prototype objects.\n                    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                    data = typedArrayConstructor.from(arg1);\n                } else if (arg1 instanceof typedArrayConstructor) {\n                    data = arg1;\n                } else {\n                    throw new TypeError(`A ${type} tensor's data must be type of ${typedArrayConstructor}`);\n                }\n            }\n        } else {\n            //\n            // Override: constructor(data, ...)\n            //\n            dims = arg1;\n            if (Array.isArray(arg0)) {\n                // only boolean[] and string[] is supported\n                if (arg0.length === 0) {\n                    throw new TypeError(\"Tensor type cannot be inferred from an empty array.\");\n                }\n                const firstElementType = typeof arg0[0];\n                if (firstElementType === \"string\") {\n                    type = \"string\";\n                    data = arg0;\n                } else if (firstElementType === \"boolean\") {\n                    type = \"bool\";\n                    // 'arg0' is of type 'boolean[]'. Uint8Array.from(boolean[]) actually works, but typescript thinks this is\n                    // wrong type. We use 'as any' to make it happy.\n                    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                    data = Uint8Array.from(arg0);\n                } else {\n                    throw new TypeError(`Invalid element type of data array: ${firstElementType}.`);\n                }\n            } else {\n                // get tensor type from TypedArray\n                const mappedType = NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.get(arg0.constructor);\n                if (mappedType === undefined) {\n                    throw new TypeError(`Unsupported type for tensor data: ${arg0.constructor}.`);\n                }\n                type = mappedType;\n                data = arg0;\n            }\n        }\n        // type and data is processed, now processing dims\n        if (dims === undefined) {\n            // assume 1-D tensor if dims omitted\n            dims = [\n                data.length\n            ];\n        } else if (!Array.isArray(dims)) {\n            throw new TypeError(\"A tensor's dims must be a number array\");\n        }\n        // perform check\n        const size = calculateSize(dims);\n        if (size !== data.length) {\n            throw new Error(`Tensor's size(${size}) does not match data length(${data.length}).`);\n        }\n        this.dims = dims;\n        this.type = type;\n        this.data = data;\n        this.size = size;\n    }\n    // #endregion\n    /**\n     * Create a new tensor object from image object\n     *\n     * @param buffer - Extracted image buffer data - assuming RGBA format\n     * @param imageFormat - input image configuration - required configurations height, width, format\n     * @param tensorFormat - output tensor configuration - Default is RGB format\n     */ static bufferToTensor(buffer, options) {\n        if (buffer === undefined) {\n            throw new Error(\"Image buffer must be defined\");\n        }\n        if (options.height === undefined || options.width === undefined) {\n            throw new Error(\"Image height and width must be defined\");\n        }\n        const { height, width } = options;\n        const norm = options.norm;\n        let normMean;\n        let normBias;\n        if (norm === undefined || norm.mean === undefined) {\n            normMean = 255;\n        } else {\n            normMean = norm.mean;\n        }\n        if (norm === undefined || norm.bias === undefined) {\n            normBias = 0;\n        } else {\n            normBias = norm.bias;\n        }\n        const inputformat = options.bitmapFormat !== undefined ? options.bitmapFormat : \"RGBA\";\n        // default value is RGBA since imagedata and HTMLImageElement uses it\n        const outputformat = options.tensorFormat !== undefined ? options.tensorFormat !== undefined ? options.tensorFormat : \"RGB\" : \"RGB\";\n        const offset = height * width;\n        const float32Data = outputformat === \"RGBA\" ? new Float32Array(offset * 4) : new Float32Array(offset * 3);\n        // Default pointer assignments\n        let step = 4, rImagePointer = 0, gImagePointer = 1, bImagePointer = 2, aImagePointer = 3;\n        let rTensorPointer = 0, gTensorPointer = offset, bTensorPointer = offset * 2, aTensorPointer = -1;\n        // Updating the pointer assignments based on the input image format\n        if (inputformat === \"RGB\") {\n            step = 3;\n            rImagePointer = 0;\n            gImagePointer = 1;\n            bImagePointer = 2;\n            aImagePointer = -1;\n        }\n        // Updating the pointer assignments based on the output tensor format\n        if (outputformat === \"RGBA\") {\n            aTensorPointer = offset * 3;\n        } else if (outputformat === \"RBG\") {\n            rTensorPointer = 0;\n            bTensorPointer = offset;\n            gTensorPointer = offset * 2;\n        } else if (outputformat === \"BGR\") {\n            bTensorPointer = 0;\n            gTensorPointer = offset;\n            rTensorPointer = offset * 2;\n        }\n        for(let i = 0; i < offset; i++, rImagePointer += step, bImagePointer += step, gImagePointer += step, aImagePointer += step){\n            float32Data[rTensorPointer++] = (buffer[rImagePointer] + normBias) / normMean;\n            float32Data[gTensorPointer++] = (buffer[gImagePointer] + normBias) / normMean;\n            float32Data[bTensorPointer++] = (buffer[bImagePointer] + normBias) / normMean;\n            if (aTensorPointer !== -1 && aImagePointer !== -1) {\n                float32Data[aTensorPointer++] = (buffer[aImagePointer] + normBias) / normMean;\n            }\n        }\n        // Float32Array -> ort.Tensor\n        const outputTensor = outputformat === \"RGBA\" ? new Tensor(\"float32\", float32Data, [\n            1,\n            4,\n            height,\n            width\n        ]) : new Tensor(\"float32\", float32Data, [\n            1,\n            3,\n            height,\n            width\n        ]);\n        return outputTensor;\n    }\n    static async fromImage(image, options) {\n        // checking the type of image object\n        const isHTMLImageEle = typeof HTMLImageElement !== \"undefined\" && image instanceof HTMLImageElement;\n        const isImageDataEle = typeof ImageData !== \"undefined\" && image instanceof ImageData;\n        const isImageBitmap = typeof ImageBitmap !== \"undefined\" && image instanceof ImageBitmap;\n        const isURL = typeof String !== \"undefined\" && (image instanceof String || typeof image === \"string\");\n        let data;\n        let tensorConfig = {};\n        // filling and checking image configuration options\n        if (isHTMLImageEle) {\n            // HTMLImageElement - image object - format is RGBA by default\n            const canvas = document.createElement(\"canvas\");\n            const pixels2DContext = canvas.getContext(\"2d\");\n            if (pixels2DContext != null) {\n                let height = image.naturalHeight;\n                let width = image.naturalWidth;\n                if (options !== undefined && options.resizedHeight !== undefined && options.resizedWidth !== undefined) {\n                    height = options.resizedHeight;\n                    width = options.resizedWidth;\n                }\n                if (options !== undefined) {\n                    tensorConfig = options;\n                    if (options.tensorFormat !== undefined) {\n                        throw new Error(\"Image input config format must be RGBA for HTMLImageElement\");\n                    } else {\n                        tensorConfig.tensorFormat = \"RGBA\";\n                    }\n                    if (options.height !== undefined && options.height !== height) {\n                        throw new Error(\"Image input config height doesn't match HTMLImageElement height\");\n                    } else {\n                        tensorConfig.height = height;\n                    }\n                    if (options.width !== undefined && options.width !== width) {\n                        throw new Error(\"Image input config width doesn't match HTMLImageElement width\");\n                    } else {\n                        tensorConfig.width = width;\n                    }\n                } else {\n                    tensorConfig.tensorFormat = \"RGBA\";\n                    tensorConfig.height = height;\n                    tensorConfig.width = width;\n                }\n                canvas.width = width;\n                canvas.height = height;\n                pixels2DContext.drawImage(image, 0, 0, width, height);\n                data = pixels2DContext.getImageData(0, 0, width, height).data;\n            } else {\n                throw new Error(\"Can not access image data\");\n            }\n        } else if (isImageDataEle) {\n            // ImageData - image object - format is RGBA by default\n            const format = \"RGBA\";\n            let height;\n            let width;\n            if (options !== undefined && options.resizedWidth !== undefined && options.resizedHeight !== undefined) {\n                height = options.resizedHeight;\n                width = options.resizedWidth;\n            } else {\n                height = image.height;\n                width = image.width;\n            }\n            if (options !== undefined) {\n                tensorConfig = options;\n                if (options.bitmapFormat !== undefined && options.bitmapFormat !== format) {\n                    throw new Error(\"Image input config format must be RGBA for ImageData\");\n                } else {\n                    tensorConfig.bitmapFormat = \"RGBA\";\n                }\n            } else {\n                tensorConfig.bitmapFormat = \"RGBA\";\n            }\n            tensorConfig.height = height;\n            tensorConfig.width = width;\n            if (options !== undefined) {\n                const tempCanvas = document.createElement(\"canvas\");\n                tempCanvas.width = width;\n                tempCanvas.height = height;\n                const pixels2DContext = tempCanvas.getContext(\"2d\");\n                if (pixels2DContext != null) {\n                    pixels2DContext.putImageData(image, 0, 0);\n                    data = pixels2DContext.getImageData(0, 0, width, height).data;\n                } else {\n                    throw new Error(\"Can not access image data\");\n                }\n            } else {\n                data = image.data;\n            }\n        } else if (isImageBitmap) {\n            // ImageBitmap - image object - format must be provided by user\n            if (options === undefined) {\n                throw new Error(\"Please provide image config with format for Imagebitmap\");\n            }\n            if (options.bitmapFormat !== undefined) {\n                throw new Error(\"Image input config format must be defined for ImageBitmap\");\n            }\n            const pixels2DContext = document.createElement(\"canvas\").getContext(\"2d\");\n            if (pixels2DContext != null) {\n                const height = image.height;\n                const width = image.width;\n                pixels2DContext.drawImage(image, 0, 0, width, height);\n                data = pixels2DContext.getImageData(0, 0, width, height).data;\n                if (options !== undefined) {\n                    // using square brackets to avoid TS error - type 'never'\n                    if (options.height !== undefined && options.height !== height) {\n                        throw new Error(\"Image input config height doesn't match ImageBitmap height\");\n                    } else {\n                        tensorConfig.height = height;\n                    }\n                    // using square brackets to avoid TS error - type 'never'\n                    if (options.width !== undefined && options.width !== width) {\n                        throw new Error(\"Image input config width doesn't match ImageBitmap width\");\n                    } else {\n                        tensorConfig.width = width;\n                    }\n                } else {\n                    tensorConfig.height = height;\n                    tensorConfig.width = width;\n                }\n                return Tensor.bufferToTensor(data, tensorConfig);\n            } else {\n                throw new Error(\"Can not access image data\");\n            }\n        } else if (isURL) {\n            return new Promise((resolve, reject)=>{\n                const canvas = document.createElement(\"canvas\");\n                const context = canvas.getContext(\"2d\");\n                if (!image || !context) {\n                    return reject();\n                }\n                const newImage = new Image();\n                newImage.crossOrigin = \"Anonymous\";\n                newImage.src = image;\n                newImage.onload = ()=>{\n                    canvas.width = newImage.width;\n                    canvas.height = newImage.height;\n                    context.drawImage(newImage, 0, 0, canvas.width, canvas.height);\n                    const img = context.getImageData(0, 0, canvas.width, canvas.height);\n                    if (options !== undefined) {\n                        // using square brackets to avoid TS error - type 'never'\n                        if (options.height !== undefined && options.height !== canvas.height) {\n                            throw new Error(\"Image input config height doesn't match ImageBitmap height\");\n                        } else {\n                            tensorConfig.height = canvas.height;\n                        }\n                        // using square brackets to avoid TS error - type 'never'\n                        if (options.width !== undefined && options.width !== canvas.width) {\n                            throw new Error(\"Image input config width doesn't match ImageBitmap width\");\n                        } else {\n                            tensorConfig.width = canvas.width;\n                        }\n                    } else {\n                        tensorConfig.height = canvas.height;\n                        tensorConfig.width = canvas.width;\n                    }\n                    resolve(Tensor.bufferToTensor(img.data, tensorConfig));\n                };\n            });\n        } else {\n            throw new Error(\"Input data provided is not supported - aborted tensor creation\");\n        }\n        if (data !== undefined) {\n            return Tensor.bufferToTensor(data, tensorConfig);\n        } else {\n            throw new Error(\"Input data provided is not supported - aborted tensor creation\");\n        }\n    }\n    toImageData(options) {\n        var _a, _b;\n        const pixels2DContext = document.createElement(\"canvas\").getContext(\"2d\");\n        let image;\n        if (pixels2DContext != null) {\n            // Default values for height and width & format\n            const width = this.dims[3];\n            const height = this.dims[2];\n            const channels = this.dims[1];\n            const inputformat = options !== undefined ? options.format !== undefined ? options.format : \"RGB\" : \"RGB\";\n            const normMean = options !== undefined ? ((_a = options.norm) === null || _a === void 0 ? void 0 : _a.mean) !== undefined ? options.norm.mean : 255 : 255;\n            const normBias = options !== undefined ? ((_b = options.norm) === null || _b === void 0 ? void 0 : _b.bias) !== undefined ? options.norm.bias : 0 : 0;\n            const offset = height * width;\n            if (options !== undefined) {\n                if (options.height !== undefined && options.height !== height) {\n                    throw new Error(\"Image output config height doesn't match tensor height\");\n                }\n                if (options.width !== undefined && options.width !== width) {\n                    throw new Error(\"Image output config width doesn't match tensor width\");\n                }\n                if (options.format !== undefined && channels === 4 && options.format !== \"RGBA\" || channels === 3 && options.format !== \"RGB\" && options.format !== \"BGR\") {\n                    throw new Error(\"Tensor format doesn't match input tensor dims\");\n                }\n            }\n            // Default pointer assignments\n            const step = 4;\n            let rImagePointer = 0, gImagePointer = 1, bImagePointer = 2, aImagePointer = 3;\n            let rTensorPointer = 0, gTensorPointer = offset, bTensorPointer = offset * 2, aTensorPointer = -1;\n            // Updating the pointer assignments based on the input image format\n            if (inputformat === \"RGBA\") {\n                rTensorPointer = 0;\n                gTensorPointer = offset;\n                bTensorPointer = offset * 2;\n                aTensorPointer = offset * 3;\n            } else if (inputformat === \"RGB\") {\n                rTensorPointer = 0;\n                gTensorPointer = offset;\n                bTensorPointer = offset * 2;\n            } else if (inputformat === \"RBG\") {\n                rTensorPointer = 0;\n                bTensorPointer = offset;\n                gTensorPointer = offset * 2;\n            }\n            image = pixels2DContext.createImageData(width, height);\n            for(let i = 0; i < height * width; rImagePointer += step, gImagePointer += step, bImagePointer += step, aImagePointer += step, i++){\n                image.data[rImagePointer] = (this.data[rTensorPointer++] - normBias) * normMean; // R value\n                image.data[gImagePointer] = (this.data[gTensorPointer++] - normBias) * normMean; // G value\n                image.data[bImagePointer] = (this.data[bTensorPointer++] - normBias) * normMean; // B value\n                image.data[aImagePointer] = aTensorPointer === -1 ? 255 : (this.data[aTensorPointer++] - normBias) * normMean; // A value\n            }\n        } else {\n            throw new Error(\"Can not access image data\");\n        }\n        return image;\n    }\n    // #endregion\n    // #region tensor utilities\n    reshape(dims) {\n        return new Tensor(this.type, this.data, dims);\n    }\n} //# sourceMappingURL=tensor-impl.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL29ubnhydW50aW1lLWNvbW1vbi9kaXN0L2xpYi90ZW5zb3ItaW1wbC5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsNERBQTREO0FBQzVELGtDQUFrQztBQUNsQyxNQUFNQSwyQkFBMkIsT0FBT0Msa0JBQWtCLGVBQWUsT0FBT0EsY0FBY0MsSUFBSSxLQUFLO0FBQ3ZHLE1BQU1DLDRCQUE0QixPQUFPQyxtQkFBbUIsZUFBZSxPQUFPQSxlQUFlRixJQUFJLEtBQUs7QUFDMUcsa0dBQWtHO0FBQ2xHLE1BQU1HLHdDQUF3QyxJQUFJQyxJQUFJO0lBQ2xEO1FBQUM7UUFBV0M7S0FBYTtJQUN6QjtRQUFDO1FBQVNDO0tBQVc7SUFDckI7UUFBQztRQUFRQztLQUFVO0lBQ25CO1FBQUM7UUFBVUM7S0FBWTtJQUN2QjtRQUFDO1FBQVNDO0tBQVc7SUFDckI7UUFBQztRQUFTQztLQUFXO0lBQ3JCO1FBQUM7UUFBUUo7S0FBVztJQUNwQjtRQUFDO1FBQVdLO0tBQWE7SUFDekI7UUFBQztRQUFVQztLQUFZO0NBQzFCO0FBQ0Qsa0dBQWtHO0FBQ2xHLE1BQU1DLHdDQUF3QyxJQUFJVCxJQUFJO0lBQ2xEO1FBQUNDO1FBQWM7S0FBVTtJQUN6QjtRQUFDQztRQUFZO0tBQVE7SUFDckI7UUFBQ0M7UUFBVztLQUFPO0lBQ25CO1FBQUNDO1FBQWE7S0FBUztJQUN2QjtRQUFDQztRQUFZO0tBQVE7SUFDckI7UUFBQ0M7UUFBWTtLQUFRO0lBQ3JCO1FBQUNDO1FBQWM7S0FBVTtJQUN6QjtRQUFDQztRQUFhO0tBQVM7Q0FDMUI7QUFDRCxJQUFJZCwwQkFBMEI7SUFDMUJLLHNDQUFzQ1csR0FBRyxDQUFDLFNBQVNmO0lBQ25EYyxzQ0FBc0NDLEdBQUcsQ0FBQ2YsZUFBZTtBQUM3RDtBQUNBLElBQUlFLDJCQUEyQjtJQUMzQkUsc0NBQXNDVyxHQUFHLENBQUMsVUFBVVo7SUFDcERXLHNDQUFzQ0MsR0FBRyxDQUFDWixnQkFBZ0I7QUFDOUQ7QUFDQTs7OztDQUlDLEdBQ0QsTUFBTWEsZ0JBQWdCLENBQUNDO0lBQ25CLElBQUlDLE9BQU87SUFDWCxJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSUYsS0FBS0csTUFBTSxFQUFFRCxJQUFLO1FBQ2xDLE1BQU1FLE1BQU1KLElBQUksQ0FBQ0UsRUFBRTtRQUNuQixJQUFJLE9BQU9FLFFBQVEsWUFBWSxDQUFDQyxPQUFPQyxhQUFhLENBQUNGLE1BQU07WUFDdkQsTUFBTSxJQUFJRyxVQUFVLENBQUMsS0FBSyxFQUFFTCxFQUFFLDJCQUEyQixFQUFFRSxJQUFJLENBQUM7UUFDcEU7UUFDQSxJQUFJQSxNQUFNLEdBQUc7WUFDVCxNQUFNLElBQUlJLFdBQVcsQ0FBQyxLQUFLLEVBQUVOLEVBQUUsdUNBQXVDLEVBQUVFLElBQUksQ0FBQztRQUNqRjtRQUNBSCxRQUFRRztJQUNaO0lBQ0EsT0FBT0g7QUFDWDtBQUNPLE1BQU1RO0lBQ1RDLFlBQVlDLElBQUksRUFBRUMsSUFBSSxFQUFFQyxJQUFJLENBQUU7UUFDMUIsSUFBSUM7UUFDSixJQUFJQztRQUNKLElBQUlmO1FBQ0oscUNBQXFDO1FBQ3JDLElBQUksT0FBT1csU0FBUyxVQUFVO1lBQzFCLEVBQUU7WUFDRix5Q0FBeUM7WUFDekMsRUFBRTtZQUNGRyxPQUFPSDtZQUNQWCxPQUFPYTtZQUNQLElBQUlGLFNBQVMsVUFBVTtnQkFDbkIsZ0JBQWdCO2dCQUNoQixJQUFJLENBQUNLLE1BQU1DLE9BQU8sQ0FBQ0wsT0FBTztvQkFDdEIsTUFBTSxJQUFJTCxVQUFVO2dCQUN4QjtnQkFDQSw0R0FBNEc7Z0JBQzVHLHVDQUF1QztnQkFDdkNRLE9BQU9IO1lBQ1gsT0FDSztnQkFDRCxpQkFBaUI7Z0JBQ2pCLE1BQU1NLHdCQUF3Qi9CLHNDQUFzQ2dDLEdBQUcsQ0FBQ1I7Z0JBQ3hFLElBQUlPLDBCQUEwQkUsV0FBVztvQkFDckMsTUFBTSxJQUFJYixVQUFVLENBQUMseUJBQXlCLEVBQUVJLEtBQUssQ0FBQyxDQUFDO2dCQUMzRDtnQkFDQSxJQUFJSyxNQUFNQyxPQUFPLENBQUNMLE9BQU87b0JBQ3JCLDRHQUE0RztvQkFDNUcscUJBQXFCO29CQUNyQiw4RUFBOEU7b0JBQzlFLDhEQUE4RDtvQkFDOURHLE9BQU9HLHNCQUFzQmxDLElBQUksQ0FBQzRCO2dCQUN0QyxPQUNLLElBQUlBLGdCQUFnQk0sdUJBQXVCO29CQUM1Q0gsT0FBT0g7Z0JBQ1gsT0FDSztvQkFDRCxNQUFNLElBQUlMLFVBQVUsQ0FBQyxFQUFFLEVBQUVPLEtBQUssK0JBQStCLEVBQUVJLHNCQUFzQixDQUFDO2dCQUMxRjtZQUNKO1FBQ0osT0FDSztZQUNELEVBQUU7WUFDRixtQ0FBbUM7WUFDbkMsRUFBRTtZQUNGbEIsT0FBT1k7WUFDUCxJQUFJSSxNQUFNQyxPQUFPLENBQUNOLE9BQU87Z0JBQ3JCLDJDQUEyQztnQkFDM0MsSUFBSUEsS0FBS1IsTUFBTSxLQUFLLEdBQUc7b0JBQ25CLE1BQU0sSUFBSUksVUFBVTtnQkFDeEI7Z0JBQ0EsTUFBTWMsbUJBQW1CLE9BQU9WLElBQUksQ0FBQyxFQUFFO2dCQUN2QyxJQUFJVSxxQkFBcUIsVUFBVTtvQkFDL0JQLE9BQU87b0JBQ1BDLE9BQU9KO2dCQUNYLE9BQ0ssSUFBSVUscUJBQXFCLFdBQVc7b0JBQ3JDUCxPQUFPO29CQUNQLDBHQUEwRztvQkFDMUcsZ0RBQWdEO29CQUNoRCw4REFBOEQ7b0JBQzlEQyxPQUFPekIsV0FBV04sSUFBSSxDQUFDMkI7Z0JBQzNCLE9BQ0s7b0JBQ0QsTUFBTSxJQUFJSixVQUFVLENBQUMsb0NBQW9DLEVBQUVjLGlCQUFpQixDQUFDLENBQUM7Z0JBQ2xGO1lBQ0osT0FDSztnQkFDRCxrQ0FBa0M7Z0JBQ2xDLE1BQU1DLGFBQWF6QixzQ0FBc0NzQixHQUFHLENBQUNSLEtBQUtELFdBQVc7Z0JBQzdFLElBQUlZLGVBQWVGLFdBQVc7b0JBQzFCLE1BQU0sSUFBSWIsVUFBVSxDQUFDLGtDQUFrQyxFQUFFSSxLQUFLRCxXQUFXLENBQUMsQ0FBQyxDQUFDO2dCQUNoRjtnQkFDQUksT0FBT1E7Z0JBQ1BQLE9BQU9KO1lBQ1g7UUFDSjtRQUNBLGtEQUFrRDtRQUNsRCxJQUFJWCxTQUFTb0IsV0FBVztZQUNwQixvQ0FBb0M7WUFDcENwQixPQUFPO2dCQUFDZSxLQUFLWixNQUFNO2FBQUM7UUFDeEIsT0FDSyxJQUFJLENBQUNhLE1BQU1DLE9BQU8sQ0FBQ2pCLE9BQU87WUFDM0IsTUFBTSxJQUFJTyxVQUFVO1FBQ3hCO1FBQ0EsZ0JBQWdCO1FBQ2hCLE1BQU1OLE9BQU9GLGNBQWNDO1FBQzNCLElBQUlDLFNBQVNjLEtBQUtaLE1BQU0sRUFBRTtZQUN0QixNQUFNLElBQUlvQixNQUFNLENBQUMsY0FBYyxFQUFFdEIsS0FBSyw2QkFBNkIsRUFBRWMsS0FBS1osTUFBTSxDQUFDLEVBQUUsQ0FBQztRQUN4RjtRQUNBLElBQUksQ0FBQ0gsSUFBSSxHQUFHQTtRQUNaLElBQUksQ0FBQ2MsSUFBSSxHQUFHQTtRQUNaLElBQUksQ0FBQ0MsSUFBSSxHQUFHQTtRQUNaLElBQUksQ0FBQ2QsSUFBSSxHQUFHQTtJQUNoQjtJQUNBLGFBQWE7SUFDYjs7Ozs7O0tBTUMsR0FDRCxPQUFPdUIsZUFBZUMsTUFBTSxFQUFFQyxPQUFPLEVBQUU7UUFDbkMsSUFBSUQsV0FBV0wsV0FBVztZQUN0QixNQUFNLElBQUlHLE1BQU07UUFDcEI7UUFDQSxJQUFJRyxRQUFRQyxNQUFNLEtBQUtQLGFBQWFNLFFBQVFFLEtBQUssS0FBS1IsV0FBVztZQUM3RCxNQUFNLElBQUlHLE1BQU07UUFDcEI7UUFDQSxNQUFNLEVBQUVJLE1BQU0sRUFBRUMsS0FBSyxFQUFFLEdBQUdGO1FBQzFCLE1BQU1HLE9BQU9ILFFBQVFHLElBQUk7UUFDekIsSUFBSUM7UUFDSixJQUFJQztRQUNKLElBQUlGLFNBQVNULGFBQWFTLEtBQUtHLElBQUksS0FBS1osV0FBVztZQUMvQ1UsV0FBVztRQUNmLE9BQ0s7WUFDREEsV0FBV0QsS0FBS0csSUFBSTtRQUN4QjtRQUNBLElBQUlILFNBQVNULGFBQWFTLEtBQUtJLElBQUksS0FBS2IsV0FBVztZQUMvQ1csV0FBVztRQUNmLE9BQ0s7WUFDREEsV0FBV0YsS0FBS0ksSUFBSTtRQUN4QjtRQUNBLE1BQU1DLGNBQWNSLFFBQVFTLFlBQVksS0FBS2YsWUFBWU0sUUFBUVMsWUFBWSxHQUFHO1FBQ2hGLHFFQUFxRTtRQUNyRSxNQUFNQyxlQUFlVixRQUFRVyxZQUFZLEtBQUtqQixZQUN6Q00sUUFBUVcsWUFBWSxLQUFLakIsWUFBWU0sUUFBUVcsWUFBWSxHQUFHLFFBQzdEO1FBQ0osTUFBTUMsU0FBU1gsU0FBU0M7UUFDeEIsTUFBTVcsY0FBY0gsaUJBQWlCLFNBQVMsSUFBSS9DLGFBQWFpRCxTQUFTLEtBQUssSUFBSWpELGFBQWFpRCxTQUFTO1FBQ3ZHLDhCQUE4QjtRQUM5QixJQUFJRSxPQUFPLEdBQUdDLGdCQUFnQixHQUFHQyxnQkFBZ0IsR0FBR0MsZ0JBQWdCLEdBQUdDLGdCQUFnQjtRQUN2RixJQUFJQyxpQkFBaUIsR0FBR0MsaUJBQWlCUixRQUFRUyxpQkFBaUJULFNBQVMsR0FBR1UsaUJBQWlCLENBQUM7UUFDaEcsbUVBQW1FO1FBQ25FLElBQUlkLGdCQUFnQixPQUFPO1lBQ3ZCTSxPQUFPO1lBQ1BDLGdCQUFnQjtZQUNoQkMsZ0JBQWdCO1lBQ2hCQyxnQkFBZ0I7WUFDaEJDLGdCQUFnQixDQUFDO1FBQ3JCO1FBQ0EscUVBQXFFO1FBQ3JFLElBQUlSLGlCQUFpQixRQUFRO1lBQ3pCWSxpQkFBaUJWLFNBQVM7UUFDOUIsT0FDSyxJQUFJRixpQkFBaUIsT0FBTztZQUM3QlMsaUJBQWlCO1lBQ2pCRSxpQkFBaUJUO1lBQ2pCUSxpQkFBaUJSLFNBQVM7UUFDOUIsT0FDSyxJQUFJRixpQkFBaUIsT0FBTztZQUM3QlcsaUJBQWlCO1lBQ2pCRCxpQkFBaUJSO1lBQ2pCTyxpQkFBaUJQLFNBQVM7UUFDOUI7UUFDQSxJQUFLLElBQUlwQyxJQUFJLEdBQUdBLElBQUlvQyxRQUFRcEMsS0FBS3VDLGlCQUFpQkQsTUFBTUcsaUJBQWlCSCxNQUFNRSxpQkFBaUJGLE1BQU1JLGlCQUFpQkosS0FBTTtZQUN6SEQsV0FBVyxDQUFDTSxpQkFBaUIsR0FBRyxDQUFDcEIsTUFBTSxDQUFDZ0IsY0FBYyxHQUFHVixRQUFPLElBQUtEO1lBQ3JFUyxXQUFXLENBQUNPLGlCQUFpQixHQUFHLENBQUNyQixNQUFNLENBQUNpQixjQUFjLEdBQUdYLFFBQU8sSUFBS0Q7WUFDckVTLFdBQVcsQ0FBQ1EsaUJBQWlCLEdBQUcsQ0FBQ3RCLE1BQU0sQ0FBQ2tCLGNBQWMsR0FBR1osUUFBTyxJQUFLRDtZQUNyRSxJQUFJa0IsbUJBQW1CLENBQUMsS0FBS0osa0JBQWtCLENBQUMsR0FBRztnQkFDL0NMLFdBQVcsQ0FBQ1MsaUJBQWlCLEdBQUcsQ0FBQ3ZCLE1BQU0sQ0FBQ21CLGNBQWMsR0FBR2IsUUFBTyxJQUFLRDtZQUN6RTtRQUNKO1FBQ0EsNkJBQTZCO1FBQzdCLE1BQU1tQixlQUFlYixpQkFBaUIsU0FBUyxJQUFJM0IsT0FBTyxXQUFXOEIsYUFBYTtZQUFDO1lBQUc7WUFBR1o7WUFBUUM7U0FBTSxJQUNuRyxJQUFJbkIsT0FBTyxXQUFXOEIsYUFBYTtZQUFDO1lBQUc7WUFBR1o7WUFBUUM7U0FBTTtRQUM1RCxPQUFPcUI7SUFDWDtJQUNBLGFBQWFDLFVBQVVDLEtBQUssRUFBRXpCLE9BQU8sRUFBRTtRQUNuQyxvQ0FBb0M7UUFDcEMsTUFBTTBCLGlCQUFpQixPQUFRQyxxQkFBc0IsZUFBZUYsaUJBQWlCRTtRQUNyRixNQUFNQyxpQkFBaUIsT0FBUUMsY0FBZSxlQUFlSixpQkFBaUJJO1FBQzlFLE1BQU1DLGdCQUFnQixPQUFRQyxnQkFBaUIsZUFBZU4saUJBQWlCTTtRQUMvRSxNQUFNQyxRQUFRLE9BQVFDLFdBQVksZUFBZ0JSLENBQUFBLGlCQUFpQlEsVUFBVSxPQUFPUixVQUFVLFFBQU87UUFDckcsSUFBSXBDO1FBQ0osSUFBSTZDLGVBQWUsQ0FBQztRQUNwQixtREFBbUQ7UUFDbkQsSUFBSVIsZ0JBQWdCO1lBQ2hCLDhEQUE4RDtZQUM5RCxNQUFNUyxTQUFTQyxTQUFTQyxhQUFhLENBQUM7WUFDdEMsTUFBTUMsa0JBQWtCSCxPQUFPSSxVQUFVLENBQUM7WUFDMUMsSUFBSUQsbUJBQW1CLE1BQU07Z0JBQ3pCLElBQUlyQyxTQUFTd0IsTUFBTWUsYUFBYTtnQkFDaEMsSUFBSXRDLFFBQVF1QixNQUFNZ0IsWUFBWTtnQkFDOUIsSUFBSXpDLFlBQVlOLGFBQWFNLFFBQVEwQyxhQUFhLEtBQUtoRCxhQUFhTSxRQUFRMkMsWUFBWSxLQUFLakQsV0FBVztvQkFDcEdPLFNBQVNELFFBQVEwQyxhQUFhO29CQUM5QnhDLFFBQVFGLFFBQVEyQyxZQUFZO2dCQUNoQztnQkFDQSxJQUFJM0MsWUFBWU4sV0FBVztvQkFDdkJ3QyxlQUFlbEM7b0JBQ2YsSUFBSUEsUUFBUVcsWUFBWSxLQUFLakIsV0FBVzt3QkFDcEMsTUFBTSxJQUFJRyxNQUFNO29CQUNwQixPQUNLO3dCQUNEcUMsYUFBYXZCLFlBQVksR0FBRztvQkFDaEM7b0JBQ0EsSUFBSVgsUUFBUUMsTUFBTSxLQUFLUCxhQUFhTSxRQUFRQyxNQUFNLEtBQUtBLFFBQVE7d0JBQzNELE1BQU0sSUFBSUosTUFBTTtvQkFDcEIsT0FDSzt3QkFDRHFDLGFBQWFqQyxNQUFNLEdBQUdBO29CQUMxQjtvQkFDQSxJQUFJRCxRQUFRRSxLQUFLLEtBQUtSLGFBQWFNLFFBQVFFLEtBQUssS0FBS0EsT0FBTzt3QkFDeEQsTUFBTSxJQUFJTCxNQUFNO29CQUNwQixPQUNLO3dCQUNEcUMsYUFBYWhDLEtBQUssR0FBR0E7b0JBQ3pCO2dCQUNKLE9BQ0s7b0JBQ0RnQyxhQUFhdkIsWUFBWSxHQUFHO29CQUM1QnVCLGFBQWFqQyxNQUFNLEdBQUdBO29CQUN0QmlDLGFBQWFoQyxLQUFLLEdBQUdBO2dCQUN6QjtnQkFDQWlDLE9BQU9qQyxLQUFLLEdBQUdBO2dCQUNmaUMsT0FBT2xDLE1BQU0sR0FBR0E7Z0JBQ2hCcUMsZ0JBQWdCTSxTQUFTLENBQUNuQixPQUFPLEdBQUcsR0FBR3ZCLE9BQU9EO2dCQUM5Q1osT0FBT2lELGdCQUFnQk8sWUFBWSxDQUFDLEdBQUcsR0FBRzNDLE9BQU9ELFFBQVFaLElBQUk7WUFDakUsT0FDSztnQkFDRCxNQUFNLElBQUlRLE1BQU07WUFDcEI7UUFDSixPQUNLLElBQUkrQixnQkFBZ0I7WUFDckIsdURBQXVEO1lBQ3ZELE1BQU1rQixTQUFTO1lBQ2YsSUFBSTdDO1lBQ0osSUFBSUM7WUFDSixJQUFJRixZQUFZTixhQUFhTSxRQUFRMkMsWUFBWSxLQUFLakQsYUFBYU0sUUFBUTBDLGFBQWEsS0FBS2hELFdBQVc7Z0JBQ3BHTyxTQUFTRCxRQUFRMEMsYUFBYTtnQkFDOUJ4QyxRQUFRRixRQUFRMkMsWUFBWTtZQUNoQyxPQUNLO2dCQUNEMUMsU0FBU3dCLE1BQU14QixNQUFNO2dCQUNyQkMsUUFBUXVCLE1BQU12QixLQUFLO1lBQ3ZCO1lBQ0EsSUFBSUYsWUFBWU4sV0FBVztnQkFDdkJ3QyxlQUFlbEM7Z0JBQ2YsSUFBSUEsUUFBUVMsWUFBWSxLQUFLZixhQUFhTSxRQUFRUyxZQUFZLEtBQUtxQyxRQUFRO29CQUN2RSxNQUFNLElBQUlqRCxNQUFNO2dCQUNwQixPQUNLO29CQUNEcUMsYUFBYXpCLFlBQVksR0FBRztnQkFDaEM7WUFDSixPQUNLO2dCQUNEeUIsYUFBYXpCLFlBQVksR0FBRztZQUNoQztZQUNBeUIsYUFBYWpDLE1BQU0sR0FBR0E7WUFDdEJpQyxhQUFhaEMsS0FBSyxHQUFHQTtZQUNyQixJQUFJRixZQUFZTixXQUFXO2dCQUN2QixNQUFNcUQsYUFBYVgsU0FBU0MsYUFBYSxDQUFDO2dCQUMxQ1UsV0FBVzdDLEtBQUssR0FBR0E7Z0JBQ25CNkMsV0FBVzlDLE1BQU0sR0FBR0E7Z0JBQ3BCLE1BQU1xQyxrQkFBa0JTLFdBQVdSLFVBQVUsQ0FBQztnQkFDOUMsSUFBSUQsbUJBQW1CLE1BQU07b0JBQ3pCQSxnQkFBZ0JVLFlBQVksQ0FBQ3ZCLE9BQU8sR0FBRztvQkFDdkNwQyxPQUFPaUQsZ0JBQWdCTyxZQUFZLENBQUMsR0FBRyxHQUFHM0MsT0FBT0QsUUFBUVosSUFBSTtnQkFDakUsT0FDSztvQkFDRCxNQUFNLElBQUlRLE1BQU07Z0JBQ3BCO1lBQ0osT0FDSztnQkFDRFIsT0FBT29DLE1BQU1wQyxJQUFJO1lBQ3JCO1FBQ0osT0FDSyxJQUFJeUMsZUFBZTtZQUNwQiwrREFBK0Q7WUFDL0QsSUFBSTlCLFlBQVlOLFdBQVc7Z0JBQ3ZCLE1BQU0sSUFBSUcsTUFBTTtZQUNwQjtZQUNBLElBQUlHLFFBQVFTLFlBQVksS0FBS2YsV0FBVztnQkFDcEMsTUFBTSxJQUFJRyxNQUFNO1lBQ3BCO1lBQ0EsTUFBTXlDLGtCQUFrQkYsU0FBU0MsYUFBYSxDQUFDLFVBQVVFLFVBQVUsQ0FBQztZQUNwRSxJQUFJRCxtQkFBbUIsTUFBTTtnQkFDekIsTUFBTXJDLFNBQVN3QixNQUFNeEIsTUFBTTtnQkFDM0IsTUFBTUMsUUFBUXVCLE1BQU12QixLQUFLO2dCQUN6Qm9DLGdCQUFnQk0sU0FBUyxDQUFDbkIsT0FBTyxHQUFHLEdBQUd2QixPQUFPRDtnQkFDOUNaLE9BQU9pRCxnQkFBZ0JPLFlBQVksQ0FBQyxHQUFHLEdBQUczQyxPQUFPRCxRQUFRWixJQUFJO2dCQUM3RCxJQUFJVyxZQUFZTixXQUFXO29CQUN2Qix5REFBeUQ7b0JBQ3pELElBQUlNLFFBQVFDLE1BQU0sS0FBS1AsYUFBYU0sUUFBUUMsTUFBTSxLQUFLQSxRQUFRO3dCQUMzRCxNQUFNLElBQUlKLE1BQU07b0JBQ3BCLE9BQ0s7d0JBQ0RxQyxhQUFhakMsTUFBTSxHQUFHQTtvQkFDMUI7b0JBQ0EseURBQXlEO29CQUN6RCxJQUFJRCxRQUFRRSxLQUFLLEtBQUtSLGFBQWFNLFFBQVFFLEtBQUssS0FBS0EsT0FBTzt3QkFDeEQsTUFBTSxJQUFJTCxNQUFNO29CQUNwQixPQUNLO3dCQUNEcUMsYUFBYWhDLEtBQUssR0FBR0E7b0JBQ3pCO2dCQUNKLE9BQ0s7b0JBQ0RnQyxhQUFhakMsTUFBTSxHQUFHQTtvQkFDdEJpQyxhQUFhaEMsS0FBSyxHQUFHQTtnQkFDekI7Z0JBQ0EsT0FBT25CLE9BQU9lLGNBQWMsQ0FBQ1QsTUFBTTZDO1lBQ3ZDLE9BQ0s7Z0JBQ0QsTUFBTSxJQUFJckMsTUFBTTtZQUNwQjtRQUNKLE9BQ0ssSUFBSW1DLE9BQU87WUFDWixPQUFPLElBQUlpQixRQUFRLENBQUNDLFNBQVNDO2dCQUN6QixNQUFNaEIsU0FBU0MsU0FBU0MsYUFBYSxDQUFDO2dCQUN0QyxNQUFNZSxVQUFVakIsT0FBT0ksVUFBVSxDQUFDO2dCQUNsQyxJQUFJLENBQUNkLFNBQVMsQ0FBQzJCLFNBQVM7b0JBQ3BCLE9BQU9EO2dCQUNYO2dCQUNBLE1BQU1FLFdBQVcsSUFBSUM7Z0JBQ3JCRCxTQUFTRSxXQUFXLEdBQUc7Z0JBQ3ZCRixTQUFTRyxHQUFHLEdBQUcvQjtnQkFDZjRCLFNBQVNJLE1BQU0sR0FBRztvQkFDZHRCLE9BQU9qQyxLQUFLLEdBQUdtRCxTQUFTbkQsS0FBSztvQkFDN0JpQyxPQUFPbEMsTUFBTSxHQUFHb0QsU0FBU3BELE1BQU07b0JBQy9CbUQsUUFBUVIsU0FBUyxDQUFDUyxVQUFVLEdBQUcsR0FBR2xCLE9BQU9qQyxLQUFLLEVBQUVpQyxPQUFPbEMsTUFBTTtvQkFDN0QsTUFBTXlELE1BQU1OLFFBQVFQLFlBQVksQ0FBQyxHQUFHLEdBQUdWLE9BQU9qQyxLQUFLLEVBQUVpQyxPQUFPbEMsTUFBTTtvQkFDbEUsSUFBSUQsWUFBWU4sV0FBVzt3QkFDdkIseURBQXlEO3dCQUN6RCxJQUFJTSxRQUFRQyxNQUFNLEtBQUtQLGFBQWFNLFFBQVFDLE1BQU0sS0FBS2tDLE9BQU9sQyxNQUFNLEVBQUU7NEJBQ2xFLE1BQU0sSUFBSUosTUFBTTt3QkFDcEIsT0FDSzs0QkFDRHFDLGFBQWFqQyxNQUFNLEdBQUdrQyxPQUFPbEMsTUFBTTt3QkFDdkM7d0JBQ0EseURBQXlEO3dCQUN6RCxJQUFJRCxRQUFRRSxLQUFLLEtBQUtSLGFBQWFNLFFBQVFFLEtBQUssS0FBS2lDLE9BQU9qQyxLQUFLLEVBQUU7NEJBQy9ELE1BQU0sSUFBSUwsTUFBTTt3QkFDcEIsT0FDSzs0QkFDRHFDLGFBQWFoQyxLQUFLLEdBQUdpQyxPQUFPakMsS0FBSzt3QkFDckM7b0JBQ0osT0FDSzt3QkFDRGdDLGFBQWFqQyxNQUFNLEdBQUdrQyxPQUFPbEMsTUFBTTt3QkFDbkNpQyxhQUFhaEMsS0FBSyxHQUFHaUMsT0FBT2pDLEtBQUs7b0JBQ3JDO29CQUNBZ0QsUUFBUW5FLE9BQU9lLGNBQWMsQ0FBQzRELElBQUlyRSxJQUFJLEVBQUU2QztnQkFDNUM7WUFDSjtRQUNKLE9BQ0s7WUFDRCxNQUFNLElBQUlyQyxNQUFNO1FBQ3BCO1FBQ0EsSUFBSVIsU0FBU0ssV0FBVztZQUNwQixPQUFPWCxPQUFPZSxjQUFjLENBQUNULE1BQU02QztRQUN2QyxPQUNLO1lBQ0QsTUFBTSxJQUFJckMsTUFBTTtRQUNwQjtJQUNKO0lBQ0E4RCxZQUFZM0QsT0FBTyxFQUFFO1FBQ2pCLElBQUk0RCxJQUFJQztRQUNSLE1BQU12QixrQkFBa0JGLFNBQVNDLGFBQWEsQ0FBQyxVQUFVRSxVQUFVLENBQUM7UUFDcEUsSUFBSWQ7UUFDSixJQUFJYSxtQkFBbUIsTUFBTTtZQUN6QiwrQ0FBK0M7WUFDL0MsTUFBTXBDLFFBQVEsSUFBSSxDQUFDNUIsSUFBSSxDQUFDLEVBQUU7WUFDMUIsTUFBTTJCLFNBQVMsSUFBSSxDQUFDM0IsSUFBSSxDQUFDLEVBQUU7WUFDM0IsTUFBTXdGLFdBQVcsSUFBSSxDQUFDeEYsSUFBSSxDQUFDLEVBQUU7WUFDN0IsTUFBTWtDLGNBQWNSLFlBQVlOLFlBQWFNLFFBQVE4QyxNQUFNLEtBQUtwRCxZQUFZTSxRQUFROEMsTUFBTSxHQUFHLFFBQVM7WUFDdEcsTUFBTTFDLFdBQVdKLFlBQVlOLFlBQWEsQ0FBQyxDQUFDa0UsS0FBSzVELFFBQVFHLElBQUksTUFBTSxRQUFReUQsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHdEQsSUFBSSxNQUFNWixZQUFZTSxRQUFRRyxJQUFJLENBQUNHLElBQUksR0FBRyxNQUFPO1lBQ3hKLE1BQU1ELFdBQVdMLFlBQVlOLFlBQWEsQ0FBQyxDQUFDbUUsS0FBSzdELFFBQVFHLElBQUksTUFBTSxRQUFRMEQsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHdEQsSUFBSSxNQUFNYixZQUFZTSxRQUFRRyxJQUFJLENBQUNJLElBQUksR0FBRyxJQUFLO1lBQ3RKLE1BQU1LLFNBQVNYLFNBQVNDO1lBQ3hCLElBQUlGLFlBQVlOLFdBQVc7Z0JBQ3ZCLElBQUlNLFFBQVFDLE1BQU0sS0FBS1AsYUFBYU0sUUFBUUMsTUFBTSxLQUFLQSxRQUFRO29CQUMzRCxNQUFNLElBQUlKLE1BQU07Z0JBQ3BCO2dCQUNBLElBQUlHLFFBQVFFLEtBQUssS0FBS1IsYUFBYU0sUUFBUUUsS0FBSyxLQUFLQSxPQUFPO29CQUN4RCxNQUFNLElBQUlMLE1BQU07Z0JBQ3BCO2dCQUNBLElBQUlHLFFBQVE4QyxNQUFNLEtBQUtwRCxhQUFjb0UsYUFBYSxLQUFLOUQsUUFBUThDLE1BQU0sS0FBSyxVQUNyRWdCLGFBQWEsS0FBTTlELFFBQVE4QyxNQUFNLEtBQUssU0FBUzlDLFFBQVE4QyxNQUFNLEtBQUssT0FBUztvQkFDNUUsTUFBTSxJQUFJakQsTUFBTTtnQkFDcEI7WUFDSjtZQUNBLDhCQUE4QjtZQUM5QixNQUFNaUIsT0FBTztZQUNiLElBQUlDLGdCQUFnQixHQUFHQyxnQkFBZ0IsR0FBR0MsZ0JBQWdCLEdBQUdDLGdCQUFnQjtZQUM3RSxJQUFJQyxpQkFBaUIsR0FBR0MsaUJBQWlCUixRQUFRUyxpQkFBaUJULFNBQVMsR0FBR1UsaUJBQWlCLENBQUM7WUFDaEcsbUVBQW1FO1lBQ25FLElBQUlkLGdCQUFnQixRQUFRO2dCQUN4QlcsaUJBQWlCO2dCQUNqQkMsaUJBQWlCUjtnQkFDakJTLGlCQUFpQlQsU0FBUztnQkFDMUJVLGlCQUFpQlYsU0FBUztZQUM5QixPQUNLLElBQUlKLGdCQUFnQixPQUFPO2dCQUM1QlcsaUJBQWlCO2dCQUNqQkMsaUJBQWlCUjtnQkFDakJTLGlCQUFpQlQsU0FBUztZQUM5QixPQUNLLElBQUlKLGdCQUFnQixPQUFPO2dCQUM1QlcsaUJBQWlCO2dCQUNqQkUsaUJBQWlCVDtnQkFDakJRLGlCQUFpQlIsU0FBUztZQUM5QjtZQUNBYSxRQUFRYSxnQkFBZ0J5QixlQUFlLENBQUM3RCxPQUFPRDtZQUMvQyxJQUFLLElBQUl6QixJQUFJLEdBQUdBLElBQUl5QixTQUFTQyxPQUFPYSxpQkFBaUJELE1BQU1FLGlCQUFpQkYsTUFBTUcsaUJBQWlCSCxNQUFNSSxpQkFBaUJKLE1BQU10QyxJQUFLO2dCQUNqSWlELE1BQU1wQyxJQUFJLENBQUMwQixjQUFjLEdBQUcsQ0FBQyxJQUFJLENBQUMxQixJQUFJLENBQUM4QixpQkFBaUIsR0FBR2QsUUFBTyxJQUFLRCxVQUFVLFVBQVU7Z0JBQzNGcUIsTUFBTXBDLElBQUksQ0FBQzJCLGNBQWMsR0FBRyxDQUFDLElBQUksQ0FBQzNCLElBQUksQ0FBQytCLGlCQUFpQixHQUFHZixRQUFPLElBQUtELFVBQVUsVUFBVTtnQkFDM0ZxQixNQUFNcEMsSUFBSSxDQUFDNEIsY0FBYyxHQUFHLENBQUMsSUFBSSxDQUFDNUIsSUFBSSxDQUFDZ0MsaUJBQWlCLEdBQUdoQixRQUFPLElBQUtELFVBQVUsVUFBVTtnQkFDM0ZxQixNQUFNcEMsSUFBSSxDQUFDNkIsY0FBYyxHQUNyQkksbUJBQW1CLENBQUMsSUFBSSxNQUFNLENBQUMsSUFBSSxDQUFDakMsSUFBSSxDQUFDaUMsaUJBQWlCLEdBQUdqQixRQUFPLElBQUtELFVBQVUsVUFBVTtZQUNyRztRQUNKLE9BQ0s7WUFDRCxNQUFNLElBQUlQLE1BQU07UUFDcEI7UUFDQSxPQUFPNEI7SUFDWDtJQUNBLGFBQWE7SUFDYiwyQkFBMkI7SUFDM0J1QyxRQUFRMUYsSUFBSSxFQUFFO1FBQ1YsT0FBTyxJQUFJUyxPQUFPLElBQUksQ0FBQ0ssSUFBSSxFQUFFLElBQUksQ0FBQ0MsSUFBSSxFQUFFZjtJQUM1QztBQUNKLEVBQ0EsdUNBQXVDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vanN2b2ljZS1kZW1vLy4uL25vZGVfbW9kdWxlcy9vbm54cnVudGltZS1jb21tb24vZGlzdC9saWIvdGVuc29yLWltcGwuanM/YTYxYSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbmNvbnN0IGlzQmlnSW50NjRBcnJheUF2YWlsYWJsZSA9IHR5cGVvZiBCaWdJbnQ2NEFycmF5ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgQmlnSW50NjRBcnJheS5mcm9tID09PSAnZnVuY3Rpb24nO1xuY29uc3QgaXNCaWdVaW50NjRBcnJheUF2YWlsYWJsZSA9IHR5cGVvZiBCaWdVaW50NjRBcnJheSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIEJpZ1VpbnQ2NEFycmF5LmZyb20gPT09ICdmdW5jdGlvbic7XG4vLyBhIHJ1bnRpbWUgbWFwIHRoYXQgbWFwcyB0eXBlIHN0cmluZyB0byBUeXBlZEFycmF5IGNvbnN0cnVjdG9yLiBTaG91bGQgbWF0Y2ggVGVuc29yLkRhdGFUeXBlTWFwLlxuY29uc3QgTlVNRVJJQ19URU5TT1JfVFlQRV9UT19UWVBFREFSUkFZX01BUCA9IG5ldyBNYXAoW1xuICAgIFsnZmxvYXQzMicsIEZsb2F0MzJBcnJheV0sXG4gICAgWyd1aW50OCcsIFVpbnQ4QXJyYXldLFxuICAgIFsnaW50OCcsIEludDhBcnJheV0sXG4gICAgWyd1aW50MTYnLCBVaW50MTZBcnJheV0sXG4gICAgWydpbnQxNicsIEludDE2QXJyYXldLFxuICAgIFsnaW50MzInLCBJbnQzMkFycmF5XSxcbiAgICBbJ2Jvb2wnLCBVaW50OEFycmF5XSxcbiAgICBbJ2Zsb2F0NjQnLCBGbG9hdDY0QXJyYXldLFxuICAgIFsndWludDMyJywgVWludDMyQXJyYXldLFxuXSk7XG4vLyBhIHJ1bnRpbWUgbWFwIHRoYXQgbWFwcyB0eXBlIHN0cmluZyB0byBUeXBlZEFycmF5IGNvbnN0cnVjdG9yLiBTaG91bGQgbWF0Y2ggVGVuc29yLkRhdGFUeXBlTWFwLlxuY29uc3QgTlVNRVJJQ19URU5TT1JfVFlQRURBUlJBWV9UT19UWVBFX01BUCA9IG5ldyBNYXAoW1xuICAgIFtGbG9hdDMyQXJyYXksICdmbG9hdDMyJ10sXG4gICAgW1VpbnQ4QXJyYXksICd1aW50OCddLFxuICAgIFtJbnQ4QXJyYXksICdpbnQ4J10sXG4gICAgW1VpbnQxNkFycmF5LCAndWludDE2J10sXG4gICAgW0ludDE2QXJyYXksICdpbnQxNiddLFxuICAgIFtJbnQzMkFycmF5LCAnaW50MzInXSxcbiAgICBbRmxvYXQ2NEFycmF5LCAnZmxvYXQ2NCddLFxuICAgIFtVaW50MzJBcnJheSwgJ3VpbnQzMiddLFxuXSk7XG5pZiAoaXNCaWdJbnQ2NEFycmF5QXZhaWxhYmxlKSB7XG4gICAgTlVNRVJJQ19URU5TT1JfVFlQRV9UT19UWVBFREFSUkFZX01BUC5zZXQoJ2ludDY0JywgQmlnSW50NjRBcnJheSk7XG4gICAgTlVNRVJJQ19URU5TT1JfVFlQRURBUlJBWV9UT19UWVBFX01BUC5zZXQoQmlnSW50NjRBcnJheSwgJ2ludDY0Jyk7XG59XG5pZiAoaXNCaWdVaW50NjRBcnJheUF2YWlsYWJsZSkge1xuICAgIE5VTUVSSUNfVEVOU09SX1RZUEVfVE9fVFlQRURBUlJBWV9NQVAuc2V0KCd1aW50NjQnLCBCaWdVaW50NjRBcnJheSk7XG4gICAgTlVNRVJJQ19URU5TT1JfVFlQRURBUlJBWV9UT19UWVBFX01BUC5zZXQoQmlnVWludDY0QXJyYXksICd1aW50NjQnKTtcbn1cbi8qKlxuICogY2FsY3VsYXRlIHNpemUgZnJvbSBkaW1zLlxuICpcbiAqIEBwYXJhbSBkaW1zIHRoZSBkaW1zIGFycmF5LiBNYXkgYmUgYW4gaWxsZWdhbCBpbnB1dC5cbiAqL1xuY29uc3QgY2FsY3VsYXRlU2l6ZSA9IChkaW1zKSA9PiB7XG4gICAgbGV0IHNpemUgPSAxO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGltcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBkaW0gPSBkaW1zW2ldO1xuICAgICAgICBpZiAodHlwZW9mIGRpbSAhPT0gJ251bWJlcicgfHwgIU51bWJlci5pc1NhZmVJbnRlZ2VyKGRpbSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYGRpbXNbJHtpfV0gbXVzdCBiZSBhbiBpbnRlZ2VyLCBnb3Q6ICR7ZGltfWApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkaW0gPCAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgZGltc1ske2l9XSBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIGludGVnZXIsIGdvdDogJHtkaW19YCk7XG4gICAgICAgIH1cbiAgICAgICAgc2l6ZSAqPSBkaW07XG4gICAgfVxuICAgIHJldHVybiBzaXplO1xufTtcbmV4cG9ydCBjbGFzcyBUZW5zb3Ige1xuICAgIGNvbnN0cnVjdG9yKGFyZzAsIGFyZzEsIGFyZzIpIHtcbiAgICAgICAgbGV0IHR5cGU7XG4gICAgICAgIGxldCBkYXRhO1xuICAgICAgICBsZXQgZGltcztcbiAgICAgICAgLy8gY2hlY2sgd2hldGhlciBhcmcwIGlzIHR5cGUgb3IgZGF0YVxuICAgICAgICBpZiAodHlwZW9mIGFyZzAgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gT3ZlcnJpZGU6IGNvbnN0cnVjdG9yKHR5cGUsIGRhdGEsIC4uLilcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICB0eXBlID0gYXJnMDtcbiAgICAgICAgICAgIGRpbXMgPSBhcmcyO1xuICAgICAgICAgICAgaWYgKGFyZzAgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgLy8gc3RyaW5nIHRlbnNvclxuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShhcmcxKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBIHN0cmluZyB0ZW5zb3JcXCdzIGRhdGEgbXVzdCBiZSBhIHN0cmluZyBhcnJheS4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gd2UgZG9uJ3QgY2hlY2sgd2hldGhlciBldmVyeSBlbGVtZW50IGluIHRoZSBhcnJheSBpcyBzdHJpbmc7IHRoaXMgaXMgdG9vIHNsb3cuIHdlIGFzc3VtZSBpdCdzIGNvcnJlY3QgYW5kXG4gICAgICAgICAgICAgICAgLy8gZXJyb3Igd2lsbCBiZSBwb3B1bGF0ZWQgYXQgaW5mZXJlbmNlXG4gICAgICAgICAgICAgICAgZGF0YSA9IGFyZzE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBudW1lcmljIHRlbnNvclxuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVkQXJyYXlDb25zdHJ1Y3RvciA9IE5VTUVSSUNfVEVOU09SX1RZUEVfVE9fVFlQRURBUlJBWV9NQVAuZ2V0KGFyZzApO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlZEFycmF5Q29uc3RydWN0b3IgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBVbnN1cHBvcnRlZCB0ZW5zb3IgdHlwZTogJHthcmcwfS5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYXJnMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdXNlICdhcyBhbnknIGhlcmUgYmVjYXVzZSBUeXBlU2NyaXB0J3MgY2hlY2sgb24gdHlwZSBvZiAnU3VwcG9ydGVkVHlwZWRBcnJheUNvbnN0cnVjdG9ycy5mcm9tKCknIHByb2R1Y2VzXG4gICAgICAgICAgICAgICAgICAgIC8vIGluY29ycmVjdCByZXN1bHRzLlxuICAgICAgICAgICAgICAgICAgICAvLyAndHlwZWRBcnJheUNvbnN0cnVjdG9yJyBzaG91bGQgYmUgb25lIG9mIHRoZSB0eXBlZCBhcnJheSBwcm90b3R5cGUgb2JqZWN0cy5cbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IHR5cGVkQXJyYXlDb25zdHJ1Y3Rvci5mcm9tKGFyZzEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChhcmcxIGluc3RhbmNlb2YgdHlwZWRBcnJheUNvbnN0cnVjdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSBhcmcxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgQSAke3R5cGV9IHRlbnNvcidzIGRhdGEgbXVzdCBiZSB0eXBlIG9mICR7dHlwZWRBcnJheUNvbnN0cnVjdG9yfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBPdmVycmlkZTogY29uc3RydWN0b3IoZGF0YSwgLi4uKVxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIGRpbXMgPSBhcmcxO1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYXJnMCkpIHtcbiAgICAgICAgICAgICAgICAvLyBvbmx5IGJvb2xlYW5bXSBhbmQgc3RyaW5nW10gaXMgc3VwcG9ydGVkXG4gICAgICAgICAgICAgICAgaWYgKGFyZzAubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RlbnNvciB0eXBlIGNhbm5vdCBiZSBpbmZlcnJlZCBmcm9tIGFuIGVtcHR5IGFycmF5LicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBmaXJzdEVsZW1lbnRUeXBlID0gdHlwZW9mIGFyZzBbMF07XG4gICAgICAgICAgICAgICAgaWYgKGZpcnN0RWxlbWVudFR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGUgPSAnc3RyaW5nJztcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IGFyZzA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGZpcnN0RWxlbWVudFR5cGUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgICAgICB0eXBlID0gJ2Jvb2wnO1xuICAgICAgICAgICAgICAgICAgICAvLyAnYXJnMCcgaXMgb2YgdHlwZSAnYm9vbGVhbltdJy4gVWludDhBcnJheS5mcm9tKGJvb2xlYW5bXSkgYWN0dWFsbHkgd29ya3MsIGJ1dCB0eXBlc2NyaXB0IHRoaW5rcyB0aGlzIGlzXG4gICAgICAgICAgICAgICAgICAgIC8vIHdyb25nIHR5cGUuIFdlIHVzZSAnYXMgYW55JyB0byBtYWtlIGl0IGhhcHB5LlxuICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgICAgICAgICBkYXRhID0gVWludDhBcnJheS5mcm9tKGFyZzApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgSW52YWxpZCBlbGVtZW50IHR5cGUgb2YgZGF0YSBhcnJheTogJHtmaXJzdEVsZW1lbnRUeXBlfS5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBnZXQgdGVuc29yIHR5cGUgZnJvbSBUeXBlZEFycmF5XG4gICAgICAgICAgICAgICAgY29uc3QgbWFwcGVkVHlwZSA9IE5VTUVSSUNfVEVOU09SX1RZUEVEQVJSQVlfVE9fVFlQRV9NQVAuZ2V0KGFyZzAuY29uc3RydWN0b3IpO1xuICAgICAgICAgICAgICAgIGlmIChtYXBwZWRUeXBlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVW5zdXBwb3J0ZWQgdHlwZSBmb3IgdGVuc29yIGRhdGE6ICR7YXJnMC5jb25zdHJ1Y3Rvcn0uYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHR5cGUgPSBtYXBwZWRUeXBlO1xuICAgICAgICAgICAgICAgIGRhdGEgPSBhcmcwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHR5cGUgYW5kIGRhdGEgaXMgcHJvY2Vzc2VkLCBub3cgcHJvY2Vzc2luZyBkaW1zXG4gICAgICAgIGlmIChkaW1zID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIGFzc3VtZSAxLUQgdGVuc29yIGlmIGRpbXMgb21pdHRlZFxuICAgICAgICAgICAgZGltcyA9IFtkYXRhLmxlbmd0aF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIUFycmF5LmlzQXJyYXkoZGltcykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0EgdGVuc29yXFwncyBkaW1zIG11c3QgYmUgYSBudW1iZXIgYXJyYXknKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBwZXJmb3JtIGNoZWNrXG4gICAgICAgIGNvbnN0IHNpemUgPSBjYWxjdWxhdGVTaXplKGRpbXMpO1xuICAgICAgICBpZiAoc2l6ZSAhPT0gZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVGVuc29yJ3Mgc2l6ZSgke3NpemV9KSBkb2VzIG5vdCBtYXRjaCBkYXRhIGxlbmd0aCgke2RhdGEubGVuZ3RofSkuYCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kaW1zID0gZGltcztcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICAgICAgdGhpcy5zaXplID0gc2l6ZTtcbiAgICB9XG4gICAgLy8gI2VuZHJlZ2lvblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyB0ZW5zb3Igb2JqZWN0IGZyb20gaW1hZ2Ugb2JqZWN0XG4gICAgICpcbiAgICAgKiBAcGFyYW0gYnVmZmVyIC0gRXh0cmFjdGVkIGltYWdlIGJ1ZmZlciBkYXRhIC0gYXNzdW1pbmcgUkdCQSBmb3JtYXRcbiAgICAgKiBAcGFyYW0gaW1hZ2VGb3JtYXQgLSBpbnB1dCBpbWFnZSBjb25maWd1cmF0aW9uIC0gcmVxdWlyZWQgY29uZmlndXJhdGlvbnMgaGVpZ2h0LCB3aWR0aCwgZm9ybWF0XG4gICAgICogQHBhcmFtIHRlbnNvckZvcm1hdCAtIG91dHB1dCB0ZW5zb3IgY29uZmlndXJhdGlvbiAtIERlZmF1bHQgaXMgUkdCIGZvcm1hdFxuICAgICAqL1xuICAgIHN0YXRpYyBidWZmZXJUb1RlbnNvcihidWZmZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKGJ1ZmZlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ltYWdlIGJ1ZmZlciBtdXN0IGJlIGRlZmluZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5oZWlnaHQgPT09IHVuZGVmaW5lZCB8fCBvcHRpb25zLndpZHRoID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW1hZ2UgaGVpZ2h0IGFuZCB3aWR0aCBtdXN0IGJlIGRlZmluZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IGhlaWdodCwgd2lkdGggfSA9IG9wdGlvbnM7XG4gICAgICAgIGNvbnN0IG5vcm0gPSBvcHRpb25zLm5vcm07XG4gICAgICAgIGxldCBub3JtTWVhbjtcbiAgICAgICAgbGV0IG5vcm1CaWFzO1xuICAgICAgICBpZiAobm9ybSA9PT0gdW5kZWZpbmVkIHx8IG5vcm0ubWVhbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBub3JtTWVhbiA9IDI1NTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG5vcm1NZWFuID0gbm9ybS5tZWFuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub3JtID09PSB1bmRlZmluZWQgfHwgbm9ybS5iaWFzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG5vcm1CaWFzID0gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG5vcm1CaWFzID0gbm9ybS5iaWFzO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlucHV0Zm9ybWF0ID0gb3B0aW9ucy5iaXRtYXBGb3JtYXQgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuYml0bWFwRm9ybWF0IDogJ1JHQkEnO1xuICAgICAgICAvLyBkZWZhdWx0IHZhbHVlIGlzIFJHQkEgc2luY2UgaW1hZ2VkYXRhIGFuZCBIVE1MSW1hZ2VFbGVtZW50IHVzZXMgaXRcbiAgICAgICAgY29uc3Qgb3V0cHV0Zm9ybWF0ID0gb3B0aW9ucy50ZW5zb3JGb3JtYXQgIT09IHVuZGVmaW5lZCA/XG4gICAgICAgICAgICAob3B0aW9ucy50ZW5zb3JGb3JtYXQgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMudGVuc29yRm9ybWF0IDogJ1JHQicpIDpcbiAgICAgICAgICAgICdSR0InO1xuICAgICAgICBjb25zdCBvZmZzZXQgPSBoZWlnaHQgKiB3aWR0aDtcbiAgICAgICAgY29uc3QgZmxvYXQzMkRhdGEgPSBvdXRwdXRmb3JtYXQgPT09ICdSR0JBJyA/IG5ldyBGbG9hdDMyQXJyYXkob2Zmc2V0ICogNCkgOiBuZXcgRmxvYXQzMkFycmF5KG9mZnNldCAqIDMpO1xuICAgICAgICAvLyBEZWZhdWx0IHBvaW50ZXIgYXNzaWdubWVudHNcbiAgICAgICAgbGV0IHN0ZXAgPSA0LCBySW1hZ2VQb2ludGVyID0gMCwgZ0ltYWdlUG9pbnRlciA9IDEsIGJJbWFnZVBvaW50ZXIgPSAyLCBhSW1hZ2VQb2ludGVyID0gMztcbiAgICAgICAgbGV0IHJUZW5zb3JQb2ludGVyID0gMCwgZ1RlbnNvclBvaW50ZXIgPSBvZmZzZXQsIGJUZW5zb3JQb2ludGVyID0gb2Zmc2V0ICogMiwgYVRlbnNvclBvaW50ZXIgPSAtMTtcbiAgICAgICAgLy8gVXBkYXRpbmcgdGhlIHBvaW50ZXIgYXNzaWdubWVudHMgYmFzZWQgb24gdGhlIGlucHV0IGltYWdlIGZvcm1hdFxuICAgICAgICBpZiAoaW5wdXRmb3JtYXQgPT09ICdSR0InKSB7XG4gICAgICAgICAgICBzdGVwID0gMztcbiAgICAgICAgICAgIHJJbWFnZVBvaW50ZXIgPSAwO1xuICAgICAgICAgICAgZ0ltYWdlUG9pbnRlciA9IDE7XG4gICAgICAgICAgICBiSW1hZ2VQb2ludGVyID0gMjtcbiAgICAgICAgICAgIGFJbWFnZVBvaW50ZXIgPSAtMTtcbiAgICAgICAgfVxuICAgICAgICAvLyBVcGRhdGluZyB0aGUgcG9pbnRlciBhc3NpZ25tZW50cyBiYXNlZCBvbiB0aGUgb3V0cHV0IHRlbnNvciBmb3JtYXRcbiAgICAgICAgaWYgKG91dHB1dGZvcm1hdCA9PT0gJ1JHQkEnKSB7XG4gICAgICAgICAgICBhVGVuc29yUG9pbnRlciA9IG9mZnNldCAqIDM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3V0cHV0Zm9ybWF0ID09PSAnUkJHJykge1xuICAgICAgICAgICAgclRlbnNvclBvaW50ZXIgPSAwO1xuICAgICAgICAgICAgYlRlbnNvclBvaW50ZXIgPSBvZmZzZXQ7XG4gICAgICAgICAgICBnVGVuc29yUG9pbnRlciA9IG9mZnNldCAqIDI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3V0cHV0Zm9ybWF0ID09PSAnQkdSJykge1xuICAgICAgICAgICAgYlRlbnNvclBvaW50ZXIgPSAwO1xuICAgICAgICAgICAgZ1RlbnNvclBvaW50ZXIgPSBvZmZzZXQ7XG4gICAgICAgICAgICByVGVuc29yUG9pbnRlciA9IG9mZnNldCAqIDI7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvZmZzZXQ7IGkrKywgckltYWdlUG9pbnRlciArPSBzdGVwLCBiSW1hZ2VQb2ludGVyICs9IHN0ZXAsIGdJbWFnZVBvaW50ZXIgKz0gc3RlcCwgYUltYWdlUG9pbnRlciArPSBzdGVwKSB7XG4gICAgICAgICAgICBmbG9hdDMyRGF0YVtyVGVuc29yUG9pbnRlcisrXSA9IChidWZmZXJbckltYWdlUG9pbnRlcl0gKyBub3JtQmlhcykgLyBub3JtTWVhbjtcbiAgICAgICAgICAgIGZsb2F0MzJEYXRhW2dUZW5zb3JQb2ludGVyKytdID0gKGJ1ZmZlcltnSW1hZ2VQb2ludGVyXSArIG5vcm1CaWFzKSAvIG5vcm1NZWFuO1xuICAgICAgICAgICAgZmxvYXQzMkRhdGFbYlRlbnNvclBvaW50ZXIrK10gPSAoYnVmZmVyW2JJbWFnZVBvaW50ZXJdICsgbm9ybUJpYXMpIC8gbm9ybU1lYW47XG4gICAgICAgICAgICBpZiAoYVRlbnNvclBvaW50ZXIgIT09IC0xICYmIGFJbWFnZVBvaW50ZXIgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgZmxvYXQzMkRhdGFbYVRlbnNvclBvaW50ZXIrK10gPSAoYnVmZmVyW2FJbWFnZVBvaW50ZXJdICsgbm9ybUJpYXMpIC8gbm9ybU1lYW47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gRmxvYXQzMkFycmF5IC0+IG9ydC5UZW5zb3JcbiAgICAgICAgY29uc3Qgb3V0cHV0VGVuc29yID0gb3V0cHV0Zm9ybWF0ID09PSAnUkdCQScgPyBuZXcgVGVuc29yKCdmbG9hdDMyJywgZmxvYXQzMkRhdGEsIFsxLCA0LCBoZWlnaHQsIHdpZHRoXSkgOlxuICAgICAgICAgICAgbmV3IFRlbnNvcignZmxvYXQzMicsIGZsb2F0MzJEYXRhLCBbMSwgMywgaGVpZ2h0LCB3aWR0aF0pO1xuICAgICAgICByZXR1cm4gb3V0cHV0VGVuc29yO1xuICAgIH1cbiAgICBzdGF0aWMgYXN5bmMgZnJvbUltYWdlKGltYWdlLCBvcHRpb25zKSB7XG4gICAgICAgIC8vIGNoZWNraW5nIHRoZSB0eXBlIG9mIGltYWdlIG9iamVjdFxuICAgICAgICBjb25zdCBpc0hUTUxJbWFnZUVsZSA9IHR5cGVvZiAoSFRNTEltYWdlRWxlbWVudCkgIT09ICd1bmRlZmluZWQnICYmIGltYWdlIGluc3RhbmNlb2YgSFRNTEltYWdlRWxlbWVudDtcbiAgICAgICAgY29uc3QgaXNJbWFnZURhdGFFbGUgPSB0eXBlb2YgKEltYWdlRGF0YSkgIT09ICd1bmRlZmluZWQnICYmIGltYWdlIGluc3RhbmNlb2YgSW1hZ2VEYXRhO1xuICAgICAgICBjb25zdCBpc0ltYWdlQml0bWFwID0gdHlwZW9mIChJbWFnZUJpdG1hcCkgIT09ICd1bmRlZmluZWQnICYmIGltYWdlIGluc3RhbmNlb2YgSW1hZ2VCaXRtYXA7XG4gICAgICAgIGNvbnN0IGlzVVJMID0gdHlwZW9mIChTdHJpbmcpICE9PSAndW5kZWZpbmVkJyAmJiAoaW1hZ2UgaW5zdGFuY2VvZiBTdHJpbmcgfHwgdHlwZW9mIGltYWdlID09PSAnc3RyaW5nJyk7XG4gICAgICAgIGxldCBkYXRhO1xuICAgICAgICBsZXQgdGVuc29yQ29uZmlnID0ge307XG4gICAgICAgIC8vIGZpbGxpbmcgYW5kIGNoZWNraW5nIGltYWdlIGNvbmZpZ3VyYXRpb24gb3B0aW9uc1xuICAgICAgICBpZiAoaXNIVE1MSW1hZ2VFbGUpIHtcbiAgICAgICAgICAgIC8vIEhUTUxJbWFnZUVsZW1lbnQgLSBpbWFnZSBvYmplY3QgLSBmb3JtYXQgaXMgUkdCQSBieSBkZWZhdWx0XG4gICAgICAgICAgICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgICAgIGNvbnN0IHBpeGVsczJEQ29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICAgICAgaWYgKHBpeGVsczJEQ29udGV4dCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbGV0IGhlaWdodCA9IGltYWdlLm5hdHVyYWxIZWlnaHQ7XG4gICAgICAgICAgICAgICAgbGV0IHdpZHRoID0gaW1hZ2UubmF0dXJhbFdpZHRoO1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zICE9PSB1bmRlZmluZWQgJiYgb3B0aW9ucy5yZXNpemVkSGVpZ2h0ICE9PSB1bmRlZmluZWQgJiYgb3B0aW9ucy5yZXNpemVkV2lkdGggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBoZWlnaHQgPSBvcHRpb25zLnJlc2l6ZWRIZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIHdpZHRoID0gb3B0aW9ucy5yZXNpemVkV2lkdGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGVuc29yQ29uZmlnID0gb3B0aW9ucztcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMudGVuc29yRm9ybWF0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW1hZ2UgaW5wdXQgY29uZmlnIGZvcm1hdCBtdXN0IGJlIFJHQkEgZm9yIEhUTUxJbWFnZUVsZW1lbnQnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbnNvckNvbmZpZy50ZW5zb3JGb3JtYXQgPSAnUkdCQSc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuaGVpZ2h0ICE9PSB1bmRlZmluZWQgJiYgb3B0aW9ucy5oZWlnaHQgIT09IGhlaWdodCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbWFnZSBpbnB1dCBjb25maWcgaGVpZ2h0IGRvZXNuXFwndCBtYXRjaCBIVE1MSW1hZ2VFbGVtZW50IGhlaWdodCcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGVuc29yQ29uZmlnLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy53aWR0aCAhPT0gdW5kZWZpbmVkICYmIG9wdGlvbnMud2lkdGggIT09IHdpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ltYWdlIGlucHV0IGNvbmZpZyB3aWR0aCBkb2VzblxcJ3QgbWF0Y2ggSFRNTEltYWdlRWxlbWVudCB3aWR0aCcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGVuc29yQ29uZmlnLndpZHRoID0gd2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRlbnNvckNvbmZpZy50ZW5zb3JGb3JtYXQgPSAnUkdCQSc7XG4gICAgICAgICAgICAgICAgICAgIHRlbnNvckNvbmZpZy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIHRlbnNvckNvbmZpZy53aWR0aCA9IHdpZHRoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYW52YXMud2lkdGggPSB3aWR0aDtcbiAgICAgICAgICAgICAgICBjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICAgICAgICAgIHBpeGVsczJEQ29udGV4dC5kcmF3SW1hZ2UoaW1hZ2UsIDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgICAgICAgIGRhdGEgPSBwaXhlbHMyRENvbnRleHQuZ2V0SW1hZ2VEYXRhKDAsIDAsIHdpZHRoLCBoZWlnaHQpLmRhdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhbiBub3QgYWNjZXNzIGltYWdlIGRhdGEnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc0ltYWdlRGF0YUVsZSkge1xuICAgICAgICAgICAgLy8gSW1hZ2VEYXRhIC0gaW1hZ2Ugb2JqZWN0IC0gZm9ybWF0IGlzIFJHQkEgYnkgZGVmYXVsdFxuICAgICAgICAgICAgY29uc3QgZm9ybWF0ID0gJ1JHQkEnO1xuICAgICAgICAgICAgbGV0IGhlaWdodDtcbiAgICAgICAgICAgIGxldCB3aWR0aDtcbiAgICAgICAgICAgIGlmIChvcHRpb25zICE9PSB1bmRlZmluZWQgJiYgb3B0aW9ucy5yZXNpemVkV2lkdGggIT09IHVuZGVmaW5lZCAmJiBvcHRpb25zLnJlc2l6ZWRIZWlnaHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGhlaWdodCA9IG9wdGlvbnMucmVzaXplZEhlaWdodDtcbiAgICAgICAgICAgICAgICB3aWR0aCA9IG9wdGlvbnMucmVzaXplZFdpZHRoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaGVpZ2h0ID0gaW1hZ2UuaGVpZ2h0O1xuICAgICAgICAgICAgICAgIHdpZHRoID0gaW1hZ2Uud2lkdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGVuc29yQ29uZmlnID0gb3B0aW9ucztcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5iaXRtYXBGb3JtYXQgIT09IHVuZGVmaW5lZCAmJiBvcHRpb25zLmJpdG1hcEZvcm1hdCAhPT0gZm9ybWF0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW1hZ2UgaW5wdXQgY29uZmlnIGZvcm1hdCBtdXN0IGJlIFJHQkEgZm9yIEltYWdlRGF0YScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGVuc29yQ29uZmlnLmJpdG1hcEZvcm1hdCA9ICdSR0JBJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0ZW5zb3JDb25maWcuYml0bWFwRm9ybWF0ID0gJ1JHQkEnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGVuc29yQ29uZmlnLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgICAgIHRlbnNvckNvbmZpZy53aWR0aCA9IHdpZHRoO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRlbXBDYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgICAgICAgICB0ZW1wQ2FudmFzLndpZHRoID0gd2lkdGg7XG4gICAgICAgICAgICAgICAgdGVtcENhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgICAgICAgICAgY29uc3QgcGl4ZWxzMkRDb250ZXh0ID0gdGVtcENhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICAgICAgICAgIGlmIChwaXhlbHMyRENvbnRleHQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBwaXhlbHMyRENvbnRleHQucHV0SW1hZ2VEYXRhKGltYWdlLCAwLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IHBpeGVsczJEQ29udGV4dC5nZXRJbWFnZURhdGEoMCwgMCwgd2lkdGgsIGhlaWdodCkuZGF0YTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2FuIG5vdCBhY2Nlc3MgaW1hZ2UgZGF0YScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRhdGEgPSBpbWFnZS5kYXRhO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzSW1hZ2VCaXRtYXApIHtcbiAgICAgICAgICAgIC8vIEltYWdlQml0bWFwIC0gaW1hZ2Ugb2JqZWN0IC0gZm9ybWF0IG11c3QgYmUgcHJvdmlkZWQgYnkgdXNlclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUGxlYXNlIHByb3ZpZGUgaW1hZ2UgY29uZmlnIHdpdGggZm9ybWF0IGZvciBJbWFnZWJpdG1hcCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuYml0bWFwRm9ybWF0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ltYWdlIGlucHV0IGNvbmZpZyBmb3JtYXQgbXVzdCBiZSBkZWZpbmVkIGZvciBJbWFnZUJpdG1hcCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcGl4ZWxzMkRDb250ZXh0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJykuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgICAgIGlmIChwaXhlbHMyRENvbnRleHQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGhlaWdodCA9IGltYWdlLmhlaWdodDtcbiAgICAgICAgICAgICAgICBjb25zdCB3aWR0aCA9IGltYWdlLndpZHRoO1xuICAgICAgICAgICAgICAgIHBpeGVsczJEQ29udGV4dC5kcmF3SW1hZ2UoaW1hZ2UsIDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgICAgICAgIGRhdGEgPSBwaXhlbHMyRENvbnRleHQuZ2V0SW1hZ2VEYXRhKDAsIDAsIHdpZHRoLCBoZWlnaHQpLmRhdGE7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyB1c2luZyBzcXVhcmUgYnJhY2tldHMgdG8gYXZvaWQgVFMgZXJyb3IgLSB0eXBlICduZXZlcidcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuaGVpZ2h0ICE9PSB1bmRlZmluZWQgJiYgb3B0aW9ucy5oZWlnaHQgIT09IGhlaWdodCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbWFnZSBpbnB1dCBjb25maWcgaGVpZ2h0IGRvZXNuXFwndCBtYXRjaCBJbWFnZUJpdG1hcCBoZWlnaHQnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbnNvckNvbmZpZy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gdXNpbmcgc3F1YXJlIGJyYWNrZXRzIHRvIGF2b2lkIFRTIGVycm9yIC0gdHlwZSAnbmV2ZXInXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLndpZHRoICE9PSB1bmRlZmluZWQgJiYgb3B0aW9ucy53aWR0aCAhPT0gd2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW1hZ2UgaW5wdXQgY29uZmlnIHdpZHRoIGRvZXNuXFwndCBtYXRjaCBJbWFnZUJpdG1hcCB3aWR0aCcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGVuc29yQ29uZmlnLndpZHRoID0gd2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRlbnNvckNvbmZpZy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIHRlbnNvckNvbmZpZy53aWR0aCA9IHdpZHRoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gVGVuc29yLmJ1ZmZlclRvVGVuc29yKGRhdGEsIHRlbnNvckNvbmZpZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhbiBub3QgYWNjZXNzIGltYWdlIGRhdGEnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc1VSTCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgICAgICAgICBjb25zdCBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgICAgICAgICAgaWYgKCFpbWFnZSB8fCAhY29udGV4dCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IG5ld0ltYWdlID0gbmV3IEltYWdlKCk7XG4gICAgICAgICAgICAgICAgbmV3SW1hZ2UuY3Jvc3NPcmlnaW4gPSAnQW5vbnltb3VzJztcbiAgICAgICAgICAgICAgICBuZXdJbWFnZS5zcmMgPSBpbWFnZTtcbiAgICAgICAgICAgICAgICBuZXdJbWFnZS5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNhbnZhcy53aWR0aCA9IG5ld0ltYWdlLndpZHRoO1xuICAgICAgICAgICAgICAgICAgICBjYW52YXMuaGVpZ2h0ID0gbmV3SW1hZ2UuaGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmRyYXdJbWFnZShuZXdJbWFnZSwgMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaW1nID0gY29udGV4dC5nZXRJbWFnZURhdGEoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdXNpbmcgc3F1YXJlIGJyYWNrZXRzIHRvIGF2b2lkIFRTIGVycm9yIC0gdHlwZSAnbmV2ZXInXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5oZWlnaHQgIT09IHVuZGVmaW5lZCAmJiBvcHRpb25zLmhlaWdodCAhPT0gY2FudmFzLmhlaWdodCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW1hZ2UgaW5wdXQgY29uZmlnIGhlaWdodCBkb2VzblxcJ3QgbWF0Y2ggSW1hZ2VCaXRtYXAgaGVpZ2h0Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZW5zb3JDb25maWcuaGVpZ2h0ID0gY2FudmFzLmhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHVzaW5nIHNxdWFyZSBicmFja2V0cyB0byBhdm9pZCBUUyBlcnJvciAtIHR5cGUgJ25ldmVyJ1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMud2lkdGggIT09IHVuZGVmaW5lZCAmJiBvcHRpb25zLndpZHRoICE9PSBjYW52YXMud2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ltYWdlIGlucHV0IGNvbmZpZyB3aWR0aCBkb2VzblxcJ3QgbWF0Y2ggSW1hZ2VCaXRtYXAgd2lkdGgnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlbnNvckNvbmZpZy53aWR0aCA9IGNhbnZhcy53aWR0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbnNvckNvbmZpZy5oZWlnaHQgPSBjYW52YXMuaGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgICAgdGVuc29yQ29uZmlnLndpZHRoID0gY2FudmFzLndpZHRoO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoVGVuc29yLmJ1ZmZlclRvVGVuc29yKGltZy5kYXRhLCB0ZW5zb3JDb25maWcpKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IGRhdGEgcHJvdmlkZWQgaXMgbm90IHN1cHBvcnRlZCAtIGFib3J0ZWQgdGVuc29yIGNyZWF0aW9uJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIFRlbnNvci5idWZmZXJUb1RlbnNvcihkYXRhLCB0ZW5zb3JDb25maWcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBkYXRhIHByb3ZpZGVkIGlzIG5vdCBzdXBwb3J0ZWQgLSBhYm9ydGVkIHRlbnNvciBjcmVhdGlvbicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRvSW1hZ2VEYXRhKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY29uc3QgcGl4ZWxzMkRDb250ZXh0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJykuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgbGV0IGltYWdlO1xuICAgICAgICBpZiAocGl4ZWxzMkRDb250ZXh0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIC8vIERlZmF1bHQgdmFsdWVzIGZvciBoZWlnaHQgYW5kIHdpZHRoICYgZm9ybWF0XG4gICAgICAgICAgICBjb25zdCB3aWR0aCA9IHRoaXMuZGltc1szXTtcbiAgICAgICAgICAgIGNvbnN0IGhlaWdodCA9IHRoaXMuZGltc1syXTtcbiAgICAgICAgICAgIGNvbnN0IGNoYW5uZWxzID0gdGhpcy5kaW1zWzFdO1xuICAgICAgICAgICAgY29uc3QgaW5wdXRmb3JtYXQgPSBvcHRpb25zICE9PSB1bmRlZmluZWQgPyAob3B0aW9ucy5mb3JtYXQgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZm9ybWF0IDogJ1JHQicpIDogJ1JHQic7XG4gICAgICAgICAgICBjb25zdCBub3JtTWVhbiA9IG9wdGlvbnMgIT09IHVuZGVmaW5lZCA/ICgoKF9hID0gb3B0aW9ucy5ub3JtKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubWVhbikgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMubm9ybS5tZWFuIDogMjU1KSA6IDI1NTtcbiAgICAgICAgICAgIGNvbnN0IG5vcm1CaWFzID0gb3B0aW9ucyAhPT0gdW5kZWZpbmVkID8gKCgoX2IgPSBvcHRpb25zLm5vcm0pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5iaWFzKSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5ub3JtLmJpYXMgOiAwKSA6IDA7XG4gICAgICAgICAgICBjb25zdCBvZmZzZXQgPSBoZWlnaHQgKiB3aWR0aDtcbiAgICAgICAgICAgIGlmIChvcHRpb25zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5oZWlnaHQgIT09IHVuZGVmaW5lZCAmJiBvcHRpb25zLmhlaWdodCAhPT0gaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW1hZ2Ugb3V0cHV0IGNvbmZpZyBoZWlnaHQgZG9lc25cXCd0IG1hdGNoIHRlbnNvciBoZWlnaHQnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMud2lkdGggIT09IHVuZGVmaW5lZCAmJiBvcHRpb25zLndpZHRoICE9PSB3aWR0aCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ltYWdlIG91dHB1dCBjb25maWcgd2lkdGggZG9lc25cXCd0IG1hdGNoIHRlbnNvciB3aWR0aCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5mb3JtYXQgIT09IHVuZGVmaW5lZCAmJiAoY2hhbm5lbHMgPT09IDQgJiYgb3B0aW9ucy5mb3JtYXQgIT09ICdSR0JBJykgfHxcbiAgICAgICAgICAgICAgICAgICAgKGNoYW5uZWxzID09PSAzICYmIChvcHRpb25zLmZvcm1hdCAhPT0gJ1JHQicgJiYgb3B0aW9ucy5mb3JtYXQgIT09ICdCR1InKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUZW5zb3IgZm9ybWF0IGRvZXNuXFwndCBtYXRjaCBpbnB1dCB0ZW5zb3IgZGltcycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIERlZmF1bHQgcG9pbnRlciBhc3NpZ25tZW50c1xuICAgICAgICAgICAgY29uc3Qgc3RlcCA9IDQ7XG4gICAgICAgICAgICBsZXQgckltYWdlUG9pbnRlciA9IDAsIGdJbWFnZVBvaW50ZXIgPSAxLCBiSW1hZ2VQb2ludGVyID0gMiwgYUltYWdlUG9pbnRlciA9IDM7XG4gICAgICAgICAgICBsZXQgclRlbnNvclBvaW50ZXIgPSAwLCBnVGVuc29yUG9pbnRlciA9IG9mZnNldCwgYlRlbnNvclBvaW50ZXIgPSBvZmZzZXQgKiAyLCBhVGVuc29yUG9pbnRlciA9IC0xO1xuICAgICAgICAgICAgLy8gVXBkYXRpbmcgdGhlIHBvaW50ZXIgYXNzaWdubWVudHMgYmFzZWQgb24gdGhlIGlucHV0IGltYWdlIGZvcm1hdFxuICAgICAgICAgICAgaWYgKGlucHV0Zm9ybWF0ID09PSAnUkdCQScpIHtcbiAgICAgICAgICAgICAgICByVGVuc29yUG9pbnRlciA9IDA7XG4gICAgICAgICAgICAgICAgZ1RlbnNvclBvaW50ZXIgPSBvZmZzZXQ7XG4gICAgICAgICAgICAgICAgYlRlbnNvclBvaW50ZXIgPSBvZmZzZXQgKiAyO1xuICAgICAgICAgICAgICAgIGFUZW5zb3JQb2ludGVyID0gb2Zmc2V0ICogMztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlucHV0Zm9ybWF0ID09PSAnUkdCJykge1xuICAgICAgICAgICAgICAgIHJUZW5zb3JQb2ludGVyID0gMDtcbiAgICAgICAgICAgICAgICBnVGVuc29yUG9pbnRlciA9IG9mZnNldDtcbiAgICAgICAgICAgICAgICBiVGVuc29yUG9pbnRlciA9IG9mZnNldCAqIDI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpbnB1dGZvcm1hdCA9PT0gJ1JCRycpIHtcbiAgICAgICAgICAgICAgICByVGVuc29yUG9pbnRlciA9IDA7XG4gICAgICAgICAgICAgICAgYlRlbnNvclBvaW50ZXIgPSBvZmZzZXQ7XG4gICAgICAgICAgICAgICAgZ1RlbnNvclBvaW50ZXIgPSBvZmZzZXQgKiAyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW1hZ2UgPSBwaXhlbHMyRENvbnRleHQuY3JlYXRlSW1hZ2VEYXRhKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBoZWlnaHQgKiB3aWR0aDsgckltYWdlUG9pbnRlciArPSBzdGVwLCBnSW1hZ2VQb2ludGVyICs9IHN0ZXAsIGJJbWFnZVBvaW50ZXIgKz0gc3RlcCwgYUltYWdlUG9pbnRlciArPSBzdGVwLCBpKyspIHtcbiAgICAgICAgICAgICAgICBpbWFnZS5kYXRhW3JJbWFnZVBvaW50ZXJdID0gKHRoaXMuZGF0YVtyVGVuc29yUG9pbnRlcisrXSAtIG5vcm1CaWFzKSAqIG5vcm1NZWFuOyAvLyBSIHZhbHVlXG4gICAgICAgICAgICAgICAgaW1hZ2UuZGF0YVtnSW1hZ2VQb2ludGVyXSA9ICh0aGlzLmRhdGFbZ1RlbnNvclBvaW50ZXIrK10gLSBub3JtQmlhcykgKiBub3JtTWVhbjsgLy8gRyB2YWx1ZVxuICAgICAgICAgICAgICAgIGltYWdlLmRhdGFbYkltYWdlUG9pbnRlcl0gPSAodGhpcy5kYXRhW2JUZW5zb3JQb2ludGVyKytdIC0gbm9ybUJpYXMpICogbm9ybU1lYW47IC8vIEIgdmFsdWVcbiAgICAgICAgICAgICAgICBpbWFnZS5kYXRhW2FJbWFnZVBvaW50ZXJdID1cbiAgICAgICAgICAgICAgICAgICAgYVRlbnNvclBvaW50ZXIgPT09IC0xID8gMjU1IDogKHRoaXMuZGF0YVthVGVuc29yUG9pbnRlcisrXSAtIG5vcm1CaWFzKSAqIG5vcm1NZWFuOyAvLyBBIHZhbHVlXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhbiBub3QgYWNjZXNzIGltYWdlIGRhdGEnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW1hZ2U7XG4gICAgfVxuICAgIC8vICNlbmRyZWdpb25cbiAgICAvLyAjcmVnaW9uIHRlbnNvciB1dGlsaXRpZXNcbiAgICByZXNoYXBlKGRpbXMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUZW5zb3IodGhpcy50eXBlLCB0aGlzLmRhdGEsIGRpbXMpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRlbnNvci1pbXBsLmpzLm1hcCJdLCJuYW1lcyI6WyJpc0JpZ0ludDY0QXJyYXlBdmFpbGFibGUiLCJCaWdJbnQ2NEFycmF5IiwiZnJvbSIsImlzQmlnVWludDY0QXJyYXlBdmFpbGFibGUiLCJCaWdVaW50NjRBcnJheSIsIk5VTUVSSUNfVEVOU09SX1RZUEVfVE9fVFlQRURBUlJBWV9NQVAiLCJNYXAiLCJGbG9hdDMyQXJyYXkiLCJVaW50OEFycmF5IiwiSW50OEFycmF5IiwiVWludDE2QXJyYXkiLCJJbnQxNkFycmF5IiwiSW50MzJBcnJheSIsIkZsb2F0NjRBcnJheSIsIlVpbnQzMkFycmF5IiwiTlVNRVJJQ19URU5TT1JfVFlQRURBUlJBWV9UT19UWVBFX01BUCIsInNldCIsImNhbGN1bGF0ZVNpemUiLCJkaW1zIiwic2l6ZSIsImkiLCJsZW5ndGgiLCJkaW0iLCJOdW1iZXIiLCJpc1NhZmVJbnRlZ2VyIiwiVHlwZUVycm9yIiwiUmFuZ2VFcnJvciIsIlRlbnNvciIsImNvbnN0cnVjdG9yIiwiYXJnMCIsImFyZzEiLCJhcmcyIiwidHlwZSIsImRhdGEiLCJBcnJheSIsImlzQXJyYXkiLCJ0eXBlZEFycmF5Q29uc3RydWN0b3IiLCJnZXQiLCJ1bmRlZmluZWQiLCJmaXJzdEVsZW1lbnRUeXBlIiwibWFwcGVkVHlwZSIsIkVycm9yIiwiYnVmZmVyVG9UZW5zb3IiLCJidWZmZXIiLCJvcHRpb25zIiwiaGVpZ2h0Iiwid2lkdGgiLCJub3JtIiwibm9ybU1lYW4iLCJub3JtQmlhcyIsIm1lYW4iLCJiaWFzIiwiaW5wdXRmb3JtYXQiLCJiaXRtYXBGb3JtYXQiLCJvdXRwdXRmb3JtYXQiLCJ0ZW5zb3JGb3JtYXQiLCJvZmZzZXQiLCJmbG9hdDMyRGF0YSIsInN0ZXAiLCJySW1hZ2VQb2ludGVyIiwiZ0ltYWdlUG9pbnRlciIsImJJbWFnZVBvaW50ZXIiLCJhSW1hZ2VQb2ludGVyIiwiclRlbnNvclBvaW50ZXIiLCJnVGVuc29yUG9pbnRlciIsImJUZW5zb3JQb2ludGVyIiwiYVRlbnNvclBvaW50ZXIiLCJvdXRwdXRUZW5zb3IiLCJmcm9tSW1hZ2UiLCJpbWFnZSIsImlzSFRNTEltYWdlRWxlIiwiSFRNTEltYWdlRWxlbWVudCIsImlzSW1hZ2VEYXRhRWxlIiwiSW1hZ2VEYXRhIiwiaXNJbWFnZUJpdG1hcCIsIkltYWdlQml0bWFwIiwiaXNVUkwiLCJTdHJpbmciLCJ0ZW5zb3JDb25maWciLCJjYW52YXMiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJwaXhlbHMyRENvbnRleHQiLCJnZXRDb250ZXh0IiwibmF0dXJhbEhlaWdodCIsIm5hdHVyYWxXaWR0aCIsInJlc2l6ZWRIZWlnaHQiLCJyZXNpemVkV2lkdGgiLCJkcmF3SW1hZ2UiLCJnZXRJbWFnZURhdGEiLCJmb3JtYXQiLCJ0ZW1wQ2FudmFzIiwicHV0SW1hZ2VEYXRhIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJjb250ZXh0IiwibmV3SW1hZ2UiLCJJbWFnZSIsImNyb3NzT3JpZ2luIiwic3JjIiwib25sb2FkIiwiaW1nIiwidG9JbWFnZURhdGEiLCJfYSIsIl9iIiwiY2hhbm5lbHMiLCJjcmVhdGVJbWFnZURhdGEiLCJyZXNoYXBlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/onnxruntime-common/dist/lib/tensor-impl.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/onnxruntime-common/dist/lib/tensor.js":
/*!*************************************************************!*\
  !*** ../node_modules/onnxruntime-common/dist/lib/tensor.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Tensor: () => (/* binding */ Tensor)\n/* harmony export */ });\n/* harmony import */ var _tensor_impl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tensor-impl */ \"(ssr)/../node_modules/onnxruntime-common/dist/lib/tensor-impl.js\");\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\n// eslint-disable-next-line @typescript-eslint/naming-convention\nconst Tensor = _tensor_impl__WEBPACK_IMPORTED_MODULE_0__.Tensor; //# sourceMappingURL=tensor.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL29ubnhydW50aW1lLWNvbW1vbi9kaXN0L2xpYi90ZW5zb3IuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSw0REFBNEQ7QUFDNUQsa0NBQWtDO0FBQ21CO0FBQ3JELGdFQUFnRTtBQUN6RCxNQUFNQSxTQUFTQyxnREFBVUEsQ0FBQyxDQUNqQyxrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9qc3ZvaWNlLWRlbW8vLi4vbm9kZV9tb2R1bGVzL29ubnhydW50aW1lLWNvbW1vbi9kaXN0L2xpYi90ZW5zb3IuanM/Y2ExMCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbmltcG9ydCB7IFRlbnNvciBhcyBUZW5zb3JJbXBsIH0gZnJvbSAnLi90ZW5zb3ItaW1wbCc7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXG5leHBvcnQgY29uc3QgVGVuc29yID0gVGVuc29ySW1wbDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRlbnNvci5qcy5tYXAiXSwibmFtZXMiOlsiVGVuc29yIiwiVGVuc29ySW1wbCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/onnxruntime-common/dist/lib/tensor.js\n");

/***/ })

};
;